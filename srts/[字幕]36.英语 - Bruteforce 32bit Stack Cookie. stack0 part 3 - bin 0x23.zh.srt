1
00:00:00,149 --> 00:00:05,679
这是第三个也是最后一个视频
现在我们将完成对堆栈级别的攻击

2
00:00:05,680 --> 00:00:10,050
0来自我们编译的原恒星
现代体系。

3
00:00:10,049 --> 00:00:14,769
在第一部分中，我们得到了一个概述
在编译代码时所做的更改

4
00:00:14,769 --> 00:00:18,389
用一个更现代的编译器
紧挨着饼干堆。

5
00:00:18,390 --> 00:00:24,390
在第二部分，我们忽略了cookie
目前还发现了更多的剥削

6
00:00:24,390 --> 00:00:27,800
缓解并为他们开发了一个旁路。

7
00:00:27,800 --> 00:00:30,500
所以只剩下一件事了。

8
00:00:30,499 --> 00:00:39,839
最终击败了堆栈cookie。

9
00:00:39,840 --> 00:00:44,290
就像我们在第一个视频中提到的，我们
如果二进制文件

10
00:00:44,290 --> 00:00:46,460
是32位二进制。

11
00:00:46,460 --> 00:00:49,680
大约有1600万个可能值
一堆饼干。

12
00:00:49,680 --> 00:00:55,230
没那么多，但有1600万人被处决
可能是你开始想要的数字

13
00:00:55,230 --> 00:00:56,780
优化一点。

14
00:00:56,780 --> 00:01:01,440
虽然我不是超级快速计算专家，
我决定我不想写一篇潜在的

15
00:01:01,440 --> 00:01:04,580
python脚本很慢，但要编写一些C代码。

16
00:01:04,580 --> 00:01:09,250
但就像我说的，我不是什么专家
是最快的，我怀疑

17
00:01:09,250 --> 00:01:13,860
也许这里的瓶颈不会很慢
脚本，但是内核需要做很多

18
00:01:13,860 --> 00:01:16,860
一次又一次地执行程序的东西
再一次。

19
00:01:16,860 --> 00:01:21,670
所以可能不需要编写C代码
也许我的C代码也很糟糕。

20
00:01:21,670 --> 00:01:25,940
但我只是想说
不总是容易决定什么是最好的

21
00:01:25,940 --> 00:01:27,050
方法。

22
00:01:27,050 --> 00:01:30,170
既然我们这么说了，我们就试着接近
这一步一步。

23
00:01:30,170 --> 00:01:31,170
第一。

24
00:01:31,170 --> 00:01:36,870
你如何在C语言中执行一个程序。好吧，在那里
是对它的系统调用，称为exec。

25
00:01:36,870 --> 00:01:41,320
但通常我们自己也不会调用系统调用
直接，但使用提供的包装函数

26
00:01:41,320 --> 00:01:43,420
像是libc。

27
00:01:43,420 --> 00:01:47,530
所以libc提供了一些不同版本的
但他们最终都在使用

28
00:01:47,530 --> 00:01:50,060
下面是相同的exec syscall。

29
00:01:50,060 --> 00:01:51,250
在手册页上写着：

30
00:01:51,250 --> 00:01:56,500
“exec（）函数系列将替换
带有新进程的当前进程图像

31
00:01:56,500 --> 00:01:57,500
形象。”

32
00:01:57,500 --> 00:02:01,880
我想当你从未想过
程序以前执行过，这听起来真的

33
00:02:01,880 --> 00:02:02,880
奇怪的。

34
00:02:02,880 --> 00:02:06,470
“您为什么要替换当前流程？
不仅仅是执行它？

35
00:02:06,470 --> 00:02:07,870
太奇怪了”。

36
00:02:07,869 --> 00:02:11,789
这就是它的工作原理，这就是
Linux的执行模型。

37
00:02:11,790 --> 00:02:16,540
所以在我们的情况下，我们不只是想
执行并因此取代我们的程序，但是我们

38
00:02:16,540 --> 00:02:21,860
希望将stack0二进制文件作为新的
一次又一次的处理。

39
00:02:21,859 --> 00:02:27,329
为了产生一个新的过程，我们必须
执行前处理。

40
00:02:27,329 --> 00:02:31,709
fork（）通过复制创建新进程
调用过程。

41
00:02:31,709 --> 00:02:35,519
新进程称为子进程
过程。

42
00:02:35,519 --> 00:02:40,379
调用过程称为
父进程。

43
00:02:40,379 --> 00:02:44,899
还有一个有趣的地方是这里：
C库函数与

44
00:02:44,900 --> 00:02:46,230
实际内核。

45
00:02:46,230 --> 00:02:51,950
从2.3.3版开始，而不是调用
内核的fork（）系统调用glibc

46
00:02:51,950 --> 00:02:56,750
fork（）包装器[…]使用调用克隆（2）
提供与

47
00:02:56,750 --> 00:02:59,100
传统的系统调用。

48
00:02:59,099 --> 00:03:03,109
所以你要做什么来执行这个过程
过去是：

49
00:03:03,109 --> 00:03:05,159
首先是我们当前的进程。

50
00:03:05,159 --> 00:03:06,829
现在我们有了一个孩子。

51
00:03:06,829 --> 00:03:09,149
一个新的独立过程。

52
00:03:09,150 --> 00:03:14,880
你必须想象这段代码现在被涂鸦了，
我们有两个进程运行相同的代码，

53
00:03:14,879 --> 00:03:17,669
只有一个像孩子一样跑，另一个像
父母。

54
00:03:17,670 --> 00:03:21,920
您可以检查fork的返回值
你是哪个过程。

55
00:03:21,919 --> 00:03:24,259
在父进程中，您将获得
孩子。

56
00:03:24,260 --> 00:03:26,160
在孩子身上，只有0。

57
00:03:26,160 --> 00:03:31,290
然后在儿童过程中，我们可以调用
exec，将当前进程替换为

58
00:03:31,290 --> 00:03:32,650
堆栈0。

59
00:03:32,650 --> 00:03:35,270
现在在我们的案例中，我们想与
孩子。

60
00:03:35,269 --> 00:03:40,279
这意味着我们要编写漏洞输入
并读取它的输出，以确定

61
00:03:40,280 --> 00:03:42,570
如果我们成功的话。

62
00:03:42,569 --> 00:03:45,469
通常，您可以通过创建管道来完成此操作。

63
00:03:45,470 --> 00:03:50,950
pipe（）创建管道，单向数据
可用于进程间的通道

64
00:03:50,950 --> 00:03:52,390
交流。

65
00:03:52,389 --> 00:03:57,349
数组pipefd用于返回两个文件
表示管道末端的描述符。

66
00:03:57,349 --> 00:04:00,869
pipefd[0]是指管道的读取端。

67
00:04:00,870 --> 00:04:04,360
pipefd[1]表示管道的写入端。

68
00:04:04,359 --> 00:04:08,159
写入管道写入端的数据
由内核缓冲，直到读取为止

69
00:04:08,160 --> 00:04:11,510
从管道的读取端开始。

70
00:04:11,510 --> 00:04:14,280
基本上你可以用在
命令行。

71
00:04:14,280 --> 00:04:19,940
你把stdout从一个程序cat导入
另一个程序grep的stdin。

72
00:04:19,940 --> 00:04:23,490
这就是为什么我们称这个角色为“管道”。

73
00:04:23,490 --> 00:04:27,580
所以对于基本的stdin和stdout通信
您将创建两个管道。

74
00:04:27,580 --> 00:04:31,870
然后当你分叉的时候，因为你克隆
进程、子进程和父进程

75
00:04:31,870 --> 00:04:33,860
进入同一管道。

76
00:04:33,860 --> 00:04:37,980
现在很明显这取决于你是不是
父或子，您使用其中一个或另一个

77
00:04:37,979 --> 00:04:38,979
一边。

78
00:04:38,979 --> 00:04:44,019
如果是孩子，我们实际上
转到替换默认stdin和stdout

79
00:04:44,020 --> 00:04:45,430
现在用这些管子。

80
00:04:45,430 --> 00:04:47,920
打电话给dup2。

81
00:04:47,919 --> 00:04:51,839
dup2（）系统调用执行相同的任务
作为DUP（）

82
00:04:51,840 --> 00:04:55,550
dup（）系统调用创建
文件描述符。

83
00:04:55,550 --> 00:05:01,020
成功回归后，新旧
文件描述符可以互换使用。

84
00:05:01,020 --> 00:05:05,510
它们引用相同的打开文件描述
分享一切。

85
00:05:05,509 --> 00:05:11,209
但dup2，而不是使用最低编号
未使用的文件描述符为dup（），它使用

86
00:05:11,210 --> 00:05:15,490
在newfd中指定的描述符编号，
第二个参数。

87
00:05:15,490 --> 00:05:20,900
如果描述符newfd以前是打开的，
它在被重新使用之前被静默关闭。

88
00:05:20,900 --> 00:05:27,390
所以dup2关闭当前stdin和stdout
把新管子插上

89
00:05:27,389 --> 00:05:28,499
创建。

90
00:05:28,500 --> 00:05:33,120
当我们执行时，stack0和replace
新流程的当前流程

91
00:05:33,120 --> 00:05:36,000
就像打开的窃听器一样保持机智。

92
00:05:36,000 --> 00:05:42,580
所以新工艺将使用管道
连接用于读取输入和写入输出。

93
00:05:42,580 --> 00:05:46,670
然后在家长那里我们可以简单地阅读
写到管道的另一端

94
00:05:46,669 --> 00:05:49,049
因此，与子进程stack0通信。

95
00:05:49,050 --> 00:05:54,130
要做的一件好事是关闭
您在这两个过程中都没有使用的管道。

96
00:05:54,130 --> 00:05:58,300
例如，我们不需要阅读
因为我们想

97
00:05:58,300 --> 00:06:01,290
向子进程写入、发送数据。

98
00:06:01,289 --> 00:06:02,769
好啊。

99
00:06:02,770 --> 00:06:06,760
一旦我们编写了缓冲区溢出输入，
我们可以等待子进程完成

100
00:06:06,759 --> 00:06:10,119
并读取输出以查看我们是否成功。

101
00:06:10,120 --> 00:06:13,280
现在是第一个大问题。

102
00:06:13,280 --> 00:06:14,300
缓冲。

103
00:06:14,300 --> 00:06:16,790
libc将缓冲您所写的输出。

104
00:06:16,789 --> 00:06:19,839
所以子进程的输出被缓冲
在这个过程中。

105
00:06:19,840 --> 00:06:24,870
你可以想象，如果我们做一个缓冲
溢出，用螺丝拧紧堆栈，得到一个segfault

106
00:06:24,870 --> 00:06:26,390
这个缓冲区丢失。

107
00:06:26,389 --> 00:06:29,509
这个节目真是糟透了。

108
00:06:29,509 --> 00:06:33,329
但也许你认为那没什么好处
感觉，因为我们在第2部分中展示了

109
00:06:33,330 --> 00:06:37,960
从理论上讲，我们看到
外壳上的输出。

110
00:06:37,960 --> 00:06:40,670
我们看到了修改后的变量消息。

111
00:06:40,669 --> 00:06:44,399
那么外壳是如何解释的呢？
会看到输出，但我告诉你

112
00:06:44,400 --> 00:06:47,730
现在，我们看不到它与代码，我们只是
写好了吗？

113
00:06:47,730 --> 00:06:48,730
好。

114
00:06:48,730 --> 00:06:52,980
libc缓冲的方式不同
输出取决于管道类型

115
00:06:52,979 --> 00:06:53,979
连接到。

116
00:06:53,979 --> 00:06:58,729
在我们的例子中，我们使用的是普通的
管道和libc将缓冲输出数据

117
00:06:58,729 --> 00:07:03,549
直到进程调用flush（），或者
直到它被很好地填满，也许在1024年以后

118
00:07:03,550 --> 00:07:04,550
字节左右。

119
00:07:04,550 --> 00:07:05,550
我不知道。

120
00:07:05,550 --> 00:07:10,340
但我们两个都没有，产量太短了
子进程从不调用flush（）。

121
00:07:10,340 --> 00:07:13,040
所以外壳上有什么不同。

122
00:07:13,040 --> 00:07:17,560
由shell执行的程序不是
通过常规管道连接，但连接

123
00:07:17,560 --> 00:07:19,500
到一个伪终端。

124
00:07:19,500 --> 00:07:20,650
Pty。

125
00:07:20,650 --> 00:07:21,860
当libc看到的时候。

126
00:07:21,860 --> 00:07:26,550
输出被写入一个pty，伪
终端，然后它将刷新（）缓冲区

127
00:07:26,550 --> 00:07:28,220
换行。

128
00:07:28,219 --> 00:07:33,329
因为换行符就像是最后的指示
你想打印一行新行（笑）

129
00:07:33,330 --> 00:07:35,130
在终端输出上。

130
00:07:35,129 --> 00:07:39,909
我觉得这就像速度一样，你不会
如果不需要的话想冲洗，但是在

131
00:07:39,909 --> 00:07:43,279
要在换行后查看输出的终端。

132
00:07:43,280 --> 00:07:48,390
这意味着，我们还可以执行stack0
在一个PTY的上下文中编程，以便我们

133
00:07:48,389 --> 00:07:52,499
愚弄libc在每一条新线上发泄。

134
00:07:52,499 --> 00:07:55,329
还有一个方便的libc函数
为我们做。

135
00:07:55,330 --> 00:07:58,040
称为forkpty（）。

136
00:07:58,039 --> 00:08:04,349
函数的作用是：结合openpty（open
伪终端），叉（2）（我们知道）

137
00:08:04,349 --> 00:08:10,179
和登录tty（）以创建新的进程操作
在伪终端中。

138
00:08:10,180 --> 00:08:13,700
主端的文件描述符
伪终端在amaster中返回。

139
00:08:13,699 --> 00:08:15,729
所以这真的很酷。

140
00:08:15,729 --> 00:08:20,359
我们分了一个孩子的过程，已经得到了
文件描述符，以便与

141
00:08:20,360 --> 00:08:21,940
子进程。

142
00:08:21,939 --> 00:08:27,119
然后我禁用了终端的一些选项，
例如，我不想回显输入

143
00:08:27,120 --> 00:08:28,460
再一次。

144
00:08:28,460 --> 00:08:32,650
例如，如果你看我的嵌入式硬件
安全CTF视频你通常会注意到

145
00:08:32,650 --> 00:08:36,300
每当我在贝壳上打东西
董事会，我看不到我

146
00:08:36,300 --> 00:08:39,980
类型，这是因为我没有配置
回送字符的终端。

147
00:08:39,980 --> 00:08:43,640
虽然那里会很好，但我没有
这里需要它。

148
00:08:43,640 --> 00:08:47,590
还有其他一些选择可以
我们想干什么就干什么。

149
00:08:47,590 --> 00:08:50,370
然后我们也不必费劲了
管。

150
00:08:50,370 --> 00:08:52,830
所以这个孩子现在只是行政人员。

151
00:08:52,830 --> 00:08:57,580
在父级中，我们定义缓冲区溢出
输入，基本上就是我们开发的

152
00:08:57,580 --> 00:09:01,860
最后一个视频，然后还添加一些随机（）。
函数获取

153
00:09:01,860 --> 00:09:03,030
饼干。

154
00:09:03,030 --> 00:09:05,920
并将它们放入缓冲区溢出字符串中。

155
00:09:05,920 --> 00:09:11,200
一个简单的丑陋的循环以避免换行，因为
这意味着我们输入的结束，

156
00:09:11,200 --> 00:09:12,420
我们不想这样。

157
00:09:12,420 --> 00:09:17,400
然后我们将bufferoverflow字符串写入
我们的伪终端的主文件描述程序

158
00:09:17,400 --> 00:09:21,680
Stack0会阅读它并得到利用。

159
00:09:21,680 --> 00:09:25,860
然后我创建一个短循环来检查状态
但我不想阻止

160
00:09:25,860 --> 00:09:30,870
等着看，因为孩子会很可怕
是否因缓冲区溢出而死亡，

161
00:09:30,870 --> 00:09:36,720
所以我只是检查了几次状态
一个循环，如果孩子死了，我们继续，

162
00:09:36,720 --> 00:09:41,060
如果我们已经等了几次，我们决定
为了杀死子进程，

163
00:09:41,060 --> 00:09:42,990
否则我们会睡一会儿。

164
00:09:42,990 --> 00:09:46,810
通常它不应该像孩子一样循环太多
程序很短，但它是一个安全网。

165
00:09:46,810 --> 00:09:52,180
顺便说一句，程序ID、PIDS很容易出现竞争
Linux中的条件。

166
00:09:52,180 --> 00:09:56,090
你看我们没有什么把柄
直接指向子进程，我们

167
00:09:56,090 --> 00:09:57,310
只有号码。

168
00:09:57,310 --> 00:09:59,270
数字可以重复使用。

169
00:09:59,270 --> 00:10:04,310
所以理论上我们的孩子可能已经死了，
像Web服务器这样的另一个进程可能

170
00:10:04,310 --> 00:10:09,120
执行并分配了旧的PID，以及
然后我们在这里杀了它。

171
00:10:09,120 --> 00:10:12,660
没有更好的方法，Linux只是
有时候真的很难看。

172
00:10:12,660 --> 00:10:13,690
不管怎样。

173
00:10:13,690 --> 00:10:18,530
我现在想补充的另一件事是一个信号
处理程序，如果

174
00:10:18,530 --> 00:10:19,790
模具等。

175
00:10:19,790 --> 00:10:24,030
我们可以在等待之后读取输出，
但我们不知道孩子为什么和如何

176
00:10:24,030 --> 00:10:29,080
可能会死等等，我也发现了
如果我这样做的话会慢三分之一。

177
00:10:29,080 --> 00:10:31,220
因此使用了信号处理程序。

178
00:10:31,220 --> 00:10:36,270
调用此处理程序函数以通知
如果孩子出了什么事我们就去。

179
00:10:36,270 --> 00:10:39,230
所以当它收到一个信号时。

180
00:10:39,230 --> 00:10:44,650
然后在handler函数中读取
终端是stack0的输出。

181
00:10:44,650 --> 00:10:46,450
首先我们读到“再试一次？“

182
00:10:46,450 --> 00:10:47,450
消息。

183
00:10:47,450 --> 00:10:51,720
然后潜在地读取堆栈粉碎
检测到错误，或者可能成功修改

184
00:10:51,720 --> 00:10:53,060
变量消息。

185
00:10:53,060 --> 00:10:54,460
或者什么都没有。

186
00:10:54,460 --> 00:10:59,390
然后我对第二个输出进行了一次丑陋的检查
查看成功消息。

187
00:10:59,390 --> 00:11:02,020
如果是这样的话，我们就打印出来
完成。

188
00:11:02,020 --> 00:11:03,950
现在基本上准备好了。

189
00:11:03,950 --> 00:11:09,610
我添加了更多的调试输出来查看
继续，添加一个参数来提供种子。

190
00:11:09,610 --> 00:11:11,390
然后我们可以编译它。

191
00:11:11,390 --> 00:11:16,010
因为我们要用叉子，我们必须
同时链接实用程序库。

192
00:11:16,010 --> 00:11:20,770
在这里你可以看到我们被处决了多少次
每进程每秒。

193
00:11:20,770 --> 00:11:26,140
这台机器只有一个CPU，因此
花点时间，我们晚点再来。

194
00:11:26,140 --> 00:11:27,220
让我们看看。

195
00:11:27,220 --> 00:11:29,050
嗯……还没发生什么事。

196
00:11:29,050 --> 00:11:33,250
也许我们租个大点的服务器
有更多CPU核心的小时数。

197
00:11:33,250 --> 00:11:34,460
嗯，也许是这个。

198
00:11:34,460 --> 00:11:37,270
现在，为了运行它，我做了一些犹太人区的平行化。

199
00:11:37,270 --> 00:11:38,270
但是，哦，什么？

200
00:11:38,270 --> 00:11:41,970
每秒只执行9次，什么类型的
废话是什么？

201
00:11:41,970 --> 00:11:45,380
如果你观察这些过程，你会发现
称为APPOT。

202
00:11:45,380 --> 00:11:49,960
Apport是一个系统，它：
截获一旦发生就会崩溃

203
00:11:49,960 --> 00:11:53,250
第一次，
收集有关

204
00:11:53,250 --> 00:11:55,960
崩溃和操作系统环境，

205
00:11:55,960 --> 00:12:00,970
啊，所以因为我们不断地破坏一个过程
这是传递信息和减速

206
00:12:00,970 --> 00:12:02,110
一切都结束了。

207
00:12:02,110 --> 00:12:07,660
让我们禁用此服务。

208
00:12:07,660 --> 00:12:10,510
然后我们再等一会儿。

209
00:12:10,510 --> 00:12:12,150
是啊！

210
00:12:12,150 --> 00:12:16,200
请参见，一个进程输出修改后的变量
消息。

211
00:12:16,200 --> 00:12:17,480
真是太神奇了。

212
00:12:17,480 --> 00:12:21,250
我承认这不是最可靠的利用，但是
它奏效了。

213
00:12:21,250 --> 00:12:22,430
我很高兴。

214
00:12:22,430 --> 00:12:25,640
如果你有更好的开发策略
这里，请与我们分享。

215
00:12:25,640 --> 00:12:29,270
我真的很好奇还有什么别的方法
可用于在

216
00:12:29,270 --> 00:12:30,820
更可靠的方法。

217
00:12:30,820 --> 00:12:32,420
谢谢各位，下次见。

