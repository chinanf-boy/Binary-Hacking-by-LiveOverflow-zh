1
00:00:06,950 --> 00:00:12,260
在过去的视频中，我们学习了CPU的工作原理、如何读取汇编程序以及如何反转

2
00:00:12,260 --> 00:00:15,180
设计简单程序的功能。

3
00:00:15,180 --> 00:00:19,720
在接下来的视频中，我想更深入地探讨我们如何利用

4
00:00:19,720 --> 00:00:23,090
当我们有能力破坏内存时的程序。

5
00:00:23,090 --> 00:00:27,220
第一个视频将详细介绍如何设置和运行所有内容。

6
00:00:27,220 --> 00:00:31,090
所以我们可以在下一个视频中关注技术部分。

7
00:00:31,090 --> 00:00:35,390
这个视频的标题是受著名的短语文章“粉碎堆栈”的启发

8
00:00:35,390 --> 00:00:38,370
从1996年开始。

9
00:00:38,370 --> 00:00:41,240
你可以想象从那时起很多事情都发生了变化。

10
00:00:41,240 --> 00:00:45,890
尽管如此，我们首先要学习基础知识，然后才能了解现代技术。

11
00:00:45,890 --> 00:00:52,100
我们将遵循开发技术发现和尝试缓解的时间表。

12
00:00:52,100 --> 00:00:55,700
比如DEP或ASLR，就举两个例子。

13
00:00:55,700 --> 00:01:00,100
作为接下来几段视频的基础，我将使用Linux中包含的挑战

14
00:01:00,100 --> 00:01:03,250
由exploit-exercises.com提供的图像。

15
00:01:03,250 --> 00:01:07,670
这也允许你设置这个系统，我强烈推荐。

16
00:01:07,670 --> 00:01:12,360
使用ProtoStar，您将从简单的内存损坏和修改开始，函数

17
00:01:12,359 --> 00:01:15,779
重定向，最后执行自定义shellcode。

18
00:01:15,780 --> 00:01:21,090
为了尽可能容易地引入ASLR和非可执行内存

19
00:01:21,090 --> 00:01:23,730
已被禁用。

20
00:01:23,729 --> 00:01:33,199
所以首先下载protostar.iso并在vmware播放器中从中启动。

21
00:01:33,200 --> 00:01:37,660
正如你所看到的，它并不像我们的Ubuntu系统那样从一个良好的图形用户界面开始。

22
00:01:37,659 --> 00:01:38,659
做。

23
00:01:38,659 --> 00:01:42,539
但不要惊慌，你从第一集就学会了如何使用命令行。

24
00:01:42,539 --> 00:01:48,679
现在，我将利用这个时刻向您介绍“ssh”，它代表安全shell和

25
00:01:48,679 --> 00:01:54,419
是一个允许我们通过网络连接到系统的程序，它有一个ssh服务器

26
00:01:54,420 --> 00:01:55,420
跑步。

27
00:01:55,420 --> 00:01:58,980
当您必须管理运行的服务器时，这将是您获得的访问权限。

28
00:01:58,979 --> 00:02:00,049
例如网站。

29
00:02:00,049 --> 00:02:05,129
这就是我在第一集就把你介绍给指挥部的原因，

30
00:02:05,130 --> 00:02:08,100
因为你真的需要知道如何使用它。

31
00:02:08,099 --> 00:02:11,229
您还可以告诉我，我以主机操作系统的身份运行Windows。

32
00:02:11,230 --> 00:02:15,570
我想我以前没提过，但主要原因是，我认为

33
00:02:15,569 --> 00:02:21,349
大多数人从窗户开始，这意味着这是接触更多人的最佳方式。

34
00:02:21,350 --> 00:02:24,700
我们不想像我们社会的许多其他部分一样被排除在外。

35
00:02:24,700 --> 00:02:30,360
至少对我来说，黑客行为传达了一种开放和分享知识的精神。

36
00:02:30,360 --> 00:02:34,960
所以我现在必须下载Putty for Windows，它是Windows客户端

37
00:02:34,959 --> 00:02:35,959
嘘。

38
00:02:35,959 --> 00:02:40,629
要使用它连接到这台机器，我们必须找到它的IP地址。

39
00:02:40,630 --> 00:02:44,910
ProtoStar映像的用户名和密码只是“用户”。

40
00:02:44,909 --> 00:02:45,999
所以用它来登录。

41
00:02:46,000 --> 00:02:51,900
然后执行命令“ip addr”，找到分配的IP，然后将其复制到

42
00:02:51,900 --> 00:02:55,600
油灰，保存此会话并按“打开”。

43
00:02:55,599 --> 00:02:58,499
你必须重新登录，但现在好多了。

44
00:02:58,500 --> 00:03:02,830
我们可以来回复制数据，也可以有多个连接。

45
00:03:02,830 --> 00:03:12,400
对于mac和linux的等价物只是简单的“ssh”，即IP地址的用户名“user”。

46
00:03:12,400 --> 00:03:13,560
好啊。

47
00:03:13,560 --> 00:03:14,930
目前我们的外壳是/bin/sh。

48
00:03:14,930 --> 00:03:18,880
如你所见，标签完成不起作用。

49
00:03:18,880 --> 00:03:23,530
但是我们可以改为执行`/bin/bash'，这使得命令行更好一些。

50
00:03:23,530 --> 00:03:25,710
我们这里有什么。

51
00:03:25,709 --> 00:03:31,489
有了uname-a，我们可以获得一些系统信息，并且可以看到我们有一个32位的Linux

52
00:03:31,489 --> 00:03:34,129
内核为2.6.32。

53
00:03:34,129 --> 00:03:35,759
现在这是怎么工作的呢？

54
00:03:35,760 --> 00:03:41,580
网站上说：可以在/opt/protostar/bin目录中找到要利用的级别。

55
00:03:41,579 --> 00:03:43,599
让我们看看。

56
00:03:43,599 --> 00:03:47,099
` ls`列出此目录中的所有文件。

57
00:03:47,099 --> 00:03:50,979
你会立刻注意到文件名的这个奇怪的红色背景色。

58
00:03:50,980 --> 00:03:53,520
让我们仔细看看。

59
00:03:53,519 --> 00:03:58,919
使用“files”，我们可以检查文件类型，它告诉我们它是setuid elf 32位

60
00:03:58,920 --> 00:04:00,070
可执行的。

61
00:04:00,069 --> 00:04:05,469
从之前的视频中，您可能记得我们从未遇到过'setuid'。

62
00:04:05,469 --> 00:04:09,859
和往常一样，如果我们想在Linux中了解一些东西，我们可以查看Linux手册。

63
00:04:09,860 --> 00:04:14,840
不过，setuid的手册页实际上是关于libc提供的setuid函数的。

64
00:04:14,840 --> 00:04:18,940
但这并不困扰我们，因为它可能是相关的。

65
00:04:18,940 --> 00:04:21,650
让我们看看它在这里对这个函数说了些什么。

66
00:04:21,650 --> 00:04:25,130
setuid代表set user identity。

67
00:04:25,130 --> 00:04:29,760
并且…setuid设置调用进程的有效用户ID。

68
00:04:29,760 --> 00:04:34,610
mhh…通过cat/etc/passwd，我们可以看到这个系统上的所有用户。

69
00:04:34,610 --> 00:04:37,450
记住，我们的用户叫做用户，所以我们有标识1001。

70
00:04:37,451 --> 00:04:42,031
根用户的ID为0。

71
00:04:42,030 --> 00:04:47,310
这是否意味着，我们可以简单地以非特权用户的身份编写C程序并执行

72
00:04:47,310 --> 00:04:49,800
将ID为0的setuid变为根？

73
00:04:49,800 --> 00:04:51,200
显然不是。

74
00:04:51,200 --> 00:04:52,930
那太可怕了。

75
00:04:52,930 --> 00:04:58,350
再往下讲，它告诉我们可能的错误，比如说，eperm说用户不是

76
00:04:58,350 --> 00:05:02,830
特权和uid与调用进程的实际uid不匹配。

77
00:05:02,830 --> 00:05:05,890
好的……那么……它能用来做什么？

78
00:05:05,890 --> 00:05:11,280
一个示例用法是，根进程可能希望将特权删除到非特权

79
00:05:11,280 --> 00:05:16,440
用户，即在进程被利用的情况下，攻击者不会获得根权限。

80
00:05:16,440 --> 00:05:21,480
所以，如果你有一个必须从根开始的过程，但不再需要它，

81
00:05:21,480 --> 00:05:23,530
把它们放下是好事。

82
00:05:23,530 --> 00:05:24,530
不管怎样。

83
00:05:24,530 --> 00:05:26,880
这与我们的setuid二进制有什么关系？

84
00:05:26,880 --> 00:05:32,100
让我们打开第二个ssh会话来查看所有正在运行的进程。

85
00:05:32,100 --> 00:05:34,600
现在打开一个继续运行的进程。

86
00:05:34,600 --> 00:05:36,550
像VIM编辑器这样简单的东西。

87
00:05:36,550 --> 00:05:42,940
然后我们可以使用另一个shell来执行'ps aux'，列出所有正在运行的进程。

88
00:05:42,940 --> 00:05:45,500
现在我们要搜索一下，但在这里。

89
00:05:45,500 --> 00:05:49,000
第一列告诉我们正在运行的进程的用户。

90
00:05:49,000 --> 00:05:54,380
因为我们作为“用户”已经执行了VIM，所以它将以我们的特权运行。

91
00:05:54,380 --> 00:05:59,050
所以不，让我们执行其中一个setuid二进制文件并执行相同的操作。

92
00:05:59,050 --> 00:06:02,360
让我们搜索程序名。

93
00:06:02,360 --> 00:06:03,650
在这里。

94
00:06:03,650 --> 00:06:05,350
但是你看到第一行了吗？

95
00:06:05,350 --> 00:06:07,800
它说它像根一样运行。

96
00:06:07,800 --> 00:06:08,800
卧槽？

97
00:06:08,800 --> 00:06:09,930
这怎么可能？

98
00:06:09,930 --> 00:06:12,550
让我们再看看文件权限。

99
00:06:12,550 --> 00:06:18,310
好的，首先，`r``dash``x`表示系统中的任何人都可以读取此文件，并且

100
00:06:18,310 --> 00:06:19,310
执行它。

101
00:06:19,310 --> 00:06:22,940
接下来的3个权限是相同的，并引用组的权限。

102
00:06:22,940 --> 00:06:26,880
一个组只是一个ID，多个用户可以共享。

103
00:06:26,880 --> 00:06:29,640
所以我们是一个组，也叫用户。

104
00:06:29,640 --> 00:06:33,460
但是理论上你可以将多个用户组合在一起。

105
00:06:33,460 --> 00:06:35,080
好啊。

106
00:06:35,080 --> 00:06:36,460
现在它变得有趣了。

107
00:06:36,460 --> 00:06:38,760
第一个字符指示文件是否为目录。

108
00:06:38,760 --> 00:06:40,080
但事实并非如此。

109
00:06:40,080 --> 00:06:44,260
所以剩下的3个权限是文件所有者的。

110
00:06:44,260 --> 00:06:46,180
文件的所有者是根。

111
00:06:46,180 --> 00:06:50,990
并且所有者有读、写和…的权限？

112
00:06:50,990 --> 00:06:56,010
所以s替换了可执行文件的x。

113
00:06:56,010 --> 00:06:57,730
这叫做setuid位。

114
00:06:57,730 --> 00:07:02,490
我们已经研究了运行过程，所以您可以猜出它的作用。

115
00:07:02,490 --> 00:07:07,960
当设置了这个位，并且我作为一个普通用户执行它时，Linux将实际执行它。

116
00:07:07,960 --> 00:07:10,590
拥有业主的特权。

117
00:07:10,590 --> 00:07:13,380
所以在本例中，它将作为根运行。

118
00:07:13,380 --> 00:07:15,250
为什么会有人这么做？

119
00:07:15,250 --> 00:07:17,410
有两个很好的例子。

120
00:07:17,410 --> 00:07:19,670
首先，你可能知道sudo。

121
00:07:19,670 --> 00:07:24,300
这是一个程序，如果你是一个普通的用户，它允许你以根用户的身份运行一些东西。

122
00:07:24,300 --> 00:07:29,860
那么，即使您输入了命令，sudo如何以根用户身份执行程序呢？

123
00:07:29,860 --> 00:07:33,130
它也有setuid位。

124
00:07:33,130 --> 00:07:35,860
另一个很好的例子是ping程序。

125
00:07:35,860 --> 00:07:39,450
ping也将作为根运行，因为它设置了setuid位。

126
00:07:39,450 --> 00:07:40,740
你为什么要问？

127
00:07:40,740 --> 00:07:45,180
因为ping想要发送一个相当低层的ICMP包。

128
00:07:45,180 --> 00:07:50,620
Linux通常不允许普通用户创建这样的原始数据包。

129
00:07:50,620 --> 00:07:55,610
但是，由于ping并不邪恶，有人创建了setuid二进制文件，允许普通用户

130
00:07:55,610 --> 00:07:57,550
发送ICMP数据包。

131
00:07:57,550 --> 00:08:02,110
如果有一个像ping这样的程序的漏洞可以让您执行

132
00:08:02,110 --> 00:08:04,030
任意代码作为根，对吗？

133
00:08:04,030 --> 00:08:08,300
所以很明显，赛特乌德是非常危险的。

134
00:08:08,300 --> 00:08:09,310
好。

135
00:08:09,310 --> 00:08:11,340
这就是原恒星挑战的全部要点。

136
00:08:11,340 --> 00:08:17,150
如果我们可以利用这些程序中的一个，我们就可以升级特权并获得根目录。

137
00:08:17,150 --> 00:08:21,850
这基本上类似于在iPhone上越狱或在Android设备上扎根。

138
00:08:21,850 --> 00:08:27,890
您试图找到一个允许您在特权中执行任意代码的漏洞

139
00:08:27,890 --> 00:08:28,890
模式。

140
00:08:28,890 --> 00:08:33,690
嗯，在那些真正的设备上，尤其是iOS上，这是非常复杂的，而且

141
00:08:33,690 --> 00:08:39,130
涉及到更多的层，但现在你对整个事情有了更好的想象。

142
00:08:39,130 --> 00:08:42,170
在我们开始挑战之前还有最后一件事。

143
00:08:42,170 --> 00:08:44,620
你知道你可以调试程序，对吗？

144
00:08:44,620 --> 00:08:47,430
例如，您可以使用strace监视系统调用。

145
00:08:47,430 --> 00:08:48,860
或者直接使用gdb。

146
00:08:48,860 --> 00:08:52,170
gdb允许您修改内存。

147
00:08:52,170 --> 00:08:57,270
所以您可以在gdb中打开这个setuid二进制文件，修改代码并执行任何

148
00:08:57,270 --> 00:08:58,350
你想要根？

149
00:08:58,350 --> 00:09:00,160
让我们试试看。

150
00:09:00,160 --> 00:09:02,080
好的，好像在跑。

151
00:09:02,080 --> 00:09:05,150
所以让我们重新运行它并查看进程列表。

152
00:09:05,150 --> 00:09:08,460
如你所见，它不再作为根运行了。

153
00:09:08,460 --> 00:09:13,350
原因是，gdb无法调试作为另一个用户运行的进程。

154
00:09:13,350 --> 00:09:19,810
所以gdb实际上强制二进制文件不作为根文件运行，这样它就可以实际调试它了。

155
00:09:19,810 --> 00:09:24,660
好主意，但不幸的是……或者幸运的是，这不是那么简单。

156
00:09:24,660 --> 00:09:28,760
我想我们必须依靠良好的老剥削技术。

157
00:09:28,760 --> 00:09:31,440
当我们开始第一个挑战时，在下一个视频中看到你。

