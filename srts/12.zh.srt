1
00:00:06,950 --> 00:00:12,260
在过去的视频中我们学习了CPU有效，如何阅读汇编程序以及如何反转

2
00:00:12,260 --> 00:00:15,180
设计一个简单程序的功能。

3
00:00:15,180 --> 00:00:19,720
在即将发布的视频中，我想要一点点更深入，探索我们如何利用

4
00:00:19,720 --> 00:00:23,090
当我们有能力腐败时的程序记忆。

5
00:00:23,090 --> 00:00:27,220
第一个视频将更多关于如何设置并使一切运行。

6
00:00:27,220 --> 00:00:31,090
所以我们可以专注于技术部分下一个视频。

7
00:00:31,090 --> 00:00:35,390
这个视频的标题灵感来自于着名的帕克文章"粉碎堆栈

8
00:00:35,390 --> 00:00:38,370
从1996年开始的"乐趣和利润"。

9
00:00:38,370 --> 00:00:41,240
你可以想象很多东西都发生了变化自那时候起。

10
00:00:41,240 --> 00:00:45,890
虽然，我们首先要了解基础知识，在我们看看现代技术之前。

11
00:00:45,890 --> 00:00:52,100
我们将遵循剥削的时间表技术发现和尝试缓解。

12
00:00:52,100 --> 00:00:55,700
就像DEP或ASLR一样，仅举两个例子。

13
00:00:55,700 --> 00:01:00,100
作为下一对视频的基础，我将使用Linux中包含的挑战

14
00:01:00,100 --> 00:01:03,250
图片由exploit-exercises.com提供。

15
00:01:03,250 --> 00:01:07,670
这允许您也设置此系统，我强烈推荐。

16
00:01:07,670 --> 00:01:12,360
使用protostar，您将从简单开始内存损坏和修改，功能

17
00:01:12,359 --> 00:01:15,779
重定向，最后执行自定义的shellcode。

18
00:01:15,780 --> 00:01:21,090
为了使这个尽可能简单介绍，ASLR和非可执行内存

19
00:01:21,090 --> 00:01:23,730
已被禁用。

20
00:01:23,729 --> 00:01:33,199
首先下载protostar .iso并启动从它在VMWare播放器中。

21
00:01:33,200 --> 00:01:37,660
正如你所看到的，它并不是一个好的开始像我们的Ubuntu系统一样的图形用户界面

22
00:01:37,659 --> 00:01:38,659
确实。

23
00:01:38,659 --> 00:01:42,539
但是不要惊慌，你学会了如何使用第一集的命令行。

24
00:01:42,539 --> 00:01:48,679
现在，我将利用这一时刻向您介绍到`ssh`，代表安全shell和

25
00:01:48,679 --> 00:01:54,419
是一个允许我们连接的程序网络上的系统，具有ssh服务器

26
00:01:54,420 --> 00:01:55,420
运行。

27
00:01:55,420 --> 00:01:58,980
这将是您获得的访问权限你必须管理运行的服务器

28
00:01:58,979 --> 00:02:00,049
例如一个网站。

29
00:02:00,049 --> 00:02:05,129
这就是我向你介绍的原因第一集中的命令行，

30
00:02:05,130 --> 00:02:08,100
因为你真的必须知道如何使用它。

31
00:02:08,099 --> 00:02:11,229
你也可以告诉我运行Windows作为一个主机操作系统

32
00:02:11,230 --> 00:02:15,570
我想我之前没有提过，但是这里的主要原因是，我想象的是

33
00:02:15,569 --> 00:02:21,349
大多数人都是从Windows开始的意味着它是接触更多人的最佳方式。

34
00:02:21,350 --> 00:02:24,700
我们不想像这么多人那样被排除在外我们社会的其他部分。

35
00:02:24,700 --> 00:02:30,360
至少对我来说，黑客传达了一种精神开放和分享知识。

36
00:02:30,360 --> 00:02:34,960
所以这就是我必须下载PuTTY的原因Windows现在，这是一个Windows客户端

37
00:02:34,959 --> 00:02:35,959
SSH。

38
00:02:35,959 --> 00:02:40,629
要使用它连接到这台机器，我们有找到它的IP地址。

39
00:02:40,630 --> 00:02:44,910
protostar的用户名和密码图像只是"用户"。

40
00:02:44,909 --> 00:02:45,999
所以用它来登录。

41
00:02:46,000 --> 00:02:51,900
然后执行命令`ip addr`，to找到分配的IP，然后将其复制到

42
00:02:51,900 --> 00:02:55,600
putty，保存此会话并按Open。

43
00:02:55,599 --> 00:02:58,499
你必须再次登录，但这很多现在好点了。

44
00:02:58,500 --> 00:03:02,830
我们可以来回复制数据，我们可以有多个联系。

45
00:03:02,830 --> 00:03:12,400
Mac和Linux的等价物很简单`ssh`，ip地址的用户名"user"。

46
00:03:12,400 --> 00:03:13,560
好。

47
00:03:13,560 --> 00:03:14,930
目前我们的shell是/ bin / sh。

48
00:03:14,930 --> 00:03:18,880
正如您所看到的，tab补全不会工作。

49
00:03:18,880 --> 00:03:23,530
但是我们可以执行`/ bin / bash`使命令行更好一点。

50
00:03:23,530 --> 00:03:25,710
那我们在这里有什么

51
00:03:25,709 --> 00:03:31,489
使用uname -a，我们可以获得一些系统信息我们可以看到我们有一个32位的Linux

52
00:03:31,489 --> 00:03:34,129
使用2.6.32内核。

53
00:03:34,129 --> 00:03:35,759
那么现在如何运作呢。

54
00:03:35,760 --> 00:03:41,580
在网站上它说：要被利用的水平可以在/ opt / protostar / bin目录中找到。

55
00:03:41,579 --> 00:03:43,599
我们来看一下。

56
00:03:43,599 --> 00:03:47,099
`Ls`列出该目录中的所有文件。

57
00:03:47,099 --> 00:03:50,979
你马上会注意到这种奇怪的红色文件名的背景颜色。

58
00:03:50,980 --> 00:03:53,520
让我们仔细看看。

59
00:03:53,519 --> 00:03:58,919
使用`files`，我们可以检查文件类型和它告诉我们它是一个setuid ELF 32bit

60
00:03:58,920 --> 00:04:00,070
可执行文件。

61
00:04:00,069 --> 00:04:05,469
从早期的视频中你可能会记得我们之前从未见过`setuid`。

62
00:04:05,469 --> 00:04:09,859
和往常一样，如果我们想知道一些事情linux，我们可以在linux手册中查看。

63
00:04:09,860 --> 00:04:14,840
虽然，setuid的手册页实际上是关于libc提供的setuid函数。

64
00:04:14,840 --> 00:04:18,940
但这并不会打扰我们，因为它可能会相关的。

65
00:04:18,940 --> 00:04:21,650
那么让我们看看它在这里所说的内容功能。

66
00:04:21,650 --> 00:04:25,130
setuid代表设置用户身份。

67
00:04:25,130 --> 00:04:29,760
并且... setuid设置有效用户ID调用过程。

68
00:04:29,760 --> 00:04:34,610
嗯...用cat / etc / passwd我们可以看到所有这个系统上的用户。

69
00:04:34,610 --> 00:04:37,450
记住我们的用户被称为用户，所以我们有id 1001。

70
00:04:37,451 --> 00:04:42,031
root用户的id为0。

71
00:04:42,030 --> 00:04:47,310
那是否意味着我们可以简单地写一个C程序作为我们无特权的用户并执行

72
00:04:47,310 --> 00:04:49,800
setuid的id为0，成为root？

73
00:04:49,800 --> 00:04:51,200
显然不是。

74
00:04:51,200 --> 00:04:52,930
那太可怕了。

75
00:04:52,930 --> 00:04:58,350
再向下，它告诉我们可能的错误像EPERM那样说用户不是

76
00:04:58,350 --> 00:05:02,830
特权和uid不匹配调用过程的真实uid。

77
00:05:02,830 --> 00:05:05,890
好的...然后......它可以用于什么？

78
00:05:05,890 --> 00:05:11,280
一个示例用法是，根进程可能想要将权限下放给没有特权的人

79
00:05:11,280 --> 00:05:16,440
用户，以防过程被利用，攻击者无法获得root权限。

80
00:05:16,440 --> 00:05:21,480
所以如果你有一个必须开始的过程作为root但不再需要它，

81
00:05:21,480 --> 00:05:23,530
放弃它们是件好事。

82
00:05:23,530 --> 00:05:24,530
无论如何。

83
00:05:24,530 --> 00:05:26,880
这与我们的setuid有什么关系二进制？

84
00:05:26,880 --> 00:05:32,100
让我们打开第二个ssh会话在所有运行过程中。

85
00:05:32,100 --> 00:05:34,600
现在打开一个继续运行的进程。

86
00:05:34,600 --> 00:05:36,550
简单的像vim编辑器。

87
00:05:36,550 --> 00:05:42,940
然后我们可以使用其他shell来执行`ps aux`列出所有正在运行的进程。

88
00:05:42,940 --> 00:05:45,500
现在我们要搜索一下，但现在就是。

89
00:05:45,500 --> 00:05:49,000
第一列告诉我们的用户运行过程。

90
00:05:49,000 --> 00:05:54,380
而且因为我们作为"用户"已经执行了vim，它将以我们的特权运行。

91
00:05:54,380 --> 00:05:59,050
所以不要让我们执行其中一个setuid二进制文件并做同样的事情。

92
00:05:59,050 --> 00:06:02,360
我们来搜索程序名称。

93
00:06:02,360 --> 00:06:03,650
这里是。

94
00:06:03,650 --> 00:06:05,350
但是你看到了第一行吗？

95
00:06:05,350 --> 00:06:07,800
它说它以root身份运行。

96
00:06:07,800 --> 00:06:08,800
什么他妈的？

97
00:06:08,800 --> 00:06:09,930
怎么可能？

98
00:06:09,930 --> 00:06:12,550
让我们再看看文件权限。

99
00:06:12,550 --> 00:06:18,310
好吧首先，`r`` dash``x`意味着系统上的任何人都可以读取此文件

100
00:06:18,310 --> 00:06:19,310
执行它。

101
00:06:19,310 --> 00:06:22,940
接下来的3个权限是相同的并且引用到组的权限。

102
00:06:22,940 --> 00:06:26,880
一个组只是一个id，即多个用户可以分享。

103
00:06:26,880 --> 00:06:29,640
所以我们也在这个叫做的小组中用户。

104
00:06:29,640 --> 00:06:33,460
但理论上你可以组合多个用户在一起。

105
00:06:33,460 --> 00:06:35,080
好。

106
00:06:35,080 --> 00:06:36,460
现在它变得有趣了。

107
00:06:36,460 --> 00:06:38,760
第一个字符表示文件是否是一个目录。

108
00:06:38,760 --> 00:06:40,080
嗯，不是。

109
00:06:40,080 --> 00:06:44,260
所以剩下的3个权限是为了文件的所有者。

110
00:06:44,260 --> 00:06:46,180
该文件的所有者是root。

111
00:06:46,180 --> 00:06:50,990
并且所有者有权阅读，写和... S？

112
00:06:50,990 --> 00:06:56,010
所以s替换了应该是x的可执行文件。

113
00:06:56,010 --> 00:06:57,730
这称为setuid位。

114
00:06:57,730 --> 00:07:02,490
我们已经看过了运行过程，所以你可以猜到这是做什么的。

115
00:07:02,490 --> 00:07:07,960
设置此位时，我作为普通用户执行它，Linux将实际执行它

116
00:07:07,960 --> 00:07:10,590
拥有所有者的特权。

117
00:07:10,590 --> 00:07:13,380
所以在这种情况下它将以root身份运行。

118
00:07:13,380 --> 00:07:15,250
为什么有人会这样做呢？

119
00:07:15,250 --> 00:07:17,410
有两个很好的例子。

120
00:07:17,410 --> 00:07:19,670
首先，你可能知道sudo。

121
00:07:19,670 --> 00:07:24,300
哪个程序允许您运行如果您是普通用户，则以root身份登录。

122
00:07:24,300 --> 00:07:29,860
那么sudo如何以root身份执行程序，即使你输入命令？

123
00:07:29,860 --> 00:07:33,130
那么它也有setuid位。

124
00:07:33,130 --> 00:07:35,860
另一个很好的例子是ping程序。

125
00:07:35,860 --> 00:07:39,450
Ping也将以root身份运行，因为它具有setuid位设置。

126
00:07:39,450 --> 00:07:40,740
你为什么问？

127
00:07:40,740 --> 00:07:45,180
因为ping想要发送ICMP数据包这是一个相当低的层。

128
00:07:45,180 --> 00:07:50,620
而linux一般不允许正常用户创建这样的原始数据包。

129
00:07:50,620 --> 00:07:55,610
但是因为ping不是邪恶的，所以有人创造了一个setuid二进制文件，允许普通用户访问

130
00:07:55,610 --> 00:07:57,550
发送ICMP数据包。

131
00:07:57,550 --> 00:08:02,110
如果程序有漏洞怎么办？像ping一样，这将允许你执行

132
00:08:02,110 --> 00:08:04,030
任意代码为root，对吗？

133
00:08:04,030 --> 00:08:08,300
所以很明显，setuid可以是真的危险的。

134
00:08:08,300 --> 00:08:09,310
好。

135
00:08:09,310 --> 00:08:11,340
这就是挑战的重点来自protostar。

136
00:08:11,340 --> 00:08:17,150
如果我们可以在这里利用其中一个程序，我们可以升级特权并获得根。

137
00:08:17,150 --> 00:08:21,850
这基本上就像iPhone上的越狱一样或者在Android设备上生根。

138
00:08:21,850 --> 00:08:27,890
您试图找到允许的漏洞您可以在特权中执行任意代码

139
00:08:27,890 --> 00:08:28,890
模式。

140
00:08:28,890 --> 00:08:33,690
好吧，在那些真正的设备上，尤其是iOS这非常他妈的复杂，而且

141
00:08:33,690 --> 00:08:39,130
涉及更多层，但现在你对整个事物有更好的想象力。

142
00:08:39,130 --> 00:08:42,170
在我们开始挑战之前的最后一件事。

143
00:08:42,170 --> 00:08:44,620
你知道你可以调试程序吗？

144
00:08:44,620 --> 00:08:47,430
例如，你可以使用strace监视系统调用。

145
00:08:47,430 --> 00:08:48,860
或者只是使用gdb。

146
00:08:48,860 --> 00:08:52,170
并且gdb允许您修改内存。

147
00:08:52,170 --> 00:08:57,270
所以你可以打开这个setuid二进制文件在gdb中，修改代码并执行任何操作

148
00:08:57,270 --> 00:08:58,350
你想成为根？

149
00:08:58,350 --> 00:09:00,160
我们来试试吧。

150
00:09:00,160 --> 00:09:02,080
好吧它似乎运行。

151
00:09:02,080 --> 00:09:05,150
所以让我们重新运行它并查看过程名单。

152
00:09:05,150 --> 00:09:08,460
正如您所看到的，它不再以root身份运行。

153
00:09:08,460 --> 00:09:13,350
原因是，gdb无法调试以另一个用户身份运行的进程。

154
00:09:13,350 --> 00:09:19,810
所以gdb实际上强制二进制文件不运行以root身份实际调试它。

155
00:09:19,810 --> 00:09:24,660
好主意，但不幸的是......或者也许幸运的是，事情并非那么简单。

156
00:09:24,660 --> 00:09:28,760
我想我们必须依靠良好的老剥削技术。

157
00:09:28,760 --> 00:09:31,440
我们开始时会在下一个视频中与您联系第一个挑战。

