1
00:00:06,950 --> 00:00:12,260
在过去的视频中，我们学习了 CPU 的工作原理、如何读取汇编程序以及

2
00:00:12,260 --> 00:00:15,180
对简单程序函数的反工程。

3
00:00:15,180 --> 00:00:19,720
在接下来的视频中，我想更深入地探讨，

4
00:00:19,720 --> 00:00:23,090
当我们有能力破坏内存时，对该漏洞的利用。

5
00:00:23,090 --> 00:00:27,220
第一个视频，将详细介绍如何设置，和让所有内容运行起来。

6
00:00:27,220 --> 00:00:31,090
所以，我们会在下一个视频中，关注技术部分。

7
00:00:31,090 --> 00:00:35,390
这个视频的标题，是受 1996 年，著名的短语文章“粉碎堆栈(Smashing

8
00:00:35,390 --> 00:00:38,370
The Stack)，For Fun And Profit”的启发

9
00:00:38,370 --> 00:00:41,240
你可以想象的到，从那时起，很多事情都发生了变化。

10
00:00:41,240 --> 00:00:45,890
尽管如此，我们还是要先学习基础知识，然后才能了解现代技术。

11
00:00:45,890 --> 00:00:52,100
我们将遵循，漏洞技术发现和尝试缓解的历史时间表。

12
00:00:52,100 --> 00:00:55,700
比如 DEP 或 ASLR，现仅举两个例子。

13
00:00:55,700 --> 00:01:00,100
接下来，几段视频的基础，我将使用 Linux 图像中，

14
00:01:00,100 --> 00:01:03,250
由 exploit-exercises.com 提供的挑战。

15
00:01:03,250 --> 00:01:07,670
这也允许你设置这个系统，我强烈推荐。

16
00:01:07,670 --> 00:01:12,360
使用 ProtoStar，您将从简单的内存损坏和修改开始，

17
00:01:12,359 --> 00:01:15,779
函数重定向，最后到执行自定义 shellcode。

18
00:01:15,780 --> 00:01:21,090
为了尽可能容易地介绍它们，

19
00:01:21,090 --> 00:01:23,730
ASLR 和非可执行内存会被禁用。

20
00:01:23,729 --> 00:01:33,199
所以首先下载 protostar.iso ，并在 vmware Player 中，启动。

21
00:01:33,200 --> 00:01:37,660
正如你所看到的，它并不像我们的 Ubuntu 系统，那样从一个良好的图

22
00:01:37,659 --> 00:01:38,659
用户界面开始。

23
00:01:38,659 --> 00:01:42,539
但不要惊慌，你从第一集，就学会了如何使用命令行。

24
00:01:42,539 --> 00:01:48,679
现在，我将利用这个时刻向您介绍“ssh”，它代表安全 shell ，

25
00:01:48,679 --> 00:01:54,419
是一个允许我们通过网络，连接到(远程)系统的程序，

26
00:01:54,420 --> 00:01:55,420
当然远程系统要有一个 ssh 服务器在运行。

27
00:01:55,420 --> 00:01:58,980
当您必须管理运行的服务器时，这将是你能获得的安全访问权限。

28
00:01:58,979 --> 00:02:00,049
例如，一个网站托管服务器。

29
00:02:00,049 --> 00:02:05,129
这就是我在第一集，就为你介绍命令行的原因，

30
00:02:05,130 --> 00:02:08,100
因为，你真的要知道如何使用它。

31
00:02:08,099 --> 00:02:11,229
您还能以主机操作系统的身份，运行 Windows。

32
00:02:11,230 --> 00:02:15,570
我想我以前没提过，但主要原因是，我认为

33
00:02:15,569 --> 00:02:21,349
大多数人是从 Windows 系统开始的，说明，这是接触更多人的最佳方式。

34
00:02:21,350 --> 00:02:24,700
我们不想像我们社会的许多其他部分一样，被排除在外。

35
00:02:24,700 --> 00:02:30,360
至少对我来说，hacking 主题，传达了一种开放和分享知识的精神。

36
00:02:30,360 --> 00:02:34,960
所以我现在必须下载 Putty for Windows，它是 Windows 客户端

37
00:02:34,959 --> 00:02:35,959
ssh。

38
00:02:35,959 --> 00:02:40,629
要使用它连接到这台机器，我们必须找到它的 IP 地址。

39
00:02:40,630 --> 00:02:44,910
ProtoStar 镜像的用户名和密码只是“user”。

40
00:02:44,909 --> 00:02:45,999
所以用它来登录。

41
00:02:46,000 --> 00:02:51,900
然后执行命令“ip addr”，找到分配的 IP，然后将其复制到

42
00:02:51,900 --> 00:02:55,600
putty，保存此会话，并按“打开”。

43
00:02:55,599 --> 00:02:58,499
你必须重新登录，但现在好多了。

44
00:02:58,500 --> 00:03:02,830
我们可以来回复制数据，也可以用多几个连接。

45
00:03:02,830 --> 00:03:12,400
mac 和 linux 的等价物，也只是简单的“ssh”，IP 地址的用户名一样

46
00:03:12,400 --> 00:03:13,560
“user”。

47
00:03:13,560 --> 00:03:14,930
好啊。

48
00:03:14,930 --> 00:03:18,880
目前我们的 shell 是 '/bin/sh'。

49
00:03:18,880 --> 00:03:23,530
如你所见，tab-补全不起作用。

50
00:03:23,530 --> 00:03:25,710
但是我们可以改为执行`/bin/bash'，这让命令行(特性)更好一些。

51
00:03:25,709 --> 00:03:31,489
我们这里有什么。有了 "uname -a"，我们可以获得一些系统信息，并且可以看到

52
00:03:31,489 --> 00:03:34,129
我们有一个 32 位的 Linux，内核为 2.6.32。

53
00:03:34,129 --> 00:03:35,759
现在这是怎么工作的呢？

54
00:03:35,760 --> 00:03:41,580
网站上说：可以在"/opt/protostar/bin" 目录中，找到要利用的级别。

55
00:03:41,579 --> 00:03:43,599
让我们看看。`ls`列出此目录中的，所有文件。

56
00:03:43,599 --> 00:03:47,099
你会立刻注意到文件名，这个奇怪的红色背景色。

57
00:03:47,099 --> 00:03:50,979
让我们仔细看看。使用“files”，我们可以检查文件类型，它告诉我们

58
00:03:50,980 --> 00:03:53,520
它是 setuid elf 32 位 可执行文件。

59
00:03:53,519 --> 00:03:58,919
从之前的视频中，您可能记得我们从未遇到过'setuid'。

60
00:03:58,920 --> 00:04:00,070
和往常一样，如果我们想在 Linux 中，了解一些东西，我们可以查看 Linux 手册。

61
00:04:00,069 --> 00:04:05,469
不过，setuid 的手册页，实际上是 libc 提供的 setuid 函数。

62
00:04:05,469 --> 00:04:09,859
但这并不困扰我们，因为它可能是相关的。

63
00:04:09,860 --> 00:04:14,840
让我们看看它在这里，帮这个函数说了些什么。

64
00:04:14,840 --> 00:04:18,940
setuid 代表 set user identity (设置用户 ID)。

65
00:04:18,940 --> 00:04:21,650
并且… setuid 会为调用中的进程，设置的有效用户 ID。

66
00:04:21,650 --> 00:04:25,130
瞧… 通过 "cat/etc/passwd"，我们可以看到这个系统上的所有用户。

67
00:04:25,130 --> 00:04:29,760
记住，我们的用户叫做 user ，所以我们 id 为 1001。

68
00:04:29,760 --> 00:04:34,610
根(root)用户的 ID 为 0。

69
00:04:34,610 --> 00:04:37,450
这是否意味着，我们可以简单地编写 C 程序，将 setuid ID 设为 0 并执行，

70
00:04:37,451 --> 00:04:42,031
就可以，以非特权用户变为根用户？

71
00:04:42,030 --> 00:04:47,310
显然不是。

72
00:04:47,310 --> 00:04:49,800
如果可以的话，那太可怕了。

73
00:04:49,800 --> 00:04:51,200
再往下讲，它告诉我们可能的错误，比如说，

74
00:04:51,200 --> 00:04:52,930
eperm 说用户没权限，还有 uid 与调用进程的实际 uid 不匹配。

75
00:04:52,930 --> 00:04:58,350
好的… 那么… 它能用来做什么？

76
00:04:58,350 --> 00:05:02,830
一个示例用法是，根进程，可能希望将特权，降到非特权用户，

77
00:05:02,830 --> 00:05:05,890
即在进程漏洞被利用的情况下，攻击者不会获得根权限。

78
00:05:05,890 --> 00:05:11,280
所以，如果你有一个必须从根开始的过程，但不再需要它，

79
00:05:11,280 --> 00:05:16,440
降权是好事。

80
00:05:16,440 --> 00:05:21,480
不管怎样。

81
00:05:21,480 --> 00:05:23,530
这与我们的 setuid 二进制有什么关系？

82
00:05:23,530 --> 00:05:24,530
让我们打开第二个 ssh 会话，来查看所有正在运行的进程。

83
00:05:24,530 --> 00:05:26,880
现在打开一个继续运行的进程。

84
00:05:26,880 --> 00:05:32,100
像 Vim 编辑器这样简单的东西。

85
00:05:32,100 --> 00:05:34,600
然后我们可以使用另一个 shell ，来执行'ps aux'，列出所有正在运行的进程。

86
00:05:34,600 --> 00:05:36,550
现在我们要搜索一下，但在这里。

87
00:05:36,550 --> 00:05:42,940
第一列告诉我们正在运行的进程的用户。

88
00:05:42,940 --> 00:05:45,500
因为我们作为“user”已经执行了 Vim，所以它将以我们的特权运行。

89
00:05:45,500 --> 00:05:49,000
所以不能，让我们执行其中一个 setuid 二进制文件，并执行相同的

90
00:05:49,000 --> 00:05:54,380
让我们搜索程序名。

91
00:05:54,380 --> 00:05:59,050
在这里。

92
00:05:59,050 --> 00:06:02,360
但是你看到第一行了吗？

93
00:06:02,360 --> 00:06:03,650
它说它像根一样运行。

94
00:06:03,650 --> 00:06:05,350
卧槽？

95
00:06:05,350 --> 00:06:07,800
这怎么可能？

96
00:06:07,800 --> 00:06:08,800
让我们再看看文件权限。

97
00:06:08,800 --> 00:06:09,930
好的，首先，` r``dash``x `表示系统中的，任何人都可以读取此文件，

98
00:06:09,930 --> 00:06:12,550
并且执行它。

99
00:06:12,550 --> 00:06:18,310
接下来的 3 个权限是相同的，并引用组(group)的权限。

100
00:06:18,310 --> 00:06:19,310
一个组只是一个 ID，多个用户可以共享。

101
00:06:19,310 --> 00:06:22,940
所以我们是一个组，也叫 "user"。

102
00:06:22,940 --> 00:06:26,880
但是理论上，你可以将多个用户组合在一起。

103
00:06:26,880 --> 00:06:29,640
好啊。

104
00:06:29,640 --> 00:06:33,460
现在它变得有趣了。

105
00:06:33,460 --> 00:06:35,080
第一个字符指示，文件是否为目录。

106
00:06:35,080 --> 00:06:36,460
但事实并非如此。

107
00:06:36,460 --> 00:06:38,760
所以剩下的 3 个权限，是文件所有者的。

108
00:06:38,760 --> 00:06:40,080
文件的所有者是根。

109
00:06:40,080 --> 00:06:44,260
并且所有者，有 读、写和 …的权限？

110
00:06:44,260 --> 00:06:46,180
所以 s 替换了可执行文件的 x。

111
00:06:46,180 --> 00:06:50,990
这叫做 setuid 位。

112
00:06:50,990 --> 00:06:56,010
我们已经研究了运行过程，所以您可以猜出它的作用。

113
00:06:56,010 --> 00:06:57,730
当设置了这个位，并且我作为一个普通用户执行它时，Linux 将实际执

114
00:06:57,730 --> 00:07:02,490
它。

115
00:07:02,490 --> 00:07:07,960
拥有所有者的特权。

116
00:07:07,960 --> 00:07:10,590
所以在本例中，它将作为根运行。

117
00:07:10,590 --> 00:07:13,380
为什么会有人这么做？

118
00:07:13,380 --> 00:07:15,250
有两个很好的例子。

119
00:07:15,250 --> 00:07:17,410
首先，你可能知道 "sudo"。

120
00:07:17,410 --> 00:07:19,670
这是一个程序，如果你是一个普通的用户，它允许你以根用户的身份运行

121
00:07:19,670 --> 00:07:24,300
些东西。

122
00:07:24,300 --> 00:07:29,860
那么，即使您输入了命令，sudo 如何以根用户身份执行程序呢？

123
00:07:29,860 --> 00:07:33,130
它也有 setuid 位。

124
00:07:33,130 --> 00:07:35,860
另一个很好的例子是 ping 程序。

125
00:07:35,860 --> 00:07:39,450
ping 也将作为根运行，因为它设置了 setuid 位。

126
00:07:39,450 --> 00:07:40,740
你为什么要问？

127
00:07:40,740 --> 00:07:45,180
因为 ping 想要发送一个相当低层的 ICMP 包。

128
00:07:45,180 --> 00:07:50,620
Linux 通常不允许普通用户，创建这样的原始数据包。

129
00:07:50,620 --> 00:07:55,610
但是，由于 ping 并不邪恶，所以有人创建了 setuid 二进制文件，

130
00:07:55,610 --> 00:07:57,550
允许普通用户发送 ICMP 数据包。

131
00:07:57,550 --> 00:08:02,110
如果有一个像 ping 这样的程序的漏洞，

132
00:08:02,110 --> 00:08:04,030
可以让您以 root 权限，执行任意代码，对吗？

133
00:08:04,030 --> 00:08:08,300
所以很明显，setuid 是非常危险的。

134
00:08:08,300 --> 00:08:09,310
好。

135
00:08:09,310 --> 00:08:11,340
这就是 protostar 挑战的全部要点。

136
00:08:11,340 --> 00:08:17,150
如果我们可以利用这些程序中的一个，我们就可以升级特权，并获得根

137
00:08:17,150 --> 00:08:21,850
录。

138
00:08:21,850 --> 00:08:27,890
这基本上类似于，在 iPhone 或 Android 设备上越狱。

139
00:08:27,890 --> 00:08:28,890
您试图找到一个，允许您在特权中执行任意代码的漏洞

140
00:08:28,890 --> 00:08:33,690
模式。

141
00:08:33,690 --> 00:08:39,130
嗯，在那些真正的设备上，尤其是 iOS 上，这是非常复杂的，而且

142
00:08:39,130 --> 00:08:42,170
涉及到更多的层，但现在你对整个事情有了更好的想象。

143
00:08:42,170 --> 00:08:44,620
在我们开始挑战之前，还有最后一件事。

144
00:08:44,620 --> 00:08:47,430
你知道你可以调试程序，对吗？

145
00:08:47,430 --> 00:08:48,860
例如，您可以使用 strace 监视系统调用。

146
00:08:48,860 --> 00:08:52,170
或者直接使用 gdb。

147
00:08:52,170 --> 00:08:57,270
gdb 允许您修改内存。

148
00:08:57,270 --> 00:08:58,350
所以您可以在 gdb 中，打开这个 setuid 二进制文件，修改代码

149
00:08:58,350 --> 00:09:00,160
并任何你作为 root 想执行的？

150
00:09:00,160 --> 00:09:02,080
让我们试试看。

151
00:09:02,080 --> 00:09:05,150
好的，好像在运行耶。

152
00:09:05,150 --> 00:09:08,460
所以让我们重新运行它，并查看进程列表。

153
00:09:08,460 --> 00:09:13,350
如你所见，它不再作为根运行了。原因是，gdb 无法调试，另一个用户运行的进程。

154
00:09:13,350 --> 00:09:19,810
所以 gdb 实际上强制二进制文件，不作为根文件运行，这样它就可以实际调试它了。

155
00:09:19,810 --> 00:09:24,660
好主意，但不幸的是… 或者幸运的是，这不是那么简单。

156
00:09:24,660 --> 00:09:28,760
我想我们，必须依靠良好的老漏洞技术。

157
00:09:28,760 --> 00:09:31,440
当我们开始第一个挑战时，在下一个视频中看到你。

