1
00:00:00,240 --> 00:00:05,370
上一个视频我们从原恒星的例子中发现了一个格式字符串漏洞，

2
00:00:05,370 --> 00:00:09,740
but had it compiled on a modern system with ASLR and 64bit.

3
00:00:09,740 --> 00:00:13,930
一开始我以为我们解不出来，但还是摸索了一些窍门，四处游玩。

4
00:00:13,929 --> 00:00:17,509
with it, but then actually figured out a reliable technique.

5
00:00:17,510 --> 00:00:24,120
So let’s explore some more of the format levels.

6
00:00:24,119 --> 00:00:31,289
Format1, at first, looks very simple.

7
00:00:31,289 --> 00:00:35,349
记得上一次我们失败是因为它要求我们写精确的目标

8
00:00:35,350 --> 00:00:39,670
value 0xdeadbeef, and here we just have to write..

9
00:00:39,670 --> 00:00:40,670
什么？

10
00:00:40,670 --> 00:00:44,080
Let’s have quick look if our trick still works.

11
00:00:44,080 --> 00:00:49,430
So this level also takes an argument, but passes it directly to printf.

12
00:00:49,430 --> 00:00:51,860
No sprintf and buffer involved.

13
00:00:51,860 --> 00:00:52,860
Anyway.

14
00:00:52,860 --> 00:00:58,820
we compile it again on our 64bit ubuntu version and open it in gdb.

15
00:00:58,820 --> 00:01:04,630
然后，我们在目标的if比较处设置了一个断点，运行它，并使用它作为参数

16
00:01:04,629 --> 00:01:06,169
AAAAAAAAAA.

17
00:01:06,170 --> 00:01:08,410
Then we have a look at the stack.

18
00:01:08,409 --> 00:01:11,259
看到我们的as怎么不出现了吗？

19
00:01:11,259 --> 00:01:12,649
他们在哪里？

20
00:01:12,649 --> 00:01:14,819
Let’s keep looking further down.

21
00:01:14,820 --> 00:01:16,600
Oh wow.

22
00:01:16,600 --> 00:01:19,290
They are all the way down there.

23
00:01:19,290 --> 00:01:21,360
又是什么东西？

24
00:01:21,360 --> 00:01:22,360
Well so.

25
00:01:22,360 --> 00:01:27,200
看，我们没有把字符串输入复制到一个局部变量上，就像上一个缓冲区一样。

26
00:01:27,200 --> 00:01:28,200
challenge.

27
00:01:28,200 --> 00:01:30,470
We directly print the arguments.

28
00:01:30,469 --> 00:01:35,309
参数和环境变量一起放在开始处。

29
00:01:35,310 --> 00:01:36,680
of the stack.

30
00:01:36,679 --> 00:01:38,579
So these are the environment variables.

31
00:01:38,579 --> 00:01:43,599
你看，没有堆栈地址我们可以像上次那样重写和滥用

32
00:01:43,600 --> 00:01:44,600
level.

33
00:01:44,600 --> 00:01:45,600
That sucks.

34
00:01:45,600 --> 00:01:51,070
But actually it’s still solveable, we don’t need the trick from last video at all.

35
00:01:51,069 --> 00:01:53,309
It’s simpler than you might think.

36
00:01:53,310 --> 00:01:58,180
但是让我们来探讨下一个挑战，格式2，我们还没有看到的那个

37
00:01:58,179 --> 00:02:02,319
and boils down to the same thing.

38
00:02:02,319 --> 00:02:04,249
看起来更有希望，对吧？

39
00:02:04,249 --> 00:02:07,999
It does read data into a local variable on the stack.

40
00:02:07,999 --> 00:02:11,719
But it doesn’t look like we can overflow the buffer.

41
00:02:11,720 --> 00:02:15,700
This program gets the input from standard input instead of an argument.

42
00:02:15,700 --> 00:02:19,490
然后检查目标是否
64.

43
00:02:19,490 --> 00:02:20,500
Ok.

44
00:02:20,500 --> 00:02:24,300
So let’s compile it and open it in gdb.

45
00:02:24,300 --> 00:02:30,450
Again we look for the if-compare, seems to be here, 0x40 is 64.

46
00:02:30,450 --> 00:02:32,970
And set a breakpoint then run it.

47
00:02:32,970 --> 00:02:37,110
This time it’s waiting for input, so enter some As and Bs.

48
00:02:37,110 --> 00:02:40,440
Now we hit the breakpoint and let’s have a look at the stack.

49
00:02:40,440 --> 00:02:46,560
mh，我们知道我们的缓冲区有512个字节，看起来有一堆地址。

50
00:02:46,560 --> 00:02:47,890
in range.

51
00:02:47,890 --> 00:02:54,200
但为什么呢，512字节的缓冲区不是未分配的还是空的？

52
00:02:54,200 --> 00:02:55,660
Well no not really.

53
00:02:55,660 --> 00:03:00,200
您可以看到它是堆栈上的一个局部变量，这意味着它只是移动了堆栈指针。

54
00:03:00,200 --> 00:03:04,320
further up to make space for it, but doesn’t clear it.

55
00:03:04,320 --> 00:03:08,310
所以这些是以前运行的，在那里有一个堆栈的其他函数的剩余值，

56
00:03:08,310 --> 00:03:13,650
then got destroyed again when they returned, but their values always remain there.

57
00:03:13,650 --> 00:03:18,150
对于正常的程序执行来说，这并不重要，除非您不能期望

58
00:03:18,150 --> 00:03:23,100
一个用零初始化的变量，因为你可能运气不好，而且有东西在里面。

59
00:03:23,100 --> 00:03:24,640
it’s place before.

60
00:03:24,640 --> 00:03:25,640
Anyway.

61
00:03:25,640 --> 00:03:28,060
Let’s see where our target variable is.

62
00:03:28,060 --> 00:03:32,690
我们可以先用印刷体，然后用安培标靶得到一个指针，所以基本上地址

63
00:03:32,690 --> 00:03:34,560
of target.

64
00:03:34,560 --> 00:03:36,060
但那是什么？

65
00:03:36,060 --> 00:03:39,020
看起来不像堆栈地址？

66
00:03:39,020 --> 00:03:43,660
Somebody who has some experience with exploitation on 64bit knows already what that is.

67
00:03:43,660 --> 00:03:46,750
It’s a very recognisable address.

68
00:03:46,750 --> 00:03:52,310
使用vmmap，您可以检查虚拟内存，并查看它是否是二进制文件的一部分？

69
00:03:52,310 --> 00:03:54,520
Look at the permissions for this memory region.

70
00:03:54,520 --> 00:03:57,840
It is read and writeable, not executable.

71
00:03:57,840 --> 00:03:59,560
So it’s not where code is.

72
00:03:59,560 --> 00:04:01,190
It’s in a data segment.

73
00:04:01,190 --> 00:04:07,170
And when we look at the code we see that target isn’t defined in a function as local variable.

74
00:04:07,170 --> 00:04:12,450
It’s a global variable, so it’s placed in a data segment.

75
00:04:12,450 --> 00:04:18,360
现在，如果您对64位目标的开发有一些经验，您也知道这意味着，

76
00:04:18,359 --> 00:04:22,439
this address is not affected by ASLR by default.

77
00:04:22,440 --> 00:04:27,260
Lets add another printf here, like we did last video to print the address of target.

78
00:04:27,259 --> 00:04:32,859
And when we run it a few times, you see target doesn’t change.

79
00:04:32,860 --> 00:04:34,000
令人惊叹的！

80
00:04:34,000 --> 00:04:36,180
So it should be fairly straight forward.

81
00:04:36,180 --> 00:04:39,100
Step 1: let’s find our input on the stack.

82
00:04:39,099 --> 00:04:44,049
We enter some As followed by %x to print stack values.

83
00:04:44,050 --> 00:04:45,050
And here we are.

84
00:04:45,050 --> 00:04:47,260
1, 2, 3, 4, 5, 6.

85
00:04:47,259 --> 00:04:50,379
At offset 6 we have our input.

86
00:04:50,379 --> 00:04:56,209
所以我们可以把地址放在那里而不是as，然后用6%x替换

87
00:04:56,210 --> 00:04:59,040
the %n to write to it.

88
00:04:59,039 --> 00:05:01,399
Let’s try it.

89
00:05:01,400 --> 00:05:06,850
So we should now enter our input via echo, so we can encode raw characters in hex.

90
00:05:06,849 --> 00:05:09,529
Then pipe the input into format2.

91
00:05:09,530 --> 00:05:11,610
So let’s enter the address of target.

92
00:05:11,610 --> 00:05:20,070
Ah see, there it is, but it’s 4 bytes, so there is also a space still included.

93
00:05:20,070 --> 00:05:23,980
This has to be a zero, because the address is only 3 bytes.

94
00:05:23,979 --> 00:05:27,599
So we add that, but now we don’t see any output anymore.

95
00:05:27,599 --> 00:05:28,599
怎么搞的？

96
00:05:28,599 --> 00:05:31,649
Well, printf prints strings.

97
00:05:31,650 --> 00:05:37,150
And strings are null-terminated in C. So printf stops when it reahed the 0.

98
00:05:37,150 --> 00:05:40,010
So we never reach our %x format modifiers.

99
00:05:40,009 --> 00:05:47,399
This means, we should move our address to the end, so we can have format stuff before.

100
00:05:47,400 --> 00:05:49,670
Now let’s try to find again our address.

101
00:05:49,669 --> 00:05:54,159
This time I’m using the dollar syntax to enter an offset directly.

102
00:05:54,159 --> 00:05:59,529
So we know our start was at offset 6, so the address has to be further down.

103
00:05:59,530 --> 00:06:04,370
别忘了在命令行上逃离美元，因为美元是特别的

104
00:06:04,370 --> 00:06:06,680
charachter for the shell.

105
00:06:06,680 --> 00:06:10,450
If we keep going with the offsets, we can find the As.

106
00:06:10,449 --> 00:06:14,499
现在，有时偏移量可能不正确，所以可能需要添加或删除一些字符

107
00:06:14,500 --> 00:06:18,030
as padding to align it perfectly.

108
00:06:18,030 --> 00:06:19,800
Ok now looks good.

109
00:06:19,800 --> 00:06:22,850
Let’s change it to a %n.

110
00:06:22,849 --> 00:06:24,629
Segmentation fault.

111
00:06:24,630 --> 00:06:26,010
Well that didn’t work.

112
00:06:26,009 --> 00:06:27,009
Weird.

113
00:06:27,009 --> 00:06:32,269
让我们将输入写入一个文件，打开gdb，并使用该文件作为输入进行调查

114
00:06:32,270 --> 00:06:33,800
the crash.

115
00:06:33,800 --> 00:06:35,960
So here we are at a move.

116
00:06:35,960 --> 00:06:41,380
It tries to move whatever is in r15d into the address in rax.

117
00:06:41,380 --> 00:06:44,280
And so rax appears to be an invalid address.

118
00:06:44,279 --> 00:06:46,309
It’s not our target.

119
00:06:46,310 --> 00:06:48,650
There is a 0xa.

120
00:06:48,650 --> 00:06:50,490
And that is obviously a newline.

121
00:06:50,490 --> 00:06:51,550
So that’s the issue.

122
00:06:51,550 --> 00:06:56,120
We are on 64bit, so we have 64bit addresses.

123
00:06:56,120 --> 00:07:00,190
But we only entered 4 bytes, and after the echo is a newline.

124
00:07:00,189 --> 00:07:03,739
So we just have to add 4 more nullbytes.

125
00:07:03,740 --> 00:07:06,190
Ok we don’t get a crash now.

126
00:07:06,189 --> 00:07:08,489
But target is still 0.

127
00:07:08,490 --> 00:07:09,490
这是怎么回事？

128
00:07:09,490 --> 00:07:12,760
Let’s make it crash again by making the address invalid again.

129
00:07:12,759 --> 00:07:16,919
这样我们就可以调查我们的地址是否正确以及

130
00:07:16,919 --> 00:07:18,589
written to it.

131
00:07:18,590 --> 00:07:20,740
So we see, rax looks good.

132
00:07:20,740 --> 00:07:23,820
It only is invalid because of what we changed.

133
00:07:23,819 --> 00:07:25,829
Otherwise it would be great.

134
00:07:25,830 --> 00:07:30,710
所以它试图写R15d，也就是说，0？

135
00:07:30,710 --> 00:07:31,710
什么？

136
00:07:31,710 --> 00:07:35,890
%n不应该写已经打印的字符数吗？

137
00:07:35,889 --> 00:07:38,649
Let’s think for a second.

138
00:07:38,650 --> 00:07:39,850
Ohhhhhh.

139
00:07:39,850 --> 00:07:41,430
Of course it’s 0.

140
00:07:41,430 --> 00:07:44,010
Because we didn’t pint anything yet.

141
00:07:44,009 --> 00:07:48,399
Before we do the %n we obviously have to print something first.

142
00:07:48,400 --> 00:07:53,560
So let’s add %64d, to print 64 characters.

143
00:07:53,560 --> 00:07:59,330
现在有4个字符长，这意味着我们将所有内容都移动了4个，为了

144
00:07:59,330 --> 00:08:05,240
重新对齐所有内容，地址在正确的偏移量，我们必须减去

145
00:08:05,240 --> 00:08:07,060
4 characters somewhere.

146
00:08:07,060 --> 00:08:11,600
But luckily we made the padding earlier large enough and so that’s simple.

147
00:08:11,600 --> 00:08:15,410
And here we go, it’s “you modified the target”.

148
00:08:15,409 --> 00:08:21,019
最后，我们设法利用现代系统的一个简单例子

149
00:08:21,020 --> 00:08:22,790
much hassle.

150
00:08:22,789 --> 00:08:24,309
Goddamit.

151
00:08:24,309 --> 00:08:29,919
So maybe now you wonder, but the system has ASLR, why is this address fixed.

152
00:08:29,919 --> 00:08:36,009
嗯，系统有aslr，像libc这样的系统库受aslr的影响，

153
00:08:36,012 --> 00:08:37,102
您可以看到，当使用ldd打印二进制文件的库依赖项时，

154
00:08:37,099 --> 00:08:38,099
keeps changing.

155
00:08:38,099 --> 00:08:41,239
But the binary itself is not affected by ASLR.

156
00:08:41,240 --> 00:08:46,060
Unless we specifically compile it to be position independent code.

157
00:08:46,060 --> 00:08:52,820
而wie可以使用位置无关的可执行文件和-fpic的-pie标志来实现这一点。

158
00:08:52,820 --> 00:08:55,420
for position independent code.

159
00:08:55,420 --> 00:09:01,570
如果我们现在执行format2并检查目标的地址，那么我们会看到它不断地更改

160
00:09:01,570 --> 00:09:02,630
lot.

161
00:09:02,630 --> 00:09:05,250
Now it’s going to be much harder.

162
00:09:05,250 --> 00:09:08,320
Maybe with some strategies from the last video it’s doable.

163
00:09:08,320 --> 00:09:10,910
I leave that as an exercise to you watching.

