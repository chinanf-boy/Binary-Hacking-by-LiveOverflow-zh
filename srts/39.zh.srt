1
00:00:00,240 --> 00:00:05,370
上一个视频我们研究了一个格式字符串原恒星例子的脆弱性，

2
00:00:05,370 --> 00:00:09,740
但它是在一个现代系统上编译的ASLR和64位。

3
00:00:09,740 --> 00:00:13,930
一开始我以为我们解决不了但是尝试了一些技巧

4
00:00:13,929 --> 00:00:17,509
有了它，但实际上找到了一个可靠的技术。

5
00:00:17,510 --> 00:00:24,120
所以让我们进一步探讨一下水平。

6
00:00:24,119 --> 00:00:31,289
格式1起初看起来很简单。

7
00:00:31,289 --> 00:00:35,349
记得上次我们失败是因为它要求我们写的目标准确

8
00:00:35,350 --> 00:00:39,670
值0块牛肉，这里我们只需要写…

9
00:00:39,670 --> 00:00:40,670
什么？

10
00:00:40,670 --> 00:00:44,080
如果我们的把戏还没结束，让我们快点看一看。作品。

11
00:00:44,080 --> 00:00:49,430
所以这个层次也需要一个参数，但是直接传递给printf。

12
00:00:49,430 --> 00:00:51,860
不涉及sprintf和buffer。

13
00:00:51,860 --> 00:00:52,860
不管怎样。

14
00:00:52,860 --> 00:00:58,820
我们在64位Ubuntu版本上重新编译它在gdb中打开它。

15
00:00:58,820 --> 00:01:04,630
然后我们在if比较中设置一个断点目标，运行它，作为我们使用的参数

16
00:01:04,629 --> 00:01:06,169
AAAAAAAAAA

17
00:01:06,170 --> 00:01:08,410
然后我们来看看这个堆栈。

18
00:01:08,409 --> 00:01:11,259
看到我们的as怎么不出现了吗？

19
00:01:11,259 --> 00:01:12,649
他们在哪里？

20
00:01:12,649 --> 00:01:14,819
让我们继续往下看。

21
00:01:14,820 --> 00:01:16,600
哇哦。

22
00:01:16,600 --> 00:01:19,290
他们一直在下面。

23
00:01:19,290 --> 00:01:21,360
又是什么东西？

24
00:01:21,360 --> 00:01:22,360
好吧。

25
00:01:22,360 --> 00:01:27,200
看，我们没有将字符串输入复制到像缓冲区这样的局部变量

26
00:01:27,200 --> 00:01:28,200
挑战。

27
00:01:28,200 --> 00:01:30,470
我们直接打印参数。

28
00:01:30,469 --> 00:01:35,309
这些参数与一开始就有环境变量

29
00:01:35,310 --> 00:01:36,680
堆栈的

30
00:01:36,679 --> 00:01:38,579
这些是环境变量。

31
00:01:38,579 --> 00:01:43,599
你看，我们没有堆栈地址可以像上次一样改写和滥用

32
00:01:43,600 --> 00:01:44,600
水平。

33
00:01:44,600 --> 00:01:45,600
那太糟糕了。

34
00:01:45,600 --> 00:01:51,070
但事实上，它仍然是可以解决的，我们没有需要最后一段视频的技巧。

35
00:01:51,069 --> 00:01:53,309
这比你想象的要简单。

36
00:01:53,310 --> 00:01:58,180
但让我们在下一个挑战中探索这一点，格式2，我们还没看过的那个

37
00:01:58,179 --> 00:02:02,319
归根结底就是同样的事情。

38
00:02:02,319 --> 00:02:04,249
看起来更有希望，对吧？

39
00:02:04,249 --> 00:02:07,999
它确实将数据读入堆栈。

40
00:02:07,999 --> 00:02:11,719
但看起来我们不能溢出缓冲器。

41
00:02:11,720 --> 00:02:15,700
此程序从标准获取输入输入而不是参数。

42
00:02:15,700 --> 00:02:19,490
然后检查目标是否
64.

43
00:02:19,490 --> 00:02:20,500
好啊。

44
00:02:20,500 --> 00:02:24,300
所以让我们编译它并在gdb中打开它。

45
00:02:24,300 --> 00:02:30,450
我们再次寻找如果比较，似乎到了，0x40是64。

46
00:02:30,450 --> 00:02:32,970
设置一个断点，然后运行它。

47
00:02:32,970 --> 00:02:37,110
这次它正在等待输入，所以输入一些AS和BS。

48
00:02:37,110 --> 00:02:40,440
现在我们到达了断点，看看那堆。

49
00:02:40,440 --> 00:02:46,560
mh，我们知道缓冲区有512个字节，看起来有一堆地址

50
00:02:46,560 --> 00:02:47,890
在范围内。

51
00:02:47,890 --> 00:02:54,200
但为什么不是512字节的缓冲区未分配还是空？

52
00:02:54,200 --> 00:02:55,660
不，不是真的。

53
00:02:55,660 --> 00:03:00,200
你看到它是堆栈上的一个局部变量，这意味着它只是移动了堆栈指针

54
00:03:00,200 --> 00:03:04,320
为了给它腾出空间，但是没有清除它。

55
00:03:04,320 --> 00:03:08,310
所以这些是其他函数的剩余值它以前跑过，在那里有一堆，

56
00:03:08,310 --> 00:03:13,650
当他们回来的时候又被毁了，但他们的价值观始终存在。

57
00:03:13,650 --> 00:03:18,150
对于常规程序执行真的很重要，除了你不能期待

58
00:03:18,150 --> 00:03:23,100
用零初始化的变量，因为你可能运气不好，有什么事发生了

59
00:03:23,100 --> 00:03:24,640
这是以前的地方。

60
00:03:24,640 --> 00:03:25,640
不管怎样。

61
00:03:25,640 --> 00:03:28,060
让我们看看目标变量在哪里。

62
00:03:28,060 --> 00:03:32,690
我们可以先用印刷品然后用安培康靶标得到一个指针，所以基本上地址

63
00:03:32,690 --> 00:03:34,560
目标。

64
00:03:34,560 --> 00:03:36,060
但那是什么？

65
00:03:36,060 --> 00:03:39,020
看起来不像堆栈地址？

66
00:03:39,020 --> 00:03:43,660
有剥削经验的人在64位上已经知道那是什么了。

67
00:03:43,660 --> 00:03:46,750
这是一个很容易辨认的地址。

68
00:03:46,750 --> 00:03:52,310
使用vmmap，您可以检查虚拟内存看到它是我们二进制文件的一部分了吗？

69
00:03:52,310 --> 00:03:54,520
查看此内存区域的权限。

70
00:03:54,520 --> 00:03:57,840
它是可读写的，不是可执行的。

71
00:03:57,840 --> 00:03:59,560
所以代码不在这里。

72
00:03:59,560 --> 00:04:01,190
它在一个数据段中。

73
00:04:01,190 --> 00:04:07,170
当我们看到代码时，我们看到了目标未在函数中定义为局部变量。

74
00:04:07,170 --> 00:04:12,450
它是一个全局变量，因此在数据段中。

75
00:04:12,450 --> 00:04:18,360
如果你对剥削有经验的话64位目标，你也知道这意味着，

76
00:04:18,359 --> 00:04:22,439
默认情况下，此地址不受ASLR影响。

77
00:04:22,440 --> 00:04:27,260
让我们在这里添加另一个printf，就像我们一样最后一个打印目标地址的视频。

78
00:04:27,259 --> 00:04:32,859
当我们运行几次，你就会看到目标不会改变。

79
00:04:32,860 --> 00:04:34,000
令人惊叹的！

80
00:04:34,000 --> 00:04:36,180
所以应该是相当直接的。

81
00:04:36,180 --> 00:04:39,100
步骤1：让我们在堆栈上找到输入。

82
00:04:39,099 --> 00:04:44,049
我们输入一些，后跟%x以打印堆栈价值观。

83
00:04:44,050 --> 00:04:45,050
我们到了。

84
00:04:45,050 --> 00:04:47,260
1，2，3，4，5，6.

85
00:04:47,259 --> 00:04:50,379
在偏移量6处，我们有我们的输入。

86
00:04:50,379 --> 00:04:56,209
所以我们可以把地址放在那里，然后将第6个%x替换为

87
00:04:56,210 --> 00:04:59,040
要写入的%n。

88
00:04:59,039 --> 00:05:01,399
让我们试试看。

89
00:05:01,400 --> 00:05:06,850
所以我们现在应该通过echo输入我们的输入，所以我们可以用十六进制编码原始字符。

90
00:05:06,849 --> 00:05:09,529
然后将输入通过管道传输到格式2中。

91
00:05:09,530 --> 00:05:11,610
那么让我们输入目标的地址。

92
00:05:11,610 --> 00:05:20,070
啊，看，有了，但是有4个字节，所以还包括一个空间。

93
00:05:20,070 --> 00:05:23,980
这必须是零，因为地址只有3个字节。

94
00:05:23,979 --> 00:05:27,599
所以我们加上了，但现在我们看不到输出不再。

95
00:05:27,599 --> 00:05:28,599
怎么搞的？

96
00:05:28,599 --> 00:05:31,649
好吧，printf打印字符串。

97
00:05:31,650 --> 00:05:37,150
字符串在c.so printf中以NULL结尾达到0时停止。

98
00:05:37,150 --> 00:05:40,010
因此，我们永远无法达到我们的%x格式修改器。

99
00:05:40,009 --> 00:05:47,399
这意味着，我们应该把地址移到结尾，这样我们就可以有格式的东西了。

100
00:05:47,400 --> 00:05:49,670
现在让我们再找一次我们的地址。

101
00:05:49,669 --> 00:05:54,159
这次我用美元语法直接输入偏移量。

102
00:05:54,159 --> 00:05:59,529
所以我们知道我们的起点是6号，所以地址必须再往下。

103
00:05:59,530 --> 00:06:04,370
也别忘了在这里逃离美元在命令行，因为美元是特别的

104
00:06:04,370 --> 00:06:06,680
为贝壳雕刻。

105
00:06:06,680 --> 00:06:10,450
如果我们继续进行补偿，我们可以找到AS。

106
00:06:10,449 --> 00:06:14,499
有时补偿可能不对，所以你可能需要添加或删除一些字符

107
00:06:14,500 --> 00:06:18,030
作为填充物使其完全对齐。

108
00:06:18,030 --> 00:06:19,800
好的，现在看起来不错。

109
00:06:19,800 --> 00:06:22,850
我们把它改成%n。

110
00:06:22,849 --> 00:06:24,629
分段错误。

111
00:06:24,630 --> 00:06:26,010
好吧，那不管用。

112
00:06:26,009 --> 00:06:27,009
奇怪的。

113
00:06:27,009 --> 00:06:32,269
让我们将输入写入一个文件，打开gdb，并使用该文件作为输入进行调查

114
00:06:32,270 --> 00:06:33,800
撞车事故。

115
00:06:33,800 --> 00:06:35,960
所以我们要行动了。

116
00:06:35,960 --> 00:06:41,380
它试图将R15d中的任何内容移入地址在rax中。

117
00:06:41,380 --> 00:06:44,280
因此，rax似乎是一个无效的地址。

118
00:06:44,279 --> 00:06:46,309
这不是我们的目标。

119
00:06:46,310 --> 00:06:48,650
有一个0xA。

120
00:06:48,650 --> 00:06:50,490
这显然是一条新线。

121
00:06:50,490 --> 00:06:51,550
这就是问题所在。

122
00:06:51,550 --> 00:06:56,120
我们是64位的，所以我们有64位地址。

123
00:06:56,120 --> 00:07:00,190
但我们只输入了4个字节，然后回声是一条新线。

124
00:07:00,189 --> 00:07:03,739
所以我们只需要再增加4个空字节。

125
00:07:03,740 --> 00:07:06,190
好的，我们现在没有撞车。

126
00:07:06,189 --> 00:07:08,489
但目标仍然是0。

127
00:07:08,490 --> 00:07:09,490
这是怎么回事？

128
00:07:09,490 --> 00:07:12,760
让我们让它再次崩溃地址再次无效。

129
00:07:12,759 --> 00:07:16,919
这样我们就可以调查如果我们的地址正确，是什么？

130
00:07:16,919 --> 00:07:18,589
写给它。

131
00:07:18,590 --> 00:07:20,740
所以我们知道，Rax看起来不错。

132
00:07:20,740 --> 00:07:23,820
因为我们改变了什么，它才是无效的。

133
00:07:23,819 --> 00:07:25,829
否则就太好了。

134
00:07:25,830 --> 00:07:30,710
所以它试图写下R15d，是0？

135
00:07:30,710 --> 00:07:31,710
什么？

136
00:07:31,710 --> 00:07:35,890
不应该%n写入字符数已经打印？

137
00:07:35,889 --> 00:07:38,649
让我们考虑一下。

138
00:07:38,650 --> 00:07:39,850
哦。

139
00:07:39,850 --> 00:07:41,430
当然是0。

140
00:07:41,430 --> 00:07:44,010
因为我们还没有品脱任何东西。

141
00:07:44,009 --> 00:07:48,399
在进行%n之前，我们显然必须打印先做点什么。

142
00:07:48,400 --> 00:07:53,560
所以，让我们添加%64d，以打印64个字符。

143
00:07:53,560 --> 00:07:59,330
现在有4个字符长，这意味着我们把所有的东西都换了4，为了

144
00:07:59,330 --> 00:08:05,240
把所有的东西重新对齐，地址是在正确的偏移量，我们必须减去

145
00:08:05,240 --> 00:08:07,060
4个字符。

146
00:08:07,060 --> 00:08:11,600
但幸运的是，我们早先把填充物弄大了够了，这很简单。

147
00:08:11,600 --> 00:08:15,410
接下来，是"你修改了"目标"。

148
00:08:15,409 --> 00:08:21,019
最后，我们终于设法利用现代系统的简单例子

149
00:08:21,020 --> 00:08:22,790
太麻烦了。

150
00:08:22,789 --> 00:08:24,309
该死的。

151
00:08:24,309 --> 00:08:29,919
所以也许你现在想知道，但是系统aslr，为什么这个地址是固定的。

152
00:08:29,919 --> 00:08:36,009
嗯，系统有ASLR，系统像libc这样的库受到aslr的影响，

153
00:08:36,012 --> 00:08:37,102
当你使用ldd打印时，你可以看到二进制文件的库依赖项，

154
00:08:37,099 --> 00:08:38,099
不断变化。

155
00:08:38,099 --> 00:08:41,239
但是二进制文件本身不受ASLR的影响。

156
00:08:41,240 --> 00:08:46,060
除非我们专门把它编译成独立代码。

157
00:08:46,060 --> 00:08:52,820
我们可以用-pie标志位置独立可执行文件和-fpic

158
00:08:52,820 --> 00:08:55,420
位置独立代码。

159
00:08:55,420 --> 00:09:01,570
如果我们现在执行format2并检查地址目标，然后我们看到它不断地改变

160
00:09:01,570 --> 00:09:02,630
很多。

161
00:09:02,630 --> 00:09:05,250
现在要困难得多。

162
00:09:05,250 --> 00:09:08,320
也许用上一段视频中的一些策略这是可行的。

163
00:09:08,320 --> 00:09:10,910
我把它作为练习留给你看。

