1
00:00:00,240 --> 00:00:05,370
上一个视频我们从原恒星的例子中发现了一个格式字符串漏洞，

2
00:00:05,370 --> 00:00:09,740
但它是在一个具有ASLR和64位的现代系统上编译的。

3
00:00:09,740 --> 00:00:13,930
一开始我以为我们解不出来，但还是摸索了一些窍门，四处游玩。

4
00:00:13,929 --> 00:00:17,509
有了它，但实际上找到了一种可靠的技术。

5
00:00:17,510 --> 00:00:24,120
因此，让我们进一步探讨一些格式级别。

6
00:00:24,119 --> 00:00:31,289
格式1起初看起来很简单。

7
00:00:31,289 --> 00:00:35,349
记得上一次我们失败是因为它要求我们写精确的目标

8
00:00:35,350 --> 00:00:39,670
值0Xdeadbeef，这里我们只需要写..

9
00:00:39,670 --> 00:00:40,670
什么？

10
00:00:40,670 --> 00:00:44,080
如果我们的诀窍还奏效，让我们快点看一看。

11
00:00:44,080 --> 00:00:49,430
所以这个级别也接受一个参数，但直接传递给printf。

12
00:00:49,430 --> 00:00:51,860
不涉及sprintf和buffer。

13
00:00:51,860 --> 00:00:52,860
不管怎样。

14
00:00:52,860 --> 00:00:58,820
我们在64位Ubuntu版本上再次编译它，并在gdb中打开它。

15
00:00:58,820 --> 00:01:04,630
然后，我们在目标的if比较处设置了一个断点，运行它，并使用它作为参数

16
00:01:04,629 --> 00:01:06,169
AAAAAAAAAA

17
00:01:06,170 --> 00:01:08,410
然后我们来看看这个堆栈。

18
00:01:08,409 --> 00:01:11,259
看到我们的as怎么不出现了吗？

19
00:01:11,259 --> 00:01:12,649
他们在哪里？

20
00:01:12,649 --> 00:01:14,819
让我们继续往下看。

21
00:01:14,820 --> 00:01:16,600
哇哦。

22
00:01:16,600 --> 00:01:19,290
他们一直在下面。

23
00:01:19,290 --> 00:01:21,360
又是什么东西？

24
00:01:21,360 --> 00:01:22,360
好吧。

25
00:01:22,360 --> 00:01:27,200
看，我们没有把字符串输入复制到一个局部变量上，就像上一个缓冲区一样。

26
00:01:27,200 --> 00:01:28,200
挑战。

27
00:01:28,200 --> 00:01:30,470
我们直接打印参数。

28
00:01:30,469 --> 00:01:35,309
参数和环境变量一起放在开始处。

29
00:01:35,310 --> 00:01:36,680
堆栈的

30
00:01:36,679 --> 00:01:38,579
这些是环境变量。

31
00:01:38,579 --> 00:01:43,599
你看，没有堆栈地址我们可以像上次那样重写和滥用

32
00:01:43,600 --> 00:01:44,600
水平。

33
00:01:44,600 --> 00:01:45,600
那太糟糕了。

34
00:01:45,600 --> 00:01:51,070
但事实上，它仍然是可以解决的，我们根本不需要最后一个视频的技巧。

35
00:01:51,069 --> 00:01:53,309
这比你想象的要简单。

36
00:01:53,310 --> 00:01:58,180
但是让我们来探讨下一个挑战，格式2，我们还没有看到的那个

37
00:01:58,179 --> 00:02:02,319
归根结底就是同样的事情。

38
00:02:02,319 --> 00:02:04,249
看起来更有希望，对吧？

39
00:02:04,249 --> 00:02:07,999
它确实将数据读取到堆栈上的局部变量中。

40
00:02:07,999 --> 00:02:11,719
但看起来我们不能溢出缓冲区。

41
00:02:11,720 --> 00:02:15,700
此程序从标准输入而不是参数获取输入。

42
00:02:15,700 --> 00:02:19,490
然后检查目标是否
64。

43
00:02:19,490 --> 00:02:20,500
好啊。

44
00:02:20,500 --> 00:02:24,300
所以让我们编译它并在gdb中打开它。

45
00:02:24,300 --> 00:02:30,450
我们再次寻找if比较，似乎在这里，0x40是64。

46
00:02:30,450 --> 00:02:32,970
设置一个断点，然后运行它。

47
00:02:32,970 --> 00:02:37,110
这一次它正在等待输入，所以输入一些as和bs。

48
00:02:37,110 --> 00:02:40,440
现在我们到达了断点，让我们看看堆栈。

49
00:02:40,440 --> 00:02:46,560
mh，我们知道我们的缓冲区有512个字节，看起来有一堆地址。

50
00:02:46,560 --> 00:02:47,890
在范围内。

51
00:02:47,890 --> 00:02:54,200
但为什么呢，512字节的缓冲区不是未分配的还是空的？

52
00:02:54,200 --> 00:02:55,660
不，不是真的。

53
00:02:55,660 --> 00:03:00,200
您可以看到它是堆栈上的一个局部变量，这意味着它只是移动了堆栈指针。

54
00:03:00,200 --> 00:03:04,320
为了给它腾出空间，但还没弄清楚。

55
00:03:04,320 --> 00:03:08,310
所以这些是以前运行的，在那里有一个堆栈的其他函数的剩余值，

56
00:03:08,310 --> 00:03:13,650
当他们回来的时候又被摧毁了，但是他们的价值观一直都在那里。

57
00:03:13,650 --> 00:03:18,150
对于正常的程序执行来说，这并不重要，除非您不能期望

58
00:03:18,150 --> 00:03:23,100
一个用零初始化的变量，因为你可能运气不好，而且有东西在里面。

59
00:03:23,100 --> 00:03:24,640
这是以前的地方。

60
00:03:24,640 --> 00:03:25,640
不管怎样。

61
00:03:25,640 --> 00:03:28,060
让我们看看目标变量在哪里。

62
00:03:28,060 --> 00:03:32,690
我们可以先用印刷体，然后用安培标靶得到一个指针，所以基本上地址

63
00:03:32,690 --> 00:03:34,560
目标。

64
00:03:34,560 --> 00:03:36,060
但那是什么？

65
00:03:36,060 --> 00:03:39,020
看起来不像堆栈地址？

66
00:03:39,020 --> 00:03:43,660
有64位开发经验的人已经知道这是什么了。

67
00:03:43,660 --> 00:03:46,750
这是一个很容易辨认的地址。

68
00:03:46,750 --> 00:03:52,310
使用vmmap，您可以检查虚拟内存，并查看它是否是二进制文件的一部分？

69
00:03:52,310 --> 00:03:54,520
查看此内存区域的权限。

70
00:03:54,520 --> 00:03:57,840
它是可读写的，不是可执行的。

71
00:03:57,840 --> 00:03:59,560
所以代码不在这里。

72
00:03:59,560 --> 00:04:01,190
它在一个数据段中。

73
00:04:01,190 --> 00:04:07,170
当我们查看代码时，我们发现目标并没有在函数中定义为局部变量。

74
00:04:07,170 --> 00:04:12,450
它是一个全局变量，所以它被放置在一个数据段中。

75
00:04:12,450 --> 00:04:18,360
现在，如果您对64位目标的开发有一些经验，您也知道这意味着，

76
00:04:18,359 --> 00:04:22,439
默认情况下，此地址不受ASLR影响。

77
00:04:22,440 --> 00:04:27,260
让我们在这里添加另一个printf，就像上次打印目标地址的视频一样。

78
00:04:27,259 --> 00:04:32,859
当我们运行几次，你会发现目标并没有改变。

79
00:04:32,860 --> 00:04:34,000
令人惊叹的！

80
00:04:34,000 --> 00:04:36,180
所以应该是相当直接的。

81
00:04:36,180 --> 00:04:39,100
步骤1：让我们在堆栈上找到输入。

82
00:04:39,099 --> 00:04:44,049
我们输入一些，后跟%x以打印堆栈值。

83
00:04:44,050 --> 00:04:45,050
我们到了。

84
00:04:45,050 --> 00:04:47,260
1，2，3，4，5，6.

85
00:04:47,259 --> 00:04:50,379
在偏移量6处，我们有我们的输入。

86
00:04:50,379 --> 00:04:56,209
所以我们可以把地址放在那里而不是as，然后用6%x替换

87
00:04:56,210 --> 00:04:59,040
要写入的%n。

88
00:04:59,039 --> 00:05:01,399
让我们试试看。

89
00:05:01,400 --> 00:05:06,850
所以我们现在应该通过echo输入我们的输入，这样我们可以用十六进制编码原始字符。

90
00:05:06,849 --> 00:05:09,529
然后将输入通过管道传输到格式2中。

91
00:05:09,530 --> 00:05:11,610
那么让我们输入目标的地址。

92
00:05:11,610 --> 00:05:20,070
啊，看，有，但它是4个字节，所以还有一个空间还包括在内。

93
00:05:20,070 --> 00:05:23,980
这必须是零，因为地址只有3个字节。

94
00:05:23,979 --> 00:05:27,599
所以我们加上这个，但是现在我们看不到任何输出了。

95
00:05:27,599 --> 00:05:28,599
怎么搞的？

96
00:05:28,599 --> 00:05:31,649
好吧，printf打印字符串。

97
00:05:31,650 --> 00:05:37,150
字符串在C中以NULL结尾。因此，当printf达到0时，它将停止。

98
00:05:37,150 --> 00:05:40,010
因此，我们永远无法达到我们的%x格式修改器。

99
00:05:40,009 --> 00:05:47,399
这意味着，我们应该把地址移到末尾，这样我们就可以有格式的东西了。

100
00:05:47,400 --> 00:05:49,670
现在让我们再找一次我们的地址。

101
00:05:49,669 --> 00:05:54,159
这次我使用美元语法直接输入一个偏移量。

102
00:05:54,159 --> 00:05:59,529
所以我们知道我们的起点是6号，所以地址必须再往下。

103
00:05:59,530 --> 00:06:04,370
别忘了在命令行上逃离美元，因为美元是特别的

104
00:06:04,370 --> 00:06:06,680
为贝壳雕刻。

105
00:06:06,680 --> 00:06:10,450
如果我们继续使用偏移量，我们可以找到as。

106
00:06:10,449 --> 00:06:14,499
现在，有时偏移量可能不正确，所以可能需要添加或删除一些字符

107
00:06:14,500 --> 00:06:18,030
作为填充物使其完全对齐。

108
00:06:18,030 --> 00:06:19,800
好的，现在看起来不错。

109
00:06:19,800 --> 00:06:22,850
我们把它改成%n。

110
00:06:22,849 --> 00:06:24,629
分段错误。

111
00:06:24,630 --> 00:06:26,010
好吧，那不管用。

112
00:06:26,009 --> 00:06:27,009
奇怪的。

113
00:06:27,009 --> 00:06:32,269
让我们将输入写入一个文件，打开gdb，并使用该文件作为输入进行调查

114
00:06:32,270 --> 00:06:33,800
撞车事故。

115
00:06:33,800 --> 00:06:35,960
所以我们要行动了。

116
00:06:35,960 --> 00:06:41,380
它试图将r15d中的任何内容移动到rax中的地址。

117
00:06:41,380 --> 00:06:44,280
因此，rax似乎是一个无效的地址。

118
00:06:44,279 --> 00:06:46,309
这不是我们的目标。

119
00:06:46,310 --> 00:06:48,650
有一个0xA。

120
00:06:48,650 --> 00:06:50,490
这显然是一条新线。

121
00:06:50,490 --> 00:06:51,550
这就是问题所在。

122
00:06:51,550 --> 00:06:56,120
我们是64位的，所以我们有64位地址。

123
00:06:56,120 --> 00:07:00,190
但是我们只输入了4个字节，在echo之后是一个换行符。

124
00:07:00,189 --> 00:07:03,739
所以我们只需要再增加4个空字节。

125
00:07:03,740 --> 00:07:06,190
好的，我们现在没有撞车。

126
00:07:06,189 --> 00:07:08,489
但目标仍然是0。

127
00:07:08,490 --> 00:07:09,490
这是怎么回事？

128
00:07:09,490 --> 00:07:12,760
让我们再次使地址无效，使其崩溃。

129
00:07:12,759 --> 00:07:16,919
这样我们就可以调查我们的地址是否正确以及

130
00:07:16,919 --> 00:07:18,589
写给它。

131
00:07:18,590 --> 00:07:20,740
所以我们知道，Rax看起来不错。

132
00:07:20,740 --> 00:07:23,820
因为我们改变了什么，它才是无效的。

133
00:07:23,819 --> 00:07:25,829
否则就太好了。

134
00:07:25,830 --> 00:07:30,710
所以它试图写R15d，也就是说，0？

135
00:07:30,710 --> 00:07:31,710
什么？

136
00:07:31,710 --> 00:07:35,890
%n不应该写已经打印的字符数吗？

137
00:07:35,889 --> 00:07:38,649
让我们考虑一下。

138
00:07:38,650 --> 00:07:39,850
哦。

139
00:07:39,850 --> 00:07:41,430
当然是0。

140
00:07:41,430 --> 00:07:44,010
因为我们还没有品脱任何东西。

141
00:07:44,009 --> 00:07:48,399
在进行%n之前，我们显然必须先打印一些内容。

142
00:07:48,400 --> 00:07:53,560
所以，让我们添加%64d，以打印64个字符。

143
00:07:53,560 --> 00:07:59,330
现在有4个字符长，这意味着我们将所有内容都移动了4个，为了

144
00:07:59,330 --> 00:08:05,240
重新对齐所有内容，地址在正确的偏移量，我们必须减去

145
00:08:05,240 --> 00:08:07,060
4个字符。

146
00:08:07,060 --> 00:08:11,600
但幸运的是，我们早些时候把填充物做得足够大，所以这很简单。

147
00:08:11,600 --> 00:08:15,410
现在我们开始，它是“你修改了目标”。

148
00:08:15,409 --> 00:08:21,019
最后，我们设法利用现代系统的一个简单例子

149
00:08:21,020 --> 00:08:22,790
太麻烦了。

150
00:08:22,789 --> 00:08:24,309
该死的。

151
00:08:24,309 --> 00:08:29,919
所以现在你可能想知道，但是系统有ASLR，为什么这个地址是固定的。

152
00:08:29,919 --> 00:08:36,009
嗯，系统有aslr，像libc这样的系统库受aslr的影响，

153
00:08:36,012 --> 00:08:37,102
您可以看到，当使用ldd打印二进制文件的库依赖项时，

154
00:08:37,099 --> 00:08:38,099
不断变化。

155
00:08:38,099 --> 00:08:41,239
但是二进制文件本身不受ASLR的影响。

156
00:08:41,240 --> 00:08:46,060
除非我们把它专门编译成位置独立的代码。

157
00:08:46,060 --> 00:08:52,820
而wie可以使用位置无关的可执行文件和-fpic的-pie标志来实现这一点。

158
00:08:52,820 --> 00:08:55,420
位置独立代码。

159
00:08:55,420 --> 00:09:01,570
如果我们现在执行format2并检查目标的地址，那么我们会看到它不断地更改

160
00:09:01,570 --> 00:09:02,630
很多。

161
00:09:02,630 --> 00:09:05,250
现在要困难得多。

162
00:09:05,250 --> 00:09:08,320
也许用上一段视频中的一些策略，它是可行的。

163
00:09:08,320 --> 00:09:10,910
我把它作为练习留给你看。

