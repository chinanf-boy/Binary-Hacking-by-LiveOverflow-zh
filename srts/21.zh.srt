1
00:00:00,450 --> 00:00:03,520
堆到底是什么，malloc到底是做什么的？

2
00:00:03,520 --> 00:00:12,620
Those are questions we try to answer in this video.

3
00:00:12,620 --> 00:00:17,000
你可能已经知道，当你在编程时，你需要一些，更多的内存，你可能会使用

4
00:00:17,000 --> 00:00:22,340
the heap, by allocating memory with malloc and if you are done you free it again.

5
00:00:22,340 --> 00:00:26,740
不知怎么的，一些魔法正在发生，你不知道你是如何神奇地得到的。

6
00:00:26,740 --> 00:00:28,100
more memory or give it back.

7
00:00:28,100 --> 00:00:32,320
在我们讨论malloc之前，我们先讨论一下我们的进程如何获得任何内存。

8
00:00:32,320 --> 00:00:33,750
in the first place.

9
00:00:33,750 --> 00:00:36,800
This is done via mmap or brk.

10
00:00:36,800 --> 00:00:40,370
Those are system calls, which means we ask the kernel directly.

11
00:00:40,370 --> 00:00:46,000
mmap请求内核给我们一些新的虚拟地址空间，基本上请求一个新的

12
00:00:46,000 --> 00:00:47,000
memory segment.

13
00:00:47,000 --> 00:00:52,900
除了mmap之外，还有brk，可以用来改变已经使用的

14
00:00:52,899 --> 00:00:53,899
memory segment.

15
00:00:53,899 --> 00:00:55,899
This is real fucking magic.

16
00:00:55,900 --> 00:01:00,860
最后，这个过程并不关心这个内存是如何实现的-如果有RAM，

17
00:01:00,860 --> 00:01:04,790
在RAM上的确切位置存储它，或者如果您有一个交换文件，因为您没有

18
00:01:04,789 --> 00:01:05,789
have enough RAM.

19
00:01:05,789 --> 00:01:11,139
内核和硬件负责处理这个问题，并将内存映射到进程中，

20
00:01:11,140 --> 00:01:15,420
意味着进程可以透明地访问这些内存地址并使用它们

21
00:01:15,419 --> 00:01:22,909
- and transparent in this context means, “doesn’t have to know anything about it”.

22
00:01:22,909 --> 00:01:28,729
您可以使用strace执行heap1，并且可以看到所有对mmap的调用最初设置为

23
00:01:28,729 --> 00:01:30,349
up the processes memory regions.

24
00:01:30,350 --> 00:01:34,690
And near the end it uses brk to setup the heap.

25
00:01:34,689 --> 00:01:40,269
那么，我们为什么不使用mmap或brk为我们的进程获取更多的内存呢？

26
00:01:40,270 --> 00:01:44,830
为什么我们总是用malloc和free谈论堆？

27
00:01:44,829 --> 00:01:51,129
好吧，malloc只是一个非常花哨和方便的包装，可以处理BRK或MMAPping

28
00:01:51,130 --> 00:01:52,310
for us.

29
00:01:52,310 --> 00:01:54,720
And does much more.

30
00:01:54,719 --> 00:02:00,689
Malloc will call mmap or brk to get more memory if the heap doesn’t exist or is too small.

31
00:02:00,689 --> 00:02:06,539
But on top of that it will help us to organize and manage that memory.

32
00:02:06,539 --> 00:02:11,479
同样，在CTF挑战期间，以及我们稍后将看到的示例中，使用堆

33
00:02:11,480 --> 00:02:15,640
so little, that we won’t see any additional memory mapped regions.

34
00:02:15,640 --> 00:02:21,430
为了简单起见，我们认为堆只是一大块固定内存

35
00:02:21,430 --> 00:02:23,140
mapped memory.

36
00:02:23,140 --> 00:02:26,110
And we can do in this memory whatever we want.

37
00:02:26,110 --> 00:02:31,330
So when we refer to the heap, we actually mean this memory region.

38
00:02:31,330 --> 00:02:34,970
那么，malloc将管理堆意味着什么呢？

39
00:02:34,970 --> 00:02:38,090
Let’s explore this abstractly first.

40
00:02:38,090 --> 00:02:40,600
We want to allocate 8 bytes.

41
00:02:40,599 --> 00:02:42,879
So we call malloc with 8.

42
00:02:42,880 --> 00:02:46,310
This means we block 8 bytes on the heap.

43
00:02:46,310 --> 00:02:50,900
对malloc的每个调用都将返回区域被阻塞的堆的地址，以及

44
00:02:50,900 --> 00:02:54,990
with this address we know where we can write our 8 bytes to.

45
00:02:54,989 --> 00:03:00,499
So we can now write the string “AAAABBBB” to that address.

46
00:03:00,500 --> 00:03:03,420
Now we allocate two more times.

47
00:03:03,420 --> 00:03:06,730
malloc(8), malloc(8).

48
00:03:06,730 --> 00:03:07,920
This begs the question what does blocking mean.

49
00:03:07,920 --> 00:03:09,310
Malloc如何知道返回的地址？

50
00:03:09,310 --> 00:03:10,760
如果我雇你给我写一个程序，给我一个我可以使用的内存地址

51
00:03:10,760 --> 00:03:11,880
safely for different sizes, you could come up with a working solution.

52
00:03:11,879 --> 00:03:13,189
And if you would implement that you would have created your own heap algorithm.

53
00:03:13,190 --> 00:03:16,150
So there are many different ways one could implement that.

54
00:03:16,150 --> 00:03:20,170
Though most commonly used is an implementation called DLmalloc.

55
00:03:20,170 --> 00:03:23,790
Because a dude with the name Douglas Lea wrote it.

56
00:03:23,790 --> 00:03:28,540
malloc算法将为它所阻塞的每个块存储块的大小。

57
00:03:28,540 --> 00:03:29,540
before it.

58
00:03:29,540 --> 00:03:34,240
And it will also keep 4 bytes before that empty for how the free is implemented.

59
00:03:34,240 --> 00:03:36,330
But we will only focus on malloc for now.

60
00:03:36,329 --> 00:03:40,439
Let’s do the mallocs again, and let’s think like a computer.

61
00:03:40,439 --> 00:03:44,839
所以在开始的时候，当第一个malloc被调用时，我们显然知道

62
00:03:44,840 --> 00:03:45,950
the heap.

63
00:03:45,950 --> 00:03:50,510
所以我们存储要在那里分配的大小，并返回块所在的地址

64
00:03:50,510 --> 00:03:53,830
part, that is usable by the programmer, starts.

65
00:03:53,830 --> 00:03:58,310
但是，malloc现在如何知道下一个调用malloc的位置

66
00:03:58,310 --> 00:03:59,320
放置？

67
00:03:59,319 --> 00:04:02,079
Not that we write over our previously allocated area.

68
00:04:02,079 --> 00:04:06,679
Well we obviously have to kinda memorize where our free region begins.

69
00:04:06,680 --> 00:04:10,770
所以malloc只需要做一些计算，并更新指向开头的地址

70
00:04:10,769 --> 00:04:15,189
of the heap, by adding the size of the chunk we allocated to it.

71
00:04:15,189 --> 00:04:17,129
And this happens every malloc.

72
00:04:17,130 --> 00:04:22,760
So there is a pointer somewhere, that will always point to free memory.

73
00:04:22,760 --> 00:04:24,670
Cool.

74
00:04:24,670 --> 00:04:26,140
Just for understanding purposes.

75
00:04:26,140 --> 00:04:29,760
考虑到malloc的返回地址，你能怎么处理？

76
00:04:29,760 --> 00:04:34,090
Well, this pointer points to the start where we can write data to.

77
00:04:34,090 --> 00:04:39,030
So if we look at the address just before that, we can read the size of the current chunk.

78
00:04:39,030 --> 00:04:43,540
如果我们知道大小，我们可以将大小添加到该地址以访问下一个块

79
00:04:43,540 --> 00:04:44,890
the heap.

80
00:04:44,890 --> 00:04:47,390
Where we can do the same again.

81
00:04:47,390 --> 00:04:51,290
Now let’s have a look at the heap level 1 challenge from protostar.

82
00:04:51,290 --> 00:04:54,890
We will use that example to look at how malloc works in real-life.

83
00:04:54,890 --> 00:04:59,360
但首先，让我们一行一行地遍历代码，并尝试想象堆将如何

84
00:04:59,360 --> 00:05:00,520
look like.

85
00:05:00,520 --> 00:05:04,000
And then next video we actually do that practically.

86
00:05:04,000 --> 00:05:06,340
The objective here seems to call winner().

87
00:05:06,340 --> 00:05:10,500
So we somehow have to redirect code execution to that function.

88
00:05:10,500 --> 00:05:15,380
在顶部有一个名为internet的结构，它有两个成员，一个优先级

89
00:05:15,380 --> 00:05:16,380
integer.

90
00:05:16,380 --> 00:05:22,030
第二个成员是一个名为name的char指针，也就是说name包含一个指针

91
00:05:22,030 --> 00:05:24,500
to a string somewhere else.

92
00:05:24,500 --> 00:05:25,780
Structs are like classes.

93
00:05:25,780 --> 00:05:30,570
At least in terms of providing a structure with multiple different member attributes.

94
00:05:30,570 --> 00:05:36,030
现在，main从类型struct internet指针定义了三个变量，但只有两个变量

95
00:05:36,030 --> 00:05:37,030
are used.

96
00:05:37,030 --> 00:05:39,850
I guess a leftover from creating this level.

97
00:05:39,850 --> 00:05:45,450
我强调结构Internet指针，因为这三个Internet对象没有存储

98
00:05:45,450 --> 00:05:46,450
on the stack.

99
00:05:46,450 --> 00:05:52,500
Only the addresses, the pointer, to those objects are stored in i1, i2 and i3.

100
00:05:52,500 --> 00:05:56,900
Anyhow, then it starts allocating those objects on the heap.

101
00:05:56,900 --> 00:06:01,550
It first calls malloc with enough space for the i1 object.

102
00:06:01,550 --> 00:06:05,630
Sizeof will return the number of bytes this struct requires.

103
00:06:05,630 --> 00:06:10,920
在本例中是8，因为整数优先级是4个字节和char指针，

104
00:06:10,920 --> 00:06:13,290
which is an address, is also 4 bytes.

105
00:06:13,290 --> 00:06:16,270
Because we are on a 32bit machine.

106
00:06:16,270 --> 00:06:20,250
And we know that malloc returns the address on the heap that we can now use.

107
00:06:20,250 --> 00:06:25,550
So i1 points to the start of 8 bytes in memory.

108
00:06:25,550 --> 00:06:30,620
现在我们要将优先级设置为1，它将1写入分配的

109
00:06:30,620 --> 00:06:32,310
area.

110
00:06:32,310 --> 00:06:36,930
然后它再分配8个字节，结果地址将存储在char中

111
00:06:36,930 --> 00:06:38,520
pointer name.

112
00:06:38,520 --> 00:06:42,300
Which is at offset +4 of the i1 object.

113
00:06:42,300 --> 00:06:50,310
作为一个程序员，我们编写i1-&gt；名称来访问name属性，但是实现了它吗？

114
00:06:50,310 --> 00:06:56,090
在这种情况下，I1+4是

115
00:06:56,090 --> 00:06:57,770
char pointer name.

116
00:06:57,770 --> 00:07:04,090
所以现在i1-&gt；名称将包含一个地址，该地址指向我们

117
00:07:04,090 --> 00:07:06,000
just allocated.

118
00:07:06,000 --> 00:07:10,910
Those 8 bytes are intended to store a list of characters, a string - the name.

119
00:07:10,910 --> 00:07:12,700
Then the same is done over again for i2.

120
00:07:12,700 --> 00:07:15,040
We make space for the struct i2.

121
00:07:15,040 --> 00:07:16,910
We set its priority to 2.

122
00:07:16,910 --> 00:07:20,860
And we allocate another 8 byte for the name string.

123
00:07:20,860 --> 00:07:26,920
So basically we have now two objects allocated on the heap that we can work with.

124
00:07:26,920 --> 00:07:29,500
Next come two strcpys.

125
00:07:29,500 --> 00:07:34,500
我们知道strcpy总是非常可疑，因为没有长度指示，而且

126
00:07:34,500 --> 00:07:37,490
we can potentially write more than we have space.

127
00:07:37,490 --> 00:07:42,770
在这种情况下，Internet名称只分配了8个字节，因此我们可以

128
00:07:42,770 --> 00:07:45,620
over those 8 bytes and really screw up stuff.

129
00:07:45,620 --> 00:07:51,810
Anyhow, the strcpy will copy the first argument to the name of the i1 object.

130
00:07:51,810 --> 00:07:58,400
I1指向I1对象的开始，偏移量+4（即名称）是地址

131
00:07:58,400 --> 00:08:02,120
of the free 8 bytes that were allocated for the string.

132
00:08:02,120 --> 00:08:07,590
所以strcpy将获取存储在那里的地址，并从参数1复制字符串。

133
00:08:07,590 --> 00:08:09,020
location.

134
00:08:09,020 --> 00:08:11,420
And the same thing is happening for the second argument with i2 object.

135
00:08:11,421 --> 00:08:13,021
It will take the address stored at +4 of i2, and attempt to copy there our string.

136
00:08:13,020 --> 00:08:15,830
After that, we will printf and then quit the program.

137
00:08:15,830 --> 00:08:20,700
在下一个视频中，我们将在执行该程序以了解

138
00:08:20,700 --> 00:08:27,280
how the heap looks in real-life and how we can work with it in gdb.

139
00:08:27,280 --> 00:08:30,460
Oh by the way.

140
00:08:30,460 --> 00:08:31,460
I lied.

141
00:08:31,460 --> 00:08:34,300
I said the second word would contain the size of the chunk.

142
00:08:34,300 --> 00:08:40,490
Well it does, but also the lowest bit is used to indicate that the PREVIOUS chunk is used.

143
00:08:40,490 --> 00:08:41,520
Not free.

144
00:08:41,520 --> 00:08:44,170
That becomes more important for the free() algorithm.

145
00:08:44,170 --> 00:08:48,600
Thus in our example those numbers values would all be hex 11.

146
00:08:48,600 --> 00:08:52,540
I just want to put a small disclaimer here at the end.

147
00:08:52,540 --> 00:08:55,750
I simplified the heap and malloc a lot.

148
00:08:55,750 --> 00:09:00,770
例如，我只讲了一个指向自由区的指针，实际上在那里

149
00:09:00,770 --> 00:09:02,940
is obviously way more to this.

150
00:09:02,940 --> 00:09:08,780
如果我们研究剥削的历史，我们现在正在研究更多

151
00:09:08,780 --> 00:09:11,140
than 15 years ago - like 2001-ish.

152
00:09:11,140 --> 00:09:16,820
很多东西都没有改变，概念都是一样的，但是很多东西都没有改变。

153
00:09:16,820 --> 00:09:18,440
is also different.

154
00:09:18,440 --> 00:09:24,280
今天的malloc实现是基于dlmalloc的，但它不是最初的dlmalloc

155
00:09:24,280 --> 00:09:28,000
anymore - now its usually referred to as ptmalloc.

156
00:09:28,000 --> 00:09:30,440
And my goal here is to teach you the fundamentals.

157
00:09:30,440 --> 00:09:36,580
尽管这不是100%正确的，但您现在应该大致了解堆是什么，以及

158
00:09:36,580 --> 00:09:41,230
what to look for and you can transfer this knowledge to any heap implementation.

