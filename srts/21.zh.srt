1
00:00:00,450 --> 00:00:03,520
到底是什么堆，malloc是什么？真的吗？

2
00:00:03,520 --> 00:00:12,620
这些是我们试图回答的问题视频。

3
00:00:12,620 --> 00:00:17,000
你可能在编程时就知道了你需要更多的记忆

4
00:00:17,000 --> 00:00:22,340
堆，通过使用malloc分配内存如果你完成了，你会再次释放它。

5
00:00:22,340 --> 00:00:26,740
不知怎么的，一些魔法正在发生，而你不知道你是怎么神奇地得到的

6
00:00:26,740 --> 00:00:28,100
更多的记忆或者把它还给我。

7
00:00:28,100 --> 00:00:32,320
在我们讨论Malloc之前，我们先来谈谈我们的过程如何获得记忆

8
00:00:32,320 --> 00:00:33,750
首先。

9
00:00:33,750 --> 00:00:36,800
这是通过mmap或brk完成的。

10
00:00:36,800 --> 00:00:40,370
这些是系统调用，这意味着我们要求直接的内核。

11
00:00:40,370 --> 00:00:46,000
mmap请求内核给我们一些新的虚拟地址空间，基本上请求一个新的

12
00:00:46,000 --> 00:00:47,000
内存段。

13
00:00:47,000 --> 00:00:52,900
除了MMAP，还有BRK，它可以用于更改已使用的

14
00:00:52,899 --> 00:00:53,899
内存段。

15
00:00:53,899 --> 00:00:55,899
这是真正的魔法。

16
00:00:55,900 --> 00:01:00,860
最后，这个过程并不关心这个内存是实现的-如果有RAM，

17
00:01:00,860 --> 00:01:04,790
你把它放在随机存储器的哪个地方，或者如果你有一个交换文件，因为你没有

18
00:01:04,789 --> 00:01:05,789
有足够的内存。

19
00:01:05,789 --> 00:01:11,139
内核和硬件会处理这个问题，把记忆映射到过程中

20
00:01:11,140 --> 00:01:15,420
意味着进程可以透明地访问这些内存地址并与它们一起工作

21
00:01:15,419 --> 00:01:22,909
-在这种情况下，透明意味着必须知道任何有关它的事情"。

22
00:01:22,909 --> 00:01:28,729
您可以用strace执行heap1，然后查看所有对mmap的调用以初始设置

23
00:01:28,729 --> 00:01:30,349
处理内存区域。

24
00:01:30,350 --> 00:01:34,690
在接近尾端时，它使用BRK设置堆。

25
00:01:34,689 --> 00:01:40,269
我们为什么不用mmap或brk为我们的进程获取更多内存？

26
00:01:40,270 --> 00:01:44,830
为什么我们总是讨论堆马尔洛克和自由？

27
00:01:44,829 --> 00:01:51,129
嗯，Malloc只是一个非常花哨和方便的处理brk或mmapping的包装器

28
00:01:51,130 --> 00:01:52,310
对我们来说。

29
00:01:52,310 --> 00:01:54,720
做得更多。

30
00:01:54,719 --> 00:02:00,689
malloc将调用mmap或brk以获取更多内存如果堆不存在或太小。

31
00:02:00,689 --> 00:02:06,539
但除此之外，它将帮助我们组织并管理记忆。

32
00:02:06,539 --> 00:02:11,479
同样在CTF挑战中，以及示例我们很快就会看到，使用堆

33
00:02:11,480 --> 00:02:15,640
太少了，我们再也看不到了内存映射区域。

34
00:02:15,640 --> 00:02:21,430
为了简单起见，我们考虑堆，只是一大块固定内存

35
00:02:21,430 --> 00:02:23,140
映射内存。

36
00:02:23,140 --> 00:02:26,110
在这个记忆中，我们可以做任何我们想做的事。

37
00:02:26,110 --> 00:02:31,330
所以当我们提到堆时，实际上指这个记忆区域。

38
00:02:31,330 --> 00:02:34,970
那么，Malloc将如何处理堆？

39
00:02:34,970 --> 00:02:38,090
让我们先抽象地探讨一下这个问题。

40
00:02:38,090 --> 00:02:40,600
我们要分配8个字节。

41
00:02:40,599 --> 00:02:42,879
所以我们用8来称呼malloc。

42
00:02:42,880 --> 00:02:46,310
这意味着我们在堆上阻塞了8个字节。

43
00:02:46,310 --> 00:02:50,900
每次呼叫malloc都会返回地址区域被阻塞的堆的，以及

44
00:02:50,900 --> 00:02:54,990
有了这个地址，我们知道在哪里可以写我们的8字节到。

45
00:02:54,989 --> 00:03:00,499
现在我们可以编写字符串"aaaabbbb"到那个地址。

46
00:03:00,500 --> 00:03:03,420
现在我们再分配两次。

47
00:03:03,420 --> 00:03:06,730
malloc（8），malloc（8）。

48
00:03:06,730 --> 00:03:07,920
这就引出了一个问题：阻塞是什么？平均。

49
00:03:07,920 --> 00:03:09,310
Malloc如何知道返回的地址？

50
00:03:09,310 --> 00:03:10,760
如果我雇你给我写个程序单给了我一个记忆地址

51
00:03:10,760 --> 00:03:11,880
对于不同的尺寸，您可以安全地来找到一个有效的解决方案。

52
00:03:11,879 --> 00:03:13,189
如果你能实现它，你会已经创建了自己的堆算法。

53
00:03:13,190 --> 00:03:16,150
所以有很多不同的方法实现这一点。

54
00:03:16,150 --> 00:03:20,170
尽管最常用的是实现称为dlmalloc。

55
00:03:20,170 --> 00:03:23,790
因为一个叫道格拉斯·李的家伙写的它。

56
00:03:23,790 --> 00:03:28,540
malloc算法将为每个它阻止块的大小。

57
00:03:28,540 --> 00:03:29,540
在它之前。

58
00:03:29,540 --> 00:03:34,240
它还将保留4个字节空表示如何实现自由。

59
00:03:34,240 --> 00:03:36,330
但我们现在只关注malloc。

60
00:03:36,329 --> 00:03:40,439
我们再来一次马洛克舞吧像电脑一样思考。

61
00:03:40,439 --> 00:03:44,839
所以在开始的时候，当第一个malloc是打电话来，我们显然知道

62
00:03:44,840 --> 00:03:45,950
堆。

63
00:03:45,950 --> 00:03:50,510
所以我们存储要分配的大小然后返回块所在的地址

64
00:03:50,510 --> 00:03:53,830
部分，这是程序员可用的，开始。

65
00:03:53,830 --> 00:03:58,310
不过，马洛克现在怎么知道下一个调用malloc，下一个块可以在其中

66
00:03:58,310 --> 00:03:59,320
放置？

67
00:03:59,319 --> 00:04:02,079
不是说我们重写了以前分配的面积。

68
00:04:02,079 --> 00:04:06,679
很明显我们必须记住我们的自由区开始了。

69
00:04:06,680 --> 00:04:10,770
所以malloc只需要做一些计算，并更新指向开头的地址

70
00:04:10,769 --> 00:04:15,189
堆的大小，通过添加块的大小我们分配给它。

71
00:04:15,189 --> 00:04:17,129
每一个malloc都会发生这种情况。

72
00:04:17,130 --> 00:04:22,760
所以在某个地方有一个指针，它会总是指向空闲内存。

73
00:04:22,760 --> 00:04:24,670
酷。

74
00:04:24,670 --> 00:04:26,140
只是为了理解目的。

75
00:04:26,140 --> 00:04:29,760
给出了malloc的返回地址，什么？你能接受吗？

76
00:04:29,760 --> 00:04:34,090
好吧，这个指针指向我们可以将数据写入。

77
00:04:34,090 --> 00:04:39,030
所以如果我们看一下前面的地址，我们可以读取当前块的大小。

78
00:04:39,030 --> 00:04:43,540
如果我们知道尺寸，我们可以增加尺寸到下一个区块的地址

79
00:04:43,540 --> 00:04:44,890
堆。

80
00:04:44,890 --> 00:04:47,390
我们可以再这样做。

81
00:04:47,390 --> 00:04:51,290
现在让我们看看堆级别一个来自原恒星的挑战。

82
00:04:51,290 --> 00:04:54,890
我们将用这个例子来看看malloc在现实生活中工作。

83
00:04:54,890 --> 00:04:59,360
但首先，让我们通过代码行按行并尝试想象堆将如何

84
00:04:59,360 --> 00:05:00,520
看起来像。

85
00:05:00,520 --> 00:05:04,000
下一个视频我们实际上是这么做的。

86
00:05:04,000 --> 00:05:06,340
这里的目标似乎称为winner（）。

87
00:05:06,340 --> 00:05:10,500
所以我们必须以某种方式重定向代码执行到那个功能。

88
00:05:10,500 --> 00:05:15,380
在顶部有一个名为互联网，有两个成员，优先

89
00:05:15,380 --> 00:05:16,380
整数。

90
00:05:16,380 --> 00:05:22,030
第二个成员是char指针名称-表示名称包含指针

91
00:05:22,030 --> 00:05:24,500
到其他地方的字符串。

92
00:05:24,500 --> 00:05:25,780
结构类似于类。

93
00:05:25,780 --> 00:05:30,570
至少在提供结构方面具有多个不同的成员属性。

94
00:05:30,570 --> 00:05:36,030
现在，main从类型结构Internet指针，但只有两个

95
00:05:36,030 --> 00:05:37,030
被使用。

96
00:05:37,030 --> 00:05:39,850
我想这是创建这个级别的剩余部分。

97
00:05:39,850 --> 00:05:45,450
我强调结构Internet指针，因为这三个互联网对象没有存储

98
00:05:45,450 --> 00:05:46,450
在堆栈上。

99
00:05:46,450 --> 00:05:52,500
只有那些地址，指针对象存储在i1、i2和i3中。

100
00:05:52,500 --> 00:05:56,900
无论如何，然后它开始分配那些对象堆上。

101
00:05:56,900 --> 00:06:01,550
它首先给malloc打电话，因为它有足够的空间I1对象。

102
00:06:01,550 --> 00:06:05,630
sizeof将返回结构需要。

103
00:06:05,630 --> 00:06:10,920
在这种情况下是8，因为整数优先级为4字节，字符指针，

104
00:06:10,920 --> 00:06:13,290
它是一个地址，也是4个字节。

105
00:06:13,290 --> 00:06:16,270
因为我们在32位机器上。

106
00:06:16,270 --> 00:06:20,250
我们知道malloc会返回地址在我们现在可以使用的堆上。

107
00:06:20,250 --> 00:06:25,550
所以I1指向内存中8个字节的开头。

108
00:06:25,550 --> 00:06:30,620
现在我们要将优先级设置为1，这是将1写入分配的

109
00:06:30,620 --> 00:06:32,310
面积。

110
00:06:32,310 --> 00:06:36,930
然后它再分配8个字节，结果地址将存储在char中

111
00:06:36,930 --> 00:06:38,520
指针名称。

112
00:06:38,520 --> 00:06:42,300
它位于i1对象的偏移量+4处。

113
00:06:42,300 --> 00:06:50,310
作为程序员，我们编写i1-&gt；名称，以访问name属性，但实现的是

114
00:06:50,310 --> 00:06:56,090
仅仅是到了I1的某个偏移量，在这种情况下，I1+4是

115
00:06:56,090 --> 00:06:57,770
字符指针名称。

116
00:06:57,770 --> 00:07:04,090
所以现在i1-&gt；名称将包含一个地址，其中指向分配的堆区域

117
00:07:04,090 --> 00:07:06,000
刚刚分配。

118
00:07:06,000 --> 00:07:10,910
这8个字节用于存储列表一个字符串——名字。

119
00:07:10,910 --> 00:07:12,700
然后对I2再次进行同样的操作。

120
00:07:12,700 --> 00:07:15,040
我们为结构I2腾出空间。

121
00:07:15,040 --> 00:07:16,910
我们把它的优先级设置为2。

122
00:07:16,910 --> 00:07:20,860
我们为名称分配了另外8个字节字符串。

123
00:07:20,860 --> 00:07:26,920
所以基本上我们已经分配了两个对象我们可以一起工作。

124
00:07:26,920 --> 00:07:29,500
接下来是两条街道。

125
00:07:29,500 --> 00:07:34,500
我们知道史崔比总是非常可疑，因为没有长度指示和

126
00:07:34,500 --> 00:07:37,490
我们可能写的比我们现有的要多空间。

127
00:07:37,490 --> 00:07:42,770
在这种情况下，分配了Internet名称只有8个字节，所以我们可以写

128
00:07:42,770 --> 00:07:45,620
超过了8字节，真的搞砸了。

129
00:07:45,620 --> 00:07:51,810
无论如何，strcpy将复制第一个参数到i1对象的名称。

130
00:07:51,810 --> 00:07:58,400
I1指向I1对象的开始，并且在偏移量+4处，即名称，是地址

131
00:07:58,400 --> 00:08:02,120
在分配给的可用8字节中字符串。

132
00:08:02,120 --> 00:08:07,590
所以strcpy将获取存储在那里的地址从参数1复制字符串

133
00:08:07,590 --> 00:08:09,020
位置。

134
00:08:09,020 --> 00:08:11,420
第二次也发生了同样的事情带I2对象的参数。

135
00:08:11,421 --> 00:08:13,021
它将采用存储在I2+4的地址，尝试复制我们的字符串。

136
00:08:13,020 --> 00:08:15,830
之后，我们将打印并退出程序。

137
00:08:15,830 --> 00:08:20,700
在下一个视频中，我们将看到在执行此程序时堆以了解

138
00:08:20,700 --> 00:08:27,280
堆在现实生活中的样子以及我们可以在gdb中使用它。

139
00:08:27,280 --> 00:08:30,460
哦，顺便说一下。

140
00:08:30,460 --> 00:08:31,460
我撒谎了。

141
00:08:31,460 --> 00:08:34,300
我说第二个词会包含大小块的。

142
00:08:34,300 --> 00:08:40,490
是的，但也使用了最低的位以指示使用上一个块。

143
00:08:40,490 --> 00:08:41,520
不是免费的。

144
00:08:41,520 --> 00:08:44,170
这对自由人来说更加重要。算法。

145
00:08:44,170 --> 00:08:48,600
因此在我们的示例中，这些数值都是十六进制11。

146
00:08:48,600 --> 00:08:52,540
我只想在这里写一个小小的免责声明最后。

147
00:08:52,540 --> 00:08:55,750
我把堆和malloc简化了很多。

148
00:08:55,750 --> 00:09:00,770
例如，我只谈到一个指针指向自由区，实际上在那里

149
00:09:00,770 --> 00:09:02,940
很明显，这是更重要的。

150
00:09:02,940 --> 00:09:08,780
如果我们研究剥削的历史我们目前正在从更多

151
00:09:08,780 --> 00:09:11,140
比15年前——比如2001年的ISH。

152
00:09:11,140 --> 00:09:16,820
很多东西都没有改变，概念是相同的，但很多SDTUFF

153
00:09:16,820 --> 00:09:18,440
也是不同的。

154
00:09:18,440 --> 00:09:24,280
今天的malloc实现基于dlmalloc，但它不是真正的原始dlmalloc

155
00:09:24,280 --> 00:09:28,000
现在它通常被称为ptmalloc。

156
00:09:28,000 --> 00:09:30,440
我的目标是教你基础知识。

157
00:09:30,440 --> 00:09:36,580
尽管这不是100%正确，你应该现在大致了解堆是什么，以及

158
00:09:36,580 --> 00:09:41,230
你要找什么，你可以把这个了解任何堆实现。

