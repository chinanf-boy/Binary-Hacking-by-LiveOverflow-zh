1
00:00:00,450 --> 00:00:03,520
堆(heap)到底是什么， malloc  确切是做什么的？

2
00:00:03,520 --> 00:00:12,620
正是这视频，试图回答的问题。

3
00:00:12,620 --> 00:00:17,000
你可能已经知道，当你在编程时，你会需要用到一些。而多数用到的内存，可能都是堆。

4
00:00:17,000 --> 00:00:22,340
而堆，是使用  malloc  分配而来，如果完事了，就会再次释放它。

5
00:00:22,340 --> 00:00:26,740
不知怎么的，一些魔法正在发生，你不知道你是神奇得到，

6
00:00:26,740 --> 00:00:28,100
更多的内存，或者把它还给系统。

7
00:00:28,100 --> 00:00:32,320
在我们讨论 malloc 之前，我们先讨论一下我们的进程，

8
00:00:32,320 --> 00:00:33,750
是如何第一时间，获得任何内存的。

9
00:00:33,750 --> 00:00:36,800
这是通过 mmap 或 brk  完成的。

10
00:00:36,800 --> 00:00:40,370
这些是系统调用，这意味着，我们直接询问内核。

11
00:00:40,370 --> 00:00:46,000
mmap 请求内核，给我们一些新的虚拟地址空间，

12
00:00:46,000 --> 00:00:47,000
基本上，是请求一个新的内存段。

13
00:00:47,000 --> 00:00:52,900
除了mmap 之外，还有 brk ，

14
00:00:52,899 --> 00:00:53,899
可以用来改变已经使用的内存段。

15
00:00:53,899 --> 00:00:55,899
这是真正的魔法。

16
00:00:55,900 --> 00:01:00,860
最后，这个过程并不关心这个内存是如何实现的 - 如果有RAM的话，

17
00:01:00,860 --> 00:01:04,790
在 RAM 上的确切位置存储它，或者是有一个 SWAP 文件，

18
00:01:04,789 --> 00:01:05,789
因为您没有足够的内存。

19
00:01:05,789 --> 00:01:11,139
内核和硬件会负责处理这个问题，并将内存映射到进程中，

20
00:01:11,140 --> 00:01:15,420
意味着，进程可以透明地访问这些内存地址，并使用它们

21
00:01:15,419 --> 00:01:22,909
—— 在这种情况下，透明意味着“不必知道任何事情”。

22
00:01:22,909 --> 00:01:28,729
您可以使用 strace 执行 heap1，并且可以看到所有对 mmap 的调用，

23
00:01:28,729 --> 00:01:30,349
初始设置为进程内存区域。

24
00:01:30,350 --> 00:01:34,690
最后，它使用 brk 来设置堆。

25
00:01:34,689 --> 00:01:40,269
那么，我们为什么不使用 mmap 或 brk ，为我们的进程获取更多的内存呢？

26
00:01:40,270 --> 00:01:44,830
还有为什么我们总是在谈论堆时，带上 malloc 和 free ？

27
00:01:44,829 --> 00:01:51,129
好吧， malloc 只是一个非常花哨和方便的包装，

28
00:01:51,130 --> 00:01:52,310
可以为我们处理 brk 或 mmap过程。

29
00:01:52,310 --> 00:01:54,720
甚至更多。

30
00:01:54,719 --> 00:02:00,689
如果堆不存在或太小， malloc 将调用 mmap 或 brk 以获取更多内存。

31
00:02:00,689 --> 00:02:06,539
但除此之外，它将帮助我们，组织和管理内存。

32
00:02:06,539 --> 00:02:11,479
同样，在CTF挑战期间，以及我们稍后看到的示例中，

33
00:02:11,480 --> 00:02:15,640
会很少用到堆，我们将看不到任何多余的内存映射区域。

34
00:02:15,640 --> 00:02:21,430
为了简单起见，我们可以把堆，想成一大块固定的

35
00:02:21,430 --> 00:02:23,140
映射内存。

36
00:02:23,140 --> 00:02:26,110
在这个内存中，我们可以做任何我们想做的事。

37
00:02:26,110 --> 00:02:31,330
所以，当我们提到堆时，实际上是指这个内存区域。

38
00:02:31,330 --> 00:02:34,970
那么， malloc 管理堆，是什么意思呢？

39
00:02:34,970 --> 00:02:38,090
让我们先抽象一下这个问题。

40
00:02:38,090 --> 00:02:40,600
我们要分配8个字节。

41
00:02:40,599 --> 00:02:42,879
所以我们用 8，来调用 malloc 。

42
00:02:42,880 --> 00:02:46,310
这意味着，我们在堆上，划分了(圈住了)8个字节。

43
00:02:46,310 --> 00:02:50,900
对 malloc 的每个调用都将返回，划分区域的堆的地址，

44
00:02:50,900 --> 00:02:54,990
有了这个地址，我们就知道在哪里，可以写入8个字节。

45
00:02:54,989 --> 00:03:00,499
现在，我们可以将字符串“aaaabbb”写入该地址。

46
00:03:00,500 --> 00:03:03,420
现在，我们再分配两次。

47
00:03:03,420 --> 00:03:06,730
malloc(8), malloc(8)。

48
00:03:06,730 --> 00:03:07,920
这就引出了一个问题：划分(block)是什么意思。

49
00:03:07,920 --> 00:03:09,310
还有，Malloc 如何知道，返回的是什么地址？

50
00:03:09,310 --> 00:03:10,760
如果我雇你，给我写一个程序，给我一个，我可以安全使用的内存地址，

51
00:03:10,760 --> 00:03:11,880
它有不同的尺寸，您可以提出一个有效的解决方案。

52
00:03:11,879 --> 00:03:13,189
如果，您实现了它，那么，您就创建自己的堆算法。

53
00:03:13,190 --> 00:03:16,150
所以，是有很多不同的方法，可以实现它。

54
00:03:16,150 --> 00:03:20,170
尽管，最常用的是一个名为 DLmalloc 的实现。

55
00:03:20,170 --> 00:03:23,790
因为，是一个叫 Douglas Lea 的兄弟写的。

56
00:03:23,790 --> 00:03:28,540
 malloc 算法存储，每个块的划分的大小。

57
00:03:28,540 --> 00:03:29,540
在它落实之前。

58
00:03:29,540 --> 00:03:34,240
它还将保留4个字节，供给 free 实现的。

59
00:03:34,240 --> 00:03:36,330
但我们现在只关注 malloc 。

60
00:03:36,329 --> 00:03:40,439
我们再做一次 malloc，让我们像计算机一样思考。

61
00:03:40,439 --> 00:03:44,839
所以，在开始的时候，当第一个 malloc 被调用时，

62
00:03:44,840 --> 00:03:45,950
我们显然知道堆的开头。

63
00:03:45,950 --> 00:03:50,510
所以，我们存储要分配的大小，并返回，内存块所在的地址

64
00:03:50,510 --> 00:03:53,830
这样，程序员就可以使用，以此开始。

65
00:03:53,830 --> 00:03:58,310
但是， malloc 现在如何知道，下一个 malloc 调用，

66
00:03:58,310 --> 00:03:59,320
下个内存块，能够放置的位置？

67
00:03:59,319 --> 00:04:02,079
不是，复写之前分配的区域。

68
00:04:02,079 --> 00:04:06,679
很明显，我们必须记住 空闲区域(内存)的起点。

69
00:04:06,680 --> 00:04:10,770
所以， malloc 只需要做些计算，并更新指向堆开头的地址，

70
00:04:10,769 --> 00:04:15,189
具体就是，通过添加分配的块大小。

71
00:04:15,189 --> 00:04:17,129
且每次 malloc ，都会发生这种情况。

72
00:04:17,130 --> 00:04:22,760
所以，这里某个地方，肯定有个指针，它总是指向空闲内存。

73
00:04:22,760 --> 00:04:24,670
酷。

74
00:04:24,670 --> 00:04:26,140
为了更好的理解。

75
00:04:26,140 --> 00:04:29,760
若给出 malloc 的返回地址，你能怎么处理？

76
00:04:29,760 --> 00:04:34,090
这么说吧，这个指针指向，我们可以写入数据的起点。

77
00:04:34,090 --> 00:04:39,030
因此，如果我们在这之前，查看地址，就可以读取当前块的大小。

78
00:04:39,030 --> 00:04:43,540
如果我们知道大小，我们可以将大小，加到该地址，

79
00:04:43,540 --> 00:04:44,890
以访问堆的下一个块。

80
00:04:44,890 --> 00:04:47,390
然后，我们可以重复这么做。

81
00:04:47,390 --> 00:04:51,290
现在，让我们来看看来自 protostar 的堆级别1挑战。

82
00:04:51,290 --> 00:04:54,890
我们将用这个例子，看看 malloc 在现实生活中是如何工作的。

83
00:04:54,890 --> 00:04:59,360
但首先，让我们一行一行地走一遍代码，

84
00:04:59,360 --> 00:05:00,520
并试着，去想象堆，是什么样子的。

85
00:05:00,520 --> 00:05:04,000
而下一个视频，我们才会实际去做。

86
00:05:04,000 --> 00:05:06,340
这里的 objective ，似乎调用 winner() 。

87
00:05:06,340 --> 00:05:10,500
所以，我们必须以某种方式，将代码执行重定向到该函数。

88
00:05:10,500 --> 00:05:15,380
在顶部有一个名为 internet 的结构，它有两个成员，

89
00:05:15,380 --> 00:05:16,380
一个 priority 整数。

90
00:05:16,380 --> 00:05:22,030
第二个成员是，一个名为 name 的 char 指针，也就是说，name 包含一个指针，

91
00:05:22,030 --> 00:05:24,500
它指向其他地方的字符串。

92
00:05:24,500 --> 00:05:25,780
结构(struct)，与类(class)相似。

93
00:05:25,780 --> 00:05:30,570
至少在结构层面，都提供多个不同成员属性。

94
00:05:30,570 --> 00:05:36,030
现在，main 用 struct internet指针类型，定义了三个变量，

95
00:05:36,030 --> 00:05:37,030
但只有两个变量被使用。

96
00:05:37,030 --> 00:05:39,850
我猜，这是创建这个级别的剩余部分。

97
00:05:39,850 --> 00:05:45,450
我强调下 internet指针结构，因为这三个 internet 对象

98
00:05:45,450 --> 00:05:46,450
并不是存储在堆上的。

99
00:05:46,450 --> 00:05:52,500
只有指向，这些对象的地址（指针），是存储在 i1、i2和i3 中。

100
00:05:52,500 --> 00:05:56,900
总之，它会开始在堆上，分配这些对象。

101
00:05:56,900 --> 00:06:01,550
它首先，调用 malloc ，为 i1 对象提供足够的空间。

102
00:06:01,550 --> 00:06:05,630
sizeof 将返回此结构，所需的字节数。

103
00:06:05,630 --> 00:06:10,920
在本例中是 8，因为整数 priority 是4个字节，

104
00:06:10,920 --> 00:06:13,290
和char指针，它是一个地址，也是4个字节。

105
00:06:13,290 --> 00:06:16,270
又因为，我们在32位机器上。

106
00:06:16,270 --> 00:06:20,250
我们知道 malloc 返回堆中，我们现在可以使用的地址。

107
00:06:20,250 --> 00:06:25,550
所以，i1 指向内存中，某8个字节的开头。

108
00:06:25,550 --> 00:06:30,620
现在，我们要将 priority 设置为1，它将 1 

109
00:06:30,620 --> 00:06:32,310
写入分配区域的头 4 字节。

110
00:06:32,310 --> 00:06:36,930
然后，它会再分配8个字节，而

111
00:06:36,930 --> 00:06:38,520
结果的地址，将存储在char指针 name 里面。

112
00:06:38,520 --> 00:06:42,300
它位于 i1对象的 偏移 +4 处。

113
00:06:42,300 --> 00:06:50,310
作为一个程序员，我们编写i1-&gt;name，来访问 name 属性，但具体的实现，不过是简单

114
00:06:50,310 --> 00:06:56,090
去到与 i1 地址的几个偏移位置，在这种情况下， i1 +4 是就是

115
00:06:56,090 --> 00:06:57,770
char 指针 name 的位置。

116
00:06:57,770 --> 00:07:04,090
所以，现在 i1-&gt;name 将包含一个地址，该地址指向我们

117
00:07:04,090 --> 00:07:06,000
刚刚分配的堆区域。

118
00:07:06,000 --> 00:07:10,910
这8个字节用于存储 字符的列表，也就是一个字符串 —— name 变量。

119
00:07:10,910 --> 00:07:12,700
然后，对i2 再次进行同样的操作。

120
00:07:12,700 --> 00:07:15,040
我们为结构i2 腾出空间。

121
00:07:15,040 --> 00:07:16,910
我们把它的 priority 设置为2。

122
00:07:16,910 --> 00:07:20,860
我们为 name字符串，分配了另外8个字节。

123
00:07:20,860 --> 00:07:26,920
所以现在来说，我们在堆上分配了两个，在使用的对象。

124
00:07:26,920 --> 00:07:29,500
接下来，是两条strcpys。

125
00:07:29,500 --> 00:07:34,500
我们知道 strcpy 总是非常可疑，因为没有长度指示，

126
00:07:34,500 --> 00:07:37,490
而且，可能会超过空间。

127
00:07:37,490 --> 00:07:42,770
在这种情况下，internet-name 只分配了8个字节，虽然我们是可以写入

128
00:07:42,770 --> 00:07:45,620
超过了8字节，但也会真的拆散了它。

129
00:07:45,620 --> 00:07:51,810
无论如何，strcpy会将第一个参数复制到，i1对象的 name 中。

130
00:07:51,810 --> 00:07:58,400
 i1 指向 i1 对象的开始，偏移量+4（即 name ），

131
00:07:58,400 --> 00:08:02,120
是为字符串分配的8个字节可用地址。

132
00:08:02,120 --> 00:08:07,590
所以，strcpy将获取存储在那里的地址，并从参数1复制字符串到该地址。

133
00:08:07,590 --> 00:08:09,020
位置。

134
00:08:09,020 --> 00:08:11,420
同样的事情，也发生在，i2 对象的第二个参数。

135
00:08:11,421 --> 00:08:13,021
它将获取存储在 i2 +4 的地址，并尝试将字符串复制到该地址。

136
00:08:13,020 --> 00:08:15,830
之后，我们将 printf，然后退出程序。

137
00:08:15,830 --> 00:08:20,700
在下一个视频中，我们将在执行该程序，

138
00:08:20,700 --> 00:08:27,280
了解堆在现实生活中的样貌，以及我们如何在gdb中使用它。

139
00:08:27,280 --> 00:08:30,460
哦，顺便说一下。

140
00:08:30,460 --> 00:08:31,460
我撒谎了。

141
00:08:31,460 --> 00:08:34,300
我说第二个词，将包含块的大小。

142
00:08:34,300 --> 00:08:40,490
虽然它会，但最低的位，也会表示前一个块是被使用得的。

143
00:08:40,490 --> 00:08:41,520
不是空闲状态。

144
00:08:41,520 --> 00:08:44,170
对于 free() 算法来说，这变得更加重要。

145
00:08:44,170 --> 00:08:48,600
因此在我们的示例中，这些数值都是 hex 11。

146
00:08:48,600 --> 00:08:52,540
我只想在最后，写一个小小的免责声明。

147
00:08:52,540 --> 00:08:55,750
我把堆和 malloc 简化了很多。

148
00:08:55,750 --> 00:09:00,770
例如，我只讲了一个指向空闲区的指针，

149
00:09:00,770 --> 00:09:02,940
而实际上，很明显那里是非常重要的。

150
00:09:02,940 --> 00:09:08,780
如果，我们看过漏洞的历史，

151
00:09:08,780 --> 00:09:11,140
那么我们会发现，正在学习的东西，早在15年前 —— 比如2001年的ISH。

152
00:09:11,140 --> 00:09:16,820
很多东西都是没有改变，概念都是一样的，

153
00:09:16,820 --> 00:09:18,440
但是很多东西也都是不同的。

154
00:09:18,440 --> 00:09:24,280
今天的 malloc 实现是基于 dlmalloc 的，但它早已不是最初的dl malloc 

155
00:09:24,280 --> 00:09:28,000
现在它通常被称为 ptmalloc 。

156
00:09:28,000 --> 00:09:30,440
我的目标是，教你基础知识。

157
00:09:30,440 --> 00:09:36,580
尽管这不是100%正确的，但您现在应该大致了解，堆是什么，以及下一步。

158
00:09:36,580 --> 00:09:41,230
您可以将这些知识，变为到任何的堆实现。

