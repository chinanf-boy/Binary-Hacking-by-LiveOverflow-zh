1
00:00:00,450 --> 00:00:03,520
堆到底是什么，malloc到底是做什么的？

2
00:00:03,520 --> 00:00:12,620
这些是我们在这段视频中试图回答的问题。

3
00:00:12,620 --> 00:00:17,000
你可能已经知道，当你在编程时，你需要一些，更多的内存，你可能会使用

4
00:00:17,000 --> 00:00:22,340
堆，通过使用malloc分配内存，如果完成了，就可以再次释放它。

5
00:00:22,340 --> 00:00:26,740
不知怎么的，一些魔法正在发生，你不知道你是如何神奇地得到的。

6
00:00:26,740 --> 00:00:28,100
更多的记忆或者把它还给我。

7
00:00:28,100 --> 00:00:32,320
在我们讨论malloc之前，我们先讨论一下我们的进程如何获得任何内存。

8
00:00:32,320 --> 00:00:33,750
首先。

9
00:00:33,750 --> 00:00:36,800
这是通过mmap或brk完成的。

10
00:00:36,800 --> 00:00:40,370
这些是系统调用，这意味着我们直接询问内核。

11
00:00:40,370 --> 00:00:46,000
mmap请求内核给我们一些新的虚拟地址空间，基本上请求一个新的

12
00:00:46,000 --> 00:00:47,000
内存段。

13
00:00:47,000 --> 00:00:52,900
除了mmap之外，还有brk，可以用来改变已经使用的

14
00:00:52,899 --> 00:00:53,899
内存段。

15
00:00:53,899 --> 00:00:55,899
这是真正的魔法。

16
00:00:55,900 --> 00:01:00,860
最后，这个过程并不关心这个内存是如何实现的-如果有RAM，

17
00:01:00,860 --> 00:01:04,790
在RAM上的确切位置存储它，或者如果您有一个交换文件，因为您没有

18
00:01:04,789 --> 00:01:05,789
有足够的内存。

19
00:01:05,789 --> 00:01:11,139
内核和硬件负责处理这个问题，并将内存映射到进程中，

20
00:01:11,140 --> 00:01:15,420
意味着进程可以透明地访问这些内存地址并使用它们

21
00:01:15,419 --> 00:01:22,909
-在这种情况下，透明意味着“不必知道任何事情”。

22
00:01:22,909 --> 00:01:28,729
您可以使用strace执行heap1，并且可以看到所有对mmap的调用最初设置为

23
00:01:28,729 --> 00:01:30,349
处理内存区域。

24
00:01:30,350 --> 00:01:34,690
最后，它使用brk来设置堆。

25
00:01:34,689 --> 00:01:40,269
那么，我们为什么不使用mmap或brk为我们的进程获取更多的内存呢？

26
00:01:40,270 --> 00:01:44,830
为什么我们总是用malloc和free谈论堆？

27
00:01:44,829 --> 00:01:51,129
好吧，malloc只是一个非常花哨和方便的包装，可以处理BRK或MMAPping

28
00:01:51,130 --> 00:01:52,310
对我们来说。

29
00:01:52,310 --> 00:01:54,720
做得更多。

30
00:01:54,719 --> 00:02:00,689
如果堆不存在或太小，malloc将调用mmap或brk以获取更多内存。

31
00:02:00,689 --> 00:02:06,539
但除此之外，它将帮助我们组织和管理记忆。

32
00:02:06,539 --> 00:02:11,479
同样，在CTF挑战期间，以及我们稍后将看到的示例中，使用堆

33
00:02:11,480 --> 00:02:15,640
如此之少，我们将看不到任何额外的内存映射区域。

34
00:02:15,640 --> 00:02:21,430
为了简单起见，我们认为堆只是一大块固定内存

35
00:02:21,430 --> 00:02:23,140
映射内存。

36
00:02:23,140 --> 00:02:26,110
在这个记忆中，我们可以做任何我们想做的事。

37
00:02:26,110 --> 00:02:31,330
所以当我们提到堆时，实际上是指这个内存区域。

38
00:02:31,330 --> 00:02:34,970
那么，malloc将管理堆意味着什么呢？

39
00:02:34,970 --> 00:02:38,090
让我们先抽象地探讨一下这个问题。

40
00:02:38,090 --> 00:02:40,600
我们要分配8个字节。

41
00:02:40,599 --> 00:02:42,879
所以我们用8来称呼malloc。

42
00:02:42,880 --> 00:02:46,310
这意味着我们在堆上阻塞了8个字节。

43
00:02:46,310 --> 00:02:50,900
对malloc的每个调用都将返回区域被阻塞的堆的地址，以及

44
00:02:50,900 --> 00:02:54,990
有了这个地址，我们就知道在哪里可以写入8个字节。

45
00:02:54,989 --> 00:03:00,499
现在我们可以将字符串“aaaabbb”写入该地址。

46
00:03:00,500 --> 00:03:03,420
现在我们再分配两次。

47
00:03:03,420 --> 00:03:06,730
malloc（8），malloc（8）。

48
00:03:06,730 --> 00:03:07,920
这就引出了一个问题：阻塞意味着什么。

49
00:03:07,920 --> 00:03:09,310
Malloc如何知道返回的地址？

50
00:03:09,310 --> 00:03:10,760
如果我雇你给我写一个程序，给我一个我可以使用的内存地址

51
00:03:10,760 --> 00:03:11,880
对于不同的尺寸，您可以安全地提出一个有效的解决方案。

52
00:03:11,879 --> 00:03:13,189
如果您实现了这一点，那么您将创建自己的堆算法。

53
00:03:13,190 --> 00:03:16,150
所以有很多不同的方法可以实现它。

54
00:03:16,150 --> 00:03:20,170
尽管最常用的是一个名为dlmalloc的实现。

55
00:03:20,170 --> 00:03:23,790
因为是一个叫道格拉斯·李的家伙写的。

56
00:03:23,790 --> 00:03:28,540
malloc算法将为它所阻塞的每个块存储块的大小。

57
00:03:28,540 --> 00:03:29,540
在它之前。

58
00:03:29,540 --> 00:03:34,240
它还将保留4个字节，以表示自由是如何实现的。

59
00:03:34,240 --> 00:03:36,330
但我们现在只关注malloc。

60
00:03:36,329 --> 00:03:40,439
让我们再做一次mallocs，让我们像计算机一样思考。

61
00:03:40,439 --> 00:03:44,839
所以在开始的时候，当第一个malloc被调用时，我们显然知道

62
00:03:44,840 --> 00:03:45,950
堆。

63
00:03:45,950 --> 00:03:50,510
所以我们存储要在那里分配的大小，并返回块所在的地址

64
00:03:50,510 --> 00:03:53,830
程序员可以使用的部分启动。

65
00:03:53,830 --> 00:03:58,310
但是，malloc现在如何知道下一个调用malloc的位置

66
00:03:58,310 --> 00:03:59,320
放置？

67
00:03:59,319 --> 00:04:02,079
不是说我们重写了以前分配的区域。

68
00:04:02,079 --> 00:04:06,679
很明显，我们必须记住自由区的起点。

69
00:04:06,680 --> 00:04:10,770
所以malloc只需要做一些计算，并更新指向开头的地址

70
00:04:10,769 --> 00:04:15,189
通过添加我们分配给堆的块的大小。

71
00:04:15,189 --> 00:04:17,129
每一个malloc都会发生这种情况。

72
00:04:17,130 --> 00:04:22,760
所以在某个地方有一个指针，它总是指向空闲内存。

73
00:04:22,760 --> 00:04:24,670
酷。

74
00:04:24,670 --> 00:04:26,140
只是为了理解目的。

75
00:04:26,140 --> 00:04:29,760
考虑到malloc的返回地址，你能怎么处理？

76
00:04:29,760 --> 00:04:34,090
好吧，这个指针指向我们可以写入数据的起点。

77
00:04:34,090 --> 00:04:39,030
因此，如果我们在这之前查看地址，就可以读取当前块的大小。

78
00:04:39,030 --> 00:04:43,540
如果我们知道大小，我们可以将大小添加到该地址以访问下一个块

79
00:04:43,540 --> 00:04:44,890
堆。

80
00:04:44,890 --> 00:04:47,390
我们可以再这样做。

81
00:04:47,390 --> 00:04:51,290
现在让我们来看看来自原恒星的堆级别1挑战。

82
00:04:51,290 --> 00:04:54,890
我们将用这个例子来看看malloc在现实生活中是如何工作的。

83
00:04:54,890 --> 00:04:59,360
但首先，让我们一行一行地遍历代码，并尝试想象堆将如何

84
00:04:59,360 --> 00:05:00,520
看起来像。

85
00:05:00,520 --> 00:05:04,000
下一个视频我们实际上是这么做的。

86
00:05:04,000 --> 00:05:06,340
这里的目标似乎称为winner() 。

87
00:05:06,340 --> 00:05:10,500
所以我们必须以某种方式将代码执行重定向到该函数。

88
00:05:10,500 --> 00:05:15,380
在顶部有一个名为internet的结构，它有两个成员，一个优先级

89
00:05:15,380 --> 00:05:16,380
整数。

90
00:05:16,380 --> 00:05:22,030
第二个成员是一个名为name的char指针，也就是说name包含一个指针

91
00:05:22,030 --> 00:05:24,500
到其他地方的字符串。

92
00:05:24,500 --> 00:05:25,780
结构类似于类。

93
00:05:25,780 --> 00:05:30,570
至少在提供具有多个不同成员属性的结构方面。

94
00:05:30,570 --> 00:05:36,030
现在，main从类型struct internet指针定义了三个变量，但只有两个变量

95
00:05:36,030 --> 00:05:37,030
被使用。

96
00:05:37,030 --> 00:05:39,850
我想这是创建这个级别的剩余部分。

97
00:05:39,850 --> 00:05:45,450
我强调结构Internet指针，因为这三个Internet对象没有存储

98
00:05:45,450 --> 00:05:46,450
在堆栈上。

99
00:05:46,450 --> 00:05:52,500
只有指向这些对象的地址（指针）存储在i1、i2和i3中。

100
00:05:52,500 --> 00:05:56,900
无论如何，然后它开始在堆上分配这些对象。

101
00:05:56,900 --> 00:06:01,550
它首先调用malloc，为i1对象提供足够的空间。

102
00:06:01,550 --> 00:06:05,630
sizeof将返回此结构所需的字节数。

103
00:06:05,630 --> 00:06:10,920
在本例中是8，因为整数优先级是4个字节和char指针，

104
00:06:10,920 --> 00:06:13,290
它是一个地址，也是4个字节。

105
00:06:13,290 --> 00:06:16,270
因为我们在32位机器上。

106
00:06:16,270 --> 00:06:20,250
我们知道malloc返回堆中我们现在可以使用的地址。

107
00:06:20,250 --> 00:06:25,550
所以I1指向内存中8个字节的开头。

108
00:06:25,550 --> 00:06:30,620
现在我们要将优先级设置为1，它将1写入分配的

109
00:06:30,620 --> 00:06:32,310
面积。

110
00:06:32,310 --> 00:06:36,930
然后它再分配8个字节，结果地址将存储在char中

111
00:06:36,930 --> 00:06:38,520
指针名称。

112
00:06:38,520 --> 00:06:42,300
它位于i1对象的偏移量+4处。

113
00:06:42,300 --> 00:06:50,310
作为一个程序员，我们编写i1-&gt；名称来访问name属性，但是实现了它吗？

114
00:06:50,310 --> 00:06:56,090
在这种情况下，I1+4是

115
00:06:56,090 --> 00:06:57,770
字符指针名称。

116
00:06:57,770 --> 00:07:04,090
所以现在i1-&gt；名称将包含一个地址，该地址指向我们

117
00:07:04,090 --> 00:07:06,000
刚刚分配。

118
00:07:06,000 --> 00:07:10,910
这8个字节用于存储字符列表，一个字符串——名称。

119
00:07:10,910 --> 00:07:12,700
然后对I2再次进行同样的操作。

120
00:07:12,700 --> 00:07:15,040
我们为结构I2腾出空间。

121
00:07:15,040 --> 00:07:16,910
我们把它的优先级设置为2。

122
00:07:16,910 --> 00:07:20,860
我们为名称字符串分配了另外8个字节。

123
00:07:20,860 --> 00:07:26,920
所以基本上我们在堆上分配了两个对象，我们可以使用它们。

124
00:07:26,920 --> 00:07:29,500
接下来是两条街道。

125
00:07:29,500 --> 00:07:34,500
我们知道strcpy总是非常可疑，因为没有长度指示，而且

126
00:07:34,500 --> 00:07:37,490
我们可能写得比空间还多。

127
00:07:37,490 --> 00:07:42,770
在这种情况下，Internet名称只分配了8个字节，因此我们可以

128
00:07:42,770 --> 00:07:45,620
超过了8字节，真的搞砸了。

129
00:07:45,620 --> 00:07:51,810
无论如何，strcpy会将第一个参数复制到i1对象的名称中。

130
00:07:51,810 --> 00:07:58,400
I1指向I1对象的开始，偏移量+4（即名称）是地址

131
00:07:58,400 --> 00:08:02,120
为字符串分配的可用8个字节。

132
00:08:02,120 --> 00:08:07,590
所以strcpy将获取存储在那里的地址，并从参数1复制字符串。

133
00:08:07,590 --> 00:08:09,020
位置。

134
00:08:09,020 --> 00:08:11,420
同样的事情也发生在第二个关于I2对象的争论中。

135
00:08:11,421 --> 00:08:13,021
它将获取存储在i2的+4的地址，并尝试将字符串复制到该地址。

136
00:08:13,020 --> 00:08:15,830
之后，我们将打印f，然后退出程序。

137
00:08:15,830 --> 00:08:20,700
在下一个视频中，我们将在执行该程序以了解

138
00:08:20,700 --> 00:08:27,280
堆在现实生活中的外观以及我们如何在gdb中使用它。

139
00:08:27,280 --> 00:08:30,460
哦，顺便说一下。

140
00:08:30,460 --> 00:08:31,460
我撒谎了。

141
00:08:31,460 --> 00:08:34,300
我说第二个词将包含块的大小。

142
00:08:34,300 --> 00:08:40,490
是的，但最低的位也用来表示使用了前一个块。

143
00:08:40,490 --> 00:08:41,520
不是免费的。

144
00:08:41,520 --> 00:08:44,170
对于free() 算法来说，这变得更加重要。

145
00:08:44,170 --> 00:08:48,600
因此在我们的示例中，这些数值都是十六进制11。

146
00:08:48,600 --> 00:08:52,540
我只想在最后写一个小小的免责声明。

147
00:08:52,540 --> 00:08:55,750
我把堆和malloc简化了很多。

148
00:08:55,750 --> 00:09:00,770
例如，我只讲了一个指向自由区的指针，实际上在那里

149
00:09:00,770 --> 00:09:02,940
很明显，这是更重要的。

150
00:09:02,940 --> 00:09:08,780
如果我们研究剥削的历史，我们现在正在研究更多

151
00:09:08,780 --> 00:09:11,140
比15年前——比如2001年的ISH。

152
00:09:11,140 --> 00:09:16,820
很多东西都没有改变，概念都是一样的，但是很多东西都没有改变。

153
00:09:16,820 --> 00:09:18,440
也是不同的。

154
00:09:18,440 --> 00:09:24,280
今天的malloc实现是基于dlmalloc的，但它不是最初的dlmalloc

155
00:09:24,280 --> 00:09:28,000
现在它通常被称为ptmalloc。

156
00:09:28,000 --> 00:09:30,440
我的目标是教你基础知识。

157
00:09:30,440 --> 00:09:36,580
尽管这不是100%正确的，但您现在应该大致了解堆是什么，以及

158
00:09:36,580 --> 00:09:41,230
要查找的内容，您可以将这些知识转移到任何堆实现中。

