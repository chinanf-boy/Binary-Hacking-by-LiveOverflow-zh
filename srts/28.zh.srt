1
00:00:00,110 --> 00:00:05,340
上一集我们进行了第一次网络挑战，我们首先反向设计了服务器

2
00:00:05,340 --> 00:00:09,150
正在监听一个端口，然后我们用netcat连接到它。

3
00:00:09,150 --> 00:00:14,060
这个视频我们想深入一层，看看TCP协议。

4
00:00:14,059 --> 00:00:18,069
这将是我们第一次看到发送数据包意味着什么

5
00:00:18,070 --> 00:00:25,600
网络。

6
00:00:25,600 --> 00:00:27,950
我们已经多次使用过netcat。

7
00:00:27,950 --> 00:00:31,620
我们在CTF和最后一个视频中使用它来连接挑战。

8
00:00:31,620 --> 00:00:35,250
在Web安全系列中，我们使用它来与真正的Web服务器对话。

9
00:00:35,250 --> 00:00:41,000
所以你知道，netcat是一个非常方便的工具，可以通过网络发送TCP包。

10
00:00:41,000 --> 00:00:45,190
所以我建议我们下载wireshark来分析我们用netcat发送的数据包。

11
00:00:45,190 --> 00:00:50,890
当我们打开wireshark时，我们选择要捕获数据包的网络接口。

12
00:00:50,890 --> 00:00:55,770
在这种情况下，我们的流量不会离开机器，因此我们可以选择环回接口。

13
00:00:55,770 --> 00:01:00,480
环回更像是一个虚拟的网络接口，它不是一个真正的物理网卡卡住了

14
00:01:00,480 --> 00:01:01,750
在你的电脑里。

15
00:01:01,750 --> 00:01:06,940
通过这个接口，我们在本地机器上发送的所有流量都将通过这个接口传输。

16
00:01:06,940 --> 00:01:13,570
正如您可能知道的，自己的机器总是被标识为localhost或IP 127.0.0.1。

17
00:01:13,570 --> 00:01:19,290
现在让我们使用两个终端窗口，在一个窗口中，我们以监听模式启动netcat。

18
00:01:19,290 --> 00:01:20,970
我们选择一个端口。

19
00:01:20,970 --> 00:01:25,720
在另一个窗口中，我们可以执行netstat，就像在最后一个视频中一样，我们可以列出所有

20
00:01:25,720 --> 00:01:29,080
当前正在侦听端口的进程。

21
00:01:29,080 --> 00:01:31,240
下面是我们的netcat过程。

22
00:01:31,240 --> 00:01:35,280
你知道吗，让我们用strace来执行netcat服务器，这样我们就可以看到

23
00:01:35,280 --> 00:01:39,100
netcat用于建立服务器的系统调用。

24
00:01:39,100 --> 00:01:45,500
所以它将首先创建一个套接字，设置一些选项，然后绑定端口1234，现在正在监听

25
00:01:45,500 --> 00:01:49,770
在该端口上，正在等待通过accept建立连接。

26
00:01:49,770 --> 00:01:54,530
这基本上就是我们在上一个视频中逆向工程的内容。

27
00:01:54,530 --> 00:01:58,280
我们也可以快速检查wireshark，我们看不到任何数据包通过

28
00:01:58,280 --> 00:01:59,320
网络尚未。

29
00:01:59,320 --> 00:02:00,320
好啊。

30
00:02:00,320 --> 00:02:04,210
现在，让我们使用第二个窗口连接到这个netcat服务器。

31
00:02:04,210 --> 00:02:09,010
您可以在服务器上看到accept现在返回，因为客户端与

32
00:02:09,009 --> 00:02:10,009
端口。

33
00:02:10,009 --> 00:02:12,689
现在，我们在Wireshark中看到了三个条目。

34
00:02:12,690 --> 00:02:16,410
我们看到一个syn，syn ack和ack。小包裹。

35
00:02:16,410 --> 00:02:19,070
让我们快速看一下。

36
00:02:19,070 --> 00:02:23,110
正如您在最低的窗口中看到的，数据包只是一些二进制数据。

37
00:02:23,110 --> 00:02:28,730
这个二进制数据意味着wireshark可以很好地解析和显示我们。

38
00:02:28,730 --> 00:02:33,680
所以在上面我们可以看到解码后的包，它被层层划分。

39
00:02:33,680 --> 00:02:38,890
因为这个包没有离开我们的机器，所以以太网层都是零。

40
00:02:38,890 --> 00:02:43,200
通常，您可以在这里找到您的MAC地址和来自交换机或路由器的MAC地址。

41
00:02:43,200 --> 00:02:47,200
因此，该层仅用于两个直接连接之间。

42
00:02:47,200 --> 00:02:50,770
除了MAC地址，这个层还包含一个类型。

43
00:02:50,770 --> 00:02:57,550
类型设置为hex 800，表示下一层是IPv4层。

44
00:02:57,550 --> 00:03:00,500
Wireshark看到了这一点，现在知道如何解码下一个字节了。

45
00:03:00,500 --> 00:03:05,640
单击下一层时，wireshark将突出显示包的哪些字节属于

46
00:03:05,640 --> 00:03:06,780
到那一层。

47
00:03:06,780 --> 00:03:12,630
然后您可以看到它是如何决定它是一个IPv4，版本4层的，因为

48
00:03:12,629 --> 00:03:16,759
这个字节的前4位是4。

49
00:03:16,760 --> 00:03:21,440
您还可以在这里看到源IP和目标IP，在本例中是相同的。

50
00:03:21,440 --> 00:03:26,830
因此，当带有MAC地址的以太网层是关于直接连接时，IP层

51
00:03:26,830 --> 00:03:31,260
在互联网上可以包含一个非常远的地址，并且交换机将确保

52
00:03:31,260 --> 00:03:36,440
直到你到达那台机器，这个包才被转发。

53
00:03:36,440 --> 00:03:41,290
这个层还包含了关于层的信息，这就是协议

54
00:03:41,290 --> 00:03:42,290
标识符。

55
00:03:42,290 --> 00:03:47,370
在本例中，它是6，这意味着这个IP层的内容是一个TCP头。

56
00:03:47,370 --> 00:03:52,450
IP和TCP通常在一起，这很常见，因此您可能听说过

57
00:03:52,450 --> 00:03:57,790
在TCP/IP之前，它只是说在IP层上有一个TCP层。

58
00:03:57,790 --> 00:04:02,500
因此，以太网层有助于从一台机器到另一台机器，IP层有助于识别

59
00:04:02,500 --> 00:04:07,900
TCP层现在将帮助识别

60
00:04:07,900 --> 00:04:12,040
这台机器上的程序或进程应该处理这个包。

61
00:04:12,040 --> 00:04:14,500
并用端口号标识。

62
00:04:14,500 --> 00:04:18,650
您可以在这里看到目标端口设置为1234。

63
00:04:18,650 --> 00:04:24,210
您还可以在这里看到一个源端口，这是必需的，这样您就可以从

64
00:04:24,210 --> 00:04:25,480
这个服务器。

65
00:04:25,479 --> 00:04:29,859
所以当服务器用一个包响应时，它将使用这个端口，这样客户端

66
00:04:29,860 --> 00:04:33,330
机器知道哪个进程得到这个响应。

67
00:04:33,330 --> 00:04:36,000
这通常是一个随机的高端口号。

68
00:04:35,999 --> 00:04:41,059
不管怎样，现在我们了解了完整的TCP包是如何构造的，现在让我们来看看

69
00:04:41,060 --> 00:04:42,530
协议。

70
00:04:42,529 --> 00:04:48,379
协议只是指一组关于如何与另一台计算机对话的规则。

71
00:04:48,380 --> 00:04:53,940
如果客户机和服务器就如何来回发送数据达成一致，它将工作。

72
00:04:53,940 --> 00:05:00,160
所以我们现在看到的就是有人为了创建一个数据连接而想到的。

73
00:05:00,159 --> 00:05:05,509
请记住，目前我们还没有向netcat发送任何数据，到目前为止，我们只建立了

74
00:05:05,509 --> 00:05:06,649
连接。

75
00:05:06,649 --> 00:05:10,909
好的，我们看到交换了3个包。

76
00:05:10,909 --> 00:05:15,459
首先，客户机发送了一个所谓的SYN包，一个同步包。

77
00:05:15,460 --> 00:05:19,230
然后服务器用一个syn，ack包响应。

78
00:05:19,229 --> 00:05:22,079
意思是我承认我收到了它。

79
00:05:22,080 --> 00:05:25,650
这很重要，因为可能最初的数据包没有到达。

80
00:05:25,650 --> 00:05:30,860
因此，当您作为客户机得到响应时，您知道服务器收到了您的消息。

81
00:05:30,860 --> 00:05:35,200
这意味着客户机现在知道连接可以工作了。

82
00:05:35,199 --> 00:05:40,199
但是从服务器的角度来看，服务器还不知道发送

83
00:05:40,199 --> 00:05:42,129
数据包成功。

84
00:05:42,129 --> 00:05:45,179
也许服务器只能接收但不能发送数据包。

85
00:05:45,180 --> 00:05:51,260
因此，客户机将用一个ACK包响应SYN、ACK包，确认

86
00:05:51,259 --> 00:05:57,989
它得到了服务器的回答，现在双方都确定，是的，我成功地交换了数据包

87
00:05:57,990 --> 00:06:01,140
用另一台机器，现在我们可以谈数据了。

88
00:06:01,139 --> 00:06:03,489
这一切都是透明的。

89
00:06:03,490 --> 00:06:06,520
您不必自己构建这些包。

90
00:06:06,520 --> 00:06:09,500
您只需打开一个插座并等待连接。

91
00:06:09,499 --> 00:06:10,499
好啊。

92
00:06:10,499 --> 00:06:13,889
现在让我们将一些数据从客户机发送到服务器。

93
00:06:13,889 --> 00:06:18,249
您可以立即看到服务器能够读取您发送的行。

94
00:06:18,250 --> 00:06:19,940
这在Wireshark中是怎么看的？

95
00:06:19,939 --> 00:06:23,499
我们看到两个新的包。

96
00:06:23,499 --> 00:06:27,619
从客户机到服务器的PSH数据包，以及返回的ACK数据包。

97
00:06:27,619 --> 00:06:31,369
来自客户机的数据包现在也有一个额外的数据层。

98
00:06:31,369 --> 00:06:35,259
数据层只包含我们发送的原始字节。

99
00:06:35,259 --> 00:06:39,919
服务器用ACK响应，通知客户端包成功

100
00:06:39,919 --> 00:06:40,919
收到。

101
00:06:40,919 --> 00:06:43,159
现在让我们从服务器发送一个响应。

102
00:06:43,159 --> 00:06:49,399
你看，服务器只是把文本写到文件描述符4，它是文件描述符

103
00:06:49,401 --> 00:06:50,771
接受返回。

104
00:06:50,770 --> 00:06:56,470
如您所见，应用程序只需写入该paseudo文件、该套接字和

105
00:06:56,470 --> 00:06:59,460
下面的魔法通过网络发送了。

106
00:06:59,459 --> 00:07:04,389
现在让我们看看它做了什么，它还发送了一个psh包和客户机

107
00:07:04,389 --> 00:07:07,969
用一个ACK包将到达的货物打包回去。

108
00:07:07,969 --> 00:07:09,359
还有一件事。

109
00:07:09,360 --> 00:07:11,980
显然，数据包的大小是有限的。

110
00:07:11,979 --> 00:07:16,709
所以当你发送大量数据时会发生什么，比如说你上传了一个巨大的文件，

111
00:07:16,709 --> 00:07:18,759
那怎么办？

112
00:07:18,760 --> 00:07:21,280
让我们复制一些字符并发送它们。

113
00:07:21,279 --> 00:07:25,569
啊，看，现在有两个以上的包。

114
00:07:25,569 --> 00:07:30,069
在开发应用程序时，您不会看到它，但在内核、网卡或

115
00:07:30,069 --> 00:07:33,099
司机，我真的不知道，它被分开了。

116
00:07:33,099 --> 00:07:37,339
您还可以看到第二个包没有与第一个包一起发送，第二个包

117
00:07:37,339 --> 00:07:41,639
只有当服务器确认第一个包时，才会发送该包。

118
00:07:41,639 --> 00:07:44,279
让我们看看当你杀死客户时会发生什么。

119
00:07:44,279 --> 00:07:49,909
即使我们只是ctrl+c netcat，我们也可以在wireshark中看到，fin包已经发送了

120
00:07:49,909 --> 00:07:53,219
out，do表示我们已经完成了这个频道。

121
00:07:53,219 --> 00:07:57,939
您可以释放您的资源，并且不必期望来自此连接的更多数据包。

122
00:07:57,940 --> 00:08:01,330
和安装过程一样，有3个包交换。

123
00:08:01,330 --> 00:08:06,320
服务器通过客户机确认fin，现在客户机知道，服务器知道

124
00:08:06,319 --> 00:08:07,799
完成了。

125
00:08:07,800 --> 00:08:13,140
但是服务器还不知道客户机是否知道它已经完成了，所以它也

126
00:08:13,139 --> 00:08:14,439
用ACK响应。

127
00:08:14,439 --> 00:08:16,739
现在都结束了。

128
00:08:16,740 --> 00:08:21,130
现在整个交换被称为TCP流。

129
00:08:21,129 --> 00:08:26,849
我们建立了一个连接，然后来回交换数据，然后退出连接。

130
00:08:26,849 --> 00:08:32,619
wireshark允许我们研究这个流，例如使用follow tcp流。

131
00:08:32,620 --> 00:08:37,070
这里只有可见的数据和发送内容的颜色编码。

132
00:08:37,070 --> 00:08:41,500
现在您应该从Web安全系列中观看我的HTTP协议视频，因为

133
00:08:41,500 --> 00:08:46,160
现在您将更好地理解拥有服务器和客户机意味着什么。

134
00:08:46,160 --> 00:08:51,080
HTTP只是通过TCP发送的数据，正是我们发送这些消息的方式。

135
00:08:51,079 --> 00:08:56,469
浏览器和Web服务器只是一些特殊的程序，它们用特殊的

136
00:08:56,470 --> 00:08:57,860
通过TCP接收的消息。

