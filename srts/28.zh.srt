1
00:00:00,110 --> 00:00:05,340
上一集我们进行了第一次网络挑战，首个网络反工程，

2
00:00:05,340 --> 00:00:09,150
是关于服务器正在监听一个端口，然后，我们用 netcat 连接到它。

3
00:00:09,150 --> 00:00:14,060
这个视频我们想深入一层，看看TCP协议。

4
00:00:14,059 --> 00:00:18,069
这将是我们第一次了解，

5
00:00:18,070 --> 00:00:25,600
在网络发送数据包，是什么意思。

6
00:00:25,600 --> 00:00:27,950
我们已经多次使用过 netcat。

7
00:00:27,950 --> 00:00:31,620
我们在CTF和最后一个视频中，使用它来连接挑战(服务)。

8
00:00:31,620 --> 00:00:35,250
在Web安全系列中，我们使用它，与真正的Web服务器进行对话。

9
00:00:35,250 --> 00:00:41,000
所以你知道，netcat是一个非常方便的工具，可以通过网络发送TCP包。

10
00:00:41,000 --> 00:00:45,190
所以，我建议我们下载wireshark来分析，用netcat发送的数据包。

11
00:00:45,190 --> 00:00:50,890
当我们打开 wireshark 时，我们选择要捕获数据包的网络接口。

12
00:00:50,890 --> 00:00:55,770
在这种情况下，我们的流量不会离开机器，因此我们可以选择环回(lookback)接口。

13
00:00:55,770 --> 00:01:00,480
环回更像是一个虚拟的网络接口，它不是一个真正的物理网卡,

14
00:01:00,480 --> 00:01:01,750
在你的电脑里。

15
00:01:01,750 --> 00:01:06,940
通过这个接口，我们在本地机器上发送的所有流量，都将通过这个接口传输。

16
00:01:06,940 --> 00:01:13,570
正如您可能知道的，自己的机器总是，被标识为localhost或IP 127.0.0.1。

17
00:01:13,570 --> 00:01:19,290
现在，让我们使用两个终端窗口，在一个窗口中，我们以监听模式启动netcat。

18
00:01:19,290 --> 00:01:20,970
和我们选择一个端口。

19
00:01:20,970 --> 00:01:25,720
在另一个窗口中，我们可以执行 netstat，就像在上个视频中一样，我们可以列出，

20
00:01:25,720 --> 00:01:29,080
所有当前正在监听端口的进程。

21
00:01:29,080 --> 00:01:31,240
下面是我们的 netcat 进程。

22
00:01:31,240 --> 00:01:35,280
知道吗，让我们用 strace 来执行 netcat 服务器，

23
00:01:35,280 --> 00:01:39,100
这样我们就可以看到，netcat 用于建立服务器的所有 syscalls。

24
00:01:39,100 --> 00:01:45,500
所以，它将首先创建一个套接字，设置一些选项，然后绑定端口1234，

25
00:01:45,500 --> 00:01:49,770
现在正在监听该端口，等待通过 accept 建立一个连接。

26
00:01:49,770 --> 00:01:54,530
这基本上，就是我们在上一个视频中，逆向工程的内容。

27
00:01:54,530 --> 00:01:58,280
我们也可以快速检查 wireshark，我们看不到网络，

28
00:01:58,280 --> 00:01:59,320
任何数据包发送

29
00:01:59,320 --> 00:02:00,320
好啊。

30
00:02:00,320 --> 00:02:04,210
现在，让我们使用第二个窗口，连接到这个netcat服务器。

31
00:02:04,210 --> 00:02:09,010
您可以在服务器上，看到 accept 现在 返回，

32
00:02:09,009 --> 00:02:10,009
因为客户端连接到了端口。

33
00:02:10,009 --> 00:02:12,689
现在，我们在Wireshark中，看到了三个条目。

34
00:02:12,690 --> 00:02:16,410
我们看到SYN, SYNACK 和 ACK。数据包。

35
00:02:16,410 --> 00:02:19,070
让我们快速看一下。

36
00:02:19,070 --> 00:02:23,110
正如您在最底部的窗口中，看到的，数据包只是一些二进制数据。

37
00:02:23,110 --> 00:02:28,730
这个二进制数据，意味着wireshark，可以很好地解析和显示。

38
00:02:28,730 --> 00:02:33,680
所以在这上面，我们可以看到解码后的包，它被层层划分。

39
00:02:33,680 --> 00:02:38,890
因为，这个包没有离开我们的机器，所以，以太网层都是零。

40
00:02:38,890 --> 00:02:43,200
通常，您可以在这里找到您的MAC地址，和来自交换机或路由器的MAC地址。

41
00:02:43,200 --> 00:02:47,200
因此，该层仅用于两个直接连接之间。

42
00:02:47,200 --> 00:02:50,770
除了，MAC地址，这个层还包含一个类型。

43
00:02:50,770 --> 00:02:57,550
类型设置为hex 800，表示下一层是IPv4层。

44
00:02:57,550 --> 00:03:00,500
Wireshark看到了，并知道现在，如何解码下一个字节了。

45
00:03:00,500 --> 00:03:05,640
单击下一层时，wireshark将高亮显示包的哪些字节，

46
00:03:05,640 --> 00:03:06,780
属于哪一层。

47
00:03:06,780 --> 00:03:12,630
然之后，您可以看到它，是如何决定它是一个IPv4，版本4的层，因为

48
00:03:12,629 --> 00:03:16,759
这个字节的前4位是 4。

49
00:03:16,760 --> 00:03:21,440
您还可以在这里，看到源IP和目标IP，在本例中是相同的。

50
00:03:21,440 --> 00:03:26,830
因此，当带有MAC地址的以太网层，是关于直接连接时，

51
00:03:26,830 --> 00:03:31,260
IP层可以包含一个，在互联网上，非常远的地址，并且，

52
00:03:31,260 --> 00:03:36,440
交换机将确保直到你到达那台机器，这个包才被转发。

53
00:03:36,440 --> 00:03:41,290
然后，这个层还包含了关于层的信息，

54
00:03:41,290 --> 00:03:42,290
而这就是协议标识符。

55
00:03:42,290 --> 00:03:47,370
在本例中，它是6，这意味着，这个IP层的内容是一个TCP头。

56
00:03:47,370 --> 00:03:52,450
IP和TCP通常在一起，这很常见，因此您可能之前谬听说过TCP/IP，

57
00:03:52,450 --> 00:03:57,790
它只是说在IP层上，有一个TCP层。

58
00:03:57,790 --> 00:04:02,500
因此，以太网层有助于从一台机器到另一台机器，

59
00:04:02,500 --> 00:04:07,900
IP层有助于识别哪台机器才是真实的目的地，

60
00:04:07,900 --> 00:04:12,040
而TCP层现在将帮助识别，这台机器上的程序或进程，应该处理这个包。

61
00:04:12,040 --> 00:04:14,500
并用端口号标示。

62
00:04:14,500 --> 00:04:18,650
您可以在这里，看到目标端口设置为1234。

63
00:04:18,650 --> 00:04:24,210
您还可以在这里，看到一个源端口，这是必需的，

64
00:04:24,210 --> 00:04:25,480
这样您就可以从这个服务器接收回应。

65
00:04:25,479 --> 00:04:29,859
所以，当服务器用一个包响应时，它将使用这个端口，

66
00:04:29,860 --> 00:04:33,330
这样客户端机器，知道哪个进程得到这个响应。

67
00:04:33,330 --> 00:04:36,000
这(服务端所用)通常是一个随机的，大数，端口号。

68
00:04:35,999 --> 00:04:41,059
总之，现在我们了解了完整的TCP包是如何构造的，

69
00:04:41,060 --> 00:04:42,530
现在让我们来看看协议。

70
00:04:42,529 --> 00:04:48,379
协议只是指一组，关于如何与另一台计算机对话的规则。

71
00:04:48,380 --> 00:04:53,940
如果客户端和服务器，就如何来回发送数据达成一致，它将工作。

72
00:04:53,940 --> 00:05:00,160
所以，我们现在看到的，就是有人为了创建一个数据连接而想出来的。

73
00:05:00,159 --> 00:05:05,509
请记住，目前我们还没有向netcat发送任何数据，到目前为止，

74
00:05:05,509 --> 00:05:06,649
我们只是建立了连接。

75
00:05:06,649 --> 00:05:10,909
好的，我们看到交换了3个包。

76
00:05:10,909 --> 00:05:15,459
首先，客户端发送了一个所谓的SYN包，一个同步(synchronize)包。

77
00:05:15,460 --> 00:05:19,230
然后，服务器用一个 SYN，ACK包响应。

78
00:05:19,229 --> 00:05:22,079
意思是，知道，我收到它。

79
00:05:22,080 --> 00:05:25,650
这很重要，因为可能最初的数据包没有到达。

80
00:05:25,650 --> 00:05:30,860
因此，当您作为客户端得到响应时，您知道服务器，是收到了您的消息。

81
00:05:30,860 --> 00:05:35,200
这意味着，客户端现在知道连接可以工作了。

82
00:05:35,199 --> 00:05:40,199
但是，从服务器的角度来看，

83
00:05:40,199 --> 00:05:42,129
服务器还不知道发送数据包是否成功。

84
00:05:42,129 --> 00:05:45,179
也许服务器只能接收，但不能发送数据包。

85
00:05:45,180 --> 00:05:51,260
因此，客户端将用一个ACK包，响应SYN、ACK包，

86
00:05:51,259 --> 00:05:57,989
确认它得到了服务器的回答，现在双方都确定，是的，我们之间成功交换了数据包，

87
00:05:57,990 --> 00:06:01,140
现在，我们可以谈数据了。

88
00:06:01,139 --> 00:06:03,489
这一切都是透明的。

89
00:06:03,490 --> 00:06:06,520
您不必自己构建这些包。

90
00:06:06,520 --> 00:06:09,500
您只需打开一个套接字，并等待连接。

91
00:06:09,499 --> 00:06:10,499
好啊。

92
00:06:10,499 --> 00:06:13,889
现在让我们将一些数据，从客户端发送到服务器。

93
00:06:13,889 --> 00:06:18,249
您可以立即看到服务器，能够读取您发送的行。

94
00:06:18,250 --> 00:06:19,940
这在Wireshark中，是怎么看的？

95
00:06:19,939 --> 00:06:23,499
我们看到两个新的包。

96
00:06:23,499 --> 00:06:27,619
从客户端到服务器的PSH数据包，以及返回的ACK数据包。

97
00:06:27,619 --> 00:06:31,369
来自客户端的数据包，现在也有一个额外的数据(DATA)层。

98
00:06:31,369 --> 00:06:35,259
数据层，只包含我们发送的原始字节。

99
00:06:35,259 --> 00:06:39,919
服务器用ACK响应，

100
00:06:39,919 --> 00:06:40,919
通知客户端包，我成功收到你的信息。

101
00:06:40,919 --> 00:06:43,159
现在，让我们从服务器发送一个响应。

102
00:06:43,159 --> 00:06:49,399
你看，服务器只是把文本写到文件描述符4，

103
00:06:49,401 --> 00:06:50,771
它是 accept 返回的文件描述符。

104
00:06:50,770 --> 00:06:56,470
如您所见，应用程序只需写入该 paseud o文件、该套接字和

105
00:06:56,470 --> 00:06:59,460
下面的魔法，就会通过网络发送出去了。

106
00:06:59,459 --> 00:07:04,389
现在，让我们看看它做了什么，它还发送了一个PSH包，

107
00:07:04,389 --> 00:07:07,969
和客户端用一个ACK包响应回去，确认(快递)包到了。

108
00:07:07,969 --> 00:07:09,359
还有一件事。

109
00:07:09,360 --> 00:07:11,980
显然，数据包的大小是有限的。

110
00:07:11,979 --> 00:07:16,709
所以，当你发送大量数据时会发生什么，比如，说你上传了一个巨大的文件，

111
00:07:16,709 --> 00:07:18,759
那怎么办？

112
00:07:18,760 --> 00:07:21,280
让我们复制一些字符，并发送它们。

113
00:07:21,279 --> 00:07:25,569
啊，看，现在有两个以上的包。

114
00:07:25,569 --> 00:07:30,069
在开发应用程序时，您不会看到它，

115
00:07:30,069 --> 00:07:33,099
但在内核、网卡或传输，我真的不知道，它是被分开的。

116
00:07:33,099 --> 00:07:37,339
您还可以看到第二个包，没有与第一个包一起发送，

117
00:07:37,339 --> 00:07:41,639
第二个包只有当服务器确认第一个包时，才会发送该包。

118
00:07:41,639 --> 00:07:44,279
让我们看看，当你关闭客户端时，会发生什么。

119
00:07:44,279 --> 00:07:49,909
即使，我们只是ctrl+c netcat，我们也可以在w ireshark 中看到，FIN包已经发送出去，

120
00:07:49,909 --> 00:07:53,219
确切表示，我们已经完成了这个 channel （传输管道）。

121
00:07:53,219 --> 00:07:57,939
您可以释放您的资源，并且不必期望，来自此连接的更多数据包。

122
00:07:57,940 --> 00:08:01,330
和进程的初始设置一样，有3个包交换。

123
00:08:01,330 --> 00:08:06,320
服务器通过客户端确认FIN，现在客户端知道，服务器知道，

124
00:08:06,319 --> 00:08:07,799
我们完成了，(分手吧)。

125
00:08:07,800 --> 00:08:13,140
但是，服务器还不知道，客户端是否知道它已经完成了，

126
00:08:13,139 --> 00:08:14,439
所以，它也用ACK响应。

127
00:08:14,439 --> 00:08:16,739
现在，都结束了。

128
00:08:16,740 --> 00:08:21,130
现在，整个交换过程被称为TCP流程，说是TCP stream（流）。

129
00:08:21,129 --> 00:08:26,849
我们建立了一个连接，然后来回交换数据，然后退出连接。

130
00:08:26,849 --> 00:08:32,619
wireshark 允许我们研究这个 stream ，例如使用Follow(跟踪) tcp stream 。

131
00:08:32,620 --> 00:08:37,070
这里，只有可见的数据和发送内容的，带颜色的代码。

132
00:08:37,070 --> 00:08:41,500
现在，您应该从Web安全系列中，观看我的HTTP协议视频，

133
00:08:41,500 --> 00:08:46,160
因为现在您将更好地理解，拥有服务器和客户端意味着什么。

134
00:08:46,160 --> 00:08:51,080
还有，HTTP只是在TCP之上发送的数据(协议/规则)，正是我们发送这些消息的方式。

135
00:08:51,079 --> 00:08:56,469
一个浏览器和Web服务器只是一些特殊的程序，

136
00:08:56,470 --> 00:08:57,860
它们用特殊方式，在 TCP 上接收的特殊消息。

