1
00:00:00,110 --> 00:00:05,340
上一集我们进行了第一次网络挑战
我们是不是第一次反向设计了服务器

2
00:00:05,340 --> 00:00:09,150
正在监听端口，然后我们连接
与netcat一起。

3
00:00:09,150 --> 00:00:14,060
这个视频我们想再深入一层
看看TCP协议。

4
00:00:14,059 --> 00:00:18,069
这将是我们第一次
看看发送一个包意味着什么

5
00:00:18,070 --> 00:00:25,600
网络。

6
00:00:25,600 --> 00:00:27,950
我们已经多次使用过netcat。

7
00:00:27,950 --> 00:00:31,620
我们在CTF和最后一个视频中使用它来连接
迎接挑战。

8
00:00:31,620 --> 00:00:35,250
在Web安全系列中，我们使用它
与真正的网络服务器交谈。

9
00:00:35,250 --> 00:00:41,000
所以你知道netcat是一个非常方便的工具
通过网络发送TCP数据包。

10
00:00:41,000 --> 00:00:45,190
所以我建议我们下载wireshark来分析
我们用netcat发送的数据包。

11
00:00:45,190 --> 00:00:50,890
当我们打开wireshark时，我们选择网络
接口我们要捕获数据包。

12
00:00:50,890 --> 00:00:55,770
在这种情况下，我们的交通不会离开
因此我们可以选择环回接口。

13
00:00:55,770 --> 00:01:00,480
环回更像是一个虚拟网络接口，
这不是真正的物理网卡卡住了

14
00:01:00,480 --> 00:01:01,750
在你的电脑里。

15
00:01:01,750 --> 00:01:06,940
通过这个接口我们所有的流量
我们用本地机器发送的。

16
00:01:06,940 --> 00:01:13,570
你可能知道，自己的机器总是
标识为localhost或IP 127.0.0.1。

17
00:01:13,570 --> 00:01:19,290
现在我们用两个终端窗口
一个窗口，我们以监听模式启动netcat

18
00:01:19,290 --> 00:01:20,970
我们选择一个端口。

19
00:01:20,970 --> 00:01:25,720
在另一个窗口中，我们可以执行netstat，
就像上一个视频，我们可以列出所有

20
00:01:25,720 --> 00:01:29,080
当前正在侦听的进程
港口。

21
00:01:29,080 --> 00:01:31,240
下面是我们的netcat过程。

22
00:01:31,240 --> 00:01:35,280
你知道吗，让我们执行我们的netcat
服务器带有strace，因此我们可以看到

23
00:01:35,280 --> 00:01:39,100
netcat用于建立服务器的系统调用。

24
00:01:39,100 --> 00:01:45,500
所以它将首先创建一个套接字，设置一些
选项，然后绑定端口1234，现在正在侦听

25
00:01:45,500 --> 00:01:49,770
在那个端口上，正在等待连接
接受建立。

26
00:01:49,770 --> 00:01:54,530
基本上就是我们逆向工程的
在最后一段视频中。

27
00:01:54,530 --> 00:01:58,280
我们还可以快速检查wireshark，
没有看到任何数据包通过

28
00:01:58,280 --> 00:01:59,320
网络尚未。

29
00:01:59,320 --> 00:02:00,320
好啊。

30
00:02:00,320 --> 00:02:04,210
现在让我们用第二个窗口连接
到这个netcat服务器。

31
00:02:04,210 --> 00:02:09,010
您可以在服务器上看到现在接受的
返回，因为客户端与

32
00:02:09,009 --> 00:02:10,009
端口。

33
00:02:10,009 --> 00:02:12,689
现在，我们在Wireshark中看到了三个条目。

34
00:02:12,690 --> 00:02:16,410
我们看到一个syn，syn ack和ack。小包裹。

35
00:02:16,410 --> 00:02:19,070
让我们快速看一下。

36
00:02:19,070 --> 00:02:23,110
正如你在最低的窗口看到的，一个包
只是一些二进制数据。

37
00:02:23,110 --> 00:02:28,730
二进制数据的含义是
可以很好地分析和显示我们。

38
00:02:28,730 --> 00:02:33,680
所以在上面我们可以看到解码后的包
它被层层划分。

39
00:02:33,680 --> 00:02:38,890
因为这个包裹没有离开我们的机器
以太网层都是零。

40
00:02:38,890 --> 00:02:43,200
通常你会在这里找到你的MAC地址
以及交换机或路由器的MAC地址。

41
00:02:43,200 --> 00:02:47,200
所以该层只在两个直接层之间使用
连接。

42
00:02:47,200 --> 00:02:50,770
除了MAC地址，这个层也
包含类型。

43
00:02:50,770 --> 00:02:57,550
类型设置为hex 800，表示
下一层是一个IPv4层。

44
00:02:57,550 --> 00:03:00,500
Wireshark看到了这一点，现在知道如何解码了
下一个字节。

45
00:03:00,500 --> 00:03:05,640
当你点击下一层时，wireshark
将突出显示数据包的哪些字节属于

46
00:03:05,640 --> 00:03:06,780
到那一层。

47
00:03:06,780 --> 00:03:12,630
然后你可以看到它是如何决定的
它是一个IP v4，版本4层，因为

48
00:03:12,629 --> 00:03:16,759
这个字节的前4位是4。

49
00:03:16,760 --> 00:03:21,440
您还可以在这里看到源和目标
IP，在本例中是相同的。

50
00:03:21,440 --> 00:03:26,830
所以当以太网层有MAC地址时
是关于直接连接，IP层

51
00:03:26,830 --> 00:03:31,260
可以包含一个非常远的地址
互联网和交换机将确保

52
00:03:31,260 --> 00:03:36,440
这个包被转发到
那台机器。

53
00:03:36,440 --> 00:03:41,290
此层还包含有关
之后的层，这就是协议

54
00:03:41,290 --> 00:03:42,290
标识符。

55
00:03:42,290 --> 00:03:47,370
在这个例子中是6，这意味着内容
这个IP层是一个TCP头。

56
00:03:47,370 --> 00:03:52,450
IP和TCP通常在一起，它是
很常见，所以你可能听说过

57
00:03:52,450 --> 00:03:57,790
以前的TCP/IP，它只是说
是IP层上的TCP层。

58
00:03:57,790 --> 00:04:02,500
因此，以太网层有助于从计算机
对于机器，IP层有助于识别

59
00:04:02,500 --> 00:04:07,900
哪台机器才是真正的目的地，
TCP层现在将帮助识别

60
00:04:07,900 --> 00:04:12,040
这台机器上的程序或进程应该
处理这个包。

61
00:04:12,040 --> 00:04:14,500
并用端口号标识。

62
00:04:14,500 --> 00:04:18,650
你可以在这里看到目的港
设置为1234。

63
00:04:18,650 --> 00:04:24,210
您还可以在这里看到一个源端口，它
是必需的，因此您可以从

64
00:04:24,210 --> 00:04:25,480
这个服务器。

65
00:04:25,479 --> 00:04:29,859
所以当服务器用数据包响应时，
它将使用这个端口，这样客户端

66
00:04:29,860 --> 00:04:33,330
机器知道哪个进程得到这个响应。

67
00:04:33,330 --> 00:04:36,000
这通常是一个随机的高端口号。

68
00:04:35,999 --> 00:04:41,059
总之，现在我们了解了完整的TCP包
是建造的，现在让我们看看

69
00:04:41,060 --> 00:04:42,530
协议。

70
00:04:42,529 --> 00:04:48,379
协议只是指一组规则
如何与另一台计算机对话。

71
00:04:48,380 --> 00:04:53,940
如果客户机和服务器同意如何发送
数据来回，它会工作。

72
00:04:53,940 --> 00:05:00,160
所以我们现在看到的只是
为了创建一个数据连接。

73
00:05:00,159 --> 00:05:05,509
记住，目前我们还没有发送
任何与netcat有关的数据，到目前为止，我们只建立了

74
00:05:05,509 --> 00:05:06,649
连接。

75
00:05:06,649 --> 00:05:10,909
好的，我们看到交换了3个包。

76
00:05:10,909 --> 00:05:15,459
首先，客户机发送了一个所谓的syn包，
同步数据包。

77
00:05:15,460 --> 00:05:19,230
然后服务器用一个syn，ack响应
小包裹。

78
00:05:19,229 --> 00:05:22,079
意思是我承认我收到了它。

79
00:05:22,080 --> 00:05:25,650
这很重要，因为
包裹没到。

80
00:05:25,650 --> 00:05:30,860
所以当你作为一个客户得到回应时，
知道服务器收到了您的消息。

81
00:05:30,860 --> 00:05:35,200
这意味着客户端现在知道连接
作品。

82
00:05:35,199 --> 00:05:40,199
但是从服务器的角度来看
服务器还不知道发送

83
00:05:40,199 --> 00:05:42,129
数据包成功。

84
00:05:42,129 --> 00:05:45,179
也许服务器只能接收但不能接收
发送数据包。

85
00:05:45,180 --> 00:05:51,260
因此，客户机将响应SYN、ACK
带有ACK包的包，确认

86
00:05:51,259 --> 00:05:57,989
它得到了服务器的回答，现在双方
确定，是的，我成功地交换了数据包

87
00:05:57,990 --> 00:06:01,140
用另一台机器，现在我们可以谈数据了。

88
00:06:01,139 --> 00:06:03,489
这一切都是透明的。

89
00:06:03,490 --> 00:06:06,520
你不必构建这些包
你自己。

90
00:06:06,520 --> 00:06:09,500
你只是打开一个插座等着
连接。

91
00:06:09,499 --> 00:06:10,499
好啊。

92
00:06:10,499 --> 00:06:13,889
现在让我们从客户端发送一些数据
到服务器。

93
00:06:13,889 --> 00:06:18,249
您可以立即看到服务器
能够阅读您发送的行。

94
00:06:18,250 --> 00:06:19,940
这在Wireshark中是怎么看的？

95
00:06:19,939 --> 00:06:23,499
我们看到两个新的包。

96
00:06:23,499 --> 00:06:27,619
从客户机到服务器的PSH包，
以及一个ACK包。

97
00:06:27,619 --> 00:06:31,369
来自客户端的数据包现在还具有
附加数据层。

98
00:06:31,369 --> 00:06:35,259
数据层只包含原始数据
我们发送的字节。

99
00:06:35,259 --> 00:06:39,919
服务器以ACK响应，通知
数据包成功的客户端

100
00:06:39,919 --> 00:06:40,919
收到。

101
00:06:40,919 --> 00:06:43,159
现在让我们从服务器发送响应。

102
00:06:43,159 --> 00:06:49,399
你看，服务器只是写了文本
到文件描述符4，它是文件描述符

103
00:06:49,401 --> 00:06:50,771
接受返回。

104
00:06:50,770 --> 00:06:56,470
如您所见，应用程序只需编写
到那个paseudo文件，那个套接字，和

105
00:06:56,470 --> 00:06:59,460
下面的魔法通过网络发送了。

106
00:06:59,459 --> 00:07:04,389
现在让我们看看它做了什么，
它还发送了一个PSH包和客户端

107
00:07:04,389 --> 00:07:07,969
用一个ACK包对到达进行了确认
回来。

108
00:07:07,969 --> 00:07:09,359
还有一件事。

109
00:07:09,360 --> 00:07:11,980
显然，数据包的大小是有限的。

110
00:07:11,979 --> 00:07:16,709
所以当你发送大量数据时会发生什么，
假设你在某个地方上传了一个大文件，

111
00:07:16,709 --> 00:07:18,759
这将如何工作？

112
00:07:18,760 --> 00:07:21,280
让我们复制一些字符
寄给他们。

113
00:07:21,279 --> 00:07:25,569
啊，看，现在不止两个
小包。

114
00:07:25,569 --> 00:07:30,069
在开发应用程序时看不到它，
但内核、网卡或

115
00:07:30,069 --> 00:07:33,099
司机，我真的不知道，它裂了
起来。

116
00:07:33,099 --> 00:07:37,339
您还可以看到第二个包是
不是和第一个，第二个一起送的

117
00:07:37,339 --> 00:07:41,639
只有在服务器确认后才发送数据包
第一个。

118
00:07:41,639 --> 00:07:44,279
让我们看看当你杀死
客户端。

119
00:07:44,279 --> 00:07:49,909
即使我们只需要ctrl+c netcat，我们也可以
在wireshark中看到，那个fin包被发送了

120
00:07:49,909 --> 00:07:53,219
out，do表示我们已经完成了这个频道。

121
00:07:53,219 --> 00:07:57,939
你可以释放你的资源，但你不能
必须期待来自此连接的更多数据包。

122
00:07:57,940 --> 00:08:01,330
和安装时一样，有3个数据包
交换。

123
00:08:01,330 --> 00:08:06,320
服务器通过客户端确认fin，
现在客户机知道了，服务器知道了

124
00:08:06,319 --> 00:08:07,799
完成了。

125
00:08:07,800 --> 00:08:13,140
但是服务器还不知道客户机
知道它知道它已经完成了，所以它也

126
00:08:13,139 --> 00:08:14,439
用ACK响应。

127
00:08:14,439 --> 00:08:16,739
现在都结束了。

128
00:08:16,740 --> 00:08:21,130
现在整个交易所被称为
TCP流。

129
00:08:21,129 --> 00:08:26,849
我们建立了联系，然后交换了
数据来回，然后退出连接。

130
00:08:26,849 --> 00:08:32,619
Wireshark允许我们调查这个
流，例如使用follow tcp stream。

131
00:08:32,620 --> 00:08:37,070
这里只有数据是可见的和彩色编码的
谁送了什么。

132
00:08:37,070 --> 00:08:41,500
现在你应该看我的HTTP协议了
来自Web安全系列的视频，因为

133
00:08:41,500 --> 00:08:46,160
你现在能更好地理解它是什么
意味着有一个服务器和客户机。

134
00:08:46,160 --> 00:08:51,080
HTTP只是通过TCP发送的数据，
我们是如何发送这些信息的。

135
00:08:51,079 --> 00:08:56,469
浏览器和Web服务器都很特别
用特殊的东西做特殊事情的程序

136
00:08:56,470 --> 00:08:57,860
通过TCP接收的消息。

