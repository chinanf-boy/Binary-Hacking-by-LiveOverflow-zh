1
00:00:00,120 --> 00:00:03,620
所以我们在不久前就完成了“原恒星”的开发。

2
00:00:03,620 --> 00:00:08,770
这意味着我们对多年来二元开发的工作方式有了很好的基本了解。

3
00:00:08,770 --> 00:00:10,230
以前。

4
00:00:10,230 --> 00:00:13,750
如今的剥削不再那么容易了，你们中的一些人注意到了这一点，因为

5
00:00:13,750 --> 00:00:19,550
您试图复制源代码并在他们自己的现代Linux机器上编译它。

6
00:00:19,550 --> 00:00:23,360
所以我认为开始引进现代技术和利用

7
00:00:23,360 --> 00:00:28,800
通过重新访问当前Ubuntu上的一些原恒星挑战来缓解。

8
00:00:28,800 --> 00:00:30,000
看看我们能走多远。

9
00:00:30,000 --> 00:00:38,350
它们仍然是可利用的吗？

10
00:00:38,350 --> 00:00:42,220
因此，让我们再次快速查看非常简单的源代码。

11
00:00:42,219 --> 00:00:48,689
有这些变量、一个缓冲区和这个修改后的整数，设置为0。

12
00:00:48,690 --> 00:00:53,460
然后有一个gets() 函数，它将一些输入读入缓冲区，然后

13
00:00:53,460 --> 00:00:55,570
无法检查长度。

14
00:00:55,570 --> 00:01:00,910
这样我们就可以完全填充缓冲区，甚至可以在缓冲区之外写入

15
00:01:00,909 --> 00:01:02,889
相邻存储器。

16
00:01:02,890 --> 00:01:08,330
旧的prototastarvm上的二进制文件在缓冲区后面有修改过的变量。

17
00:01:08,330 --> 00:01:14,250
因此，如果写入的字节超过64个，则会重写修改变量的0值，从而

18
00:01:14,250 --> 00:01:17,390
更改此if的结果。

19
00:01:17,390 --> 00:01:19,910
所以让我们在现代系统上再试一次。

20
00:01:19,910 --> 00:01:27,100
我正在使用DigitalOcean快速启动一台新的UbuntuLinux机器，并在其中使用ssh。

21
00:01:27,100 --> 00:01:29,430
然后我获取代码并编译它。

22
00:01:29,430 --> 00:01:31,280
哦，新系统。

23
00:01:31,280 --> 00:01:34,700
所以我们还必须安装gcc，编译器。

24
00:01:34,700 --> 00:01:36,240
现在它起作用了。

25
00:01:36,240 --> 00:01:40,250
您已经可以看到编译器警告我们使用get() 。

26
00:01:40,250 --> 00:01:44,990
你看，犯这样的编程错误真的需要开发人员忽略

27
00:01:44,990 --> 00:01:45,990
这样的警告。

28
00:01:45,990 --> 00:01:50,500
它告诉我们，你不必再去了解其他地方的危险。

29
00:01:50,500 --> 00:01:52,270
你马上就来。

30
00:01:52,270 --> 00:01:53,270
让我们来看一看。

31
00:01:53,270 --> 00:01:57,760
让我们尝试输入大量字符，看看是否可以更改修改后的变量。

32
00:01:57,760 --> 00:02:01,700
但它似乎不起作用。

33
00:02:01,700 --> 00:02:05,370
我们唯一能得到的是一个堆栈粉碎检测到的错误。

34
00:02:05,370 --> 00:02:07,350
这个过程被中止了。

35
00:02:07,350 --> 00:02:12,160
这是第一个证据表明这里正在发生更多的事情。

36
00:02:12,159 --> 00:02:16,339
那么让我们看看编译器生成的汇编代码。

37
00:02:16,340 --> 00:02:20,310
首先，让我们检查一下为什么不能覆盖修改后的变量。

38
00:02:20,310 --> 00:02:24,000
检测到的堆栈粉碎与此有关吗？

39
00:02:23,999 --> 00:02:25,309
嗯。

40
00:02:25,310 --> 00:02:26,560
但让我们看看。

41
00:02:26,560 --> 00:02:30,930
您可以在堆栈上看到这个位置是存储修改后的局部变量的位置。

42
00:02:30,930 --> 00:02:35,570
您可以看到这一点，因为值0被移动到它上面，就像在C代码中一样。

43
00:02:35,569 --> 00:02:39,739
这里是堆栈上的缓冲区，因为它的地址是

44
00:02:39,739 --> 00:02:41,169
传递给获取。

45
00:02:41,170 --> 00:02:42,980
就像C代码一样。

46
00:02:42,980 --> 00:02:47,460
所以当你看到这个，你会注意到，修改后的变量不在

47
00:02:47,459 --> 00:02:49,229
缓冲区也不复存在了。

48
00:02:49,230 --> 00:02:54,700
我们可以写任意多的字符，但是我们永远不会覆盖修改过的字符。

49
00:02:54,700 --> 00:02:59,170
您也可以尝试对C代码中的变量重新排序，但这对

50
00:02:59,170 --> 00:03:01,250
汇编程序代码。

51
00:03:01,250 --> 00:03:03,870
这不是巧合。

52
00:03:03,870 --> 00:03:08,010
与简单的整数变量相比，缓冲区或数组是有风险的。

53
00:03:08,010 --> 00:03:10,730
缓冲区容易发生缓冲区溢出。

54
00:03:10,730 --> 00:03:16,050
因此，编译器决定以特定的方式对局部变量进行排序。

55
00:03:16,049 --> 00:03:19,109
它与堆栈粉碎检测到的消息有点关系。

56
00:03:19,109 --> 00:03:24,039
您看到此消息是由于堆栈cookie、堆栈金丝雀或堆栈保护

57
00:03:24,040 --> 00:03:25,190
改写。

58
00:03:25,189 --> 00:03:27,019
那到底是什么？

59
00:03:27,019 --> 00:03:31,569
让我们在反汇编程序中打开已编译的二进制文件，以便更好地查看它。

60
00:03:31,569 --> 00:03:36,029
如果您仍在学习这些东西，汇编程序代码看起来总是非常吓人。

61
00:03:36,030 --> 00:03:38,980
但这都是关于认识和学习模式。

62
00:03:38,980 --> 00:03:42,370
这里有一个类似的模式和堆栈cookies。

63
00:03:42,370 --> 00:03:46,830
因为当你逆向工程一个程序时，你基本上可以忽略很多东西。

64
00:03:46,829 --> 00:03:50,909
例如，这里和下面，都与堆栈cookie有关，所以它什么都没有。

65
00:03:50,909 --> 00:03:53,729
处理程序的功能。

66
00:03:53,730 --> 00:03:57,870
如果您对这个函数的大致功能感兴趣，可以查找

67
00:03:57,870 --> 00:04:02,240
在这里打电话，所以有一个GET，那就是读一些东西。

68
00:04:02,239 --> 00:04:07,509
然后比较一个局部变量，然后它打印一个字符串，在这两种情况下都使用puts。

69
00:04:07,510 --> 00:04:09,980
所以你已经从中得到了一个大致的想法。

70
00:04:09,980 --> 00:04:14,610
但是我们已经知道它做什么了，那么栈cookie的各个部分又有什么变化。

71
00:04:14,609 --> 00:04:19,989
在函数的开头，一个值从一个奇怪的位置移动，fs位于偏移十六进制

72
00:04:19,989 --> 00:04:23,139
28，进入寄存器RAX。

73
00:04:23,139 --> 00:04:25,249
然后将该值放入堆栈。

74
00:04:25,250 --> 00:04:30,150
在函数的末尾，在返回之前，再次从

75
00:04:30,150 --> 00:04:36,070
然后用这个神秘的fs hex 28值对堆栈进行异或处理。

76
00:04:36,069 --> 00:04:39,439
这只是检查两个值是否相同。

77
00:04:39,440 --> 00:04:43,000
如果它们相等，则允许函数返回。

78
00:04:43,000 --> 00:04:48,670
如果检查失败，并且这些值不同，则会调用堆栈检查失败

79
00:04:48,669 --> 00:04:51,799
程序永远不会回来。

80
00:04:51,800 --> 00:04:53,160
这是有道理的。

81
00:04:53,160 --> 00:04:57,340
所以在开始的时候，一些未知的值被写到堆栈上，然后事情就发生了，

82
00:04:57,340 --> 00:05:00,320
例如，gets() 调用可能溢出缓冲区，

83
00:05:00,320 --> 00:05:04,140
最后，栈中的值再次与这个神秘的值进行比较。

84
00:05:04,139 --> 00:05:09,069
所以如果我们有一个覆盖这个堆栈cookie的缓冲区溢出，这个检查就会失败。

85
00:05:09,069 --> 00:05:15,079
所以fs，或gs或其它段寄存器，是特殊寄存器，根据不同的用途

86
00:05:15,080 --> 00:05:20,310
在32位或64位上，如果您在Windows或Linux上，并且如果您编写低级引导或

87
00:05:20,310 --> 00:05:23,940
内核环0代码或如果编写用户空间环3程序。

88
00:05:23,940 --> 00:05:26,410
他们身上有很多历史包袱。

89
00:05:26,410 --> 00:05:30,050
老实说，我不完全理解。

90
00:05:30,050 --> 00:05:34,100
也许评论中的人可以纠正我并添加一些附加信息。

91
00:05:34,100 --> 00:05:36,950
所以用一点盐来解释这个问题。

92
00:05:36,949 --> 00:05:41,059
您可以想象fs寄存器指向一些内存。

93
00:05:41,060 --> 00:05:44,770
从这个过程的角度来看，我们实际上并不知道它的意义所在。

94
00:05:44,770 --> 00:05:45,770
去。

95
00:05:45,770 --> 00:05:48,920
内核（我认为）设置在它指向的地方。

96
00:05:48,919 --> 00:05:52,829
所以这个过程并不真正关心它指向哪里，它可以直接使用它。

97
00:05:52,830 --> 00:05:57,400
然后它可以在内存中的特定偏移量处引用不同的值。

98
00:05:57,400 --> 00:06:01,990
因此，例如，堆栈cookie存储在偏移量hex 28处。

99
00:06:01,990 --> 00:06:07,010
实际上，位置也必须在进程的虚拟内存中。

100
00:06:07,009 --> 00:06:15,239
让我们快速安装gdb增强踏板，因为它有很好的内存查找功能。

101
00:06:15,240 --> 00:06:19,460
我们可以通过在堆栈cookie处理例程和搜索中设置断点来测试这一点。

102
00:06:19,460 --> 00:06:22,340
此值的进程内存。

103
00:06:22,340 --> 00:06:27,140
你可以看到它出现在某种映射内存中。

104
00:06:27,139 --> 00:06:29,949
如果你查一下记忆地图，它就在这里。

105
00:06:29,950 --> 00:06:34,110
这就是fs指向的位置。

106
00:06:34,110 --> 00:06:39,100
因为例如，我们现在可以用hex 41覆盖这个值，所以大写aaaaaaa。

107
00:06:39,099 --> 00:06:43,059
当我们继续输入大量数据时，我们将在

108
00:06:43,060 --> 00:06:46,430
带有十六进制414141的堆栈。

109
00:06:46,430 --> 00:06:50,610
当我们到达函数的末尾时，堆栈cookie值显然被覆盖了。

110
00:06:50,610 --> 00:06:51,820
我们用414141。

111
00:06:51,819 --> 00:06:58,079
但我们还手工将堆栈cookie的原始值设置为41414。

112
00:06:58,080 --> 00:07:02,440
即使我们无法检查和查看fs指向的位置，CPU也知道

113
00:07:02,439 --> 00:07:05,879
现在的值是并将比较这两个值。

114
00:07:05,880 --> 00:07:10,100
我们继续返回并得到一个segfault。

115
00:07:10,100 --> 00:07:12,620
而不是去堆栈检查失败。

116
00:07:12,620 --> 00:07:16,630
这意味着我们实际上已经更改了堆栈cookie的原始值。

117
00:07:16,629 --> 00:07:17,789
很酷啊？

118
00:07:17,789 --> 00:07:22,289
但你看，这并不是一个绕道饼干，它对我们在这方面没有帮助

119
00:07:22,290 --> 00:07:24,510
并神奇地使其可利用。

120
00:07:24,509 --> 00:07:27,179
我们只是在玩弄它，以便更好地理解它。

121
00:07:27,180 --> 00:07:31,760
我们知道原始的堆栈cookie值存储在内存的某个地方。

122
00:07:31,759 --> 00:07:36,729
所以这些饼干有确切的用途，但不是神奇的药能阻止

123
00:07:36,729 --> 00:07:38,399
每一次剥削尝试。

124
00:07:38,400 --> 00:07:43,320
但是现在您已经更好地了解了堆栈cookie的局限性，它们只是

125
00:07:43,320 --> 00:07:48,070
堆栈上的一个值，该值放在函数的开头并进行比较。

126
00:07:48,069 --> 00:07:51,189
函数返回前的原始值。

127
00:07:51,189 --> 00:07:55,379
这意味着我们可以覆盖堆栈上的返回指针，但问题是，函数

128
00:07:55,379 --> 00:07:58,389
永远不会回来，因为cookie是错误的。

129
00:07:58,389 --> 00:08:02,469
如果在cookie之前堆栈上还有其他变量，它们可能都是静止的。

130
00:08:02,470 --> 00:08:04,110
改写。

131
00:08:04,110 --> 00:08:08,440
所以它实际上只是保护你不被击碎返回指针的经典

132
00:08:08,439 --> 00:08:09,639
缓冲区溢出。

133
00:08:09,639 --> 00:08:14,399
它只会停止函数窗体的返回，但可能不会停止由于

134
00:08:14,400 --> 00:08:17,090
在堆栈上覆盖的内容。

135
00:08:17,090 --> 00:08:22,620
所以在我们的例子中，理论上，如果修改后的变量放在

136
00:08:22,620 --> 00:08:27,440
缓冲区，我们仍然可以覆盖它，而不必写到覆盖为止。

137
00:08:27,439 --> 00:08:29,119
堆栈cookie。

138
00:08:29,120 --> 00:08:33,920
但是编译器开发人员知道缓冲区溢出是一件很常见的事情，所以他们希望

139
00:08:33,919 --> 00:08:37,199
缓冲区应尽可能靠近堆栈cookie。

140
00:08:37,200 --> 00:08:41,800
这会导致修改后的变量和缓冲区变量以这种方式重新排序。

141
00:08:41,800 --> 00:08:46,090
缓冲区放在修改后的变量之后，靠近cookie。

142
00:08:46,089 --> 00:08:47,309
该死。

143
00:08:47,310 --> 00:08:50,770
关于堆叠cookies还有一件有趣的事情。

144
00:08:50,769 --> 00:08:56,309
让我们重新运行程序并收集一些随机的cookie。

145
00:08:56,310 --> 00:08:59,920
你注意到什么了吗，它们都是从一个零字节开始的。

146
00:08:59,920 --> 00:09:03,890
所以这是小endian格式，但是在内存中，字节应该是这样的。

147
00:09:03,889 --> 00:09:06,119
所以这很有趣。

148
00:09:06,120 --> 00:09:12,010
为什么它们不将所有8个字节都用于随机值，而是将其中一个字节折衷为

149
00:09:12,010 --> 00:09:13,530
静态0。

150
00:09:13,530 --> 00:09:19,860
这难道不是让它更弱吗，因为现在你只需要野蛮变形，嗯，猜猜，7字节？

151
00:09:19,860 --> 00:09:24,760
显然，有多种方法可以攻击堆栈cookie，它显然应该

152
00:09:24,760 --> 00:09:29,880
不是可猜测的或不可预测的，但7个字节已经是huuuge数了。

153
00:09:29,880 --> 00:09:31,790
所以可能足够好。

154
00:09:31,790 --> 00:09:37,570
但正如您所知，有很多方法可以从内存中泄漏值，例如使用格式

155
00:09:37,570 --> 00:09:39,250
字符串漏洞。

156
00:09:39,250 --> 00:09:44,730
所以您使用它来泄漏一个堆栈cookie值，然后您的溢出再次是微不足道的。

157
00:09:44,730 --> 00:09:47,690
但有些溢出是因为strcpy。

158
00:09:47,690 --> 00:09:50,630
C中的字符串以零结尾。

159
00:09:50,630 --> 00:09:55,850
因此，即使您知道栈cookie，并且您有一个易受攻击的strcpy，也可以

160
00:09:55,851 --> 00:10:01,131
永远不要用corerct值覆盖cookie，因为您不能写入0字节。

161
00:10:01,130 --> 00:10:03,620
因为空字节在C中标记了字符串的结尾。

162
00:10:03,620 --> 00:10:09,110
但在我们的示例中，使用gets() ，根据手册页，您可以看到

163
00:10:09,110 --> 00:10:14,120
只在换行处停止，因此可以用它写入0个字节。

164
00:10:14,120 --> 00:10:17,190
所以在cookie中包含0字节是一个非常聪明的选择。

165
00:10:17,190 --> 00:10:23,250
这是对strcpys的额外保护，即使cookie值已知。

166
00:10:23,250 --> 00:10:26,650
但也许你现在问自己，32位怎么样？

167
00:10:26,649 --> 00:10:29,069
是否还有一个字节用于空字节？

168
00:10:29,070 --> 00:10:31,150
让我们看看。

169
00:10:31,149 --> 00:10:34,719
要在64位上编译32位程序，您必须安装一些其他东西。

170
00:10:34,720 --> 00:10:37,720
我们还可以快速检查这是否是不可利用的。

171
00:10:37,720 --> 00:10:41,570
您可以看到，我们也只得到堆栈粉碎保护错误。

172
00:10:41,570 --> 00:10:42,570
好啊。

173
00:10:42,570 --> 00:10:44,870
所以让我们在这里提取一些堆叠的饼干。

174
00:10:44,870 --> 00:10:48,450
您还可以看到32位上使用了不同的段寄存器。

175
00:10:48,449 --> 00:10:50,919
但同样的概念。

176
00:10:50,920 --> 00:10:52,860
谁会想到呢？

177
00:10:52,860 --> 00:10:54,690
还有一个0字节。

178
00:10:54,690 --> 00:10:57,780
所以这只产生了3个字节的随机性。

179
00:10:57,779 --> 00:11:00,569
1600万可能值。

180
00:11:00,570 --> 00:11:04,410
&lt；痛苦的噪音&gt；mhmh听起来有点可怕。

181
00:11:04,410 --> 00:11:10,440
1600万取决于程序运行的环境和方式并不多。

182
00:11:10,440 --> 00:11:13,370
也许在我们的例子中，它实际上可能使它成为可利用的。

183
00:11:13,370 --> 00:11:18,990
我的意思是原来的原恒星虚拟机也是32位的，所以我认为这是公平的游戏。

184
00:11:18,990 --> 00:11:23,120
但公平地说，64位可能使其无法开发。

185
00:11:23,120 --> 00:11:24,390
所以计划是明确的。

186
00:11:24,390 --> 00:11:30,360
我们编写了一个程序，随时调用这个32位版本的堆栈级别0，并发送一个

187
00:11:30,360 --> 00:11:35,770
利用它的字符串，该字符串使用随机的cookie cookie值对其进行破坏。

188
00:11:35,769 --> 00:11:40,479
在某个时刻，我们可能会幸运地猜到正确的cookie值，溢出返回值。

189
00:11:40,480 --> 00:11:46,140
指针并将代码执行重定向到输出，如果是，我们需要。

190
00:11:46,140 --> 00:11:47,170
好。

191
00:11:47,170 --> 00:11:48,850
这个计划听起来不错。

192
00:11:48,850 --> 00:11:50,740
如果只是这么简单的话。

193
00:11:50,740 --> 00:11:53,960
我们需要更多的时间来完成这项工作，所以让我们在另一个视频中完成这项工作。

194
00:11:53,959 --> 00:11:56,479
但这是一个有趣的挑战，所以你也应该试试。

