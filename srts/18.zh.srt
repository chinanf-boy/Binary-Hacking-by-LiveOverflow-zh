1
00:00:07,109 --> 00:00:12,739
In this episode we will have a look at format level 1 from exploit-exercises protostar.

2
00:00:12,740 --> 00:00:17,390
This class of vulnerability is weird, but was mind blowing to me, when I first saw it.

3
00:00:17,390 --> 00:00:18,770
So first of all...

4
00:00:18,770 --> 00:00:20,770
什么是格式字符串？

5
00:00:20,770 --> 00:00:25,090
Probably the most known function in C is printf.

6
00:00:25,090 --> 00:00:27,890
Printf prints formatted data to stdout.

7
00:00:27,890 --> 00:00:32,390
在我的“C编程”视频中，我使用printf打印了一个用户可以打印的名称

8
00:00:32,390 --> 00:00:33,660
supply.

9
00:00:33,660 --> 00:00:36,140
The parameters for printf() are the following.

10
00:00:36,140 --> 00:00:39,180
The first parameter is the so called “format string”.

11
00:00:39,180 --> 00:00:42,240
在早期的视频中，那是“敲门，敲门”。

12
00:00:42,240 --> 00:00:43,390
percentage ‘S’.

13
00:00:43,390 --> 00:00:46,840
And as a second parameter we used argv[1].

14
00:00:46,840 --> 00:00:48,740
Which contains a string.

15
00:00:48,739 --> 00:00:54,459
所以printf读取格式字符串并找到百分比“s”，这意味着

16
00:00:54,460 --> 00:00:56,150
this position belongs a string.

17
00:00:56,149 --> 00:01:03,379
So it takes the first supplied variable, in this case argv[1] and places the string there.

18
00:01:03,380 --> 00:01:07,970
格式字符串支持许多不同类型的变量，例如%d，它

19
00:01:07,970 --> 00:01:09,740
is a signed decimal integer.

20
00:01:09,740 --> 00:01:12,210
Or %x, to display a number in hex.

21
00:01:12,210 --> 00:01:14,570
And you can do even more than that.

22
00:01:14,570 --> 00:01:19,220
例如，如果在百分比和说明符之间指定一个数字，则可以告诉

23
00:01:19,220 --> 00:01:21,130
to what size it should be padded.

24
00:01:21,130 --> 00:01:27,750
And you can for example prepend a 0 to that number, to pad the result with zeroes.

25
00:01:27,750 --> 00:01:30,900
Format string functions like that exist also in other languages.

26
00:01:30,900 --> 00:01:33,800
For example you can use pretty much the same features in python.

27
00:01:33,799 --> 00:01:34,799
Print.

28
00:01:34,799 --> 00:01:39,659
一个格式字符串，包含百分比，然后变量包含另一个百分比。

29
00:01:39,659 --> 00:01:40,659
sign.

30
00:01:40,659 --> 00:01:44,249
Or better use the format function which has a slightly different syntax.

31
00:01:44,250 --> 00:01:46,100
But in the end it’s all the same.

32
00:01:46,100 --> 00:01:48,050
And now you wonder.

33
00:01:48,049 --> 00:01:53,069
怎么能利用那些只打印文本的东西呢？

34
00:01:53,070 --> 00:01:56,760
So let’s have a look at the source code of format level 1.

35
00:01:56,759 --> 00:02:01,689
Main calls the function vuln with the string from argv[1].

36
00:02:01,689 --> 00:02:04,289
And that string is placed in printf.

37
00:02:04,290 --> 00:02:09,600
And then we have a global variable target, which is checked if it got modified.

38
00:02:09,599 --> 00:02:13,949
So pretty similar to the early stack buffer overflow challenges.

39
00:02:13,950 --> 00:02:16,480
We need to manipulate this value.

40
00:02:16,480 --> 00:02:20,410
但是我们如何用printf操作内存中的变量呢？

41
00:02:20,410 --> 00:02:21,410
Well.

42
00:02:21,410 --> 00:02:24,200
Let’s do this step by step.

43
00:02:24,200 --> 00:02:27,230
Let’s first execute the program.

44
00:02:27,230 --> 00:02:32,020
As you can see, it will simply print whatever we supply in argv[1].

45
00:02:32,020 --> 00:02:33,230
That looks simple.

46
00:02:33,230 --> 00:02:35,840
But there is one small thing you should notice.

47
00:02:35,840 --> 00:02:38,930
Which parameter of the printf() does the attacker control?...

48
00:02:38,930 --> 00:02:43,090
It’s not the second parameter like in the programming in C video.

49
00:02:43,090 --> 00:02:44,570
It’s the first parameter.

50
00:02:44,569 --> 00:02:45,679
The format string.

51
00:02:45,680 --> 00:02:46,680
Soooo…

52
00:02:46,680 --> 00:02:48,910
我们能用百分比语法吗？

53
00:02:48,910 --> 00:02:50,010
Let’s try.

54
00:02:50,010 --> 00:02:52,360
Let’s enter a format string.

55
00:02:52,360 --> 00:02:53,360
Test ‘%d’.

56
00:02:53,360 --> 00:02:54,800
Oh damn.

57
00:02:54,800 --> 00:02:56,050
it printed a number.

58
00:02:56,050 --> 00:02:57,050
Weird.

59
00:02:57,050 --> 00:02:58,050
我们再加一点！

60
00:02:58,050 --> 00:02:59,460
Woha. more numbers.

61
00:02:59,459 --> 00:03:03,739
Let’s print them as hex instead of signed decimal numbers.

62
00:03:03,739 --> 00:03:05,069
That looks more familiar.

63
00:03:05,069 --> 00:03:08,449
还记得我们在看堆栈的视频吗？

64
00:03:08,450 --> 00:03:12,890
这些以bfff开头的值是否提醒了您一些事情？

65
00:03:12,890 --> 00:03:15,100
Those were stack addresses.

66
00:03:15,100 --> 00:03:17,350
那么我们在这里打印什么？

67
00:03:17,349 --> 00:03:22,049
如果你看过前一集关于反转c的内容，你就知道函数是如何工作的。

68
00:03:22,050 --> 00:03:23,050
called.

69
00:03:23,050 --> 00:03:24,610
Especially in 32bit.

70
00:03:24,610 --> 00:03:29,330
The parameters are simply placed on to the stack, and then the function is called.

71
00:03:29,330 --> 00:03:34,350
因此，如果您通常使用printf，那么您想要打印的变量将是

72
00:03:34,350 --> 00:03:36,500
placed on the stack.

73
00:03:36,500 --> 00:03:42,240
好吧，现在没有变量放在堆栈上，那么您要读取什么值呢？

74
00:03:42,240 --> 00:03:46,530
Obviously you are reading whatever printf can find on the stack.

75
00:03:46,530 --> 00:03:49,040
So any value on the stack.

76
00:03:49,040 --> 00:03:51,600
那你能用它做什么呢？

77
00:03:51,600 --> 00:03:54,330
First of all, it is a memory leak vulnerability.

78
00:03:54,330 --> 00:03:57,050
You can leak all kinds of stuff from the stack.

79
00:03:57,050 --> 00:04:02,160
假设您有一个带有aslr的程序，这意味着堆栈在内存中的位置是

80
00:04:02,159 --> 00:04:03,159
random.

81
00:04:03,159 --> 00:04:06,079
你不知道它在哪里，但是你需要一个缓冲区溢出的地址

82
00:04:06,080 --> 00:04:07,740
jump to shellcode.

83
00:04:07,739 --> 00:04:12,759
在这里，您可以从进程内存中泄漏值，更具体地说是从

84
00:04:12,760 --> 00:04:16,520
stack, and thus possibly leaking stack addresses.

85
00:04:16,519 --> 00:04:19,809
Which can then be used in a second step for a buffer overflow.

86
00:04:19,810 --> 00:04:25,520
在我最近玩的CTF中，有一个可利用的挑战，我使用了一种格式

87
00:04:25,520 --> 00:04:28,800
string vulnerability to leak the stack canary.

88
00:04:28,800 --> 00:04:32,850
我将在另一个地方做一个关于漏洞缓解的视频，但是堆栈金丝雀是

89
00:04:32,849 --> 00:04:36,279
a random value which protects from buffer overflows.

90
00:04:36,280 --> 00:04:40,060
If I can get this number, I can defeat this protection.

91
00:04:40,060 --> 00:04:41,410
Which I did.

92
00:04:41,409 --> 00:04:46,789
所以一开始从进程内存中泄漏一些奇怪的值听上去不太像，

93
00:04:46,789 --> 00:04:50,649
但是有很多例子你可以想出，在那里透露一些记忆可以

94
00:04:50,650 --> 00:04:52,760
help exploiting a target.

95
00:04:52,759 --> 00:04:58,059
After all, bugs like heartbleed were “just” leaking some memory and it was awful.

96
00:04:58,059 --> 00:05:00,219
Ok but in our particular case.

97
00:05:00,219 --> 00:05:02,999
How can we use that to modify a value.

98
00:05:02,999 --> 00:05:06,409
At the moment it only looks like we can leak values from the stack.

99
00:05:06,409 --> 00:05:08,029
Let’s have a look at the printf manpage.

100
00:05:08,029 --> 00:05:09,699
man 3 printf.

101
00:05:09,699 --> 00:05:14,009
And let’s scroll to the well known BUGS section.

102
00:05:14,009 --> 00:05:17,389
它在这里说，“如果某些东西来自不受信任的用户

103
00:05:17,389 --> 00:05:24,159
输入，它可能包含%n，导致printf（）调用写入内存并创建安全性

104
00:05:24,159 --> 00:05:27,599
孔”和更进一步的说明符

105
00:05:27,599 --> 00:05:29,069
“n”解释为：

106
00:05:29,069 --> 00:05:34,719
n到目前为止写入的字符数存储在整数中，该整数由

107
00:05:34,719 --> 00:05:39,099
int * (or variant) pointer argument.

108
00:05:39,099 --> 00:05:44,509
所以百分比“n”将已经打印的字符量写入

109
00:05:44,509 --> 00:05:46,079
a variable.

110
00:05:46,080 --> 00:05:48,990
And a variable is just some area in memory.

111
00:05:48,990 --> 00:05:52,900
And we know that to specify where that area is, we need use a pointer.

112
00:05:52,900 --> 00:05:57,960
或者，如果我们只看汇编程序代码，指针只是一个地址，所以printf

113
00:05:57,960 --> 00:06:00,020
knows where to write the result.

114
00:06:00,020 --> 00:06:05,030
因此，如果您要用%n编写一个合法的C程序，您将放置一个指向整数的指针

115
00:06:05,030 --> 00:06:11,140
变量作为printf的参数，或者在汇编程序中，只需将

116
00:06:11,139 --> 00:06:14,169
the variable onto the stack.

117
00:06:14,169 --> 00:06:19,549
这意味着，无论堆栈上的值是什么，都将用作printf的位置

118
00:06:19,550 --> 00:06:20,550
will write to.

119
00:06:20,550 --> 00:06:23,320
Now you can basically solve this challenge alone.

120
00:06:23,319 --> 00:06:26,169
We need to write a value in target.

121
00:06:26,169 --> 00:06:30,949
So let’s use objdump -t to find all symbols from this binary.

122
00:06:30,949 --> 00:06:33,579
And here is the address of the target variable.

123
00:06:33,580 --> 00:06:38,690
现在，当我们希望printf在这个位置写东西时，我们必须找到这个地址

124
00:06:38,689 --> 00:06:39,689
on the stack.

125
00:06:39,689 --> 00:06:40,959
Let’s start investigating.

126
00:06:40,960 --> 00:06:48,070
我将使用python和命令行via-c中的一行脚本来帮助我

127
00:06:48,069 --> 00:06:49,949
printing a test string.

128
00:06:49,949 --> 00:06:52,489
For example 10 hex numbers.

129
00:06:52,490 --> 00:06:54,100
Mh.

130
00:06:54,099 --> 00:06:58,719
Maybe I want to seperate them.

131
00:06:58,719 --> 00:07:01,739
Doesn’t look like the address is here.

132
00:07:01,740 --> 00:07:03,730
Maybe if we print more values from the stack.

133
00:07:03,729 --> 00:07:04,729
Nope.

134
00:07:04,729 --> 00:07:05,729
Not here.

135
00:07:05,729 --> 00:07:06,729
也许更多？

136
00:07:06,729 --> 00:07:07,729
Wait a minute.

137
00:07:07,729 --> 00:07:09,299
What is that weird pattern.

138
00:07:09,300 --> 00:07:13,310
From the values of those hex values it could be ascii.

139
00:07:13,309 --> 00:07:16,209
hex 20 is a space afterall.

140
00:07:16,210 --> 00:07:20,270
With python we can quickly convert those hex values to a ascii characters.

141
00:07:20,270 --> 00:07:21,510
And wooohh..

142
00:07:21,509 --> 00:07:22,509
%x？

143
00:07:22,509 --> 00:07:24,839
That loooks like our string that we have supplied.

144
00:07:24,839 --> 00:07:26,139
Let’s test that.

145
00:07:26,139 --> 00:07:31,179
Let’s add some capital As, because we can recognize those ascii values easily.

146
00:07:31,180 --> 00:07:34,290
Now we just have to look for 4141414141.

147
00:07:34,289 --> 00:07:36,049
And indeed.

148
00:07:36,050 --> 00:07:37,140
there are our As.

149
00:07:37,139 --> 00:07:38,649
And that makes sense.

150
00:07:38,650 --> 00:07:42,890
因为程序参数只存储在堆栈上，就像环境变量一样

151
00:07:42,889 --> 00:07:44,189
and other stuff.

152
00:07:44,189 --> 00:07:45,189
Cool.

153
00:07:45,189 --> 00:07:51,139
这意味着我们可以通过

154
00:07:51,139 --> 00:07:53,549
adding it to our string.

155
00:07:53,550 --> 00:07:59,380
So get the address again for target, and then we can add the address in our string.

156
00:07:59,379 --> 00:08:03,569
Maybe wrap it in some As and Bs, so we can find it in the output easily.

157
00:08:03,569 --> 00:08:04,689
Uhhh. yes.

158
00:08:04,689 --> 00:08:06,369
There it is.

159
00:08:06,369 --> 00:08:07,369
酷！

160
00:08:07,369 --> 00:08:13,459
所以理论上，我们只需要用%n替换打印此地址的%x

161
00:08:13,459 --> 00:08:46,439
改为写这个

162
00:08:46,440 --> 00:08:49,930
address location.

163
00:08:49,930 --> 00:08:54,690
You could do it more intelligently, but I will just figure it out with trial and error.

164
00:08:54,690 --> 00:08:59,130
你必须小心，因为请记住我们以前的视频中堆栈移动的地方

165
00:08:59,130 --> 00:09:01,690
因为环境变量之类的东西？

166
00:09:01,690 --> 00:09:06,330
The different length program argument that we supply, moves around the stack as well.

167
00:09:06,329 --> 00:09:10,479
So you might have to fiddle around quite a bit until you just get it right.

168
00:09:10,480 --> 00:09:13,110
Ok that took a bit, but looks cool.

169
00:09:13,110 --> 00:09:16,410
The last %x seems to reference our address now.

170
00:09:16,410 --> 00:09:22,220
And when we replace the x with the n, to write to that address we modified the target.

171
00:09:22,220 --> 00:09:27,540
你可以想象，如果我们能在记忆中的任何地方写，我们就能改写一些东西。

172
00:09:27,540 --> 00:09:30,330
to redirect code execution as well.

173
00:09:30,330 --> 00:09:32,570
So that will be the case in later levels.

174
00:09:32,569 --> 00:09:36,059
Just a small tip for when you work on format string exploits.

175
00:09:36,060 --> 00:09:39,050
It makes sense to keep your attack string always the same length.

176
00:09:39,050 --> 00:09:41,490
Then you don’t have to fiddle around much.

177
00:09:41,490 --> 00:09:45,500
只需使用一个python脚本，它总是以500个字符的长度扩展或剪切字符串。

178
00:09:45,500 --> 00:09:46,500
or something.

179
00:09:46,500 --> 00:09:49,290
And then you have enough space to play around and the stack doesn’t move around.

