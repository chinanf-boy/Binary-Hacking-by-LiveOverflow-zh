1
00:00:07,109 --> 00:00:12,739
在这一集中，我们将了解格式一级从剥削练习原恒星。

2
00:00:12,740 --> 00:00:17,390
这种脆弱性很奇怪，但是当我第一次看到它的时候，我真的很激动。

3
00:00:17,390 --> 00:00:18,770
所以首先…

4
00:00:18,770 --> 00:00:20,770
什么是格式字符串？

5
00:00:20,770 --> 00:00:25,090
C语言中最著名的函数可能是printf。

6
00:00:25,090 --> 00:00:27,890
printf将格式化数据打印到stdout。

7
00:00:27,890 --> 00:00:32,390
在我的"C编程"视频中，我有使用printf打印用户可以打印的名称

8
00:00:32,390 --> 00:00:33,660
供应。

9
00:00:33,660 --> 00:00:36,140
printf（）的参数如下。

10
00:00:36,140 --> 00:00:39,180
第一个参数是所谓的"格式""字符串"。

11
00:00:39,180 --> 00:00:42,240
在早期的视频中，那是"敲门，敲门"。

12
00:00:42,240 --> 00:00:43,390
百分比"s"。

13
00:00:43,390 --> 00:00:46,840
作为第二个参数，我们使用argv[1]。

14
00:00:46,840 --> 00:00:48,740
它包含一个字符串。

15
00:00:48,739 --> 00:00:54,459
所以printf读取格式字符串并找到百分比"s"，意思是

16
00:00:54,460 --> 00:00:56,150
这个位置属于一个字符串。

17
00:00:56,149 --> 00:01:03,379
所以它接受第一个提供的变量，在本例argv[1]并将字符串放在那里。

18
00:01:03,380 --> 00:01:07,970
格式字符串支持很多不同的变量类型，例如%d，其中

19
00:01:07,970 --> 00:01:09,740
是有符号十进制整数。

20
00:01:09,740 --> 00:01:12,210
或%x，以十六进制显示数字。

21
00:01:12,210 --> 00:01:14,570
你甚至可以做得更多。

22
00:01:14,570 --> 00:01:19,220
例如，如果指定一个介于您可以分辨的百分比和说明符

23
00:01:19,220 --> 00:01:21,130
它应该填充到多大的尺寸。

24
00:01:21,130 --> 00:01:27,750
例如，你可以在这之前加一个0数字，用零填充结果。

25
00:01:27,750 --> 00:01:30,900
类似的格式字符串函数也存在其他语言。

26
00:01:30,900 --> 00:01:33,800
例如，您可以使用几乎相同的python的特性。

27
00:01:33,799 --> 00:01:34,799
打印。

28
00:01:34,799 --> 00:01:39,659
格式字符串，带有百分比，然后后面的变量还有另一个百分比

29
00:01:39,659 --> 00:01:40,659
符号。

30
00:01:40,659 --> 00:01:44,249
或者最好使用格式函数稍有不同的语法。

31
00:01:44,250 --> 00:01:46,100
但最终还是一样的。

32
00:01:46,100 --> 00:01:48,050
现在你想知道。

33
00:01:48,049 --> 00:01:53,069
怎么会有什么东西，只是打印出来的文本，被利用？

34
00:01:53,070 --> 00:01:56,760
那么让我们看一下源代码格式级别1。

35
00:01:56,759 --> 00:02:01,689
main使用字符串调用函数vuln来自ARGV〔1〕。

36
00:02:01,689 --> 00:02:04,289
这个字符串放在printf中。

37
00:02:04,290 --> 00:02:09,600
然后我们有一个全局变量目标，如果它被修改了就会被检查。

38
00:02:09,599 --> 00:02:13,949
非常类似于早期的堆栈缓冲区溢出挑战。

39
00:02:13,950 --> 00:02:16,480
我们需要操纵这个值。

40
00:02:16,480 --> 00:02:20,410
但是我们如何操作内存中的变量用Primtf？

41
00:02:20,410 --> 00:02:21,410
好。

42
00:02:21,410 --> 00:02:24,200
让我们一步一步地做这个。

43
00:02:24,200 --> 00:02:27,230
让我们先执行程序。

44
00:02:27,230 --> 00:02:32,020
如你所见，它只需打印任何我们以argv供应[1]。

45
00:02:32,020 --> 00:02:33,230
看起来很简单。

46
00:02:33,230 --> 00:02:35,840
但有一件事你应该注意。

47
00:02:35,840 --> 00:02:38,930
攻击者使用printf（）的哪个参数控制？…

48
00:02:38,930 --> 00:02:43,090
它不是第二个参数，就像在C视频中编程。

49
00:02:43,090 --> 00:02:44,570
这是第一个参数。

50
00:02:44,569 --> 00:02:45,679
格式字符串。

51
00:02:45,680 --> 00:02:46,680
Soooo…

52
00:02:46,680 --> 00:02:48,910
我们能用百分比语法吗？

53
00:02:48,910 --> 00:02:50,010
让我们试试看。

54
00:02:50,010 --> 00:02:52,360
让我们输入一个格式字符串。

55
00:02:52,360 --> 00:02:53,360
测试"%d"。

56
00:02:53,360 --> 00:02:54,800
哦，该死的。

57
00:02:54,800 --> 00:02:56,050
它印了一个数字。

58
00:02:56,050 --> 00:02:57,050
奇怪的。

59
00:02:57,050 --> 00:02:58,050
我们再加一点！

60
00:02:58,050 --> 00:02:59,460
哇哈。更多的数字。

61
00:02:59,459 --> 00:03:03,739
让我们把它们打印成十六进制而不是有符号的十进制数字。

62
00:03:03,739 --> 00:03:05,069
看起来更熟悉。

63
00:03:05,069 --> 00:03:08,449
记住我们看的视频在堆栈上？

64
00:03:08,450 --> 00:03:12,890
以bfff开头的值是否提醒你喜欢什么？

65
00:03:12,890 --> 00:03:15,100
这些是堆栈地址。

66
00:03:15,100 --> 00:03:17,350
那么我们在这里打印什么？

67
00:03:17,349 --> 00:03:22,049
如果你看过上一集关于反转c，你知道函数是怎样的

68
00:03:22,050 --> 00:03:23,050
打电话。

69
00:03:23,050 --> 00:03:24,610
尤其是32位。

70
00:03:24,610 --> 00:03:29,330
参数简单地放在堆栈，然后调用函数。

71
00:03:29,330 --> 00:03:34,350
因此，如果您正常使用printf，要打印的变量将是

72
00:03:34,350 --> 00:03:36,500
放在堆栈上。

73
00:03:36,500 --> 00:03:42,240
现在没有变量被放置在堆栈上，那么您正在读取什么值？

74
00:03:42,240 --> 00:03:46,530
很明显你在读什么印刷品可以在堆栈上找到。

75
00:03:46,530 --> 00:03:49,040
所以栈中的任何值。

76
00:03:49,040 --> 00:03:51,600
那你能用它做什么呢？

77
00:03:51,600 --> 00:03:54,330
首先，它是一个内存泄漏漏洞。

78
00:03:54,330 --> 00:03:57,050
你可以从烟囱里漏出各种东西。

79
00:03:57,050 --> 00:04:02,160
假设你有一个ASLR的程序，意思是堆栈在内存中的位置是

80
00:04:02,159 --> 00:04:03,159
随机的。

81
00:04:03,159 --> 00:04:06,079
你不知道它在哪里，但是你需要缓冲区溢出的地址

82
00:04:06,080 --> 00:04:07,740
跳到shellcode。

83
00:04:07,739 --> 00:04:12,759
在这里，您可以从进程内存，更具体地说，来自

84
00:04:12,760 --> 00:04:16,520
堆栈，因此可能泄漏堆栈地址。

85
00:04:16,519 --> 00:04:19,809
然后可以在第二步中用于缓冲区溢出。

86
00:04:19,810 --> 00:04:25,520
在我最近参加的一个反恐组里可利用的挑战，我使用了一种格式

87
00:04:25,520 --> 00:04:28,800
字符串漏洞，泄漏堆栈金丝雀。

88
00:04:28,800 --> 00:04:32,850
我会做一个关于漏洞缓解的视频在另一个点上，但烟囱金丝雀是

89
00:04:32,849 --> 00:04:36,279
防止缓冲的随机值溢出。

90
00:04:36,280 --> 00:04:40,060
如果我能得到这个号码，我就能打败这个保护。

91
00:04:40,060 --> 00:04:41,410
我做到了。

92
00:04:41,409 --> 00:04:46,789
所以一开始泄露了一些奇怪的价值观进程内存听起来不太像，

93
00:04:46,789 --> 00:04:50,649
但是你可以举很多例子到了，披露一些记忆

94
00:04:50,650 --> 00:04:52,760
帮助开发目标。

95
00:04:52,759 --> 00:04:58,059
毕竟，像心血这样的虫子"只是"泄露了一些记忆，这太可怕了。

96
00:04:58,059 --> 00:05:00,219
好吧，但在我们的特殊情况下。

97
00:05:00,219 --> 00:05:02,999
我们如何使用它来修改一个值。

98
00:05:02,999 --> 00:05:06,409
目前看来我们只能泄漏堆栈中的值。

99
00:05:06,409 --> 00:05:08,029
让我们看一下printf手册页。

100
00:05:08,029 --> 00:05:09,699
男子3打印。

101
00:05:09,699 --> 00:05:14,009
让我们滚动到众所周知的错误部分。

102
00:05:14,009 --> 00:05:17,389
这里说，"如果某些内容来自不受信任的用户

103
00:05:17,389 --> 00:05:24,159
输入，它可能包含%n，导致printf（）。调用以写入内存并创建安全性

104
00:05:24,159 --> 00:05:27,599
孔再向上一点

105
00:05:27,599 --> 00:05:29,069
"n"解释为：

106
00:05:29,069 --> 00:05:34,719
n到目前为止写入的字符数存储到由

107
00:05:34,719 --> 00:05:39,099
int*（或variant）指针参数。

108
00:05:39,099 --> 00:05:44,509
所以百分比"n"写入已打印到的字符

109
00:05:44,509 --> 00:05:46,079
变量。

110
00:05:46,080 --> 00:05:48,990
变量只是内存中的一个区域。

111
00:05:48,990 --> 00:05:52,900
我们知道要指明那个区域的位置是的，我们需要一个指针。

112
00:05:52,900 --> 00:05:57,960
或者，如果我们只看汇编代码，指针只是一个地址，所以printf

113
00:05:57,960 --> 00:06:00,020
知道在哪里写结果。

114
00:06:00,020 --> 00:06:05,030
所以如果你要写一个合法的C程序对于%n，您将放置一个指向整数的指针

115
00:06:05,030 --> 00:06:11,140
变量作为printf或汇编程序的参数这只是把地址

116
00:06:11,139 --> 00:06:14,169
堆栈中的变量。

117
00:06:14,169 --> 00:06:19,549
这意味着，无论堆栈，用作printf的位置

118
00:06:19,550 --> 00:06:20,550
会写信给。

119
00:06:20,550 --> 00:06:23,320
现在你基本上可以解决这个挑战了独自一人。

120
00:06:23,319 --> 00:06:26,169
我们需要在target中写入一个值。

121
00:06:26,169 --> 00:06:30,949
所以让我们用objdump-t查找所有符号从这个二进制文件。

122
00:06:30,949 --> 00:06:33,579
这是目标变量的地址。

123
00:06:33,580 --> 00:06:38,690
现在，当我们想让printf写些东西的时候在这个地方，我们必须找到这个地址

124
00:06:38,689 --> 00:06:39,689
在堆栈上。

125
00:06:39,689 --> 00:06:40,959
我们开始调查吧。

126
00:06:40,960 --> 00:06:48,070
我将直接使用python和一行脚本从命令行通过-c来帮助我

127
00:06:48,069 --> 00:06:49,949
打印测试字符串。

128
00:06:49,949 --> 00:06:52,489
例如10个十六进制数。

129
00:06:52,490 --> 00:06:54,100
马来酸酐

130
00:06:54,099 --> 00:06:58,719
也许我想把它们分开。

131
00:06:58,719 --> 00:07:01,739
地址好像不在这里。

132
00:07:01,740 --> 00:07:03,730
也许如果我们从堆栈中打印更多的值。

133
00:07:03,729 --> 00:07:04,729
不。

134
00:07:04,729 --> 00:07:05,729
不在这里。

135
00:07:05,729 --> 00:07:06,729
也许更多？

136
00:07:06,729 --> 00:07:07,729
等一下。

137
00:07:07,729 --> 00:07:09,299
那奇怪的模式是什么？

138
00:07:09,300 --> 00:07:13,310
从这些十六进制值的值来看，它可以是ASCII。

139
00:07:13,309 --> 00:07:16,209
十六进制20毕竟是一个空格。

140
00:07:16,210 --> 00:07:20,270
使用python，我们可以快速转换这些十六进制值转换为ASCII字符。

141
00:07:20,270 --> 00:07:21,510
哇哦…

142
00:07:21,509 --> 00:07:22,509
%x？

143
00:07:22,509 --> 00:07:24,839
就像我们提供的绳子一样。

144
00:07:24,839 --> 00:07:26,139
我们来测试一下。

145
00:07:26,139 --> 00:07:31,179
我们加一些资本，因为我们可以很容易识别这些ASCII值。

146
00:07:31,180 --> 00:07:34,290
现在我们只需要找到4141414141。

147
00:07:34,289 --> 00:07:36,049
确实如此。

148
00:07:36,050 --> 00:07:37,140
有我们的AS。

149
00:07:37,139 --> 00:07:38,649
这是有道理的。

150
00:07:38,650 --> 00:07:42,890
因为程序参数是简单存储的在堆栈上，比如环境变量

151
00:07:42,889 --> 00:07:44,189
还有其他的东西。

152
00:07:44,189 --> 00:07:45,189
酷。

153
00:07:45,189 --> 00:07:51,139
这意味着我们可以简单地把地址从堆栈上的目标，通过

154
00:07:51,139 --> 00:07:53,549
添加到字符串中。

155
00:07:53,550 --> 00:07:59,380
因此，再次获取目标的地址，然后我们可以在字符串中添加地址。

156
00:07:59,379 --> 00:08:03,569
也许把它包在A和B中，这样我们就可以很容易在输出中找到它。

157
00:08:03,569 --> 00:08:04,689
嗯。对。

158
00:08:04,689 --> 00:08:06,369
就在那里。

159
00:08:06,369 --> 00:08:07,369
酷！

160
00:08:07,369 --> 00:08:13,459
所以在理论上，我们只需要替换%用%n打印此地址的x

161
00:08:13,459 --> 00:08:46,439
改为写这个

162
00:08:46,440 --> 00:08:49,930
地址位置。

163
00:08:49,930 --> 00:08:54,690
你可以做得更聪明，但我只需反复尝试就可以解决问题。

164
00:08:54,690 --> 00:08:59,130
你必须小心，因为记住我们以前的视频中的堆栈正在移动

165
00:08:59,130 --> 00:09:01,690
因为环境变量之类的东西？

166
00:09:01,690 --> 00:09:06,330
不同长度的程序参数我们供应，也在烟囱周围移动。

167
00:09:06,329 --> 00:09:10,479
所以你可能不得不在直到你把它弄好。

168
00:09:10,480 --> 00:09:13,110
好吧，那花了点时间，但看起来很酷。

169
00:09:13,110 --> 00:09:16,410
最后的%x似乎引用了我们的地址现在。

170
00:09:16,410 --> 00:09:22,220
当我们用n替换x时，我们修改了目标地址。

171
00:09:22,220 --> 00:09:27,540
你可以想象，如果我们能写在记忆中的任何地方，我们都可以改写

172
00:09:27,540 --> 00:09:30,330
也可以重定向代码执行。

173
00:09:30,330 --> 00:09:32,570
所以在后面的阶段就是这样。

174
00:09:32,569 --> 00:09:36,059
只是一个小提示，当你处理格式字符串漏洞。

175
00:09:36,060 --> 00:09:39,050
保持你的攻击线是有意义的长度总是一样的。

176
00:09:39,050 --> 00:09:41,490
那你就不必费劲了。

177
00:09:41,490 --> 00:09:45,500
只需使用始终扩展的python脚本或者把字符串剪成500个字符

178
00:09:45,500 --> 00:09:46,500
或者什么的。

179
00:09:46,500 --> 00:09:49,290
然后你有足够的空间玩而且烟囱不会移动。

