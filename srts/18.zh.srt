1
00:00:07,109 --> 00:00:12,739
在本集中，我们将从“ 漏洞-练习 protostar”中，查看 级别 1 格式。

2
00:00:12,740 --> 00:00:17,390
这类漏洞很奇怪，但当我第一次看到它时，它让我大吃一惊。

3
00:00:17,390 --> 00:00:18,770
所以，首先…

4
00:00:18,770 --> 00:00:20,770
什么是格式字符串？

5
00:00:20,770 --> 00:00:25,090
C语言中最著名的函数，可能会是 printf。

6
00:00:25,090 --> 00:00:27,890
printf将格式化数据，打印到stdout。

7
00:00:27,890 --> 00:00:32,390
在我的“C编程”视频中，我使用 printf 打印了，

8
00:00:32,390 --> 00:00:33,660
一个由用户提供的名称。

9
00:00:33,660 --> 00:00:36,140
printf() 的参数如下。

10
00:00:36,140 --> 00:00:39,180
第一个参数就是所谓的“格式字符串”。

11
00:00:39,180 --> 00:00:42,240
在早期的视频中，有块“敲门砖”，可以去看看。

12
00:00:42,240 --> 00:00:43,390
百分比“s”(%s)。

13
00:00:43,390 --> 00:00:46,840
我们使用 argv[1] ，作为第二个参数。

14
00:00:46,840 --> 00:00:48,740
它包含一个字符串。

15
00:00:48,739 --> 00:00:54,459
所以，printf 读取格式字符串，并找到“%s”，

16
00:00:54,460 --> 00:00:56,150
表明这个位置属于一个字符串(s/string)。

17
00:00:56,149 --> 00:01:03,379
所以，它采用第一个提供的变量，在本例中，就是argv[1]，并将字符串放在那(%s)的位置。

18
00:01:03,380 --> 00:01:07,970
格式字符串支持许多不同类型的变量，

19
00:01:07,970 --> 00:01:09,740
例如 %d，它是有符号十进制整数。

20
00:01:09,740 --> 00:01:12,210
或 %x，以 hex 显示数字。

21
00:01:12,210 --> 00:01:14,570
你甚至可以做得更多。

22
00:01:14,570 --> 00:01:19,220
例如，如果在百分比和说明符之间，指定一个数字，则可以告诉

23
00:01:19,220 --> 00:01:21,130
它应该填充到多大的尺寸。

24
00:01:21,130 --> 00:01:27,750
例如，你可以在这个数字前，加一个0，用0填充结果。

25
00:01:27,750 --> 00:01:30,900
类似的格式字符串函数，也存在于其他语言中。

26
00:01:30,900 --> 00:01:33,800
例如，您可以在 Python中 ，使用几乎相同的特性。

27
00:01:33,799 --> 00:01:34,799
也就是，print。

28
00:01:34,799 --> 00:01:39,659
一个包含百分比的格式字符串，然后

29
00:01:39,659 --> 00:01:40,659
变量包含另一个百分比符号。

30
00:01:40,659 --> 00:01:44,249
或者最好使用语法，稍有不同的格式函数。

31
00:01:44,250 --> 00:01:46,100
但最终结果，还是一样的。

32
00:01:46,100 --> 00:01:48,050
现在，你想知道。

33
00:01:48,049 --> 00:01:53,069
怎么TMD利用，那些只打印文本函数的漏洞呢？

34
00:01:53,070 --> 00:01:56,760
让我们来看一下，格式级别1的源代码。

35
00:01:56,759 --> 00:02:01,689
main 使用了，argv[1]中的字符串，调用函数 vuln。

36
00:02:01,689 --> 00:02:04,289
这个字符串，放在 printf 中。

37
00:02:04,290 --> 00:02:09,600
然后我们有一个全局变量 target，如果它被修改了，它就会被检查。

38
00:02:09,599 --> 00:02:13,949
所以，非常类似于，早前的栈缓冲区溢出挑战。

39
00:02:13,950 --> 00:02:16,480
我们需要，操纵这个值。

40
00:02:16,480 --> 00:02:20,410
但是，我们如何用 printf ，操纵内存中的一个变量呢？

41
00:02:20,410 --> 00:02:21,410
嗯。

42
00:02:21,410 --> 00:02:24,200
让我们一步一步地做这个。

43
00:02:24,200 --> 00:02:27,230
让我们先执行程序。

44
00:02:27,230 --> 00:02:32,020
如您所见，它将简单地打印，argv[1]中提供的任何内容。

45
00:02:32,020 --> 00:02:33,230
看起来很简单。

46
00:02:33,230 --> 00:02:35,840
但有一件事，你应该注意。

47
00:02:35,840 --> 00:02:38,930
攻击者会控制 printf() 的哪个参数？…

48
00:02:38,930 --> 00:02:43,090
它不是第二个参数，就像 C视频中的编程那样。

49
00:02:43,090 --> 00:02:44,570
没错，是第一个参数。

50
00:02:44,569 --> 00:02:45,679
格式字符串。

51
00:02:45,680 --> 00:02:46,680
所以呀…

52
00:02:46,680 --> 00:02:48,910
我们能只用百分比语法，就搞定吗？

53
00:02:48,910 --> 00:02:50,010
让我们试试看。

54
00:02:50,010 --> 00:02:52,360
让我们输入一个格式字符串。

55
00:02:52,360 --> 00:02:53,360
测试“%d”。

56
00:02:53,360 --> 00:02:54,800
哦，该死的。

57
00:02:54,800 --> 00:02:56,050
它打印了一个数字。

58
00:02:56,050 --> 00:02:57,050
奇怪啊。

59
00:02:57,050 --> 00:02:58,050
我们再加一点！

60
00:02:58,050 --> 00:02:59,460
哇哈。更多的数字。

61
00:02:59,459 --> 00:03:03,739
让我们把它们打印成 hex ，而不是有符号的十进制数字。

62
00:03:03,739 --> 00:03:05,069
看起来更熟悉。

63
00:03:05,069 --> 00:03:08,449
还记得我们查看栈的哪些视频吗？

64
00:03:08,450 --> 00:03:12,890
这些以 bfff 开头的值，是不是提醒了您一些事情？

65
00:03:12,890 --> 00:03:15,100
这些是栈地址。

66
00:03:15,100 --> 00:03:17,350
那么我们，在这里到底打印的是什么呀？

67
00:03:17,349 --> 00:03:22,049
如果，你看过关于反转C程序的前一集内容，

68
00:03:22,050 --> 00:03:23,050
你就知道函数调用是如何工作的。

69
00:03:23,050 --> 00:03:24,610
尤其是32位。

70
00:03:24,610 --> 00:03:29,330
参数只是被简单地放在栈上，然后函数就会被调用。

71
00:03:29,330 --> 00:03:34,350
因此，如果您正常使用 printf，

72
00:03:34,350 --> 00:03:36,500
那么您想要打印的变量，也就是放在栈上的。

73
00:03:36,500 --> 00:03:42,240
嗯，若现在没有变量，放在栈上，那么您读取又是什么值呢？

74
00:03:42,240 --> 00:03:46,530
显然，printf会在栈中，找到可以读取的任何内容。

75
00:03:46,530 --> 00:03:49,040
没错，栈中的任何值。

76
00:03:49,040 --> 00:03:51,600
那你能用它做什么呢？

77
00:03:51,600 --> 00:03:54,330
首先点明，它是个内存泄漏漏洞。

78
00:03:54,330 --> 00:03:57,050
你可以，从 stack 里漏出各种东西。

79
00:03:57,050 --> 00:04:02,160
假设，您有一个带有aslr的程序，这表明，

80
00:04:02,159 --> 00:04:03,159
栈在内存中的位置是随机的。

81
00:04:03,159 --> 00:04:06,079
你不知道它在哪里，但是你需要一个缓冲区溢出的地址，

82
00:04:06,080 --> 00:04:07,740
用来跳到 shellcode。

83
00:04:07,739 --> 00:04:12,759
在这里，您可以从进程内存中，泄漏值，

84
00:04:12,760 --> 00:04:16,520
更具体来说，是从栈中泄漏，因此可能泄漏栈地址。

85
00:04:16,519 --> 00:04:19,809
然后，可以在第二步中，使缓冲区溢出。

86
00:04:19,810 --> 00:04:25,520
在我最近玩的 CTF 中，有一个漏洞挑战，

87
00:04:25,520 --> 00:04:28,800
我使用了一种格式字符串漏洞，泄漏栈中的'金丝雀'。

88
00:04:28,800 --> 00:04:32,850
我会另找时间，做一个关于漏洞缓解的视频，

89
00:04:32,849 --> 00:04:36,279
但是栈金丝雀是，防止缓冲区溢出的随机值。

90
00:04:36,280 --> 00:04:40,060
如果，我能得到这个号码，我就能打破这层保护。

91
00:04:40,060 --> 00:04:41,410
而我，也做到了。

92
00:04:41,409 --> 00:04:46,789
所以，一开始从进程内存中，泄漏的一些奇怪值，听上去不太像那么一回事，

93
00:04:46,789 --> 00:04:50,649
但是，会有很多你可以使用的例子，

94
00:04:50,650 --> 00:04:52,760
而在那里，泄漏一些内存，可以帮助破解一个目标。

95
00:04:52,759 --> 00:04:58,059
毕竟，像心血这样的bug，也“只是”泄露了一些内存，而这后果是很严重的。

96
00:04:58,059 --> 00:05:00,219
好吧，但在我们这一情况下。

97
00:05:00,219 --> 00:05:02,999
我们要如何使用它，来修改一个值呢。

98
00:05:02,999 --> 00:05:06,409
目前看来，我们只能从栈中，泄漏值。

99
00:05:06,409 --> 00:05:08,029
让我们看一下，printf 手册页。

100
00:05:08,029 --> 00:05:09,699
man 3 printf。

101
00:05:09,699 --> 00:05:14,009
让我们滚动到，众所周知的 bugs 部分。

102
00:05:14,009 --> 00:05:17,389
它在这里说，“如果某些来自不受信任的户的东西

103
00:05:17,389 --> 00:05:24,159
输入了，它可能包含 %n，导致 printf() 调用，

104
00:05:24,159 --> 00:05:27,599
写入内存和创建一个安全性隐患”，和更进一步的，

105
00:05:27,599 --> 00:05:29,069
“n”解释说明为：

106
00:05:29,069 --> 00:05:34,719
n 是目前为止，写入的字符数，其存储在整数中，

107
00:05:34,719 --> 00:05:39,099
而该整数由 int *（或 variant）指针参数指示。

108
00:05:39,099 --> 00:05:44,509
所以，“%n”，将已经打印的字符量

109
00:05:44,509 --> 00:05:46,079
写入一个变量。

110
00:05:46,080 --> 00:05:48,990
而这个变量只是内存中的一个区域。

111
00:05:48,990 --> 00:05:52,900
我们知道要指定这个区域的位置，我们需要一个指针。

112
00:05:52,900 --> 00:05:57,960
或者，若我们简单看看汇编程序代码，会发现指针只是一个地址，

113
00:05:57,960 --> 00:06:00,020
这样，printf 才知道在哪里写结果。

114
00:06:00,020 --> 00:06:05,030
因此，如果您要用 %n 编写一个合法的C程序，您将放置一个，

115
00:06:05,030 --> 00:06:11,140
指向一个整数变量的指针，作为 printf 的参数，

116
00:06:11,139 --> 00:06:14,169
或者在汇编程序中，只需把变量的地址推入栈中。

117
00:06:14,169 --> 00:06:19,549
这意味着，无论栈上的值是什么，

118
00:06:19,550 --> 00:06:20,550
都将用作 printf 写入的位置。

119
00:06:20,550 --> 00:06:23,320
现在，你基本上可以单独解决这个挑战了。

120
00:06:23,319 --> 00:06:26,169
我们需要在target中，写入一个值。

121
00:06:26,169 --> 00:06:30,949
所以，让我们用 objdump -t 来查找，这个二进制文件中的所有符号。

122
00:06:30,949 --> 00:06:33,579
这是 target 变量的地址。

123
00:06:33,580 --> 00:06:38,690
现在，要想 printf 在这个位置写一些东西的话，

124
00:06:38,689 --> 00:06:39,689
我们就必须在栈上，找到这个地址。

125
00:06:39,689 --> 00:06:40,959
我们开始调查吧。

126
00:06:40,960 --> 00:06:48,070
我将使用 python 和 -c 中的一行命令行脚本，

127
00:06:48,069 --> 00:06:49,949
来帮助我打印，一个测试字符串。

128
00:06:49,949 --> 00:06:52,489
例如，10个 hex 数。

129
00:06:52,490 --> 00:06:54,100
嗯

130
00:06:54,099 --> 00:06:58,719
也许，我想把它们分开。

131
00:06:58,719 --> 00:07:01,739
地址好像不在这里。

132
00:07:01,740 --> 00:07:03,730
也许，我们打印栈中的更多值，试试。

133
00:07:03,729 --> 00:07:04,729
没有。

134
00:07:04,729 --> 00:07:05,729
不在这里。

135
00:07:05,729 --> 00:07:06,729
也许，更多？

136
00:07:06,729 --> 00:07:07,729
等一下。

137
00:07:07,729 --> 00:07:09,299
这奇怪的模式，是什么？

138
00:07:09,300 --> 00:07:13,310
从这些 hex 值的值来看，它可以是ASCII。

139
00:07:13,309 --> 00:07:16,209
 hex 20 ，是一个空格。

140
00:07:16,210 --> 00:07:20,270
使用 python，我们可以将这些 hex 值，快速转换为ASCII字符。

141
00:07:20,270 --> 00:07:21,510
哇哦…

142
00:07:21,509 --> 00:07:22,509
%x？

143
00:07:22,509 --> 00:07:24,839
看起来像，我们提供的字符串一样。

144
00:07:24,839 --> 00:07:26,139
我们来测试一下。

145
00:07:26,139 --> 00:07:31,179
让我们添加一些大写字母 A，因为我们可以很容易识别这些ASCII值。

146
00:07:31,180 --> 00:07:34,290
现在，我们只需要找 41414141。

147
00:07:34,289 --> 00:07:36,049
确实如此。

148
00:07:36,050 --> 00:07:37,140
这里是我们的 A。

149
00:07:37,139 --> 00:07:38,649
对上了。

150
00:07:38,650 --> 00:07:42,890
因为，程序参数只存储在栈上，

151
00:07:42,889 --> 00:07:44,189
就像环境变量，还有其他的东西一样。

152
00:07:44,189 --> 00:07:45,189
雕。

153
00:07:45,189 --> 00:07:51,139
这意味着，我们可以自己，简单把 target 的地址推入栈

154
00:07:51,139 --> 00:07:53,549
具体就是把它，添加到我们的字符串中。

155
00:07:53,550 --> 00:07:59,380
因此，再次获取 target 的地址，然后，我们可以在字符串中，添加地址卡。

156
00:07:59,379 --> 00:08:03,569
也许把它包装在一些 A 和 B 中，这样我们就可以很容易，在输出中找到它。

157
00:08:03,569 --> 00:08:04,689
嗯。对。

158
00:08:04,689 --> 00:08:06,369
就在那里。

159
00:08:06,369 --> 00:08:07,369
雕！

160
00:08:07,369 --> 00:08:13,459
所以，理论上，我们只需要用 %n 替换，应打印此地址的 %x，

161
00:08:13,459 --> 00:08:46,439
把它改为写入这个

162
00:08:46,440 --> 00:08:49,930
地址位置。

163
00:08:49,930 --> 00:08:54,690
你可以做得更聪明，但我会用试错法来解决。

164
00:08:54,690 --> 00:08:59,130
你要小心啦，因为以前的视频中，

165
00:08:59,130 --> 00:09:01,690
栈会有所移动，因为环境变量之类的东西？

166
00:09:01,690 --> 00:09:06,330
我们提供的不同长度的程序参数，也会在栈中移动。

167
00:09:06,329 --> 00:09:10,479
所以，你可能需要在一些事情上做些调整，直到你把事情做好为止。

168
00:09:10,480 --> 00:09:13,110
好吧，那花了点时间，但看起来很雕。

169
00:09:13,110 --> 00:09:16,410
最后一个 %x，现在似乎引用了我们的地址。

170
00:09:16,410 --> 00:09:22,220
当我们用 n 替换 x 时，为了写入那个地址，我们修改了 target 。

171
00:09:22,220 --> 00:09:27,540
你可以想象，如果我们能在内存的任何地方写入，

172
00:09:27,540 --> 00:09:30,330
我们就可以覆盖某些东东，就可以重定向代码的执行。

173
00:09:30,330 --> 00:09:32,570
所以啊，这会是下一阶段。

174
00:09:32,569 --> 00:09:36,059
当您处理格式化字符串漏洞时，有个小提示。

175
00:09:36,060 --> 00:09:39,050
保持攻击字符串的长度不变，是有意义的。

176
00:09:39,050 --> 00:09:41,490
那你就不必费劲了。

177
00:09:41,490 --> 00:09:45,500
只需使用一个 python 脚本，它可以扩展或剪切字符串，

178
00:09:45,500 --> 00:09:46,500
让它保持 500 字符，或者其他。

179
00:09:46,500 --> 00:09:49,290
之后呢，你就有足够的空间玩，而栈也不会移动啦。

