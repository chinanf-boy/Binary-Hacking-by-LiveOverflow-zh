1
00:00:00,250 --> 00:00:06,670
利用练习/ProtoStar提供了一个Linux映像，它具有学习二进制文件的几个挑战

2
00:00:06,670 --> 00:00:11,800
剥削。但这些年来发生了很大的变化，如果你把这些挑战汇编起来

3
00:00:11,800 --> 00:00:16,810
你自己在一个现代的系统上，这不再是那么容易了。我已经给你看了

4
00:00:16,810 --> 00:00:23,380
之前关于堆栈挑战的视频。我必须制作一个由三部分组成的视频系列来解释

5
00:00:23,380 --> 00:00:29,650
我们怎么还能做到。也只有32位。所以如果你刚开始，

6
00:00:29,650 --> 00:00:34,100
请确保使用可以在此处下载的Linux映像，不要编译

7
00:00:34,100 --> 00:00:41,260
这是你自己的。否则，所有关于它的教程都将不起作用。现在我们来看看这个视频

8
00:00:41,260 --> 00:00:46,230
继续其他一些挑战。我们在当前的Ubuntu版本上编译它们，没有

9
00:00:46,230 --> 00:00:55,430
any compile flags and see what we get.

10
00:00:55,430 --> 00:01:01,190
很明显，游戏规则，即黑客，是，也许有一些技术我只是

11
00:01:01,190 --> 00:01:05,720
不知道。我真的不知道剥削中的边缘案例，我主要知道

12
00:01:05,720 --> 00:01:10,140
一般的技术和我认为我有一些合理的创造力。但是

13
00:01:10,140 --> 00:01:14,460
我什么都不知道。所以很可能有人可以

14
00:01:14,460 --> 00:01:20,590
利用它。在这种情况下，我希望看到一个POC。尽管如此，让我们继续

15
00:01:20,590 --> 00:01:22,960
with format0.

16
00:01:22,960 --> 00:01:28,950
那么这个挑战是关于什么的呢？攻击者可以传入一个参数，该参数是

17
00:01:28,950 --> 00:01:35,510
然后作为字符串变量传递给sprintf的格式参数。所以我们可以

18
00:01:35,509 --> 00:01:39,039
inject stuff like %d or %s.

19
00:01:39,040 --> 00:01:46,670
它还容易受到缓冲区溢出的影响，因为sprintf不会打印到控制台，

20
00:01:46,670 --> 00:01:54,790
to stdout, like regular printf, but prints, or stores the formatted string, in buffer.

21
00:01:54,790 --> 00:01:57,520
And the buffer is only 64 bytes long.

22
00:01:57,520 --> 00:02:02,690
现在，当你在虚拟机上攻击它时，你可以在这里下载这些挑战

23
00:02:02,689 --> 00:02:08,659
预编译后，目标变量将放在缓冲区之后，以便溢出

24
00:02:08,660 --> 00:02:14,330
缓冲区，并写入目标。然后你修改了目标，当你

25
00:02:14,330 --> 00:02:20,290
it so that it’s overflown with 0xdeadbeef you pass this check.

26
00:02:20,290 --> 00:02:25,480
So enter 64characters, and 0xdeadbeef and you won.

27
00:02:25,480 --> 00:02:30,370
但是这里的挑战也说，用少于10字节的字节来尝试。你会这么做的

28
00:02:30,370 --> 00:02:36,160
例如，通过滥用格式字符串修饰符将格式化输出拉伸到

29
00:02:36,160 --> 00:02:44,870
64个字符，然后您可以简单地输入0xdeadbeef。例如%64d

30
00:02:44,870 --> 00:02:51,850
将输出一个最多可填充64个字符的数字。所以64个字符加上0个死肉

31
00:02:51,850 --> 00:02:55,570
are written into buffer and you win.

32
00:02:55,569 --> 00:02:59,069
好吧，那还有可能吗？

33
00:02:59,070 --> 00:03:05,490
首先，我们必须在这个新鲜的吉祥物上安装gcc和gdb，我还要继续

34
00:03:05,489 --> 00:03:11,149
to install peda, a gdb extension that makes things look nicer.

35
00:03:11,150 --> 00:03:15,520
所以让我们从简单的缓冲区溢出示例开始。但首先让我们设置一个断点

36
00:03:15,519 --> 00:03:21,599
在Vuln（）中，在我们比较死肉之前。然后让我们启动二进制文件并传入一个输入

37
00:03:21,599 --> 00:03:29,369
这比64字节大得多。可以。所以我们碰到了断点，它比较EAX

38
00:03:29,370 --> 00:03:37,260
和0块牛肉。但是EAX是0。怎么会这样？我们不是溢出了堆栈吗？

39
00:03:37,260 --> 00:03:43,220
当然，问题是目标变量不在

40
00:03:43,220 --> 00:03:50,160
buffer. It is before, so we can write as much data as we want, we won’t overwrite target.

41
00:03:50,160 --> 00:03:57,140
你也可以在这里看到这个。EAX从基指针-0x54加载，而地址

42
00:03:57,140 --> 00:04:06,280
for the string is loaded from basepointer - 0x50, so it’s located after target.

43
00:04:06,280 --> 00:04:08,980
这是否意味着它不可利用？

44
00:04:08,980 --> 00:04:14,200
嗯…因此，如果您熟悉格式字符串漏洞，您也知道可以

45
00:04:14,200 --> 00:04:21,190
使用它写入数据，方法是滥用写已打印数量的%n修饰符

46
00:04:21,190 --> 00:04:26,960
字符到堆栈上的地址。我们可以溢出堆栈，这样我们可以

47
00:04:26,960 --> 00:04:32,710
一个地址，然后仔细地构造之前打印的字符数，例如

48
00:04:32,710 --> 00:04:38,900
它把0个死区写到一个地址。所以我们可以写信给目标公司，然后赢了。

49
00:04:38,900 --> 00:04:39,900
路，对吧？

50
00:04:39,900 --> 00:04:47,560
But ASLR is our problem. Let me add a printf to the code to print the address of target.

51
00:04:47,560 --> 00:04:52,250
ampercant target returns the reference of a variable, so that’s the address.

52
00:04:52,250 --> 00:04:58,100
当我们编译它并在一个很好的循环中运行它时，你会发现这个地址有多疯狂

53
00:04:58,100 --> 00:05:03,800
目标更改。目标是一个局部变量，因此它位于堆栈上。所以这就是

54
00:05:03,800 --> 00:05:09,590
也是一个堆栈地址。但它能改变多少呢？它总是开始

55
00:05:09,590 --> 00:05:17,680
以0x7FF结尾的是C。这里的这一个咬边似乎只有C、D、E或F。那是

56
00:05:17,680 --> 00:05:25,390
一个巨大的数字。超过10亿。但在这种情况下，也许是可行的。只需要

57
00:05:25,389 --> 00:05:30,429
一些时间。也许一天左右吧。我只想看前面的三部分视频

58
00:05:30,430 --> 00:05:36,640
where we bruteforced a 3 byte stack cookie, that was roughly 16 million possible options.

59
00:05:36,639 --> 00:05:41,879
因此，我想说，在这里，2.6亿美元的资金即将到位。至少对于非常小的二进制

60
00:05:41,880 --> 00:05:47,960
这个。执行速度比较快。让我们看看32位的情况。我们

61
00:05:47,960 --> 00:05:53,400
have to install the gcc multilib to do that. And then we can compile it with -m32.

62
00:05:53,400 --> 00:06:00,110
当我们执行它几次时，你可以看到它的随机性明显低于

63
00:06:00,110 --> 00:06:06,680
64位。它只有两个全字节，然后又是一个半字节。大约100万次尝试

64
00:06:06,680 --> 00:06:14,050
击中它。所以，它的触角肯定更大。当然，只有当你

65
00:06:14,050 --> 00:06:19,990
可以以相当快的速度完成数百万次尝试，例如在本地。如果这是一个申请

66
00:06:19,990 --> 00:06:25,070
启动或远程服务需要更长的时间，这可能意味着您无法

67
00:06:25,069 --> 00:06:26,799
really do it.

68
00:06:26,800 --> 00:06:30,660
如何创建一个格式字符串漏洞，以及它如何与%n一起工作，您可以观看

69
00:06:30,660 --> 00:06:34,920
在我做过的其他多个视频中。但还有另外一个技巧

70
00:06:34,919 --> 00:06:41,519
注意，我们可以小心。所以要用%n写入，我们希望目标地址是

71
00:06:41,520 --> 00:06:46,570
在堆栈上。在一个经典的格式字符串漏洞中，您可能会使用

72
00:06:46,569 --> 00:06:52,679
放置在堆栈上并引用自身。但没人说一定是你的地址

73
00:06:52,680 --> 00:06:58,550
放在那里，堆满了价值观，也许你走运了。如果我们看看那堆

74
00:06:58,550 --> 00:07:03,800
当我们在执行流中进行0xdeadbeef比较时，可以看到很多堆栈

75
00:07:03,800 --> 00:07:10,240
地址。因此，即使使用aslr，这些堆栈地址也是有效的。如果现在

76
00:07:10,240 --> 00:07:15,460
其中的一个会神奇地指向目标，然后我们就可以重用它了。我们可以

77
00:07:15,460 --> 00:07:20,190
参考那个地址。但是如果我们查一下我们知道的目标地址，

78
00:07:20,190 --> 00:07:26,600
我们可以看到它没有出现。哦，好吧。但你看你能有多大的创造力

79
00:07:26,599 --> 00:07:32,179
剥削。我们本可以走运的。但让我们继续

80
00:07:32,180 --> 00:07:35,660
思想。好吧，我们没有完整的目标地址

81
00:07:35,660 --> 00:07:41,900
在堆栈上，但是我们有很多其他堆栈地址。我们有一个溢出，

82
00:07:41,900 --> 00:07:47,740
所以我们可以溢出到地址中。只需覆盖一些低字节并保留

83
00:07:47,740 --> 00:07:52,500
整个正面。我们再添加一个printf来打印目标

84
00:07:52,500 --> 00:07:58,540
价值。并打印生成的格式化缓冲区。让我们一起玩。在这里你可以看到

85
00:07:58,539 --> 00:08:05,609
sprintf格式的结果。让我们尝试通过消费在堆栈上找到aabbb

86
00:08:05,610 --> 00:08:11,880
堆栈中带有someformat修饰符的值。我想找到叠层上的偏移位置

87
00:08:11,879 --> 00:08:19,699
这个值被放置，我们可以用%lx和美元符号来探索它。

88
00:08:19,699 --> 00:08:25,269
偏移量1不是，偏移量2不是偏移量3不是。诸如此类。但是

89
00:08:25,271 --> 00:08:29,701
here at offset 9 we now printed the hex value of our input.

90
00:08:29,699 --> 00:08:36,349
Now let’s look at the stack layout for a nice stack address we could partially overwrite.

91
00:08:36,349 --> 00:08:42,989
Ok so down here is one, let’s see what offset that has. Let’s keep going.

92
00:08:42,990 --> 00:08:48,330
在那里，偏移19。这也意味着从偏移开始

93
00:08:48,330 --> 00:08:54,860
9 to offset 19 we have 10 groups of 8 bytes, so 80 bytes to fill and reach this value.

94
00:08:54,860 --> 00:08:59,980
我们可以通过一个填充数字到80字节的格式字符串来实现这一点，然后使用一些输入

95
00:08:59,980 --> 00:09:05,270
以证明我们溢出了。当我们现在执行它时，我们看到

96
00:09:05,269 --> 00:09:11,929
end of our address that got printed by our 19 lx, got overwritten with As.

97
00:09:11,930 --> 00:09:17,680
如果你注意到了，你会发现目标总是在C的偏移处，所以我们可以

98
00:09:17,680 --> 00:09:23,930
选择一些以“c”结尾的输入并覆盖它。例如，l，

99
00:09:23,930 --> 00:09:28,620
是0x4c。现在让我们执行它，您可以比较

100
00:09:28,620 --> 00:09:35,200
我们现在通过覆盖l得到了什么地址，真正的目标是什么。你看

101
00:09:35,200 --> 00:09:40,850
that often it’s not the same, but eventually, it will match.

102
00:09:40,850 --> 00:09:49,890
因此，如果我们替换%lx以将8字节十六进制值打印到%n，那么我们将写入

103
00:09:49,890 --> 00:09:53,470
那个地址。所以现在我们写的是

104
00:09:53,470 --> 00:10:00,930
字符，81，因为80+单个L到这个地址。也许在某个时候我们

105
00:10:00,930 --> 00:10:08,570
击中目标。我们继续努力吧。繁荣！在那里我们击中了目标，我们写了0x51

106
00:10:08,570 --> 00:10:15,060
它的小数点是81。这是相当可靠的，我们可以尝试这几次尝试

107
00:10:15,060 --> 00:10:19,860
用手。我觉得那太棒了，不幸的是

108
00:10:19,860 --> 00:10:24,510
这不完全是解决方案，因为目标必须是0xdeadbeef。那是30亿

109
00:10:24,510 --> 00:10:30,190
十进制。因此，使用这种技术，我们必须先打印30亿个字符

110
00:10:30,190 --> 00:10:34,040
we can do %n, and that’s not possible.

111
00:10:34,040 --> 00:10:39,500
不管怎样，我认为你可以看到有多少剥削可以成为你慢慢尝试的一个难题。

112
00:10:39,500 --> 00:10:44,720
拼凑在一起。最后我没能解决，但探索这个问题

113
00:10:44,720 --> 00:10:47,670
乐趣。我真想知道是否有人能

114
00:10:47,670 --> 00:10:49,700
a semi reliable exploit for this.

