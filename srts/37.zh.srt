1
00:00:00,250 --> 00:00:06,670
利用练习/protostar提供Linux
图像学习二进制有几个挑战

2
00:00:06,670 --> 00:00:11,800
剥削。但是很多事情都改变了
如果你编撰这些挑战

3
00:00:11,800 --> 00:00:16,810
你自己在一个现代的体系里
容易了。我已经给你看了

4
00:00:16,810 --> 00:00:23,380
之前关于堆栈挑战的视频。
我必须制作一个由三部分组成的视频系列来解释

5
00:00:23,380 --> 00:00:29,650
我们怎么还能做到。那也只是
32位。所以如果你刚开始，

6
00:00:29,650 --> 00:00:34,100
确保使用Linux映像
你可以在这里下载而不编译

7
00:00:34,100 --> 00:00:41,260
这是你自己的。否则，所有教程
它不起作用。现在我们来看看这个视频

8
00:00:41,260 --> 00:00:46,230
继续其他一些挑战。我们编译
在当前的Ubuntu版本上，没有

9
00:00:46,230 --> 00:00:55,430
任何编译标志，看看我们得到了什么。

10
00:00:55,430 --> 00:01:01,190
很明显，游戏规则就是黑客，
是的，也许有一些技巧我只是

11
00:01:01,190 --> 00:01:05,720
不知道。我真的不知道
我主要知道剥削中的边缘案例

12
00:01:05,720 --> 00:01:10,140
一般的技术，我想我有
一些合理的创造力。但是

13
00:01:10,140 --> 00:01:14,460
我什么都不知道。所以很可能
外面有人可以

14
00:01:14,460 --> 00:01:20,590
利用它。那样的话，我想看看
这是一个POC。尽管如此，让我们继续

15
00:01:20,590 --> 00:01:22,960
用格式0。

16
00:01:22,960 --> 00:01:28,950
那么这个挑战是关于什么的呢？攻击者
无法传入参数，该参数是

17
00:01:28,950 --> 00:01:35,510
然后作为字符串变量传递给
sprintf的格式参数。所以我们可以

18
00:01:35,509 --> 00:01:39,039
注入类似%d或%s的内容。

19
00:01:39,040 --> 00:01:46,670
它还容易受到缓冲区溢出的影响，
因为sprintf不打印到控制台，

20
00:01:46,670 --> 00:01:54,790
到stdout，像普通的printf，但是打印，
或将格式化字符串存储在缓冲区中。

21
00:01:54,790 --> 00:01:57,520
缓冲区只有64个字节长。

22
00:01:57,520 --> 00:02:02,690
当你在虚拟机上攻击它时，
可以在这里下载这些挑战

23
00:02:02,689 --> 00:02:08,659
预编译，目标变量将
放在缓冲区后面以便溢出

24
00:02:08,660 --> 00:02:14,330
缓冲区，并写入目标。然后
你修改了目标，当你

25
00:02:14,330 --> 00:02:20,290
让它充满了0块牛肉
你通过了这张支票。

26
00:02:20,290 --> 00:02:25,480
所以输入64个字符，和0个死区
你赢了。

27
00:02:25,480 --> 00:02:30,370
但这里的挑战也说，试试看
小于10字节。你会这么做的

28
00:02:30,370 --> 00:02:36,160
通过滥用格式字符串修饰符
例如，将格式化输出拉伸到

29
00:02:36,160 --> 00:02:44,870
64个字符，然后只需输入
之后吃牛肉。例如%64d

30
00:02:44,870 --> 00:02:51,850
将输出最多64个字符的数字
衬垫。所以64个字符加上0个死肉

31
00:02:51,850 --> 00:02:55,570
写进缓冲区，你就赢了。

32
00:02:55,569 --> 00:02:59,069
好吧，那还有可能吗？

33
00:02:59,070 --> 00:03:05,490
首先，我们必须在上面安装gcc和gdb
我和新的马辛也要去

34
00:03:05,489 --> 00:03:11,149
安装PEDA，一个GDB扩展
看起来好多了。

35
00:03:11,150 --> 00:03:15,520
那么让我们从简单的缓冲区溢出开始
例子。但首先让我们设置一个断点

36
00:03:15,519 --> 00:03:21,599
在Vuln（）中，在我们比较死肉之前。然后
让我们启动二进制文件并传入一个输入

37
00:03:21,599 --> 00:03:29,369
这比64字节大得多。可以。
所以我们碰到了断点，它比较EAX

38
00:03:29,370 --> 00:03:37,260
和0块牛肉。但是EAX是0。那怎么能
是吗？我们不是溢出了堆栈吗？

39
00:03:37,260 --> 00:03:43,220
嗯，我们当然知道，问题是
目标变量不在

40
00:03:43,220 --> 00:03:50,160
缓冲器。这是以前的，所以我们可以写很多
数据，我们不会覆盖目标。

41
00:03:50,160 --> 00:03:57,140
你也可以在这里看到这个。加载Eax
从基指针-0x54，而地址

42
00:03:57,140 --> 00:04:06,280
因为字符串是从basepointer加载的
-0x50，所以它位于目标之后。

43
00:04:06,280 --> 00:04:08,980
这是否意味着它不可利用？

44
00:04:08,980 --> 00:04:14,200
嗯…所以如果你熟悉格式
字符串利用，你也知道你可以

45
00:04:14,200 --> 00:04:21,190
使用它写入数据，方法是滥用%n修饰符
写下已经打印的数量

46
00:04:21,190 --> 00:04:26,960
字符到堆栈上的地址。和
我们可以溢出堆栈，这样我们可以放置

47
00:04:26,960 --> 00:04:32,710
一个地址，然后仔细地构建
以前打印的字符数，例如

48
00:04:32,710 --> 00:04:38,900
它把0个死区写到一个地址。和
所以我们可以写信给目标，然后赢了

49
00:04:38,900 --> 00:04:39,900
路，对吧？

50
00:04:39,900 --> 00:04:47,560
但ASLR是我们的问题。让我添加一个printf
打印目标地址的代码。

51
00:04:47,560 --> 00:04:52,250
Ampercant目标返回的引用
一个变量，所以这就是地址。

52
00:04:52,250 --> 00:04:58,100
当我们编译它并在一个
当真循环时，你看到地址有多疯狂

53
00:04:58,100 --> 00:05:03,800
目标更改。目标是局部变量
所以它位于堆栈上。所以这就是

54
00:05:03,800 --> 00:05:09,590
也是一个堆栈地址。
但它能改变多少呢？它总是开始

55
00:05:09,590 --> 00:05:17,680
有0x7FF和结尾在一个C.和这一个咬
这里只有C、D、E或F，这是

56
00:05:17,680 --> 00:05:25,390
一个巨大的数字。超过10亿。但是
在这种情况下，也许是可行的。只需要

57
00:05:25,389 --> 00:05:30,429
一些时间。也许一天左右吧。我只是喜欢
参考前三部分视频

58
00:05:30,430 --> 00:05:36,640
在这里我们野蛮地构造了一个3字节的堆栈cookie，
这大概是1600万个可能的选择。

59
00:05:36,639 --> 00:05:41,879
所以在这里，2.6亿美元，我愿意
说。至少对于非常小的二进制

60
00:05:41,880 --> 00:05:47,960
这个。执行速度比较快。
让我们看看32位的情况。我们

61
00:05:47,960 --> 00:05:53,400
为此，必须安装gcc multilib。
然后我们可以用-m32编译它。

62
00:05:53,400 --> 00:06:00,110
当我们执行几次时，你可以看到
很明显它的随机性比

63
00:06:00,110 --> 00:06:06,680
64位。只有两个字节，然后
再咬一口。大约100万次尝试

64
00:06:06,680 --> 00:06:14,050
击中它。所以，它的触角肯定更大。
当然，只有当你

65
00:06:14,050 --> 00:06:19,990
可以以相当快的速度进行数百万次尝试，
例如本地。如果这是一个申请

66
00:06:19,990 --> 00:06:25,070
启动或远程服务需要更长时间，
那可能意味着你不能

67
00:06:25,069 --> 00:06:26,799
真的做到了。

68
00:06:26,800 --> 00:06:30,660
如何创建格式字符串漏洞和
这与%n的确切工作原理您可以观看

69
00:06:30,660 --> 00:06:34,920
在我做过的其他多个视频中。
但还有另外一个技巧

70
00:06:34,919 --> 00:06:41,519
注意，我们可以小心。所以写
对于%n，我们希望目标地址是

71
00:06:41,520 --> 00:06:46,570
在堆栈上。在经典格式字符串中利用
你可能也会使用你的输入

72
00:06:46,569 --> 00:06:52,679
放置在堆栈上并引用自身。
但没人说一定是你的地址

73
00:06:52,680 --> 00:06:58,550
放在那里，堆栈中充满了值，
也许你走运了。如果我们看看那堆

74
00:06:58,550 --> 00:07:03,800
当我们在0Xdeadbeef时
执行流，可以看到很多堆栈

75
00:07:03,800 --> 00:07:10,240
地址。所以这些都是有效的
将地址与aslr一起堆叠。如果现在

76
00:07:10,240 --> 00:07:15,460
其中一个会神奇地指向目标，
然后我们就可以重用它了。我们可以

77
00:07:15,460 --> 00:07:20,190
参考那个地址。
但是如果我们查一下我们知道的目标地址，

78
00:07:20,190 --> 00:07:26,600
我们可以看到它没有出现。哦，好吧。
但你看你能有多大的创造力

79
00:07:26,599 --> 00:07:32,179
剥削。我们本可以走运的。
但让我们继续

80
00:07:32,180 --> 00:07:35,660
思想。
好吧，我们没有完整的目标地址

81
00:07:35,660 --> 00:07:41,900
但我们确实有很多其他的
堆栈地址。我们有一个溢出，

82
00:07:41,900 --> 00:07:47,740
所以我们可以溢出到地址中。和
只需覆盖一些低字节并保留

83
00:07:47,740 --> 00:07:52,500
整个正面。
我们再添加一个printf来打印目标

84
00:07:52,500 --> 00:07:58,540
价值。并打印生成的格式化缓冲区。
让我们一起玩。在这里你可以看到

85
00:07:58,539 --> 00:08:05,609
sprintf格式的结果。
让我们尝试通过消费在堆栈上找到aabbb

86
00:08:05,610 --> 00:08:11,880
堆栈中带有someformat修饰符的值。
我想找到叠层上的偏移位置

87
00:08:11,879 --> 00:08:19,699
这个值被放置，我们可以探索
用%lx和美元符号。所以在堆栈上

88
00:08:19,699 --> 00:08:25,269
偏移量1不是，偏移量2不是
在偏移量3处不是。诸如此类。但是

89
00:08:25,271 --> 00:08:29,701
在偏移量9处，我们现在打印十六进制值
我们的输入。

90
00:08:29,699 --> 00:08:36,349
现在让我们看看堆栈布局
很好的堆栈地址，我们可以部分覆盖。

91
00:08:36,349 --> 00:08:42,989
好的，下面是一个，让我们看看偏移量是多少
那有。我们继续走吧。

92
00:08:42,990 --> 00:08:48,330
在那里，偏移19。
这也意味着从偏移开始

93
00:08:48,330 --> 00:08:54,860
9为了偏移19，我们有10组8字节，
所以80字节可以填充并达到这个值。

94
00:08:54,860 --> 00:08:59,980
我们可以通过一个格式字符串
将一个数字填充到80字节，然后输入一些

95
00:08:59,980 --> 00:09:05,270
以证明我们溢出了。
当我们现在执行它时，我们看到

96
00:09:05,269 --> 00:09:11,929
我们打印的地址的结尾
19 lx，被as覆盖。

97
00:09:11,930 --> 00:09:17,680
如果你注意到了，你就看到了那个目标
总是与C偏移，所以我们可以

98
00:09:17,680 --> 00:09:23,930
选择以“c”结尾的输入作为
好吧，改写它。例如，l，

99
00:09:23,930 --> 00:09:28,620
是0x4C。
现在我们来执行，您可以比较

100
00:09:28,620 --> 00:09:35,200
我们现在通过覆盖得到了什么地址
和我，以及真正的目标是什么。你看

101
00:09:35,200 --> 00:09:40,850
通常情况不同，但最终，
它会匹配的。

102
00:09:40,850 --> 00:09:49,890
因此，如果我们替换%lx来打印8
字节十六进制值为%n，然后我们将写入

103
00:09:49,890 --> 00:09:53,470
那个地址。
所以现在我们写的是

104
00:09:53,470 --> 00:10:00,930
字符，81，因为80+单个L
到这个地址。也许在某个时候我们

105
00:10:00,930 --> 00:10:08,570
击中目标。我们继续努力吧。
繁荣！在那里我们击中了目标，我们写了0x51

106
00:10:08,570 --> 00:10:15,060
它的小数点是81。那作品
相当可靠，我们可以尝试这几次尝试

107
00:10:15,060 --> 00:10:19,860
用手。
我觉得那太棒了，不幸的是

108
00:10:19,860 --> 00:10:24,510
这不完全是解决办法，因为目标
必须是0块牛肉。那是30亿

109
00:10:24,510 --> 00:10:30,190
十进制。所以有了这项技术，我们可以
必须先打印30亿个字符

110
00:10:30,190 --> 00:10:34,040
我们可以做%n，这是不可能的。

111
00:10:34,040 --> 00:10:39,500
不管怎样，我想你可以看到有多少剥削
会成为你慢慢尝试的难题

112
00:10:39,500 --> 00:10:44,720
拼凑在一起。最后我没能做到
去解决它，但是探索它真的是

113
00:10:44,720 --> 00:10:47,670
乐趣。
我真想知道是否有人能

114
00:10:47,670 --> 00:10:49,700
对此的半可靠利用。

