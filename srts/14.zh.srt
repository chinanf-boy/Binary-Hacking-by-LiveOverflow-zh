1
00:00:06,500 --> 00:00:10,910
在本集中，我们开始接近一个完全缓冲区溢出。

2
00:00:10,910 --> 00:00:15,370
在上一集中，我们学习了缓冲区溢出如何改变局部变量，

3
00:00:15,370 --> 00:00:17,230
存储在堆栈上。

4
00:00:17,230 --> 00:00:21,000
现在我们来看看第3层的堆栈，它非常相似。

5
00:00:21,000 --> 00:00:25,470
如果您忘记了我们如何解决堆栈级别0，那么您应该返回并再次观察它。

6
00:00:25,470 --> 00:00:29,600
当我们看这段代码时，我们发现它基本上是相同的。

7
00:00:29,600 --> 00:00:34,830
唯一的区别是名称，而不是修改过的变量，我们有fp变量，

8
00:00:34,830 --> 00:00:37,110
定义为函数指针。

9
00:00:37,110 --> 00:00:42,970
语法看起来有点难看，但是如果检查if大小写，它只检查fp是否不是。

10
00:00:42,970 --> 00:00:46,770
然后调用fp，就好像它是一个函数一样。

11
00:00:46,770 --> 00:00:50,350
现在您知道一个函数在内存中有一个地址位置。

12
00:00:50,350 --> 00:00:54,470
所以它基本上会调用存储在fp中的任何地址。

13
00:00:54,470 --> 00:00:59,810
现在像stack0中的修改变量一样，函数指针fp被设置为0，并且

14
00:00:59,810 --> 00:01:04,050
在gets函数之后，将检查它是否不再为零。

15
00:01:04,050 --> 00:01:07,900
所以我们知道fp也必须存储在堆栈上。

16
00:01:07,900 --> 00:01:12,360
提示是，我们可以使用gdb或objhump来确定win（）函数的位置。

17
00:01:12,360 --> 00:01:15,100
在于记忆。

18
00:01:15,100 --> 00:01:20,490
所以首先让我们使用gdb，您可以使用examine或print来获取win的地址。

19
00:01:20,490 --> 00:01:24,250
然后将反汇编风格设置为intel和disassembly main。

20
00:01:24,250 --> 00:01:30,120
与stack0完全一样，我们可以看到它在堆栈上为hex 60字节腾出空间。

21
00:01:30,119 --> 00:01:36,279
然后，我们将esp offset 5c设置为0，这就是fp变量的位置。

22
00:01:36,280 --> 00:01:41,790
在gets之后，我们比较值，如果它仍然是0，如果不是，

23
00:01:41,790 --> 00:01:46,310
我们把这个值加载到eax中，然后调用这个地址。

24
00:01:46,310 --> 00:01:48,860
所以让我们在这个调用上设置一个断点。

25
00:01:48,860 --> 00:01:53,800
现在执行它并输入足够的字符来覆盖堆栈上的这个值。

26
00:01:53,799 --> 00:01:55,769
和上一个视频完全一样。

27
00:01:55,770 --> 00:02:00,140
好的，我们点击断点，让我们看看寄存器，我们可以看到

28
00:02:00,140 --> 00:02:06,870
成功地将eax设置为41414141，这是资本A的ASCII值。

29
00:02:06,869 --> 00:02:09,749
下一条指令尝试调用这个地址。

30
00:02:09,750 --> 00:02:11,590
所以基本上跳到那里。

31
00:02:11,590 --> 00:02:16,950
但这显然是无效的内存，因为我们得到了一个分段错误。

32
00:02:16,950 --> 00:02:19,080
现在打开第二个ssh会话。

33
00:02:19,080 --> 00:02:22,120
并创建一个python脚本，这将是我们的漏洞。

34
00:02:22,120 --> 00:02:26,040
所以，我们首先尝试找出控制EAX的偏移量。

35
00:02:26,040 --> 00:02:28,070
所以只需打印一个可识别的图案。

36
00:02:28,070 --> 00:02:30,120
例如字母表。

37
00:02:30,120 --> 00:02:31,740
好啊。酷。

38
00:02:31,739 --> 00:02:33,089
所以把这个输出放到一个文件中。

39
00:02:33,090 --> 00:02:36,390
现在您可以使用gdb中的这个文件作为输入。

40
00:02:36,390 --> 00:02:41,760
所以我们不必每次都输入，它将使用该文件的内容作为输入。

41
00:02:41,760 --> 00:02:46,900
现在“运行”并使用左箭头重定向标准输入中的文件内容

42
00:02:46,900 --> 00:02:48,500
程序。

43
00:02:48,500 --> 00:02:53,920
好的，eax是hex 51，这是大写的q。

44
00:02:53,920 --> 00:02:56,700
现在我们知道哪个偏移量修改了EAX。

45
00:02:56,700 --> 00:02:58,700
让我们重写一下代码。

46
00:02:58,700 --> 00:03:01,970
让我们把这部分称为“qs”-填充。

47
00:03:01,970 --> 00:03:06,740
现在我们要在这里写下win函数的地址。

48
00:03:06,740 --> 00:03:11,040
所以只需使用反斜杠X作为这些字节值的十六进制转义。

49
00:03:11,040 --> 00:03:13,080
哦，哎呀。

50
00:03:13,080 --> 00:03:14,080
那不合适。

51
00:03:14,080 --> 00:03:16,170
缺少前导0。

52
00:03:16,170 --> 00:03:17,980
保存，写入文件。

53
00:03:17,980 --> 00:03:19,880
在GDB中检查。

54
00:03:19,879 --> 00:03:20,879
嗯？

55
00:03:20,879 --> 00:03:22,179
分离故障？

56
00:03:22,180 --> 00:03:24,270
地址看起来有点奇怪。

57
00:03:24,269 --> 00:03:25,929
看来是走错了路？

58
00:03:25,930 --> 00:03:28,300
嗯，那是因为endianes。

59
00:03:28,300 --> 00:03:31,910
所以数值基本上是相反的。

60
00:03:31,909 --> 00:03:32,909
酷。

61
00:03:32,909 --> 00:03:34,589
EAX现在看起来很好。

62
00:03:34,590 --> 00:03:41,160
让我们继续，我们成功地更改了代码流！

63
00:03:41,159 --> 00:03:43,729
现在让我们也快速解决下一个层次。

64
00:03:43,730 --> 00:03:47,430
这个级别是我们的第一个缓冲区溢出，在这里我们利用堆栈布局。

65
00:03:47,430 --> 00:03:49,610
代码不包含太多内容。

66
00:03:49,610 --> 00:03:52,210
没有可以覆盖的函数指针变量。

67
00:03:52,209 --> 00:03:54,159
现在修改了变量。

68
00:03:54,160 --> 00:03:56,350
但它仍然希望我们赢。

69
00:03:56,350 --> 00:03:57,940
那我们该怎么做呢？

70
00:03:57,940 --> 00:04:01,080
现在你还记得上一个视频中的堆栈是什么样子的吗？

71
00:04:01,080 --> 00:04:03,390
下面是一个简短的概括：

72
00:04:03,390 --> 00:04:05,890
所以在左边你可以看到汇编代码。

73
00:04:05,890 --> 00:04:10,130
在右边，我将展示这个堆栈。使用3个重要寄存器，指令

74
00:04:10,129 --> 00:04:16,949
指针eip、堆栈指针esp和基指针ebp。

75
00:04:16,950 --> 00:04:20,280
所以首先，它从另一个地方开始，有一个“主叫”。

76
00:04:20,280 --> 00:04:24,970
调用会将理论上的下一个指令指针推送到堆栈上。

77
00:04:24,970 --> 00:04:26,870
然后跳到我们的主要功能。

78
00:04:26,870 --> 00:04:31,960
如您所见，当按下下一条指令的地址时，堆栈指针

79
00:04:31,960 --> 00:04:36,000
增加了地址。

80
00:04:36,000 --> 00:04:38,940
所以现在是我们的推手潮。

81
00:04:38,940 --> 00:04:42,660
我们现在怎么知道从梅因返回哪里？

82
00:04:42,660 --> 00:04:47,800
如果你还记得的话，call会在调用后按指令的地址。

83
00:04:47,800 --> 00:04:51,800
所以栈中的下一个值就是我们想要返回的位置。

84
00:04:51,800 --> 00:04:55,780
ret指令基本上就是把这个地址输入指令

85
00:04:55,780 --> 00:04:56,960
指针。

86
00:04:56,960 --> 00:04:59,560
然后从我们来的地方跳回来。

87
00:04:59,560 --> 00:05:04,030
如你所见，当一个函数被调用时，我们想要返回的地址，将

88
00:05:04,030 --> 00:05:05,810
存储在堆栈上。

89
00:05:05,810 --> 00:05:10,000
因此，我们可以简单地溢出返回指针，而不是溢出局部变量

90
00:05:10,000 --> 00:05:11,320
在堆栈上。

91
00:05:11,320 --> 00:05:17,090
当main返回时，它会读取错误的值并跳转到那里。

92
00:05:17,090 --> 00:05:20,410
所以让我们使用刚才编写的代码，并对其进行一些修改。

93
00:05:20,410 --> 00:05:29,390
让我们把有效载荷变长一点，然后简单地把它扔到gdb中的这个程序中。

94
00:05:29,389 --> 00:05:35,769
segmationfault在hex 54中，因此我们成功地将代码执行重定向到坏内存中。

95
00:05:35,770 --> 00:05:40,530
如果你仔细观察，你也可以发现basepointer是hex 53。

96
00:05:40,530 --> 00:05:45,450
所以那个也被覆盖了，因为如果你记得上一个视频，旧的basepointer

97
00:05:45,449 --> 00:05:49,919
也存储在堆栈上，就在指令指针之前。

98
00:05:49,919 --> 00:05:55,109
十六进制54是T，所以T允许我们控制指令指针。

99
00:05:55,110 --> 00:05:59,210
这次让我们使用objdump来查找win函数的地址。

100
00:05:59,210 --> 00:06:03,540
有了-t，我们就能得到所有的符号，然后我们就可以大获全胜了。

101
00:06:03,539 --> 00:06:04,539
这是我们的地址。

102
00:06:04,539 --> 00:06:05,539
现在让我们修改我们的漏洞代码。

103
00:06:05,539 --> 00:06:08,989
让我们删除到s的所有内容，因为这是基指针。

104
00:06:08,990 --> 00:06:12,180
现在创建两个变量ebp和eip。

105
00:06:12,180 --> 00:06:15,110
我们不在乎EBP，所以我们可以随意设置。

106
00:06:15,110 --> 00:06:18,240
接下来我们要设置指令指针。

107
00:06:18,240 --> 00:06:21,820
但是让我展示一种更好的方法，将地址编码为字符串。

108
00:06:21,820 --> 00:06:23,250
所以导入结构。

109
00:06:23,250 --> 00:06:27,880
然后可以使用struct.pack将地址从整数转换为

110
00:06:27,880 --> 00:06:29,550
二进制字符串。

111
00:06:29,550 --> 00:06:33,480
然后打印填充并附加ebp和eip变量。

112
00:06:33,479 --> 00:06:37,949
因此，让我们执行这个漏洞并将其传输到stack4级别。

113
00:06:37,949 --> 00:06:40,449
代码流已成功更改！

114
00:06:40,449 --> 00:06:41,639
太神了。

115
00:06:41,639 --> 00:06:43,979
我们打碎了堆栈，控制了指令指针。

116
00:06:43,979 --> 00:06:47,339
但你还是会有分离的错误吗？

117
00:06:47,340 --> 00:06:51,530
原因是，在Win函数完成后，它试图返回到

118
00:06:51,530 --> 00:06:56,130
堆栈上的下一个值，现在有些乱七八糟，可能不在有效的

119
00:06:56,130 --> 00:06:57,520
代码区域。

120
00:06:57,520 --> 00:06:59,490
所以它最终会崩溃。

121
00:06:59,490 --> 00:07:02,070
但我们不在乎，因为我们执行了我们想要的。

122
00:07:02,070 --> 00:07:06,380
在下一个视频中，我们将用shellcode编写第一个缓冲区溢出，它将

123
00:07:06,380 --> 00:07:09,290
向您展示缓冲区溢出有多强大。

124
00:07:09,290 --> 00:07:13,020
这将是我们第一次利用它获得根用户特权。

