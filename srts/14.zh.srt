1
00:00:06,500 --> 00:00:10,910
在本集中，我们近乎完全执行了，一个缓冲区溢出漏洞。

2
00:00:10,910 --> 00:00:15,370
在上一集中，我们学习了缓冲区溢出，是

3
00:00:15,370 --> 00:00:17,230
如何改变存储在栈上的局部变量。

4
00:00:17,230 --> 00:00:21,000
现在我们来看看第3层的栈 stack3，它非常相似。

5
00:00:21,000 --> 00:00:25,470
如果您忘记了我们如何解决 stack0，那么您应该回到上一视频。

6
00:00:25,470 --> 00:00:29,600
当我们看这段代码时，我们发现它基本上是相同的。

7
00:00:29,600 --> 00:00:34,830
唯一的区别是名称，不是 一个 modified 变量，

8
00:00:34,830 --> 00:00:37,110
而是 fp 变量，定义为函数指针。

9
00:00:37,110 --> 00:00:42,970
语法看起来有点难看，但是如果关注重心放在 if 语句，

10
00:00:42,970 --> 00:00:46,770
它只是简单检查 fp 是否为 0，然后调用 fp，就好像它是一个函数一样。

11
00:00:46,770 --> 00:00:50,350
现在您知道一个函数，在内存中有一个地址位置。

12
00:00:50,350 --> 00:00:54,470
所以它基本上，会调用存储在 fp 中的任何地址。

13
00:00:54,470 --> 00:00:59,810
现在像 stack0 中的 modified 变量一样，函数指针 fp 被设置为0，并且

14
00:00:59,810 --> 00:01:04,050
在gets函数之后，会检查它是否不再为零。

15
00:01:04,050 --> 00:01:07,900
所以，我们知道 fp 也必须存储在栈上。

16
00:01:07,900 --> 00:01:12,360
有个提示是，我们可以使用 gdb 或objhump 来确定

17
00:01:12,360 --> 00:01:15,100
 win() 函数的内存位置。

18
00:01:15,100 --> 00:01:20,490
所以首先让我们使用 gdb ，您可以使用 examine 或 print 来获取 win 的地址。

19
00:01:20,490 --> 00:01:24,250
然后，将反汇编风格设置为 intel，再进行 disassembly main。

20
00:01:24,250 --> 00:01:30,120
与stack0完全一样，我们可以看到它在栈上为 hex 60字节，腾出空间。

21
00:01:30,119 --> 00:01:36,279
然后，我们将 esp offset 5c 设置为0，这就是 fp变量的位置。

22
00:01:36,280 --> 00:01:41,790
在gets之后，我们比较值是否仍然是 0，如果不是，

23
00:01:41,790 --> 00:01:46,310
我们把这个值加载到eax中，然后调用这个地址。

24
00:01:46,310 --> 00:01:48,860
所以让我们在这个调用上，设置一个断点。

25
00:01:48,860 --> 00:01:53,800
现在执行它，并输入足够的字符，来覆盖栈上的这个值。

26
00:01:53,799 --> 00:01:55,769
和上一个视频完全一样。

27
00:01:55,770 --> 00:02:00,140
好的，我们到了断点，让我们看看寄存器，

28
00:02:00,140 --> 00:02:06,870
我们可以看到，成功将 eax 设置为 41414141，这是大写 A的ASCII值。

29
00:02:06,869 --> 00:02:09,749
下一条指令，尝试调用这个地址。

30
00:02:09,750 --> 00:02:11,590
所以基本上来说，就是跳到那里。

31
00:02:11,590 --> 00:02:16,950
但这显然是无效的内存，因为我们得到了一个分段错误。

32
00:02:16,950 --> 00:02:19,080
现在打开第，二个ssh会话。

33
00:02:19,080 --> 00:02:22,120
并创建一个 python 脚本，这将是我们的漏洞脚本。

34
00:02:22,120 --> 00:02:26,040
所以，我们首先尝试找出控制 eax 的偏移量。

35
00:02:26,040 --> 00:02:28,070
所以只需打印，一个可识别模式。

36
00:02:28,070 --> 00:02:30,120
例如字母表。

37
00:02:30,120 --> 00:02:31,740
好啊。酷。

38
00:02:31,739 --> 00:02:33,089
所以把这个输出，管道到一个文件中。

39
00:02:33,090 --> 00:02:36,390
现在您可以使用，gdb  中的这个文件作为输入。

40
00:02:36,390 --> 00:02:41,760
这样，我们就不必每次输入了，它会使用该文件的内容作为输入。

41
00:02:41,760 --> 00:02:46,900
现在“run”，并使用左箭头重定向，

42
00:02:46,900 --> 00:02:48,500
程序标准输入的文件内容。

43
00:02:48,500 --> 00:02:53,920
好的，eax 是 hex 51，这是大写的 Q。

44
00:02:53,920 --> 00:02:56,700
现在我们知道，哪个偏移量修改了eax。

45
00:02:56,700 --> 00:02:58,700
让我们重写一下代码。

46
00:02:58,700 --> 00:03:01,970
让我们把这部分称为“Qs” - 填充。

47
00:03:01,970 --> 00:03:06,740
现在，我们要在这里写下 win 函数的地址。

48
00:03:06,740 --> 00:03:11,040
所以只需使用反斜杠X，作为这些字节值的十六进制转义。

49
00:03:11,040 --> 00:03:13,080
哦，哎呀。

50
00:03:13,080 --> 00:03:14,080
那不合适。

51
00:03:14,080 --> 00:03:16,170
缺少开头 0。

52
00:03:16,170 --> 00:03:17,980
保存，写入文件。

53
00:03:17,980 --> 00:03:19,880
在 gdb 中检查。

54
00:03:19,879 --> 00:03:20,879
嗯？

55
00:03:20,879 --> 00:03:22,179
分段错误？

56
00:03:22,180 --> 00:03:24,270
地址看起来有点奇怪。

57
00:03:24,269 --> 00:03:25,929
看来是走错了路？

58
00:03:25,930 --> 00:03:28,300
嗯，那是因为 endianes。

59
00:03:28,300 --> 00:03:31,910
所以，数值基本上是相反的。

60
00:03:31,909 --> 00:03:32,909
酷。

61
00:03:32,909 --> 00:03:34,589
eax 现在看起来很好。

62
00:03:34,590 --> 00:03:41,160
让我们继续，我们成功地更改了代码流！

63
00:03:41,159 --> 00:03:43,729
现在，让我们也快速解决下一级。

64
00:03:43,730 --> 00:03:47,430
这个级别是我们的第一个缓冲区溢出，在这里我们利用栈布局。

65
00:03:47,430 --> 00:03:49,610
这代码不包含太多内容。

66
00:03:49,610 --> 00:03:52,210
没有可以覆盖的函数指针变量。

67
00:03:52,209 --> 00:03:54,159
现在， modified 变量。

68
00:03:54,160 --> 00:03:56,350
但，它仍然希望我们执行 win。

69
00:03:56,350 --> 00:03:57,940
那我们该怎么做呢？

70
00:03:57,940 --> 00:04:01,080
现在你还记得上一个视频中的栈，是什么样子的吗？

71
00:04:01,080 --> 00:04:03,390
下面是一个简短的概括：

72
00:04:03,390 --> 00:04:05,890
所以在左边，你可以看到汇编代码。

73
00:04:05,890 --> 00:04:10,130
在右边，我将展示这个栈。使用3个重要寄存器，

74
00:04:10,129 --> 00:04:16,949
指令指针 eip、栈指针 esp，和基指针ebp。

75
00:04:16,950 --> 00:04:20,280
所以首先，它从另一个地方开始，有一个“call main”。

76
00:04:20,280 --> 00:04:24,970
调用（call）会将理论上的下一个指令指针，推到栈上。

77
00:04:24,970 --> 00:04:26,870
然后，跳到我们的 main 函数。

78
00:04:26,870 --> 00:04:31,960
如您所见，当下一条指令的地址被推入后，

79
00:04:31,960 --> 00:04:36,000
栈指针增加了地址。

80
00:04:36,000 --> 00:04:38,940
所以，现在是 push ebp 登场。

81
00:04:38,940 --> 00:04:42,660
我们现在怎么知道，main 的返回是到哪里？

82
00:04:42,660 --> 00:04:47,800
如果你还记得的话，call 会在自身调用后，推指令的地址进栈。

83
00:04:47,800 --> 00:04:51,800
所以栈中的下一个值，就是我们想要返回的位置。

84
00:04:51,800 --> 00:04:55,780
而 ret 指令基本上，就是把这个地址 pop（弹出），

85
00:04:55,780 --> 00:04:56,960
送入指令指针。

86
00:04:56,960 --> 00:04:59,560
然后跳回我们来的地方。

87
00:04:59,560 --> 00:05:04,030
如你所见，当一个函数被调用时，我们想要返回的地址，

88
00:05:04,030 --> 00:05:05,810
将存储在栈上。

89
00:05:05,810 --> 00:05:10,000
因此，我们可以简单地溢出返回指针，到栈上，

90
00:05:10,000 --> 00:05:11,320
而不是溢出局部变量。

91
00:05:11,320 --> 00:05:17,090
当 main 返回时，它会读取错误的值，并跳转到那里。

92
00:05:17,090 --> 00:05:20,410
所以让我们使用刚才编写的代码，并对其进行一些修改。

93
00:05:20,410 --> 00:05:29,390
让我们把 payload 变长一点，然后简单地把它扔到 gdb 里的这个程序。

94
00:05:29,389 --> 00:05:35,769
segmationfault 在 hex 54 中，因此我们成功将代码执行，重定向到坏内存中。

95
00:05:35,770 --> 00:05:40,530
如果你仔细观察，你也可以发现 basepointer 是 hex 53。

96
00:05:40,530 --> 00:05:45,450
所以，也被覆盖了，因为如果你记得上一个视频，

97
00:05:45,449 --> 00:05:49,919
*旧的* basepointer也存储在栈上，就在指令指针之前。

98
00:05:49,919 --> 00:05:55,109
hex 54是 T，所以， T 允许我们控制指令指针。

99
00:05:55,110 --> 00:05:59,210
这次，让我们使用objdump，来查找win函数的地址。

100
00:05:59,210 --> 00:06:03,540
有了 -t，我们就能得到所有的符号，然后我们就可以获取 win 啦。

101
00:06:03,539 --> 00:06:04,539
这是我们的地址。

102
00:06:04,539 --> 00:06:05,539
现在，让我们修改我们的漏洞代码。

103
00:06:05,539 --> 00:06:08,989
让我们删除到 S 的所有内容，因为这是基指针。

104
00:06:08,990 --> 00:06:12,180
现在，创建两个变量 ebp和eip 。

105
00:06:12,180 --> 00:06:15,110
我们不在乎EBP，所以我们可以随意设置。

106
00:06:15,110 --> 00:06:18,240
接下来，我们要设置指令指针。

107
00:06:18,240 --> 00:06:21,820
但是在这里，让我展示一种更好的方法，将地址编码为字符串。

108
00:06:21,820 --> 00:06:23,250
所以，import struct。

109
00:06:23,250 --> 00:06:27,880
然后，可以使用 struct.pack ，将地址从整数转换为

110
00:06:27,880 --> 00:06:29,550
二进制字符串。

111
00:06:29,550 --> 00:06:33,480
然后打印填充，并附加 ebp 和eip 变量。

112
00:06:33,479 --> 00:06:37,949
因此，让我们执行这个漏洞代码，并将其管道到 stack4 级别。

113
00:06:37,949 --> 00:06:40,449
代码流已成功更改！

114
00:06:40,449 --> 00:06:41,639
太神了。

115
00:06:41,639 --> 00:06:43,979
我们粉碎了栈，控制了指令指针。

116
00:06:43,979 --> 00:06:47,339
但，你还是会有分段错误吗？

117
00:06:47,340 --> 00:06:51,530
原因是，在 win函数完成后，

118
00:06:51,530 --> 00:06:56,130
它试图返回到栈上的下一个值，但现在有些乱七八糟，

119
00:06:56,130 --> 00:06:57,520
可能已不在有效的代码区域。

120
00:06:57,520 --> 00:06:59,490
所以，它最终会崩溃。

121
00:06:59,490 --> 00:07:02,070
但我们不在乎，因为我们执行了我们想要的。

122
00:07:02,070 --> 00:07:06,380
在下一个视频中，我们将用 shellcode 编写第一个缓冲区溢出，

123
00:07:06,380 --> 00:07:09,290
它将向您展示缓冲区溢出，有多强大。

124
00:07:09,290 --> 00:07:13,020
这将是我们第一次利用它，获得根用户特权。

