1
00:00:00,149 --> 00:00:04,339
这些来自ProtoStar的网络级别并不真正与安全相关，但它们是

2
00:00:04,340 --> 00:00:07,270
做一些简单的网络编程很好。

3
00:00:07,270 --> 00:00:11,590
为了有一个完整的开发练习系列，我们将解决

4
00:00:11,589 --> 00:00:14,629
这些挑战也是如此。

5
00:00:14,629 --> 00:00:16,959
简介；

6
00:00:16,960 --> 00:00:23,680
前两个视频已经很好地介绍了网络、套接字、TCP，

7
00:00:23,679 --> 00:00:27,959
因此，让我们在此基础上编写一个Python脚本来与此进行交互。

8
00:00:27,960 --> 00:00:30,200
通过网络编程。

9
00:00:30,199 --> 00:00:34,659
特别是对于CTF来说，这是一个重要的部分，因为对于许多挑战你

10
00:00:34,660 --> 00:00:37,520
通过TCP与服务交互。

11
00:00:37,520 --> 00:00:41,010
所以你写的漏洞必须通过网络来实现。

12
00:00:41,010 --> 00:00:42,730
让我们来看看这个水平。

13
00:00:42,730 --> 00:00:46,650
我不会再讨论所有这些未知函数的含义，因为我们已经这样做了。

14
00:00:46,650 --> 00:00:48,230
在十六进制19集。

15
00:00:48,230 --> 00:00:54,550
正如我们在定义中看到的，或者通过检查虚拟机上的netstat，我们可以看到网络级别

16
00:00:54,550 --> 00:00:57,610
1正在端口2998上运行。

17
00:00:57,610 --> 00:01:01,330
我们可以再次使用netcat与此服务进行对话，但这次，我们要编写一个

18
00:01:01,330 --> 00:01:03,240
Python脚本。

19
00:01:03,240 --> 00:01:06,370
但我们先来看一下run函数。

20
00:01:06,370 --> 00:01:13,210
首先运行生成一个随机的无符号整数，然后我们将该数字sprintf到fub中。

21
00:01:13,210 --> 00:01:18,340
我们以前没有看到过S-printf——所以除了常规printf以外，它会写入结果

22
00:01:18,340 --> 00:01:25,310
字符串到stdout，sprintf将把结果字符串写入第一个字符串中指定的地址

23
00:01:25,310 --> 00:01:27,800
论点-在本例中是废话。

24
00:01:27,800 --> 00:01:32,950
这意味着“fub”将包含以ASCII表示的数字的十进制表示，并且

25
00:01:32,951 --> 00:01:35,791
不包含原始字节值。

26
00:01:35,790 --> 00:01:41,830
然后，write将写入套接字，从而向我们发送整数，从而

27
00:01:41,830 --> 00:01:42,830
字节。

28
00:01:42,830 --> 00:01:44,790
这就是我们看到的由netcat返回的结果。

29
00:01:44,790 --> 00:01:49,000
之后，程序将等待用户输入fread。

30
00:01:49,000 --> 00:01:53,900
一旦我们发送了一些数据，它将用一个空字节覆盖任何换行符或回车符。

31
00:01:53,900 --> 00:01:58,650
这是有意义的，因为当我们使用netcat并点击enter发送信息时，

32
00:01:58,650 --> 00:02:02,740
最后会有一个换行符，因为这是我们按下的键。

33
00:02:02,740 --> 00:02:06,530
但是很明显，这个程序只需要我们实际想要发送的字符-因此

34
00:02:06,530 --> 00:02:08,350
剥去新线。

35
00:02:08,350 --> 00:02:12,260
然后，它将原始号码与接收到的号码进行比较，并成功打印

36
00:02:12,260 --> 00:02:13,310
或者失败。

37
00:02:13,310 --> 00:02:16,260
所以，让我们开始编写Python脚本。

38
00:02:16,260 --> 00:02:17,260
但我们该怎么做呢？

39
00:02:17,260 --> 00:02:23,320
关于如何进行网络编程的第一个提示可能是查看netcat如何连接到

40
00:02:23,319 --> 00:02:24,319
服务器。

41
00:02:24,319 --> 00:02:26,619
所以我们可以使用strace跟踪netcat的所有系统调用。

42
00:02:26,620 --> 00:02:30,910
现在让我们试着找出重要的，然后我们试着找出

43
00:02:30,909 --> 00:02:33,019
在python中实现它们。

44
00:02:33,019 --> 00:02:37,209
第一个显然是对socket的调用，所以我们来看看python socket文档

45
00:02:37,209 --> 00:02:39,159
关于如何在或脚本中实现这一点。

46
00:02:39,159 --> 00:02:44,529
所以对socket的调用使用参数pf inet和sock_stream，当我们在这里查看时

47
00:02:44,530 --> 00:02:46,990
在python文档中，我们看到一些非常相似的东西。

48
00:02:46,989 --> 00:02:49,609
但它建议使用af-inet。

49
00:02:49,609 --> 00:02:54,969
所以我想知道pf和af-inet之间有什么区别，所以我在谷歌上搜索并惊讶地发现，

50
00:02:54,969 --> 00:02:59,999
事实证明，这是一个从未起飞的想法的残余，事实上，在

51
00:03:00,000 --> 00:03:03,360
Linux内核现在简单地定义为与af-inet相同。

52
00:03:03,359 --> 00:03:05,829
哈，今天学到了一些东西。

53
00:03:05,830 --> 00:03:10,910
然后，python文档使用connect连接到主机名或IP和端口。

54
00:03:10,909 --> 00:03:12,639
我们也可以在边栏看到。

55
00:03:12,640 --> 00:03:17,190
这里用端口2998和IP地址127.0.0.1调用

56
00:03:17,189 --> 00:03:20,329
所以我们也可以用它。

57
00:03:20,330 --> 00:03:21,330
酷。

58
00:03:21,330 --> 00:03:26,420
现在我们可以用这个套接字来使用发送和接收。

59
00:03:26,419 --> 00:03:30,259
显然，我们想读取发送给我们的号码，所以我们使用recv，但是我们

60
00:03:30,260 --> 00:03:33,520
指定要读取的数据量。

61
00:03:33,519 --> 00:03:38,389
在这种情况下，我们需要一个32位大的无符号整数，因此我们必须读取

62
00:03:38,390 --> 00:03:39,510
4字节。

63
00:03:39,510 --> 00:03:43,670
现在，让我们简单地打印接收到的数据，然后测试它。

64
00:03:43,669 --> 00:03:44,689
酷。

65
00:03:44,689 --> 00:03:50,449
顺便说一句，当我们快速地请求一个新号码时，也会注意到很多号码

66
00:03:50,449 --> 00:03:52,279
相同而非随机？

67
00:03:52,280 --> 00:03:56,980
这是因为在代码中，随机数生成器的种子是以秒为单位的时间。

68
00:03:56,980 --> 00:04:01,550
因此，如果我们发送足够快，秒数将相同，从而产生相同的伪码。

69
00:04:01,549 --> 00:04:02,549
随机数。

70
00:04:02,549 --> 00:04:11,219
不要使用非随机源作为伪随机数生成器的种子！

71
00:04:11,219 --> 00:04:15,859
现在很容易解决，因为我们已经有了转换的经验

72
00:04:15,859 --> 00:04:20,579
使用内存值的所有漏洞的原始字节数和原始字节数

73
00:04:20,579 --> 00:04:21,579
我们已经写好了。

74
00:04:21,579 --> 00:04:25,949
所以我们可以简单地使用struct模块并将原始二进制数据转换回无符号的

75
00:04:25,949 --> 00:04:30,019
整数，然后将其作为字符串发送回服务器。

76
00:04:30,020 --> 00:04:34,340
记住struct unpack返回一个元组，因此实际的unpacked数是第一个

77
00:04:34,340 --> 00:04:35,340
元素。

78
00:04:35,340 --> 00:04:36,920
嗯……好像挂起来了。

79
00:04:36,919 --> 00:04:38,319
让我们再试一次。

80
00:04:38,320 --> 00:04:40,180
现在它似乎起作用了。

81
00:04:40,180 --> 00:04:44,230
接收在等待数据时挂起，没有任何数据，因此我假设服务器

82
00:04:44,230 --> 00:04:50,080
发送太快，没有缓冲区缓冲数据，当我们最终准备好

83
00:04:50,080 --> 00:04:52,200
接收数据，数据已经在空区丢失。

84
00:04:52,199 --> 00:04:53,199
不管怎样，它起作用了。

85
00:04:53,199 --> 00:04:59,269
不必完美，只要你成功一次，攻击就成功了。

86
00:04:59,270 --> 00:05:03,940
这一集太短了，不管怎样，这些挑战并不是真正的安全问题，所以让我们来看看

87
00:05:03,939 --> 00:05:05,699
快速解决下一个问题。

88
00:05:05,699 --> 00:05:12,959
net2非常相似，我们再次设置了一个网络，在端口2997上监听一个程序。

89
00:05:12,960 --> 00:05:18,150
在run函数中，我们看到一个for循环，它运行4次，每次生成一个

90
00:05:18,150 --> 00:05:23,160
随机数，将其添加到所有数字的总和中，然后通过网络发送。

91
00:05:23,159 --> 00:05:26,969
描述还指出我们必须添加4个32位整数。

92
00:05:26,970 --> 00:05:30,970
它已经警告我们包装的可能性。

93
00:05:30,970 --> 00:05:37,790
或者用恰当的术语，它警告我们整数溢出——这也是安全相关的。

94
00:05:37,789 --> 00:05:42,539
好的，那么我们复制前面的脚本，并快速地将其修改为读取4个整数，然后

95
00:05:42,540 --> 00:05:44,250
计算总和。

96
00:05:44,250 --> 00:05:48,450
我们可以简单地扩展struct unpack修饰符，然后还可以在

97
00:05:48,449 --> 00:05:50,179
结果元组。

98
00:05:50,180 --> 00:05:51,650
很容易。

99
00:05:51,650 --> 00:05:56,620
代码期望结果不是ASCII十进制表示，而是作为原始二进制，

100
00:05:56,620 --> 00:06:01,320
所以我们可以使用struct pack将其covenrt为二进制字符串并发送它。

101
00:06:01,319 --> 00:06:02,359
哦。

102
00:06:02,360 --> 00:06:03,410
哈哈。

103
00:06:03,409 --> 00:06:06,259
我想证明这不管用。

104
00:06:06,260 --> 00:06:09,160
因为整数溢出。

105
00:06:09,159 --> 00:06:12,559
如果我们看一下二进制和的结果，我们会发现它包含更多的

106
00:06:12,560 --> 00:06:15,390
超过32位，不能。

107
00:06:15,389 --> 00:06:17,189
整数只有32位大。

108
00:06:17,190 --> 00:06:21,730
所以发生的是，整数只是溢出，或者环绕。

109
00:06:21,729 --> 00:06:24,419
这意味着最高位的进位刚刚丢失。

110
00:06:24,419 --> 00:06:29,909
嗯，这不是完全正确的，CPU实际上意识到了这一点，当一个算法

111
00:06:29,910 --> 00:06:35,220
诸如加法之类的操作最后会溢出寄存器中的值，这是一个特殊的溢出

112
00:06:35,220 --> 00:06:37,550
设置了可以检查的标志。

113
00:06:37,550 --> 00:06:43,130
但无论如何，在这种情况下，服务器上的无符号整数将始终换行。

114
00:06:43,129 --> 00:06:47,849
显然，这个旧的python结构版本确实为我们做了这些，但是这个行为

115
00:06:47,849 --> 00:06:48,849
被贬低了

116
00:06:48,849 --> 00:06:50,969
所以我们可以在代码中做同样的事情。

117
00:06:50,969 --> 00:06:55,969
如我所说，这个问题叫做整数溢出，当你搜索这个问题时，你会发现

118
00:06:55,969 --> 00:06:57,819
很多关于它的错误报告。

119
00:06:57,819 --> 00:07:01,269
让我们做一个典型整数溢出问题的简单示例。

120
00:07:01,270 --> 00:07:06,250
假设您有一个循环，它不断读取数据并将大小添加到总大小中。

121
00:07:06,250 --> 00:07:07,250
变量。

122
00:07:07,250 --> 00:07:11,750
一旦完成了循环，它就会知道需要分配多少数据空间。

123
00:07:11,749 --> 00:07:12,749
为了。

124
00:07:12,749 --> 00:07:17,689
现在的问题是，如果您设法发送这么多的数据，计数器溢出，包装

125
00:07:17,689 --> 00:07:22,729
大约，会为大量数据分配一个较小的空间，然后

126
00:07:22,729 --> 00:07:25,849
典型溢流情况。

127
00:07:25,849 --> 00:07:30,809
我们正缓慢地进入最后一级的开发演习，我们开始

128
00:07:30,810 --> 00:07:33,640
看到一些更复杂的挑战。

129
00:07:33,639 --> 00:07:35,679
所以让我们集中注意力，下一步解决这些问题！

