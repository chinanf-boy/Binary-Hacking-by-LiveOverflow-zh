1
00:00:00,149 --> 00:00:04,339
这些来自Protostar的网络级别是
与安全无关，但它们是

2
00:00:04,340 --> 00:00:07,270
做一些简单的网络编程很好。

3
00:00:07,270 --> 00:00:11,590
为了拥有一个完整的
从剥削练习系列，我们将解决

4
00:00:11,589 --> 00:00:14,629
这些挑战也是如此。

5
00:00:14,629 --> 00:00:16,959
简介；

6
00:00:16,960 --> 00:00:23,680
前两个视频已经很好了
介绍网络、套接字、TCP，

7
00:00:23,679 --> 00:00:27,959
因此，让我们在此基础上
编写一个python脚本来与此交互

8
00:00:27,960 --> 00:00:30,200
通过网络编程。

9
00:00:30,199 --> 00:00:34,659
特别是对于CTF来说，这是一个重要的
一部分，因为对于许多挑战你

10
00:00:34,660 --> 00:00:37,520
通过TCP与服务交互。

11
00:00:37,520 --> 00:00:41,010
所以你写的这篇文章必须重来一遍
网络。

12
00:00:41,010 --> 00:00:42,730
让我们来看看这个水平。

13
00:00:42,730 --> 00:00:46,650
我不想再谈这些东西的意义了
未知函数，因为我们已经这样做了

14
00:00:46,650 --> 00:00:48,230
在十六进制19集。

15
00:00:48,230 --> 00:00:54,550
正如我们在定义中看到的，或者通过检查
在虚拟机上的netstat，我们可以看到网络级别

16
00:00:54,550 --> 00:00:57,610
1正在端口2998上运行。

17
00:00:57,610 --> 00:01:01,330
我们也可以用netcat和这个对话
服务，但这次，我们想写一个

18
00:01:01,330 --> 00:01:03,240
Python脚本。

19
00:01:03,240 --> 00:01:06,370
但让我们先看看run函数。

20
00:01:06,370 --> 00:01:13,210
第一次运行生成随机无符号整数，
然后我们把数字快速转换成fub。

21
00:01:13,210 --> 00:01:18,340
我们以前没见过S-printf-所以其他的
而不是常规的printf，

22
00:01:18,340 --> 00:01:25,310
字符串到stdout，sprintf将写入结果
在第一个字符串中指定的地址

23
00:01:25,310 --> 00:01:27,800
参数-在本例中是废话。

24
00:01:27,800 --> 00:01:32,950
这意味着"fub"将包含小数点
用ASCII表示数字，以及

25
00:01:32,951 --> 00:01:35,791
不包含原始字节值。

26
00:01:35,790 --> 00:01:41,830
然后，write将写入套接字，因此
将整数发送给我们，因此原始

27
00:01:41,830 --> 00:01:42,830
字节。

28
00:01:42,830 --> 00:01:44,790
这就是我们看到的由netcat返回的结果。

29
00:01:44,790 --> 00:01:49,000
之后，程序将等待用户
输入fread。

30
00:01:49,000 --> 00:01:53,900
一旦我们发送了一些数据，它将覆盖
换行符或回车符返回空字节。

31
00:01:53,900 --> 00:01:58,650
这是有道理的，因为当我们
使用netcat并按enter发送信息，

32
00:01:58,650 --> 00:02:02,740
结尾会有一个新行，因为
这就是我们按下的键。

33
00:02:02,740 --> 00:02:06,530
但很明显这个程序只想
我们实际上打算发送的字符-因此

34
00:02:06,530 --> 00:02:08,350
剥去新线。

35
00:02:08,350 --> 00:02:12,260
然后将原始数字与
它接收到的号码和打印成功的号码

36
00:02:12,260 --> 00:02:13,310
或者失败。

37
00:02:13,310 --> 00:02:16,260
所以，让我们开始编写Python脚本。

38
00:02:16,260 --> 00:02:17,260
但我们该怎么做呢？

39
00:02:17,260 --> 00:02:23,320
可能是关于如何进行网络编程的第一个提示
可以看看netcat是如何连接到

40
00:02:23,319 --> 00:02:24,319
服务器。

41
00:02:24,319 --> 00:02:26,619
所以我们可以使用strace跟踪所有系统调用
NETCAT的。

42
00:02:26,620 --> 00:02:30,910
现在让我们试着找出
然后我们想办法

43
00:02:30,909 --> 00:02:33,019
在python中实现它们。

44
00:02:33,019 --> 00:02:37,209
第一个显然是对socket的调用，
那么让我们来看看python套接字文档

45
00:02:37,209 --> 00:02:39,159
关于如何在或脚本中实现这一点。

46
00:02:39,159 --> 00:02:44,529
所以对socket的调用使用参数
当我们看到这里的时候

47
00:02:44,530 --> 00:02:46,990
在python文档中，我们看到一些非常相似的东西。

48
00:02:46,989 --> 00:02:49,609
但它建议使用af-inet。

49
00:02:49,609 --> 00:02:54,969
所以我想知道
pf和af-inet，所以我在谷歌上搜索，令人惊讶的是，

50
00:02:54,969 --> 00:02:59,999
事实证明，这是
从未有过的想法，事实上

51
00:03:00,000 --> 00:03:03,360
Linux内核现在简单地定义为
和我一样。

52
00:03:03,359 --> 00:03:05,829
哈，今天学到了一些东西。

53
00:03:05,830 --> 00:03:10,910
然后python文档使用connect来连接
到主机名或IP和端口。

54
00:03:10,909 --> 00:03:12,639
我们也可以在边栏看到。

55
00:03:12,640 --> 00:03:17,190
这里是2998号港口，还有
IP地址127.0.0.1

56
00:03:17,189 --> 00:03:20,329
所以我们也可以用它。

57
00:03:20,330 --> 00:03:21,330
酷。

58
00:03:21,330 --> 00:03:26,420
现在我们可以使用发送和接收
插座。

59
00:03:26,419 --> 00:03:30,259
很明显，我们想知道
是发给我们的，所以我们使用recv，但是我们

60
00:03:30,260 --> 00:03:33,520
指定要读取的数据量。

61
00:03:33,519 --> 00:03:38,389
在这种情况下，我们需要一个无符号整数，
它是32位大，因此我们必须阅读

62
00:03:38,390 --> 00:03:39,510
4字节。

63
00:03:39,510 --> 00:03:43,670
现在让我们简单地打印我们收到的数据
然后测试它。

64
00:03:43,669 --> 00:03:44,689
酷。

65
00:03:44,689 --> 00:03:50,449
顺便说一句，当我们要求一个新的
数字很快，很多数字

66
00:03:50,449 --> 00:03:52,279
相同而非随机？

67
00:03:52,280 --> 00:03:56,980
这是因为代码中的随机数
生成器按时间（秒）设定种子。

68
00:03:56,980 --> 00:04:01,550
因此，如果我们发送的足够快，秒数就会
相同，因此产生相同的伪

69
00:04:01,549 --> 00:04:02,549
随机数。

70
00:04:02,549 --> 00:04:11,219
你不曾使用非随机源作为
伪随机数生成器的种子！

71
00:04:11,219 --> 00:04:15,859
现在很容易解决，因为我们
已经很有转化的经验了

72
00:04:15,859 --> 00:04:20,579
从数字到原始字节，从原始字节到数字
从所有使用内存值

73
00:04:20,579 --> 00:04:21,579
我们已经写好了。

74
00:04:21,579 --> 00:04:25,949
所以我们可以简单地使用结构模块和
将原始二进制数据转换回无符号数据

75
00:04:25,949 --> 00:04:30,019
整数，然后将其作为字符串发送回
到服务器。

76
00:04:30,020 --> 00:04:34,340
记住struct unpack返回一个元组，
所以实际拆包的号码是第一个

77
00:04:34,340 --> 00:04:35,340
元素。

78
00:04:35,340 --> 00:04:36,920
嗯……好像挂起来了。

79
00:04:36,919 --> 00:04:38,319
让我们再试一次。

80
00:04:38,320 --> 00:04:40,180
现在它似乎起作用了。

81
00:04:40,180 --> 00:04:44,230
接收在等待数据时挂起
没有，所以我假设服务器

82
00:04:44,230 --> 00:04:50,080
发送太快，没有缓冲区缓冲
数据，当我们最终准备好

83
00:04:50,080 --> 00:04:52,200
接收数据，数据已丢失在
无效。

84
00:04:52,199 --> 00:04:53,199
不管怎样，它起作用了。

85
00:04:53,199 --> 00:04:59,269
不一定要完美，只要你
一旦成功，攻击就成功了。

86
00:04:59,270 --> 00:05:03,940
这一集太短了，这些挑战
不管怎么说，都不是真正的安全问题，所以让我们

87
00:05:03,939 --> 00:05:05,699
快速解决下一个问题。

88
00:05:05,699 --> 00:05:12,959
net2非常相似，我们又有了一个网络
用在端口2997上侦听的程序设置。

89
00:05:12,960 --> 00:05:18,150
在run函数中，我们看到一个for循环，
运行4次，每次生成

90
00:05:18,150 --> 00:05:23,160
随机数，加在它们的和上
然后通过网络发送。

91
00:05:23,159 --> 00:05:26,969
描述还说我们必须
加4个32位整数。

92
00:05:26,970 --> 00:05:30,970
它已经警告我们这种可能性
它的包装。

93
00:05:30,970 --> 00:05:37,790
或者用适当的术语，它警告我们整数
溢出-这也是安全相关的。

94
00:05:37,789 --> 00:05:42,539
好吧，那么让我们复制我们以前的脚本
快速修改为读取4个整数，然后

95
00:05:42,540 --> 00:05:44,250
计算总和。

96
00:05:44,250 --> 00:05:48,450
我们可以简单地扩展struct unpack修饰符，
然后我们也可以在

97
00:05:48,449 --> 00:05:50,179
结果元组。

98
00:05:50,180 --> 00:05:51,650
很容易。

99
00:05:51,650 --> 00:05:56,620
代码要求结果不在ASCII中
十进制表示，但作为原始二进制，

100
00:05:56,620 --> 00:06:01,320
所以我们可以使用结构包将其
一个二进制字符串并发送它。

101
00:06:01,319 --> 00:06:02,359
哦。

102
00:06:02,360 --> 00:06:03,410
哈哈。

103
00:06:03,409 --> 00:06:06,259
我想证明这不管用。

104
00:06:06,260 --> 00:06:09,160
因为整数溢出。

105
00:06:09,159 --> 00:06:12,559
如果我们看一下这个和的结果
在二进制中，我们可以看到它包含更多

106
00:06:12,560 --> 00:06:15,390
超过32位，不能。

107
00:06:15,389 --> 00:06:17,189
整数只有32位大。

108
00:06:17,190 --> 00:06:21,730
结果是，整数
溢出或缠绕。

109
00:06:21,729 --> 00:06:24,419
这意味着最高位的进位是
只是迷路了。

110
00:06:24,419 --> 00:06:29,909
嗯，这不是完全正确的，CPU是
实际上意识到这一点，当一个算术

111
00:06:29,910 --> 00:06:35,220
加法之类的操作最终会溢出
寄存器中的值，一个特殊的溢出

112
00:06:35,220 --> 00:06:37,550
设置了可以检查的标志。

113
00:06:37,550 --> 00:06:43,130
但无论如何，在这种情况下，我们的无符号整数
在服务器上，将始终环绕。

114
00:06:43,129 --> 00:06:47,849
显然，这个旧的python结构版本
实际上是为了我们，但这种行为

115
00:06:47,849 --> 00:06:48,849
被贬低了

116
00:06:48,849 --> 00:06:50,969
所以我们可以在代码中做同样的事情。

117
00:06:50,969 --> 00:06:55,969
如我所说，这个问题叫做整数溢出，
当你搜索这个的时候，你会发现

118
00:06:55,969 --> 00:06:57,819
很多关于它的错误报告。

119
00:06:57,819 --> 00:07:01,269
让我们举一个简单的例子
整数溢出问题。

120
00:07:01,270 --> 00:07:06,250
假设你有一个循环，它一直在读
数据并将大小添加到总大小

121
00:07:06,250 --> 00:07:07,250
变量。

122
00:07:07,250 --> 00:07:11,750
一旦循环完成，它就会知道
它必须分配多少数据空间

123
00:07:11,749 --> 00:07:12,749
为了。

124
00:07:12,749 --> 00:07:17,689
现在的问题是，如果你设法发送
计数器溢出的大量数据

125
00:07:17,689 --> 00:07:22,729
大约，一个较小的空间被分配给
大量的数据，然后

126
00:07:22,729 --> 00:07:25,849
典型溢流情况。

127
00:07:25,849 --> 00:07:30,809
我们正慢慢进入最后一级
利用练习的原恒星，我们开始

128
00:07:30,810 --> 00:07:33,640
看到一些更复杂的挑战。

129
00:07:33,639 --> 00:07:35,679
所以让我们集中注意力，下一步解决这些问题！

