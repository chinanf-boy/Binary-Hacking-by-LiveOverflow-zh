1
00:00:00,149 --> 00:00:04,339
这些来自 ProtoStar的网络级别问题，并不真正与安全相关，

2
00:00:04,340 --> 00:00:07,270
但对一些简单的网络编程来说，他们真的很好。

3
00:00:07,270 --> 00:00:11,590
为了有一个 exploit-exercises 完整的体现，

4
00:00:11,589 --> 00:00:14,629
我们也是会完成这些挑战。

5
00:00:14,629 --> 00:00:16,959
<简介>；

6
00:00:16,960 --> 00:00:23,680
前两个视频已经很好地介绍了网络、套接字、TCP，

7
00:00:23,679 --> 00:00:27,959
因此，让我们在此基础上，编写一个Python脚本，

8
00:00:27,960 --> 00:00:30,200
借用该程序来与网络进行交互。

9
00:00:30,199 --> 00:00:34,659
特别是对于CTF来说，这是一个重要的部分，因为对于许多挑战，

10
00:00:34,660 --> 00:00:37,520
你都是通过TCP，与服务(器)交互的。

11
00:00:37,520 --> 00:00:41,010
所以，你写的漏洞脚本，必须在网络上完成。

12
00:00:41,010 --> 00:00:42,730
让我们来看看这个级别问题。

13
00:00:42,730 --> 00:00:46,650
我不会再讨论所有这些未知函数的含义，

14
00:00:46,650 --> 00:00:48,230
因为我们已经在(hex 19 / 25)集，讲过了。

15
00:00:48,230 --> 00:00:54,550
正如，我们在定义中看到的，或者只检查了虚拟机上的 netstat，

16
00:00:54,550 --> 00:00:57,610
我们可以看到级别1网络，正在端口2998上运行。

17
00:00:57,610 --> 00:01:01,330
我们可以再次使用 netcat，与此服务进行对话，但这次，

18
00:01:01,330 --> 00:01:03,240
我们要编写一个Python脚本。

19
00:01:03,240 --> 00:01:06,370
但，我们先来看一下 run 函数。

20
00:01:06,370 --> 00:01:13,210
首先，运行生成一个随机的无符号整数，然后，我们将该数字 sprintf 到fub 中。

21
00:01:13,210 --> 00:01:18,340
我们以前没有看到过 S-printf —— 与 printf 不同，

22
00:01:18,340 --> 00:01:25,310
它会把结果字符串，写入到 stdout，

23
00:01:25,310 --> 00:01:27,800
sprintf将把结果字符串，写入由第一个参数指定的地址 —— 在本例中是 buf。

24
00:01:27,800 --> 00:01:32,950
“fub”的意思，将包含以 ASCII 表示的十进制数字，

25
00:01:32,951 --> 00:01:35,791
并且，不包含原始字节值。

26
00:01:35,790 --> 00:01:41,830
然后，write 将写入套接字，从而向我们发送整数，

27
00:01:41,830 --> 00:01:42,830
还有原始字节。

28
00:01:42,830 --> 00:01:44,790
这就是我们看到的，netcat 返回的结果。

29
00:01:44,790 --> 00:01:49,000
之后，程序用 fread，等待用户输入。

30
00:01:49,000 --> 00:01:53,900
一旦我们发送了一些数据，它将用一个空字节，覆盖任何换行符或回车符。

31
00:01:53,900 --> 00:01:58,650
说得通，因为当我们使用netcat，并点击enter，发送信息时，

32
00:01:58,650 --> 00:02:02,740
最后，会有一个换行符，因为这就是我们的按键。

33
00:02:02,740 --> 00:02:06,530
但是很明显，这个程序只需要我们实际发送的字符-

34
00:02:06,530 --> 00:02:08,350
因此剥去换行。

35
00:02:08,350 --> 00:02:12,260
然后，它将原始数字与接收到的数字进行比较，

36
00:02:12,260 --> 00:02:13,310
并打印成功或者失败。

37
00:02:13,310 --> 00:02:16,260
所以，让我们开始编写Python脚本。

38
00:02:16,260 --> 00:02:17,260
但我们该怎么做呢？

39
00:02:17,260 --> 00:02:23,320
网络编程的第一个提示，可能是，

40
00:02:23,319 --> 00:02:24,319
看 netcat 如何连接到服务器。

41
00:02:24,319 --> 00:02:26,619
所以，我们可以使用strace ，跟踪 netcat 的所有 syscall。

42
00:02:26,620 --> 00:02:30,910
现在，让我们试着找出重要的，然后，

43
00:02:30,909 --> 00:02:33,019
我们试着在 python 中实现它们。

44
00:02:33,019 --> 00:02:37,209
第一个，显然是对 socket 的调用，所以，我们来看看，

45
00:02:37,209 --> 00:02:39,159
python socket文档，关于如何实现这一点。

46
00:02:39,159 --> 00:02:44,529
所以，对 socket 的调用使用参数 PF_INET 和 SOCK_STREAM，

47
00:02:44,530 --> 00:02:46,990
现在，看着 python文档，发现一些非常相似的东西。

48
00:02:46,989 --> 00:02:49,609
但，它建议使用 AF_INET 。

49
00:02:49,609 --> 00:02:54,969
所以，我想知道 PF 和 AF_INET 之间，有什么区别，所以我在谷歌上搜索并惊讶地发现，

50
00:02:54,969 --> 00:02:59,999
事实证明，这是一个从未起飞的想法的残渣，

51
00:03:00,000 --> 00:03:03,360
在实际的 Linux内核中，它现在被简单定义为 AF_INET 。

52
00:03:03,359 --> 00:03:05,829
哈，今天学到了一些东西。

53
00:03:05,830 --> 00:03:10,910
然后，python文档，使用 connect 连接到主机名或IP和端口。

54
00:03:10,909 --> 00:03:12,639
我们也可以在 strace 看到。

55
00:03:12,640 --> 00:03:17,190
这里，用端口2998 和 IP地址127.0.0.1 调用

56
00:03:17,189 --> 00:03:20,329
所以，我们也可以用它。

57
00:03:20,330 --> 00:03:21,330
酷。

58
00:03:21,330 --> 00:03:26,420
现在，我们可以对这个套接字，发送和接收。

59
00:03:26,419 --> 00:03:30,259
显然，我们想读取发送给我们的数字，所以我们使用 recv，

60
00:03:30,260 --> 00:03:33,520
但是我们必须指定，要读取的数据量。

61
00:03:33,519 --> 00:03:38,389
在这种情况下，我们需要一个32位大的，无符号整数，

62
00:03:38,390 --> 00:03:39,510
因此，我们必须读取4个字节(32位)。

63
00:03:39,510 --> 00:03:43,670
现在，让我们简单打印接收到的数据，然后测试它。

64
00:03:43,669 --> 00:03:44,689
酷。

65
00:03:44,689 --> 00:03:50,449
顺便说一句，当我们快速请求一个新数字时，

66
00:03:50,449 --> 00:03:52,279
也会注意到很多相同数字，不是随机的吗？

67
00:03:52,280 --> 00:03:56,980
这是因为在代码中，随机数生成器的种子，是以秒为单位的时间。

68
00:03:56,980 --> 00:04:01,550
因此，如果我们发送足够快，秒数将相同，

69
00:04:01,549 --> 00:04:02,549
从而产生相同的伪随机数。

70
00:04:02,549 --> 00:04:11,219
不要使用非随机源，作为伪随机数生成器的种子！

71
00:04:11,219 --> 00:04:15,859
现在，很容易解决，因为我们已经有了转换的经验，

72
00:04:15,859 --> 00:04:20,579
就是我们曾写过的漏洞脚本中，关于内存值方面的，

73
00:04:20,579 --> 00:04:21,579
原始字节和数字之间的相互转换。

74
00:04:21,579 --> 00:04:25,949
所以我们可以简单使用struct模块，将原始二进制数据转换回，

75
00:04:25,949 --> 00:04:30,019
无符号的整数，然后将其作为字符串发送回服务器。

76
00:04:30,020 --> 00:04:34,340
记住 struct unpack 返回一个元组，因此，个

77
00:04:34,340 --> 00:04:35,340
实际的unpacked数是第一元素。

78
00:04:35,340 --> 00:04:36,920
嗯… 好像挂起来了。

79
00:04:36,919 --> 00:04:38,319
让我们再试一次。

80
00:04:38,320 --> 00:04:40,180
现在它似乎起作用了。

81
00:04:40,180 --> 00:04:44,230
接收在等待数据时挂起，没有任何数据，

82
00:04:44,230 --> 00:04:50,080
因此我假设服务器发送太快，没有缓冲区缓冲数据，

83
00:04:50,080 --> 00:04:52,200
当我们终于准备好接收数据，数据已经在 void 丢失。

84
00:04:52,199 --> 00:04:53,199
不管怎样，它起作用了。

85
00:04:53,199 --> 00:04:59,269
不必完美，只要你成功一次，攻击就成功了。

86
00:04:59,270 --> 00:05:03,940
这一集太短了，不管怎样，这些挑战并不是真正的安全问题，

87
00:05:03,939 --> 00:05:05,699
所以让我们，快速解决下一个问题。

88
00:05:05,699 --> 00:05:12,959
net2非常相似，我们再次设置了一个网络，在端口2997上，监听一个程序。

89
00:05:12,960 --> 00:05:18,150
在 run 函数中，我们看到一个for循环，它运行4次，每次生成一个随机数，

90
00:05:18,150 --> 00:05:23,160
将其添加到所有数字的总和中，然后通过网络发送。

91
00:05:23,159 --> 00:05:26,969
（挑战）描述，还指出我们必须添加4个32位整数。

92
00:05:26,970 --> 00:05:30,970
它已经警告我们，wrapping包装的可能性。

93
00:05:30,970 --> 00:05:37,790
或者用恰当的术语，它警告我们整数会溢出 —— 这也是安全相关的。

94
00:05:37,789 --> 00:05:42,539
好的，那么我们复制前面的脚本，并快速修改为读取4个整数，

95
00:05:42,540 --> 00:05:44,250
然后计算总和。

96
00:05:44,250 --> 00:05:48,450
我们可以简单扩展 struct unpack 修饰符，

97
00:05:48,449 --> 00:05:50,179
然后还可以在结果元组之上，创建一个 sum。

98
00:05:50,180 --> 00:05:51,650
很容易。

99
00:05:51,650 --> 00:05:56,620
代码期望的结果，不是ASCII十进制表示的，而是一个原始二进制，

100
00:05:56,620 --> 00:06:01,320
所以，我们可以使用struct pack，将其转换为二进制字符串并发送它。

101
00:06:01,319 --> 00:06:02,359
哦。

102
00:06:02,360 --> 00:06:03,410
哈哈。

103
00:06:03,409 --> 00:06:06,259
我想证明，这不管用。

104
00:06:06,260 --> 00:06:09,160
因为整数溢出。

105
00:06:09,159 --> 00:06:12,559
如果我们看一下二进制总和的结果，我们会发现它，

106
00:06:12,560 --> 00:06:15,390
包含超过32位，而这不应该啊。

107
00:06:15,389 --> 00:06:17,189
而一个整数应该只有32位大。

108
00:06:17,190 --> 00:06:21,730
所以发生的是，整数只是溢出，或者包漏了。

109
00:06:21,729 --> 00:06:24,419
这意味着，最高位的进位刚刚丢失。

110
00:06:24,419 --> 00:06:29,909
嗯，这并不完全正确，CPU实际上，意识到了这一点，当一个算法，

111
00:06:29,910 --> 00:06:35,220
诸如加法之类的操作，若在寄存器中，最后溢出了值，

112
00:06:35,220 --> 00:06:37,550
会设置一个特殊的溢出标志，这可以用来检查。

113
00:06:37,550 --> 00:06:43,130
但无论如何，在这种情况下，服务器上的无符号整数，将始终溢出。

114
00:06:43,129 --> 00:06:47,849
显然，这个旧的python struct 版本，确实为我们做了这些，

115
00:06:47,849 --> 00:06:48,849
但是这个行为被贬低了。

116
00:06:48,849 --> 00:06:50,969
所以，我们可以在代码中做同样的事情。

117
00:06:50,969 --> 00:06:55,969
如我所说，这个问题叫做整数溢出，当你搜索这个问题时，

118
00:06:55,969 --> 00:06:57,819
你会发现很多关于它的错误报告。

119
00:06:57,819 --> 00:07:01,269
让我们做一个典型整数溢出问题的简单示例。

120
00:07:01,270 --> 00:07:06,250
假设您有一个循环，它不断读取数据，

121
00:07:06,250 --> 00:07:07,250
并将大小添加到总大小的变量。

122
00:07:07,250 --> 00:07:11,750
一旦完成了循环，它就会知道需要分配多少内存空间。

123
00:07:11,749 --> 00:07:12,749
为了。

124
00:07:12,749 --> 00:07:17,689
现在的问题是，如果您打算发送这么多的数据，计数器却溢出，

125
00:07:17,689 --> 00:07:22,729
大量数据只分配一个较小的空间，

126
00:07:22,729 --> 00:07:25,849
这就是，典型溢出情况。

127
00:07:25,849 --> 00:07:30,809
我们正缓慢进入最后一级的 exploit-exercises protostar，

128
00:07:30,810 --> 00:07:33,640
我们开始看到一些更复杂的挑战。

129
00:07:33,639 --> 00:07:35,679
所以，让我们集中注意力，解决下一个问题！

