1
00:00:10,440 --> 00:00:11,920
我写了一个小C程序。

2
00:00:11,920 --> 00:00:14,660
这应该是一个简单的许可证检查。

3
00:00:14,660 --> 00:00:21,410
所以你可以执行它，你可以提供
键作为参数，它将被选中。

4
00:00:21,410 --> 00:00:25,440
我们的目标是破解这个程序，这样我们就不会
必须使用有效的许可证密钥。

5
00:00:25,440 --> 00:00:29,330
我已经通过
GitHub存储库。

6
00:00:29,330 --> 00:00:37,780
你可以从github.com/liveoverflow/liveoverflow\u youtube下载
或者你可以用sudo安装git

7
00:00:37,780 --> 00:00:43,460
apt get install git'并获取整个存储库
使用"git clone"和地址，您可以

8
00:00:43,460 --> 00:00:44,600
参见GITHUB。

9
00:00:44,600 --> 00:00:47,850
我们可能会更多地讨论什么是Git
是后来。

10
00:00:47,850 --> 00:00:52,390
现在已经足够知道了
开发人员如何一起编程的方法

11
00:00:52,390 --> 00:00:53,650
在一个项目上。

12
00:00:53,649 --> 00:00:57,159
我用它来分享一些东西。

13
00:00:57,159 --> 00:01:01,489
要了解二进制汇编程序代码，
我们可以使用一个叫做gdb的程序。

14
00:01:01,489 --> 00:01:04,259
GNU调试程序。

15
00:01:04,260 --> 00:01:07,330
所以键入"gdb"和二进制文件的路径。

16
00:01:07,330 --> 00:01:10,550
所以每个C程序都有一个主要功能，记得吗？

17
00:01:10,550 --> 00:01:15,370
那么让我们输入"disassemble main"
它将显示所有汇编程序指令

18
00:01:15,370 --> 00:01:17,280
从主功能。

19
00:01:17,280 --> 00:01:19,970
但是，呃，你看到它有多难看吗？

20
00:01:19,970 --> 00:01:23,360
这是非常糟糕的AT&T语法。

21
00:01:23,360 --> 00:01:26,830
所以键入"set disassembly flavor intel"。

22
00:01:26,830 --> 00:01:29,400
请记住，您可以在此处使用制表符完成
也。

23
00:01:29,400 --> 00:01:33,850
现在再次"拆卸主管道"，现在
它的可读性更高。

24
00:01:33,850 --> 00:01:34,850
好啊。

25
00:01:34,850 --> 00:01:35,850
所以。

26
00:01:35,850 --> 00:01:37,290
看起来很复杂。

27
00:01:37,290 --> 00:01:39,480
但你可以忽略其中的大部分。

28
00:01:39,480 --> 00:01:41,270
首先，要对它有一个高层次的了解。

29
00:01:41,270 --> 00:01:45,800
开始经历是没有意义的
这是一条指示。

30
00:01:45,800 --> 00:01:48,720
这个主函数显然调用其他函数。

31
00:01:48,720 --> 00:01:53,140
所以只要画一张粗略的
控制流程。

32
00:01:53,140 --> 00:01:56,210
我将实际打印出这个汇编程序代码
并用钢笔。

33
00:01:56,210 --> 00:02:00,720
这就是我一开始就这么做的
当我遇到更复杂的事情时，还是要做

34
00:02:00,720 --> 00:02:01,990
代码。

35
00:02:01,990 --> 00:02:08,200
记住要忽略大部分的事情，
注意实际流量。

36
00:02:08,200 --> 00:02:12,410
所以在开始的时候
数字2。

37
00:02:12,409 --> 00:02:15,309
然后是"跳跃不相等"。

38
00:02:15,310 --> 00:02:23,730
所以如果是2，就要检查。

39
00:02:23,730 --> 00:02:27,300
如果是这种情况，我们将继续进行"打印"。

40
00:02:27,300 --> 00:02:31,980
我们知道它是一个显示文本的函数。

41
00:02:31,980 --> 00:02:39,810
如果你不这样做，就会有一个"strcmp"
了解这个功能，阅读它的手册页。

42
00:02:39,810 --> 00:02:45,990
"man 3 strcmp"-所以这比较了两个
如果两个字符串都是

43
00:02:45,990 --> 00:02:49,510
相同的。

44
00:02:49,510 --> 00:03:00,410
打过电话后，我们看到另一个"不跳
等于"所以如果没有设置零标志，

45
00:03:00,410 --> 00:03:03,230
将是一个"看跌"电话。

46
00:03:03,230 --> 00:03:14,080
使用手册页了解它的作用，
但它只是像printf一样打印文本。

47
00:03:14,080 --> 00:03:19,200
所以如果原始数据与数字比较
2不是真的，那么它会跳到这个

48
00:03:19,200 --> 00:03:23,790
地址0x400623，位于偏移量MAIN+102处。

49
00:03:23,790 --> 00:03:30,290
所以在这种情况下，它会打印其他文本
有"看跌期权"和"退出期权"。

50
00:03:30,290 --> 00:03:34,630
我总是添加地址，或者至少部分地址
地址，从重要地点，

51
00:03:34,630 --> 00:03:37,210
所以我知道我在哪里。

52
00:03:37,209 --> 00:03:40,799
这将有助于你以后当我们通过
程序。

53
00:03:40,800 --> 00:03:42,550
现在我们缺了一个分支。

54
00:03:42,550 --> 00:03:46,710
如果这个比较不正确，这个分支
会跳到偏移主+90。

55
00:03:46,710 --> 00:03:52,390
也可以打印文本。

56
00:03:52,390 --> 00:03:57,910
一些跳跃仍然不见了，但你可以
添加它们以得到一个很好的控制流程图。

57
00:03:57,910 --> 00:04:01,460
现在让我们实际执行这个步骤
通过它。

58
00:04:01,460 --> 00:04:05,780
然后你可以在图中画出哪条路
你已经拿了你的论文。

59
00:04:05,780 --> 00:04:11,800
为此，我们首先在
以"break*main"开头的main。

60
00:04:11,800 --> 00:04:16,220
设置了断点，现在使用"run"启动
程序。

61
00:04:16,220 --> 00:04:20,100
启动程序，我们到达了断点
1在这个地址。

62
00:04:20,100 --> 00:04:24,880
断点是执行停止的点。

63
00:04:24,879 --> 00:04:27,579
现在看看"信息寄存器"的寄存器。

64
00:04:27,580 --> 00:04:34,520
在这里你可以看到那个裂口，说明
指针，指向主目录中的第一个地址。

65
00:04:34,520 --> 00:04:38,250
现在使用"si"执行一条指令。

66
00:04:38,250 --> 00:04:39,990
现在我们主要在一个新地址。

67
00:04:39,990 --> 00:04:44,000
"信息寄存器"和您看到的更改
指令指针。

68
00:04:44,000 --> 00:04:50,030
所以现在，只要一步一步，跟着
控制图中的地址。

69
00:04:50,030 --> 00:04:54,780
但是使用"ni"而不是"si"，因为
"si"将单步执行函数调用。

70
00:04:54,780 --> 00:05:07,500
但我们只想跨过这条主线
功能，而不是像"Puts"这样的东西。

71
00:05:07,500 --> 00:05:10,300
好吧，我们跳的时候你注意到了吗？

72
00:05:10,300 --> 00:05:16,160
跳到5点，然后是下一条指令
当时是623点。

73
00:05:16,160 --> 00:05:24,840
所以我们跟着跳，这意味着什么
与2相比，不是2。

74
00:05:24,840 --> 00:05:31,380
然后程序打印使用信息
628年后，这是最后一个"看跌"电话。

75
00:05:31,380 --> 00:05:35,350
所以我们可以写下，这个"投入"
打印"使用"信息。

76
00:05:35,350 --> 00:05:41,560
现在很明显，我们没有
将密钥传递给此程序。

77
00:05:41,560 --> 00:05:46,480
这意味着支票是在看参数
如果我们提供了许可证密钥。

78
00:05:46,480 --> 00:05:55,250
让我们再次运行程序，但是
使用随机许可证密钥的时间。

79
00:05:55,250 --> 00:05:57,160
是的，我们想重新启动程序。

80
00:05:57,160 --> 00:06:00,500
现在做同样的事情。

81
00:06:00,500 --> 00:06:02,170
"ni"，"ni"。

82
00:06:02,169 --> 00:06:06,129
现在我们又到5点了，我们能跳下去吗
时间？

83
00:06:06,130 --> 00:06:07,870
不！酷！

84
00:06:07,870 --> 00:06:11,510
所以我们预计下一个分支是609。

85
00:06:11,510 --> 00:06:15,880
让我们"ni"看看会发生什么。

86
00:06:15,880 --> 00:06:17,710
啊！

87
00:06:17,710 --> 00:06:18,710
另一个打印文本。

88
00:06:18,710 --> 00:06:24,960
所以"printf"是一个许可证
将检查钥匙。

89
00:06:24,960 --> 00:06:27,160
"ni"。

90
00:06:27,160 --> 00:06:28,790
现在树枝来了。

91
00:06:28,790 --> 00:06:34,080
好的，我们到了609号，让我们看看我们在哪里
是后来。

92
00:06:34,080 --> 00:06:36,000
617点。

93
00:06:36,000 --> 00:06:40,500
所以我们跳了，这意味着strcmp
失败。

94
00:06:40,500 --> 00:06:45,060
当我们继续"ni"时，我们看到
这是错误的。

95
00:06:45,060 --> 00:06:46,060
好啊。

96
00:06:46,060 --> 00:06:52,200
让我们在最后一个之前设置一个断点
比较并再次运行程序。

97
00:06:52,200 --> 00:06:57,490
请记住，您可以轻松地复制和粘贴值
在终端上简单地做标记

98
00:06:57,490 --> 00:06:59,790
然后按你的鼠标跟。

99
00:06:59,790 --> 00:07:02,300
现在再"跑"一次。

100
00:07:02,300 --> 00:07:03,970
断点1。

101
00:07:03,970 --> 00:07:05,290
现在"继续"。

102
00:07:05,290 --> 00:07:10,360
这将再次正常运行程序，
直到我们到达下一个断点。

103
00:07:10,360 --> 00:07:14,320
现在在执行"测试"之前停止了
EAX，EAX

104
00:07:14,320 --> 00:07:20,770
EAX只是指
64位RAX寄存器。

105
00:07:20,770 --> 00:07:23,430
所以它的值是hex 0xe。

106
00:07:23,430 --> 00:07:31,710
让我们把它设为0，这表示
"strcmp"是正确的并返回

107
00:07:31,710 --> 00:07:33,890
A 0。'设置$eax=0'。

108
00:07:33,889 --> 00:07:37,459
"信息寄存器"你可以看到
现在是0。

109
00:07:37,460 --> 00:07:43,020
现在再次使用"ni"步进并跟随
你的控制路径。

110
00:07:43,020 --> 00:07:48,150
'已授予访问权限！’

111
00:07:48,150 --> 00:07:50,720
哎呀！

112
00:07:50,720 --> 00:07:53,830
我们避开了许可证检查！

113
00:07:53,830 --> 00:07:58,150
我觉得那很酷！

114
00:07:58,150 --> 00:08:04,050
你可以一直写你自己的小C
程序试图使其更安全，以及

115
00:08:04,050 --> 00:08:05,810
然后你自己再来一次。

116
00:08:05,810 --> 00:08:11,510
你会发现这是不可能的
使程序无法运行。

117
00:08:11,510 --> 00:08:14,420
这种挑战被称为"crackme"。

118
00:08:14,419 --> 00:08:17,469
人们创造的小程序必须
裂开。

119
00:08:17,470 --> 00:08:20,490
或者更频繁地创建有效的keygen。

120
00:08:20,490 --> 00:08:26,700
如果你认为这样的事情很有趣，结帐
http://crackmes.de/。

121
00:08:26,699 --> 00:08:30,229
像我们刚才那样创建控制图是
非常有用。

122
00:08:30,230 --> 00:08:33,980
这就是为什么有些程序
为我们做那件事。

123
00:08:33,979 --> 00:08:39,799
这里有三个不同的例子
具体控制图。

124
00:08:39,800 --> 00:08:48,390
第一个是hopperapp，第二个是idapro和
最后一个来自Radare2。

125
00:08:48,390 --> 00:08:53,160
希望下次我们用的时候能见到你
探索此许可证检查的不同工具

126
00:08:53,160 --> 00:08:54,160
再多一点二进制。

127
00:08:54,160 --> 00:08:55,160
让我们把基本概念结合起来
CPU的

128
00:08:55,160 --> 00:08:56,160
计算机有不同的内存来存储东西
-所以首先我们需要一些东西来储存

129
00:08:56,160 --> 00:08:57,160
机器代码输入。

130
00:08:57,160 --> 00:08:58,160
让我们拿个电子表格想象一下
这就是记忆。

131
00:08:58,160 --> 00:08:59,160
您可以在它和每个内存中存储值
单元格有一个地址，该地址是

132
00:08:59,160 --> 00:09:00,160
左边。

133
00:09:00,160 --> 00:09:01,160
我会用第二栏写一些
这里有评论。

134
00:09:01,160 --> 00:09:02,160
正如你所看到的，有一些十六进制
存储在此内存中的数字。

135
00:09:02,160 --> 00:09:03,160
起初看起来很随机，但是
是我们的机器代码，很快你就会明白

136
00:09:03,160 --> 00:09:04,160
这个。

137
00:09:04,160 --> 00:09:05,160
所以CPU需要做的第一件事就是
在记忆中跟踪

138
00:09:05,160 --> 00:09:06,160
CPU当前为。

139
00:09:06,160 --> 00:09:07,160
这意味着我们应该增加一点存储空间
对于我们的CPU，称之为"指令"

140
00:09:07,160 --> 00:09:08,160
指针"。

141
00:09:08,160 --> 00:09:09,160
这个小储藏区将包含
CPU正在查看的内存地址

142
00:09:09,160 --> 00:09:10,160
时刻。

143
00:09:10,160 --> 00:09:11,160
所以很明显我们的计划是从顶层开始的，
所以地址是1。

144
00:09:11,160 --> 00:09:12,160
现在让我们启动CPU，它查看地址
1读48，aa，14。

145
00:09:12,160 --> 00:09:13,160
但是这些数字是什么意思？

146
00:09:13,160 --> 00:09:14,160
CPU知道48意味着它必须移动
周围的数据。

147
00:09:14,160 --> 00:09:15,160
aa表示移动的目的地。
14是源头。

148
00:09:15,160 --> 00:09:16,160
所以在地址14我们可以看到42。

149
00:09:16,160 --> 00:09:17,160
目的地是另一个小仓库
CPU内部的单元。

150
00:09:17,160 --> 00:09:18,160
所以CPU会把42移动到它的小地方
储存区称为AA。

151
00:09:18,160 --> 00:09:19,160
所以这个指令完成了，CPU增加了
一个一个的指令指针。

152
00:09:19,160 --> 00:09:20,160
我们重新开始。

153
00:09:20,160 --> 00:09:21,160
CPU读取地址的当前值
它的指令指针。

154
00:09:21,160 --> 00:09:22,160
所以它再次读取48，这意味着移动，和
这次是移动地址的内容

155
00:09:22,160 --> 00:09:23,160
15进小储藏室bb。

156
00:09:23,160 --> 00:09:24,160
注意如何在15左右使用括号。

157
00:09:24,160 --> 00:09:25,160
这表示15是一个地址，并且
我们实际上引用了15的内容，

158
00:09:25,160 --> 00:09:26,160
是66。

159
00:09:26,160 --> 00:09:27,160
而不是数字15本身。

160
00:09:27,160 --> 00:09:28,160
指令完成，增加指令
指针。

161
00:09:28,160 --> 00:09:29,160
下一个地址包含83、AA和BB。

162
00:09:29,160 --> 00:09:30,160
CPU知道83表示比较。

163
00:09:30,160 --> 00:09:31,160
它比较了aa和bb中的值。

164
00:09:31,160 --> 00:09:32,160
现在它必须以某种方式记住结果
这一比较。

165
00:09:32,160 --> 00:09:33,160
所以我们再加一个小的存储空间
存储此结果。

166
00:09:33,160 --> 00:09:34,160
我们称之为零旗。

167
00:09:34,160 --> 00:09:35,160
你知道比较的聪明方法是什么吗？
两个数字？

168
00:09:35,160 --> 00:09:36,160
如果你从对方身上减去他们
结果是0，它们是相同的。

169
00:09:36,160 --> 00:09:37,160
如果结果不是零，它们是不同的。

170
00:09:37,160 --> 00:09:38,160
这就是CPU所做的。

171
00:09:38,160 --> 00:09:39,160
66-42是24，所以不是0。

172
00:09:39,160 --> 00:09:40,160
所以我们把零标志设为假。

173
00:09:40,160 --> 00:09:41,160
指令完成，下一个在地址4。

174
00:09:41,160 --> 00:09:42,160
CPU读取75和07。

175
00:09:42,160 --> 00:09:43,160
75代表跳跃，如果不相等。

176
00:09:43,160 --> 00:09:44,160
07是跳转到的地址。

177
00:09:44,160 --> 00:09:45,160
所以CPU检查零标志的状态。

178
00:09:45,160 --> 00:09:46,160
零标志设为假，所以
上一个比较不相等。

179
00:09:46,160 --> 00:09:47,160
这意味着它会跳到目的地07。

180
00:09:47,160 --> 00:09:48,160
跳跃很容易。

181
00:09:48,160 --> 00:09:49,160
CPU只是设置其指令指针
到07。

182
00:09:49,160 --> 00:09:50,160
好的，下一条指令在地址7。

183
00:09:50,160 --> 00:09:51,160
它的读数是E8和17。

184
00:09:51,160 --> 00:09:52,160
在这种情况下，e8代表打印文本。

185
00:09:52,160 --> 00:09:53,160
文本可以在地址17找到。

186
00:09:53,160 --> 00:09:54,160
但17不包含文本？

187
00:09:54,160 --> 00:09:55,160
对计算机来说，一切都是数字。

188
00:09:55,160 --> 00:09:56,160
就像CPU执行的那些指令一样，
它们只是数字。

189
00:09:56,160 --> 00:09:57,160
所以文本也是由数字组成的。

190
00:09:57,160 --> 00:09:58,160
记住我是如何在
以前的视频？

191
00:09:58,160 --> 00:09:59,160
现在是拉起ASCII人的时候了
再次翻页。

192
00:09:59,160 --> 00:10:00,160
所以在终端中输入'man ascii'。

193
00:10:00,160 --> 00:10:01,160
现在试着找到Hex 4e和4f。

194
00:10:01,160 --> 00:10:02,160
哈哈。好啊。

195
00:10:02,160 --> 00:10:03,160
所以他们代表"N"和"O"。

196
00:10:03,160 --> 00:10:04,160
这意味着计算机将打印"否"。

197
00:10:04,160 --> 00:10:05,160
所以看起来这段代码只是比较了
数字。

198
00:10:05,160 --> 00:10:06,160
那两个我就不去看这个案子了
数字是一样的，但你应该试试看

199
00:10:06,160 --> 00:10:07,160
你自己。

200
00:10:07,160 --> 00:10:08,160
太疯狂了，哈？

201
00:10:08,160 --> 00:10:09,160
CPU只是按顺序读取内存
做它读到的任何事。

202
00:10:09,160 --> 00:10:10,160
程序员可以制造出疯狂复杂的东西
就这样。

203
00:10:10,160 --> 00:10:11,160
现在让我把文字改一下
它更多地反映了我们如何写作的现实。

204
00:10:11,160 --> 00:10:12,160
汇编程序。

205
00:10:12,160 --> 00:10:13,160
基本上只是它的缩写。

206
00:10:13,160 --> 00:10:14,160
也不要混淆
参数。

207
00:10:14,160 --> 00:10:15,160
简单地把它想象成一个变量赋值
在编程中。

208
00:10:15,160 --> 00:10:16,160
这是一个非常简单的例子，但是
世界并没有多大不同。

209
00:10:16,160 --> 00:10:17,160
人们只是想出了更多的指示
那可能很有趣，写得很复杂

210
00:10:17,160 --> 00:10:18,160
解决难题的代码。

211
00:10:18,160 --> 00:10:18,170
但在它们的核心，它们是如此简单。

