1
00:00:10,440 --> 00:00:11,920
我写了一个 C 小程序。

2
00:00:11,920 --> 00:00:14,660
功能是一个简单的许可证检查。

3
00:00:14,660 --> 00:00:21,410
所以你可以执行它，可以提供一个 密钥 作为参数，它会被检查。

4
00:00:21,410 --> 00:00:25,440
我们的目标是破解这个程序，这样我们就不会必须使用有效的许可证密钥。

5
00:00:25,440 --> 00:00:29,330
我已经把这个可工作的程序，放在 GitHub 存储库。

6
00:00:29,330 --> 00:00:37,780
你可以从 github.com/liveoverflow/liveoverflow_youtube 或者先安装 git

7
00:00:37,780 --> 00:00:43,460
"sudo apt get install git"，并使用"git clone"获取整个存储库，

8
00:00:43,460 --> 00:00:44,600
获取地址就在 Github。

9
00:00:44,600 --> 00:00:47,850
我们也许会稍后谈谈 Git 是啥，。

10
00:00:47,850 --> 00:00:52,390
现在，只要知道，这个开发人员能够一起编程(同一程序)的

11
00:00:52,390 --> 00:00:53,650
合作方法

12
00:00:53,649 --> 00:00:57,159
和我会用它，来分享一些东西。

13
00:00:57,159 --> 00:01:01,489
要了解二进制汇编代码，我们会使用到一个叫做 gdb 的程序。

14
00:01:01,489 --> 00:01:04,259
GNU调试程序。

15
00:01:04,260 --> 00:01:07,330
所以，只要键入"gdb"和二进制文件的路径。

16
00:01:07,330 --> 00:01:10,550
还记得，每个C程序都有一个 main 函数吗？

17
00:01:10,550 --> 00:01:15,370
那么让我们输入"disassemble main"，它将显示在 main 函数中的

18
00:01:15,370 --> 00:01:17,280
所有汇编指令。

19
00:01:17,280 --> 00:01:19,970
但是，呃，你也看到它有多难看啦？

20
00:01:19,970 --> 00:01:23,360
这是非常糟糕的 at&amp;t 语法。

21
00:01:23,360 --> 00:01:26,830
所以，键入"set disassembly flavor intel"。

22
00:01:26,830 --> 00:01:29,400
请记住，您可以在此处使 tab补全 噢。

23
00:01:29,400 --> 00:01:33,850
现在再次"disassemble main"，现在它的可读性更高。

24
00:01:33,850 --> 00:01:34,850
好啊。

25
00:01:34,850 --> 00:01:35,850
所以。

26
00:01:35,850 --> 00:01:37,290
还是，看起来很复杂。

27
00:01:37,290 --> 00:01:39,480
但你可以忽略其中的大部分。

28
00:01:39,480 --> 00:01:41,270
首先，要对它有一个高层次的了解。

29
00:01:41,270 --> 00:01:45,800
一条接一条地查看指令，从初学者角度是不可取的。

30
00:01:45,800 --> 00:01:48,720
因为，这个 main 函数显然调用其他函数（绕晕你）。

31
00:01:48,720 --> 00:01:53,140
所以，只要画一张粗略的控制流程。

32
00:01:53,140 --> 00:01:56,210
我将用钢笔，实际打印出这个汇编代码。

33
00:01:56,210 --> 00:02:01,990
当我遇到更复杂的代码时，这正是我一开始会做的。

35
00:02:01,990 --> 00:02:08,200
记住要忽略大部分的事情，注意实际流向。

36
00:02:08,200 --> 00:02:12,410
所以在开始的时候，与数字 2 做了个比较。

37
00:02:12,409 --> 00:02:15,309
然后是"jump not equal"。

38
00:02:15,310 --> 00:02:23,730
所以，如果是 2，就要检查。

39
00:02:23,730 --> 00:02:27,300
如果是这种情况，我们将继续进行"printf"。

40
00:02:27,300 --> 00:02:31,980
我们知道，它是一个显示文本的函数。

41
00:02:31,980 --> 00:02:39,810
之后有个"strcmp"，如果你不了解这个函数，阅读它的手册页。

42
00:02:39,810 --> 00:02:49,510
"man 3 strcmp" - 所以，这函数是比较了两个字符串，如果相等就返回 0


44
00:02:49,510 --> 00:03:00,410
调用后，我们看到另一个"jump not equal"，所以，如果没有设置零标志，

45
00:03:00,410 --> 00:03:03,230
这里会是一个"puts" call。

46
00:03:03,230 --> 00:03:14,080
使用手册页了解它的作用，但它只是像 printf 一样打印文本。

47
00:03:14,080 --> 00:03:19,200
所以如果原始数据与数字 2 比较，结果不是真的，那么它会跳到

48
00:03:19,200 --> 00:03:23,790
地址 0x400623 ，偏移 main+102 。

49
00:03:23,790 --> 00:03:30,290
所以，在这种情况下，它会"puts"，打印其他文本和退出程序。

50
00:03:30,290 --> 00:03:34,630
我总是添加重要的地址，或者至少部分地址的记录，

51
00:03:34,630 --> 00:03:37,210
所以，我能知道运行到了哪里。

52
00:03:37,209 --> 00:03:40,799
这对你以后，一步一步走程序过程，有所帮助。

53
00:03:40,800 --> 00:03:42,550
现在，我们缺了一个分支(branch)。

54
00:03:42,550 --> 00:03:46,710
如果这个比较不正确，这个分支会跳到，偏移 main+90。

55
00:03:46,710 --> 00:03:52,390
也只是打印文本。

56
00:03:52,390 --> 00:03:57,910
仍缺了一些 jump ，但你可以添加它们，以得到一个很好的控制流程图。

57
00:03:57,910 --> 00:04:01,460
现在，让我们实际执行和一步步前进。

58
00:04:01,460 --> 00:04:05,780
然后你可以在你纸上画出，你有流程图的哪条路。

59
00:04:05,780 --> 00:04:11,800
为此，首先使用"break *main"，在 main 函数开头设个断点。

60
00:04:11,800 --> 00:04:16,220
设置好了断点，现在使用"run"启动程序。

61
00:04:16,220 --> 00:04:20,100
启动程序，我们到达了这个断点1的地址。

62
00:04:20,100 --> 00:04:24,880
断点是执行停滞的点。

63
00:04:24,879 --> 00:04:27,579
现在，用"info registers"看到寄存器。

64
00:04:27,580 --> 00:04:34,520
在这里你可以看到那个RIP，指令指针，指向 main 中的第一个地址。

65
00:04:34,520 --> 00:04:38,250
现在使用"si"，执行一条指令。

66
00:04:38,250 --> 00:04:39,990
现在，我们在 main 中的一个新地址。

67
00:04:39,990 --> 00:04:44,000
"info registers"和，您看到指令指针的更改。

68
00:04:44,000 --> 00:04:50,030
所以现在，只要一步一步调试，跟着控制图中的地址。

69
00:04:50,030 --> 00:04:54,780
但是使用"ni"，而不是"si"，因为"si"会进到函数的调用。

70
00:04:54,780 --> 00:05:07,500
但我们只想跨过这条 main 函数，而不是细看像"puts"这样的东西。

71
00:05:07,500 --> 00:05:10,300
好吧，我们跳的时候你注意到了吗？

72
00:05:10,300 --> 00:05:16,160
跳到 5d0，然后是下一条指令，是 623。

73
00:05:16,160 --> 00:05:24,840
所以我们跟着跳，这里意味着，与 2 相比，不为真。

74
00:05:24,840 --> 00:05:31,380
然后程序在 628 之后，打印用法信息，这是最后一个"puts"调用。

75
00:05:31,380 --> 00:05:35,350
所以我们可以写下，这个"puts"打印用法信息。

76
00:05:35,350 --> 00:05:41,560
现在很明显，我们并没有将密钥传递给此程序（才导致这分支的执行)。

77
00:05:41,560 --> 00:05:46,480
这意味着，检查是在有参数，我们提供了许可证密钥的情况下，才执行。

78
00:05:46,480 --> 00:05:55,250
让我们再次运行程序，但是这一次使用随机许可证密钥。

79
00:05:55,250 --> 00:05:57,160
好的，我们重新启动程序。

80
00:05:57,160 --> 00:06:00,500
现在，做同样的事情。

81
00:06:00,500 --> 00:06:02,170
"ni"，"ni"。

82
00:06:02,169 --> 00:06:06,129
现在我们又到 5d0 了，这次我们会跳同个点吗？

83
00:06:06,130 --> 00:06:07,870
没有！酷！

84
00:06:07,870 --> 00:06:11,510
所以，我们预计下一个分支是 609。

85
00:06:11,510 --> 00:06:15,880
再"ni"，看看会发生什么。

86
00:06:15,880 --> 00:06:17,710
啊！

87
00:06:17,710 --> 00:06:18,710
另一个打印文本。

88
00:06:18,710 --> 00:06:24,960
所以，这个"printf"，表示这个许可证密钥，将被检查。

89
00:06:24,960 --> 00:06:27,160
"ni"。

90
00:06:27,160 --> 00:06:28,790
现在，分支来了。

91
00:06:28,790 --> 00:06:34,080
好的，我们到了609，让我们看看，我们后来在哪里。

92
00:06:34,080 --> 00:06:36,000
617。

93
00:06:36,000 --> 00:06:40,500
所以，我们确实跳了，但也意味着，strcmp 失败了。

94
00:06:40,500 --> 00:06:45,060
当我们继续"ni"时，我们看到这是错误的。

95
00:06:45,060 --> 00:06:46,060
好吧。

96
00:06:46,060 --> 00:06:52,200
让我们在最后一个比较之前，设置一个断点，并再次运行程序。

97
00:06:52,200 --> 00:06:57,490
请记住，您在终端上简单地做标记，可以轻松地复制和粘贴值，

98
00:06:57,490 --> 00:06:59,790
然后，按你的鼠标滚轮。

99
00:06:59,790 --> 00:07:02,300
现在再"run"一次。

100
00:07:02,300 --> 00:07:03,970
断点 1。

101
00:07:03,970 --> 00:07:05,290
现在，"continue"。

102
00:07:05,290 --> 00:07:10,360
再次正常运行程序，直到我们到达下一个断点。

103
00:07:10,360 --> 00:07:14,320
现在，在我们执行"test eax, eax"之前，歇歇

104
00:07:14,320 --> 00:07:20,770
eax 只是指向 64位 rax寄存器的前32位。

105
00:07:20,770 --> 00:07:23,430
所以它的值是，十六进制 0xE。

106
00:07:23,430 --> 00:07:31,710
让我们把它设为 0，这表示"strcmp"是正确的，并返回

107
00:07:31,710 --> 00:07:33,890
一个 0。'set $eax=0'。

108
00:07:33,889 --> 00:07:37,459
(接着)"info registers"，你可以看到现在是 0。

109
00:07:37,460 --> 00:07:43,020
现在再次使用"ni"步进，并跟随你的控制流程路径。

110
00:07:43,020 --> 00:07:48,150
'Access Granted!'(已授予访问权限！)

111
00:07:48,150 --> 00:07:50,720
呀呀呀！

112
00:07:50,720 --> 00:07:53,830
我们避开了许可证检查！

113
00:07:53,830 --> 00:07:58,150
我觉得，很酷！

114
00:07:58,150 --> 00:08:04,050
你可以一直写你自己的小C程序，尝试让它更安全，以及

115
00:08:04,050 --> 00:08:05,810
之后你自己再破解一次。

116
00:08:05,810 --> 00:08:11,510
你会发现，想让程序无法破解，常规操作是不可能做到的。

117
00:08:11,510 --> 00:08:14,420
这种挑战被称为"crackme"。

118
00:08:14,419 --> 00:08:17,469
（那里）人们创造不得不破解的小程序。

119
00:08:17,470 --> 00:08:20,490
或者更频繁地创建，有效的 keygen。

120
00:08:20,490 --> 00:08:26,700
如果你认为这样的事情很有趣，查看 http://crackmes.de/。

121
00:08:26,699 --> 00:08:30,229
像我们刚才那样画出控制流程图，是非常有用。

122
00:08:30,230 --> 00:08:33,980
这就是为什么，会有些程序帮我们做这件事。

123
00:08:33,979 --> 00:08:39,799
这里有，三个关于特定控制图的不同例子。

124
00:08:39,800 --> 00:08:48,390
第一个是 hopperapp，第二个是 IDAPro，和最后一个来自 radare2。

125
00:08:48,390 --> 00:08:53,160
希望下次，我们用不同工具，能更多地探索

126
00:08:53,160 --> 00:08:54,160
这个二进制程序。

127
00:08:54,160 --> 00:08:55,160
让我们把CPU的基本概念，总结总结

128
00:08:55,160 --> 00:08:56,160
计算机有存储东西的不同内存 - 所以首先我们需要一些东西来储存

129
00:08:56,160 --> 00:08:57,160
机器代码。

130
00:08:57,160 --> 00:08:58,160
让我们拿个电子表格，把它想成为内存。

131
00:08:58,160 --> 00:08:59,160
您可以在它里面存储变量，和每个内存单元格都有一个地址，该地址值在左边。

132
00:08:59,160 --> 00:09:00,160


133
00:09:00,160 --> 00:09:01,160
我会用第二栏，写一些注释。

134
00:09:01,160 --> 00:09:02,160
正如，你所看到的，有一些十六进制数字，存储在此内存中。

135
00:09:02,160 --> 00:09:03,160
起初看起来很随机，但是，这就是我们的机器代码，很快你就会明白。

136
00:09:03,160 --> 00:09:04,160

137
00:09:04,160 --> 00:09:05,160
所以CPU需要有的第一件东东，就是保持 CPU 当前跟踪在内存的位置。

138
00:09:05,160 --> 00:09:06,160


139
00:09:06,160 --> 00:09:07,160
这意味着，要给我们的CPU，应该增加一点储藏区，称之为"指令指针"。

140
00:09:07,160 --> 00:09:08,160


141
00:09:08,160 --> 00:09:09,160
这个小储藏区，将包含CPU当前时刻，查看的内存地址

142
00:09:09,160 --> 00:09:10,160


143
00:09:10,160 --> 00:09:11,160
所以，很明显我们的程序是，从顶层开始的，所以地址是 1。

144
00:09:11,160 --> 00:09:12,160
现在，让我们启动CPU，它查看地址1，读到了 48, aa, 14。

145
00:09:12,160 --> 00:09:13,160
但是，这些数字是什么意思？

146
00:09:13,160 --> 00:09:14,160
CPU知道 48 意味着，它必须 move 周围的数据。

147
00:09:14,160 --> 00:09:15,160
aa 表示移动的目的地。14 是源。

148
00:09:15,160 --> 00:09:16,160
所以在地址14，我们可以看到数字42。

149
00:09:16,160 --> 00:09:17,160
目的地是，CPU内部的另一个小仓库单元。

150
00:09:17,160 --> 00:09:18,160
所以，CPU会把 42，move 到它的称为aa的小储存区。

151
00:09:18,160 --> 00:09:19,160
这个指令完成了，CPU 让指令指针 增加 1 。

152
00:09:19,160 --> 00:09:20,160
然后，重新开始。

153
00:09:20,160 --> 00:09:21,160
CPU读取它的指令指针，所指向地址的当前值。

154
00:09:21,160 --> 00:09:22,160
所以，它再次读取48，这意味着 move ，和这次移动的地址是

155
00:09:22,160 --> 00:09:23,160
15，其中的内容会移动到小储存区 bb。

156
00:09:23,160 --> 00:09:24,160
注意，我是在15左右，使用了括号。

157
00:09:24,160 --> 00:09:25,160
这表示15是一个地址，并且我们实际上，引用了 15(这个地址) 的内容，

158
00:09:25,160 --> 00:09:26,160
是数字66。

159
00:09:26,160 --> 00:09:27,160
而不是，数字15本身。

160
00:09:27,160 --> 00:09:28,160
指令完成，指令指针增加1。

161
00:09:28,160 --> 00:09:29,160
下一个地址，包含 83、aa 和 bb。

162
00:09:29,160 --> 00:09:30,160
CPU知道83，表示比较(COMPARE)。

163
00:09:30,160 --> 00:09:31,160
它比较了 aa和bb(地址) 中的值。

164
00:09:31,160 --> 00:09:32,160
现在，它必须以某种方式，记住这一比较结果。

165
00:09:32,160 --> 00:09:33,160
所以，我们再加一个小的存储空间，存储此结果。

166
00:09:33,160 --> 00:09:34,160
我们称之为零标志(Zero Flag)。

167
00:09:34,160 --> 00:09:35,160
你知道'比较'两个数字的聪明方法是什么吗？

168
00:09:35,160 --> 00:09:36,160
如果，你从对方身上减去他们，而结果是0，说明它们是相同的。

169
00:09:36,160 --> 00:09:37,160
如果，结果不是零，它们就是不同的。

170
00:09:37,160 --> 00:09:38,160
这就是 CPU所做的。

171
00:09:38,160 --> 00:09:39,160
66-42 是24，所以不是 0。

172
00:09:39,160 --> 00:09:40,160
所以我们把零标志，设为 false (假的)。

173
00:09:40,160 --> 00:09:41,160
指令完成，下一个在地址 4。

174
00:09:41,160 --> 00:09:42,160
CPU读取 75和07。

175
00:09:42,160 --> 00:09:43,160
75，代表如果不相等，就 jump 。

176
00:09:43,160 --> 00:09:44,160
07 是跳到的地址。

177
00:09:44,160 --> 00:09:45,160
所以CPU，检查零标志的状态。

178
00:09:45,160 --> 00:09:46,160
零标志设为假，所以上一个比较，不相等。

179
00:09:46,160 --> 00:09:47,160
这意味着它，会跳到目的地 07。

180
00:09:47,160 --> 00:09:48,160
简单的 jump 操作

181
00:09:48,160 --> 00:09:49,160
CPU只是设置，其指令指针，指向07。

182
00:09:49,160 --> 00:09:50,160
好的，下一条指令在地址 7。

183
00:09:50,160 --> 00:09:51,160
它的读数是 e8和17。

184
00:09:51,160 --> 00:09:52,160
在这种情况下，e8 代表打印文本。

185
00:09:52,160 --> 00:09:53,160
文本可以，在 地址17 找到。

186
00:09:53,160 --> 00:09:54,160
但 (地址)17 不包含文本？

187
00:09:54,160 --> 00:09:55,160
对计算机来说，一切都是数字。

188
00:09:55,160 --> 00:09:56,160
就像CPU执行的那些指令一样，它们只是数字。

189
00:09:56,160 --> 00:09:57,160
所以文本，也是由数字组成的。

190
00:09:57,160 --> 00:09:58,160
记得，我以前的视频，是怎样转换 ASCII 值的吗？

191
00:09:58,160 --> 00:09:59,160
现在是时候，再拿出 ASCII man 大全。

192
00:09:59,160 --> 00:10:00,160
所以在终端中，输入'man ascii'。

193
00:10:00,160 --> 00:10:01,160
现在试着找到(Hex) 4e 和4f 。

194
00:10:01,160 --> 00:10:02,160
哈..。ok。

195
00:10:02,160 --> 00:10:03,160
所以它们，代表"N"和"O"。

196
00:10:03,160 --> 00:10:04,160
这意味着计算机，将打印"NO"。

197
00:10:04,160 --> 00:10:05,160
所以看起来，这段代码只是比较了两个数字。

198
00:10:05,160 --> 00:10:07,160
这里我不会去看两个数字相等的情况，但你应该自己试试看

199
00:10:07,160 --> 00:10:07,160


200
00:10:07,160 --> 00:10:08,160
太疯狂了，对吧？

201
00:10:08,160 --> 00:10:09,160
CPU只是按顺序读取内存，和做它读到的任何事。

202
00:10:09,160 --> 00:10:10,160
程序员以此，可以制造出疯狂复杂的东西。

203
00:10:10,160 --> 00:10:11,160
现在让我把文字改一下，让它更好地反映，我们是如何编写汇编的现实。

204
00:10:11,160 --> 00:10:12,160


205
00:10:12,160 --> 00:10:13,160
基本上只是，它的缩写。

206
00:10:13,160 --> 00:10:14,160
也不要混淆参数的顺序。

207
00:10:14,160 --> 00:10:15,160
简单地把它，想象成在编程中，一个变量赋值。

208
00:10:15,160 --> 00:10:16,160
这是一个非常简单的例子，但是在现实的世界，并没有多大不同。

209
00:10:16,160 --> 00:10:18,160
(现实)人们只是更多的指令，这可能会很有趣，毕竟可以编写解决复杂难题的代码。

210
00:10:17,160 --> 00:10:18,160


211
00:10:18,160 --> 00:10:18,170
但它们的核心，是清晰的，与前面的例子一样简单。

