1
00:00:00,089 --> 00:00:05,279
让我们从当前Ubuntu上的漏洞攻击练习Protostar中查看格式级别4

2
00:00:05,280 --> 00:00:06,280
机器。

3
00:00:06,280 --> 00:00:10,640
这一次，我想，我们不是从一开始就建立起完整的开发，而是

4
00:00:10,640 --> 00:00:16,090
利用我们为32位Linux映像开发的旧漏洞，看看它是否仍然存在

5
00:00:16,090 --> 00:00:17,090
作品。

6
00:00:17,090 --> 00:00:29,940
可能不会，但是我们调试它，然后慢慢让它在这个64位的Ubuntu上工作。

7
00:00:29,939 --> 00:00:32,579
好的，这是源代码。

8
00:00:32,580 --> 00:00:39,860
堆栈上有一个512字节的大缓冲区，用于从标准输入读取数据。

9
00:00:39,860 --> 00:00:45,270
但它最多只能读取512个字节，所以没有缓冲区溢出。

10
00:00:45,270 --> 00:00:50,970
但是这个缓冲区直接传递给printf，所以我们有一个格式字符串漏洞。

11
00:00:50,970 --> 00:00:57,350
我们的目标是将代码执行重定向到hello（）函数。

12
00:00:57,350 --> 00:01:01,530
注意，在printf（）之后，我们如何找到一个出口？

13
00:01:01,530 --> 00:01:07,450
好吧，这是故意放在这里的，因为退出是libc的一部分，所以会有一个全球性的

14
00:01:07,450 --> 00:01:11,440
可以覆盖的偏移表条目。

15
00:01:11,439 --> 00:01:17,179
然后当我们在这里调用exit时，将执行覆盖函数。

16
00:01:17,179 --> 00:01:21,839
所以这实际上是一个非常直接的格式字符串漏洞。

17
00:01:21,840 --> 00:01:26,070
只需在出口处写上“你好”的地址就可以了。

18
00:01:26,069 --> 00:01:32,829
hello（）和got表有固定的地址，不受aslr的影响。

19
00:01:32,829 --> 00:01:37,259
至少在这个Ubuntu版本上，因为有默认的编译器选项。

20
00:01:37,259 --> 00:01:43,979
我收到了几条评论，在他们的系统中，他们默认为pie。

21
00:01:43,979 --> 00:01:49,329
所以这里的got地址和函数会受到aslr的影响，然后我不

22
00:01:49,329 --> 00:01:53,039
认为这些简单的案例是可以利用的。

23
00:01:53,040 --> 00:01:57,880
我们需要一个更复杂的例子，更多的交互，在这里

24
00:01:57,880 --> 00:02:01,140
首先可以泄漏值以击败ASLR。

25
00:02:01,139 --> 00:02:03,059
但随着时间的推移，我们会慢慢地到达那里。

26
00:02:03,060 --> 00:02:06,270
我们不要太急于这些话题。

27
00:02:06,270 --> 00:02:11,560
所以我们现在在Ubuntu机器上编译这个代码，然后得到旧的漏洞代码。

28
00:02:11,560 --> 00:02:14,380
伙计，这是第0x13集…

29
00:02:14,379 --> 00:02:20,319
2016年8月……天哪，那是很久以前的事了。

30
00:02:20,319 --> 00:02:27,249
当我开始的时候，我想我会很快有一个关于所有基础知识的完整系列…

31
00:02:27,250 --> 00:02:30,480
我们还没有到达ROP和ASLR。嗯…

32
00:02:30,480 --> 00:02:31,480
该死的。

33
00:02:31,480 --> 00:02:32,480
不管怎样。

34
00:02:32,480 --> 00:02:34,890
让我们复制那个python代码。

35
00:02:34,890 --> 00:02:35,950
看起来不错。

36
00:02:35,950 --> 00:02:42,010
现在我把它写进一个文件--exp，然后我们可以用format4启动gdb并执行

37
00:02:42,010 --> 00:02:43,100
它。

38
00:02:43,099 --> 00:02:48,159
运行，然后我们将exp文件作为输入发送到程序。

39
00:02:48,159 --> 00:02:54,479
嗯，我们打印了很多字符，看起来不错，但我们有一个segfault。

40
00:02:54,480 --> 00:03:02,130
我们正在尝试将R150x84B4中的值写入rax中的地址。

41
00:03:02,129 --> 00:03:04,529
Rax显然是错的。

42
00:03:04,530 --> 00:03:06,470
0x58是X.

43
00:03:06,469 --> 00:03:10,599
所以这是漏洞的%n部分。

44
00:03:10,599 --> 00:03:14,869
0x84B4是已经打印的字符数，即这里的所有空格，

45
00:03:14,870 --> 00:03:21,440
它试图写入第四个值，结果不再是地址了。

46
00:03:21,440 --> 00:03:23,470
所以有两件事。

47
00:03:23,469 --> 00:03:29,029
首先，显然我们用%n编写的字符数量是错误的，我们

48
00:03:29,030 --> 00:03:31,790
还不知道我们要写什么。

49
00:03:31,790 --> 00:03:36,960
最重要的是，我们并没有按照我们在该漏洞中指定的地址写信。

50
00:03:36,959 --> 00:03:41,009
现在，我们使用格式字符串偏移量填充。

51
00:03:41,010 --> 00:03:45,550
好的，那么让我们利用这个机会，首先得到正确的地址。

52
00:03:45,549 --> 00:03:50,899
我们需要出口入口的地址，我们通过查看它的调用位置来实现这一点。

53
00:03:50,900 --> 00:03:56,260
然后我们简单地分解几个跳转到got入口的指令，这就是plt

54
00:03:56,260 --> 00:03:58,010
程序联动表。

55
00:03:58,010 --> 00:04:01,300
这里是出口入口。

56
00:04:01,299 --> 00:04:05,889
你可以看到它会跳到写在那里的任何地址，所以我们必须覆盖

57
00:04:05,889 --> 00:04:08,519
这个地址是你好。

58
00:04:08,519 --> 00:04:10,899
这是你好的地址。

59
00:04:10,900 --> 00:04:16,890
您可以再次看到，只有当前出口的最后2个字节获得了入口和我们想要的

60
00:04:16,889 --> 00:04:18,919
你好地址不一样。

61
00:04:18,919 --> 00:04:23,869
这意味着我们只需要覆盖最后两个字节。

62
00:04:23,870 --> 00:04:28,450
所以让我们把这两个新地址放在我们的漏洞代码中，我们也可以扔掉

63
00:04:28,450 --> 00:04:29,560
旧格式修改器。

64
00:04:29,560 --> 00:04:30,700
我们打印的字符数量错误，偏移量也不再匹配。

65
00:04:30,699 --> 00:04:35,899
相反，我们只需添加一组%p，以找到新的堆栈偏移量。

66
00:04:35,900 --> 00:04:42,450
所以我们再次将其写入一个文件，启动gdb并将该文件作为输入导入。

67
00:04:42,450 --> 00:04:45,920
嗯…没有实际输出？

68
00:04:45,920 --> 00:04:47,580
就像一个@和一个倒勾？

69
00:04:47,580 --> 00:04:51,830
我们用%p泄露的地址在哪里？

70
00:04:51,830 --> 00:04:56,300
这些小事情真的很让人沮丧

71
00:04:56,300 --> 00:04:58,750
我准备这集的时候。

72
00:04:58,750 --> 00:05:01,860
我想弄明白到底发生了什么，真是疯了。

73
00:05:01,860 --> 00:05:07,330
我只是一遍又一遍地执行它，希望计算机能做些别的事情。

74
00:05:07,330 --> 00:05:13,390
我正在调试它，使其在printf之前中断，并看到我的输入被传递到printf。

75
00:05:13,389 --> 00:05:14,839
但没有输出。

76
00:05:14,840 --> 00:05:18,170
该死的Ghnana工作！

77
00:05:18,169 --> 00:05:19,209
但不会。

78
00:05:19,210 --> 00:05:23,320
如果它没有做我想做的，我犯了一个错误。

79
00:05:23,319 --> 00:05:24,489
我就是问题所在。

80
00:05:24,490 --> 00:05:30,860
我需要冷静下来，退后一步，想办法弄清楚我的蠢货。

81
00:05:30,860 --> 00:05:32,230
错误。

82
00:05:32,229 --> 00:05:35,229
那么我们得到的输出究竟是什么呢？

83
00:05:35,229 --> 00:05:41,879
我将该漏洞输出通过管道传输到hexdump，并看到它在三个字符后停止。

84
00:05:41,879 --> 00:05:44,699
这是我们的地址，但被切断了。

85
00:05:44,699 --> 00:05:48,829
缺少其他地址和格式字符串。

86
00:05:48,830 --> 00:05:55,800
但当我也做了利用的六角体转储时，我注意到了明显的错误。

87
00:05:55,800 --> 00:05:58,300
地址的字节为空。

88
00:05:58,300 --> 00:06:00,950
printf以空字节停止。

89
00:06:00,949 --> 00:06:01,949
字符串以空结尾。

90
00:06:01,949 --> 00:06:04,699
天哪，我太笨了。

91
00:06:04,699 --> 00:06:10,679
这不是32位攻击的问题，因为我们的地址也有4个字节

92
00:06:10,680 --> 00:06:13,370
因此没有空字节。

93
00:06:13,370 --> 00:06:16,380
现在在64位上，默认地址只有3个字节。

94
00:06:16,379 --> 00:06:22,109
所以我们的下一步是-我们在利用结束时移动地址。

95
00:06:22,110 --> 00:06:25,100
它们仍然被放置在具有空字节的堆栈上。

96
00:06:25,099 --> 00:06:27,159
fgets将读取空字节。

97
00:06:27,159 --> 00:06:31,379
只有printf格式漏洞部分不能有空字节。

98
00:06:31,379 --> 00:06:37,139
当我们把它移到末尾时，我们希望它在一个固定的位置，所以我们将填充添加到

99
00:06:37,140 --> 00:06:41,720
我们的格式字符串，然后确保在

100
00:06:41,720 --> 00:06:42,720
结束。

101
00:06:42,720 --> 00:06:48,220
我们是64位的，所以我们有2乘以8字节，所以我们需要16个字符。

102
00:06:48,220 --> 00:06:49,470
看起来不错。

103
00:06:49,470 --> 00:06:53,120
所以我们试着把这个输入到格式4中。

104
00:06:53,120 --> 00:06:54,910
看起来不错，我们现在打印值。

105
00:06:54,909 --> 00:06:56,519
但我找不到我们的地址。

106
00:06:56,520 --> 00:06:59,920
让我们实际上有更多的%p。

107
00:06:59,919 --> 00:07:04,139
100块怎么样，很容易放在512字节里。

108
00:07:04,139 --> 00:07:06,949
好的，他们在哪里？

109
00:07:06,950 --> 00:07:08,610
他们在这儿？

110
00:07:08,610 --> 00:07:10,070
但看起来不太好。

111
00:07:10,069 --> 00:07:13,639
它们应该是两个单独的值。

112
00:07:13,639 --> 00:07:15,289
但很清楚发生了什么。

113
00:07:15,289 --> 00:07:19,709
我们忘了将地址编码为64位。

114
00:07:19,710 --> 00:07:26,240
struct pack i将整数打包为4个字节，但我们希望它打包为8个字节。

115
00:07:26,240 --> 00:07:28,470
让我们再试一次。

116
00:07:28,470 --> 00:07:29,470
它们在这里。

117
00:07:29,470 --> 00:07:30,830
这个看起来不错。

118
00:07:30,830 --> 00:07:32,250
现在我们来找出它们的偏移量。

119
00:07:32,250 --> 00:07:34,570
我们可以数数到底有多少。

120
00:07:34,569 --> 00:07:36,389
然后从100中减去。

121
00:07:36,389 --> 00:07:40,509
所以，在第68行，我们应该找到地址。

122
00:07:40,510 --> 00:07:41,510
是的，的确如此。

123
00:07:41,510 --> 00:07:42,960
就在那里。

124
00:07:42,960 --> 00:07:48,160
所以现在，我们只需要打印正确数量的字符就可以写入这两个字节。

125
00:07:48,159 --> 00:07:52,019
实际上，我们不需要两次写作，我们应该能够一次完成。

126
00:07:52,020 --> 00:07:57,000
所以我们添加了另一个格式字符串，填充了我们想要写入的字符数。

127
00:07:57,000 --> 00:08:02,350
那就是0x676，减去之前我们已经打印的字符。

128
00:08:02,349 --> 00:08:03,419
所以基本上是负8。

129
00:08:03,419 --> 00:08:07,999
然后我们还应该删除%n前面的空格，这将是另一个字符

130
00:08:08,000 --> 00:08:09,000
印刷的。

131
00:08:09,000 --> 00:08:10,000
所以现在应该可以了，对吧？

132
00:08:10,000 --> 00:08:12,060
让我们将%p更改为%n并尝试它！

133
00:08:12,060 --> 00:08:13,300
分段错误。

134
00:08:13,300 --> 00:08:14,340
该死的…

135
00:08:14,340 --> 00:08:18,940
所以当我把这些都录下来的时候，我真的觉得应该马上就好了。

136
00:08:18,940 --> 00:08:21,210
但后来我发现了分割错误。

137
00:08:21,210 --> 00:08:22,350
我真的很困惑。

138
00:08:22,349 --> 00:08:25,299
这也是我可能会困扰的事情。

139
00:08:25,300 --> 00:08:27,320
为什么会这样？

140
00:08:27,319 --> 00:08:31,519
但在我停止录音并开始写下我刚刚做的事情之后，

141
00:08:31,520 --> 00:08:32,520
剧本。

142
00:08:32,520 --> 00:08:33,970
我意识到了我的错误。

143
00:08:33,970 --> 00:08:35,730
当我写下%n

144
00:08:35,730 --> 00:08:39,570
我意识到我写了一个整数。

145
00:08:39,570 --> 00:08:44,970
但我只想写两个字节，所以我需要%hn。

146
00:08:44,970 --> 00:08:47,000
我们应该能够用gdb验证这一点。

147
00:08:47,000 --> 00:08:48,480
我们来看看。

148
00:08:48,480 --> 00:08:49,900
是的，在那里。

149
00:08:49,900 --> 00:08:52,460
地址0x676处的SegFault。

150
00:08:52,460 --> 00:08:57,320
我们写了一个整数，所以我们重写了已经存储的更高字节。

151
00:08:57,320 --> 00:08:59,130
在比赛中。

152
00:08:59,130 --> 00:09:01,520
所以我们把它改成%hn。

153
00:09:01,520 --> 00:09:03,890
写半个字或其他什么意思。

154
00:09:03,890 --> 00:09:05,780
它写两个字节。

155
00:09:05,780 --> 00:09:09,450
那很管用！代码执行重定向！你赢了

156
00:09:09,450 --> 00:09:13,300
您看到这个漏洞不同于原来的32位版本。

157
00:09:13,300 --> 00:09:20,210
它需要一些改变，但也有点相同。

158
00:09:20,210 --> 00:09:22,350
对现代系统来说绝对不是一个艰难的挑战。

159
00:09:22,350 --> 00:09:25,130
只要你不用馅饼来编译它。

