1
00:00:00,089 --> 00:00:05,279
让我们来看看格式级别4利用当前Ubuntu上的练习原型星

2
00:00:05,280 --> 00:00:06,280
机器。

3
00:00:06,280 --> 00:00:10,640
这一次我想的不是建筑从一开始就完全利用了，我们

4
00:00:10,640 --> 00:00:16,090
利用我们为之开发的旧技术32位Linux映像，看看它是否仍然存在

5
00:00:16,090 --> 00:00:17,090
作品。

6
00:00:17,090 --> 00:00:29,940
可能不会，但是我们调试它，然后慢慢让它在这个64位的Ubuntu上工作。

7
00:00:29,939 --> 00:00:32,579
好的，这是源代码。

8
00:00:32,580 --> 00:00:39,860
堆栈上有一个512字节的大缓冲区，用于从标准输入中读取数据。

9
00:00:39,860 --> 00:00:45,270
但它最多只能读取512个字节，所以没有缓冲区溢出。

10
00:00:45,270 --> 00:00:50,970
但是这个缓冲区直接传递给printf，所以我们有一个格式字符串漏洞。

11
00:00:50,970 --> 00:00:57,350
我们的目标是重定向代码执行到hello（）函数。

12
00:00:57,350 --> 00:01:01,530
注意，在printf（）之后出口？

13
00:01:01,530 --> 00:01:07,450
是故意放在这里的，因为退出是libc的一部分，因此将有一个全局

14
00:01:07,450 --> 00:01:11,440
可以覆盖的偏移表条目。

15
00:01:11,439 --> 00:01:17,179
然后当我们在这里调用exit时，我们的覆盖将改为执行函数。

16
00:01:17,179 --> 00:01:21,839
所以这实际上是一个非常直接的过程格式字符串漏洞。

17
00:01:21,840 --> 00:01:26,070
把地址写在出口你好，你完了。

18
00:01:26,069 --> 00:01:32,829
hello（）和got表有固定的地址不受ASLR影响。

19
00:01:32,829 --> 00:01:37,259
至少在这个Ubuntu版本上，因为默认编译器选项。

20
00:01:37,259 --> 00:01:43,979
我收到了好几条评论在他们的系统中，他们默认为pie。

21
00:01:43,979 --> 00:01:49,329
所以这里有got地址和函数会受到ASLR的影响，但我不会

22
00:01:49,329 --> 00:01:53,039
认为这些简单的案例是可以利用的。

23
00:01:53,040 --> 00:01:57,880
我们需要更复杂一点例子，更多的互动，我们

24
00:01:57,880 --> 00:02:01,140
首先可以泄漏值以击败ASLR。

25
00:02:01,139 --> 00:02:03,059
但随着时间的推移，我们会慢慢地到达那里。

26
00:02:03,060 --> 00:02:06,270
我们不要太急于这些话题。

27
00:02:06,270 --> 00:02:11,560
所以我们现在在Ubuntu机器上编译这个我们得到了旧的漏洞代码。

28
00:02:11,560 --> 00:02:14,380
伙计，这是第0x13集…

29
00:02:14,379 --> 00:02:20,319
2016年8月……天呐，好久不见了以前。

30
00:02:20,319 --> 00:02:27,249
当我开始的时候，我想我会快速完成所有基础知识的系列…

31
00:02:27,250 --> 00:02:30,480
我们还没有到达ROP和ASLR。嗯…

32
00:02:30,480 --> 00:02:31,480
该死的。

33
00:02:31,480 --> 00:02:32,480
不管怎样。

34
00:02:32,480 --> 00:02:34,890
让我们复制那个python代码。

35
00:02:34,890 --> 00:02:35,950
看起来不错。

36
00:02:35,950 --> 00:02:42,010
现在我把它写进一个文件--exp，然后我们可以用format4启动gdb并执行

37
00:02:42,010 --> 00:02:43,100
它。

38
00:02:43,099 --> 00:02:48,159
运行，然后我们将exp文件中的管道作为输入对程序。

39
00:02:48,159 --> 00:02:54,479
呃，我们印了很多字，看起来很好，但我们有点问题。

40
00:02:54,480 --> 00:03:02,130
我们正试图把这个值写在r15中，0x84B4到RAX中的地址。

41
00:03:02,129 --> 00:03:04,529
Rax显然是错的。

42
00:03:04,530 --> 00:03:06,470
0x58是X.

43
00:03:06,469 --> 00:03:10,599
所以这是漏洞的%n部分。

44
00:03:10,599 --> 00:03:14,869
0x84B4是已经存在的字符数印刷体，这就是这里所有的空白，

45
00:03:14,870 --> 00:03:21,440
它试图写入第四个值，原来不再是地址了。

46
00:03:21,440 --> 00:03:23,470
所以有两件事。

47
00:03:23,469 --> 00:03:29,029
首先，显然是字符的数量我们用%n写的是错误的，我们

48
00:03:29,030 --> 00:03:31,790
还不知道我们要写什么。

49
00:03:31,790 --> 00:03:36,960
最重要的是，我们没有写信给我们在漏洞中指定的地址。

50
00:03:36,959 --> 00:03:41,009
现在使用格式字符串偏移量衬垫。

51
00:03:41,010 --> 00:03:45,550
好吧，让我们利用这个机会首先是正确的地址。

52
00:03:45,549 --> 00:03:50,899
我们需要出入口的地址，我们通过寻找它的名字来做到这一点。

53
00:03:50,900 --> 00:03:56,260
然后我们简单地把这几个指令拆开跳到入口，那是PLT

54
00:03:56,260 --> 00:03:58,010
程序联动表。

55
00:03:58,010 --> 00:04:01,300
这里是出口入口。

56
00:04:01,299 --> 00:04:05,889
你可以看到它会跳到任何地址写在那里，所以我们必须重写

57
00:04:05,889 --> 00:04:08,519
这个地址是你好。

58
00:04:08,519 --> 00:04:10,899
这是你好的地址。

59
00:04:10,900 --> 00:04:16,890
您可以再次看到，只有最后2个字节当前出口的入口和我们想要的

60
00:04:16,889 --> 00:04:18,919
你好地址不一样。

61
00:04:18,919 --> 00:04:23,869
这意味着我们只需要覆盖那些最后两个字节。

62
00:04:23,870 --> 00:04:28,450
那么让我们把这两个新地址放在我们的漏洞代码，我们也可以扔掉

63
00:04:28,450 --> 00:04:29,560
旧格式修改器。

64
00:04:29,560 --> 00:04:30,700
我们打印的字符数错误偏移量也不再匹配了。

65
00:04:30,699 --> 00:04:35,899
相反，我们只是添加了一堆%p找到新的堆栈偏移量。

66
00:04:35,900 --> 00:04:42,450
所以我们再把它写进一个文件，启动gdb并将文件作为输入导入。

67
00:04:42,450 --> 00:04:45,920
嗯…没有实际输出？

68
00:04:45,920 --> 00:04:47,580
就像一个@和一个倒勾？

69
00:04:47,580 --> 00:04:51,830
我们用%p泄露的地址在哪里？

70
00:04:51,830 --> 00:04:56,300
这些小东西真的是令人沮丧，而这实际上发生在

71
00:04:56,300 --> 00:04:58,750
我准备这集的时候。

72
00:04:58,750 --> 00:05:01,860
我疯狂地想弄明白见鬼的事情正在发生。

73
00:05:01,860 --> 00:05:07,330
我只是一遍又一遍地执行它，希望电脑能做点别的。

74
00:05:07,330 --> 00:05:13,390
我正在调试它以便在打印前中断并确保我的输入被传递到printf。

75
00:05:13,389 --> 00:05:14,839
但没有输出。

76
00:05:14,840 --> 00:05:18,170
该死的Ghnana工作！

77
00:05:18,169 --> 00:05:19,209
但不会。

78
00:05:19,210 --> 00:05:23,320
如果它不做我想做的，我犯了个错误。

79
00:05:23,319 --> 00:05:24,489
我就是问题所在。

80
00:05:24,490 --> 00:05:30,860
我需要冷静，后退一步想办法弄清楚我的蠢货

81
00:05:30,860 --> 00:05:32,230
错误。

82
00:05:32,229 --> 00:05:35,229
那么我们得到的输出究竟是什么呢？

83
00:05:35,229 --> 00:05:41,879
我把开发输出传输到hexdump，然后注意三个字符后停止。

84
00:05:41,879 --> 00:05:44,699
这是我们的地址，但被切断了。

85
00:05:44,699 --> 00:05:48,829
另一个地址和格式字符串是失踪。

86
00:05:48,830 --> 00:05:55,800
但当我那时也做了我发现了明显的错误。

87
00:05:55,800 --> 00:05:58,300
地址的字节为空。

88
00:05:58,300 --> 00:06:00,950
printf以空字节停止。

89
00:06:00,949 --> 00:06:01,949
字符串以空结尾。

90
00:06:01,949 --> 00:06:04,699
天哪，我太笨了。

91
00:06:04,699 --> 00:06:10,679
这不是32位攻击的问题，因为我们的地址也有4个字节

92
00:06:10,680 --> 00:06:13,370
因此没有空字节。

93
00:06:13,370 --> 00:06:16,380
现在在64位上，默认地址只有3个字节。

94
00:06:16,379 --> 00:06:22,109
所以我们的下一步是-我们移动地址在我们剥削的最后。

95
00:06:22,110 --> 00:06:25,100
它们仍然被放在堆栈上零字节。

96
00:06:25,099 --> 00:06:27,159
fgets将读取空字节。

97
00:06:27,159 --> 00:06:31,379
只是printf格式漏洞部分不能有空字节。

98
00:06:31,379 --> 00:06:37,139
当我们把它移到尽头时，我们希望它是在固定位置，因此我们将填充添加到

99
00:06:37,140 --> 00:06:41,720
我们的格式字符串，然后确保我们离开两个地址在

100
00:06:41,720 --> 00:06:42,720
结束。

101
00:06:42,720 --> 00:06:48,220
我们是64位的，所以我们有2乘以8字节，所以我们需要16个字符。

102
00:06:48,220 --> 00:06:49,470
看起来不错。

103
00:06:49,470 --> 00:06:53,120
所以我们试着把它输入格式4。

104
00:06:53,120 --> 00:06:54,910
看起来不错，我们现在打印值。

105
00:06:54,909 --> 00:06:56,519
但我找不到我们的地址。

106
00:06:56,520 --> 00:06:59,920
让我们实际拥有更多的%p。

107
00:06:59,919 --> 00:07:04,139
100块怎么样，很容易放在512块里字节。

108
00:07:04,139 --> 00:07:06,949
好的，他们在哪里？

109
00:07:06,950 --> 00:07:08,610
他们在这儿？

110
00:07:08,610 --> 00:07:10,070
但看起来不太好。

111
00:07:10,069 --> 00:07:13,639
它们应该是两个单独的值。

112
00:07:13,639 --> 00:07:15,289
但很清楚发生了什么。

113
00:07:15,289 --> 00:07:19,709
我们忘了对地址进行编码64位。

114
00:07:19,710 --> 00:07:26,240
struct pack i将整数打包为4个字节，但我们要用8个字节打包。

115
00:07:26,240 --> 00:07:28,470
让我们再试一次。

116
00:07:28,470 --> 00:07:29,470
它们在这里。

117
00:07:29,470 --> 00:07:30,830
这看起来不错。

118
00:07:30,830 --> 00:07:32,250
现在我们来找出它们的偏移量。

119
00:07:32,250 --> 00:07:34,570
我们可以算到最后多少。

120
00:07:34,569 --> 00:07:36,389
然后从100中减去。

121
00:07:36,389 --> 00:07:40,509
所以，在第68行，我们应该找到地址。

122
00:07:40,510 --> 00:07:41,510
是的，的确如此。

123
00:07:41,510 --> 00:07:42,960
就在那里。

124
00:07:42,960 --> 00:07:48,160
所以现在，我们只需要打印正确的写入两个字节的字符数。

125
00:07:48,159 --> 00:07:52,019
实际上，我们不需要两次写作，我们应该能够一次完成。

126
00:07:52,020 --> 00:07:57,000
所以我们添加另一个带填充的格式字符串我们要写的字符数。

127
00:07:57,000 --> 00:08:02,350
那就是0x676，减去字符在那之前我们已经印好了。

128
00:08:02,349 --> 00:08:03,419
所以基本上是负8。

129
00:08:03,419 --> 00:08:07,999
然后我们还应该删除空格在%n之前，这将是另一个字符

130
00:08:08,000 --> 00:08:09,000
印刷的。

131
00:08:09,000 --> 00:08:10,000
所以现在应该可以了，对吧？

132
00:08:10,000 --> 00:08:12,060
让我们将%p更改为%n并尝试它！

133
00:08:12,060 --> 00:08:13,300
分段错误。

134
00:08:13,300 --> 00:08:14,340
该死的…

135
00:08:14,340 --> 00:08:18,940
所以当我把这些都录下来的时候，我真的我觉得应该马上就行。

136
00:08:18,940 --> 00:08:21,210
但后来我发现了分割错误。

137
00:08:21,210 --> 00:08:22,350
我真的很困惑。

138
00:08:22,349 --> 00:08:25,299
这也是我能做的迷恋

139
00:08:25,300 --> 00:08:27,320
为什么会这样？

140
00:08:27,319 --> 00:08:31,519
但在我停止录音后开始写下我刚做的事

141
00:08:31,520 --> 00:08:32,520
剧本。

142
00:08:32,520 --> 00:08:33,970
我意识到了我的错误。

143
00:08:33,970 --> 00:08:35,730
当我写下%n

144
00:08:35,730 --> 00:08:39,570
我意识到我写了一个整数。

145
00:08:39,570 --> 00:08:44,970
但我只想写两个字节，所以我需要%hn。

146
00:08:44,970 --> 00:08:47,000
我们应该能够用gdb验证这一点。

147
00:08:47,000 --> 00:08:48,480
我们来看看。

148
00:08:48,480 --> 00:08:49,900
是的，在那里。

149
00:08:49,900 --> 00:08:52,460
地址0x676处的SegFault。

150
00:08:52,460 --> 00:08:57,320
我们写了一个整数，所以我们重写了已存储的较高字节数

151
00:08:57,320 --> 00:08:59,130
在比赛中。

152
00:08:59,130 --> 00:09:01,520
所以我们把它改成%hn。

153
00:09:01,520 --> 00:09:03,890
写半个字或其他意思。

154
00:09:03,890 --> 00:09:05,780
它写两个字节。

155
00:09:05,780 --> 00:09:09,450
那很管用！代码执行重定向！你赢了

156
00:09:09,450 --> 00:09:13,300
你看这个漏洞不同于原来的32位版本。

157
00:09:13,300 --> 00:09:20,210
它需要相当多的变化，但它也还是一样的。

158
00:09:20,210 --> 00:09:22,350
对现代人来说绝对不是一个艰难的挑战系统。

159
00:09:22,350 --> 00:09:25,130
只要你不用馅饼来编译它。

