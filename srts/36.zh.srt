1
00:00:00,149 --> 00:00:05,679
此视频是第三个也是最后一个视频，我们现在将在其中完成堆栈级别的漏洞攻击

2
00:00:05,680 --> 00:00:10,050
0 from protostar, which we have compiled on a modern system.

3
00:00:10,049 --> 00:00:14,769
在第一部分中，我们大致了解了编译代码时所做的更改。

4
00:00:14,769 --> 00:00:18,389
with a more modern compiler and looked more closely at the stack cookie.

5
00:00:18,390 --> 00:00:24,390
在第二部分中，我们暂时忽略了cookie，并确定了更多的利用

6
00:00:24,390 --> 00:00:27,800
mitigations and developed a bypass for them.

7
00:00:27,800 --> 00:00:30,500
So only one thing is left.

8
00:00:30,499 --> 00:00:39,839
Finally defeating the stack cookie.

9
00:00:39,840 --> 00:00:44,290
就像我们在第一个视频中提到的，如果二进制文件

10
00:00:44,290 --> 00:00:46,460
is a 32 bit binary.

11
00:00:46,460 --> 00:00:49,680
There are around 16 million possible values for a stack cookie.

12
00:00:49,680 --> 00:00:55,230
没那么多，但1600万次处决也许是你开始想要的一个数字

13
00:00:55,230 --> 00:00:56,780
optimize a bit.

14
00:00:56,780 --> 00:01:01,440
虽然我不是超级快速计算方面的专家，但我决定我不想写潜在的

15
00:01:01,440 --> 00:01:04,580
slow python script, but write some C code.

16
00:01:04,580 --> 00:01:09,250
但就像我说的，我不是最快速度的专家，我怀疑

17
00:01:09,250 --> 00:01:13,860
也许这里的瓶颈不是一个缓慢的脚本，而是需要做很多工作的内核

18
00:01:13,860 --> 00:01:16,860
of stuff to execute the program over and over again.

19
00:01:16,860 --> 00:01:21,670
So maybe it’s unnecessary to write C code and maybe my C code is very bad too.

20
00:01:21,670 --> 00:01:25,940
但我只是想说，决定什么是最好的并不总是容易的。

21
00:01:25,940 --> 00:01:27,050
approach.

22
00:01:27,050 --> 00:01:30,170
Now that we said that, let’s try to approach this step by step.

23
00:01:30,170 --> 00:01:31,170
First.

24
00:01:31,170 --> 00:01:36,870
How do you execute a program in C. Well, there is a system call for it called exec.

25
00:01:36,870 --> 00:01:41,320
但通常我们从不直接调用系统调用，而是使用提供的包装函数

26
00:01:41,320 --> 00:01:43,420
by something like libc.

27
00:01:43,420 --> 00:01:47,530
所以libc提供了几个不同版本的exec，但它们最终都使用

28
00:01:47,530 --> 00:01:50,060
same exec syscall underneath.

29
00:01:50,060 --> 00:01:51,250
在手册页上写着：

30
00:01:51,250 --> 00:01:56,500
“exec（）函数系列将当前进程图像替换为新进程

31
00:01:56,500 --> 00:01:57,500
形象。”

32
00:01:57,500 --> 00:02:01,880
我想如果你以前从来没有想过程序是如何执行的，这听起来真的

33
00:02:01,880 --> 00:02:02,880
weird.

34
00:02:02,880 --> 00:02:06,470
“为什么要替换当前进程而不仅仅是执行它？

35
00:02:06,470 --> 00:02:07,870
That’s so weird”.

36
00:02:07,869 --> 00:02:11,789
Well that’s just how it works, that’s the execution model of Linux.

37
00:02:11,790 --> 00:02:16,540
因此，在我们的案例中，我们不只是想执行并替换我们的程序，而是

38
00:02:16,540 --> 00:02:21,860
want to execute the stack0 binary as a new process over and over again.

39
00:02:21,859 --> 00:02:27,329
To spawn a new process we have to fork the process before we exec.

40
00:02:27,329 --> 00:02:31,709
fork() creates a new process by duplicating the calling process.

41
00:02:31,709 --> 00:02:35,519
The new process is referred to as the child process.

42
00:02:35,519 --> 00:02:40,379
The calling process is referred to as the parent process.

43
00:02:40,379 --> 00:02:44,899
还有一个有趣的地方是：C库函数和

44
00:02:44,900 --> 00:02:46,230
the actual kernel.

45
00:02:46,230 --> 00:02:51,950
因为版本2.3.3，而不是调用内核的fork（）系统调用，所以glibc

46
00:02:51,950 --> 00:02:56,750
fork（）包装器[…]使用提供与

47
00:02:56,750 --> 00:02:59,100
traditional system call.

48
00:02:59,099 --> 00:03:03,109
因此，要反复执行这个过程，您要做的是：

49
00:03:03,109 --> 00:03:05,159
First fork our current process.

50
00:03:05,159 --> 00:03:06,829
now we have a child.

51
00:03:06,829 --> 00:03:09,149
An actual new separate process.

52
00:03:09,150 --> 00:03:14,880
你必须想象这段代码现在被涂鸦了，我们有两个进程在运行相同的代码，

53
00:03:14,879 --> 00:03:17,669
just one runs as the child and one runs as the parent.

54
00:03:17,670 --> 00:03:21,920
And you can check the return value of fork which process you are.

55
00:03:21,919 --> 00:03:24,259
In the parent process you get the pid of the child.

56
00:03:24,260 --> 00:03:26,160
In the child it’s just 0.

57
00:03:26,160 --> 00:03:31,290
然后在子进程中，我们可以调用exec，将当前进程替换为

58
00:03:31,290 --> 00:03:32,650
stack 0.

59
00:03:32,650 --> 00:03:35,270
Now in our case we want to communicate with the child.

60
00:03:35,269 --> 00:03:40,279
这意味着我们要将漏洞输入写入它，并读取它的输出，以确定

61
00:03:40,280 --> 00:03:42,570
if we were successful.

62
00:03:42,569 --> 00:03:45,469
Usually you would do this by creating pipes.

63
00:03:45,470 --> 00:03:50,950
pipe（）创建一个管道，一个可用于进程间的单向数据通道

64
00:03:50,950 --> 00:03:52,390
communication.

65
00:03:52,389 --> 00:03:57,349
The array pipefd is used to return two file descriptors referring to the ends of the pipe.

66
00:03:57,349 --> 00:04:00,869
pipefd[0] refers to the read end of the pipe.

67
00:04:00,870 --> 00:04:04,360
pipefd[1] refers to the write end of the pipe.

68
00:04:04,359 --> 00:04:08,159
写入管道写入端的数据由内核缓冲，直到读取为止。

69
00:04:08,160 --> 00:04:11,510
from the read end of the pipe.

70
00:04:11,510 --> 00:04:14,280
Basically the same pipe you can use on the commandline.

71
00:04:14,280 --> 00:04:19,940
You pipe stdout from one program, cat, into the stdin of another program, grep.

72
00:04:19,940 --> 00:04:23,490
That’s why we call this character a “pipe”.

73
00:04:23,490 --> 00:04:27,580
So for basic stdin and stdout communication you would create two pipes.

74
00:04:27,580 --> 00:04:31,870
然后，当您分叉时，由于您克隆了进程，子进程和父进程

75
00:04:31,870 --> 00:04:33,860
access to the same pipe.

76
00:04:33,860 --> 00:04:37,980
现在很明显，取决于你是父母还是孩子，你使用其中一个或另一个

77
00:04:37,979 --> 00:04:38,979
side of it.

78
00:04:38,979 --> 00:04:44,019
对于这个孩子，我们实际上要替换默认的stdin和stdout

79
00:04:44,020 --> 00:04:45,430
now with those pipes.

80
00:04:45,430 --> 00:04:47,920
By calling dup2.

81
00:04:47,919 --> 00:04:51,839
dup2（）系统调用执行与dup（）相同的任务，

82
00:04:51,840 --> 00:04:55,550
And The dup() system call creates a copy of the file descriptor.

83
00:04:55,550 --> 00:05:01,020
After a successful return, the old and new file descriptors may be used interchangeably.

84
00:05:01,020 --> 00:05:05,510
They refer to the same open file description and thus share everything.

85
00:05:05,509 --> 00:05:11,209
但是dup2使用的不是编号最低的未使用文件描述符dup（），而是

86
00:05:11,210 --> 00:05:15,490
descriptor number specified in newfd, the second paramenter.

87
00:05:15,490 --> 00:05:20,900
If the descriptor newfd was previously open, it is silently closed before being reused.

88
00:05:20,900 --> 00:05:27,390
所以dup2关闭当前子进程的stdin和stdout，并插入新的管道

89
00:05:27,389 --> 00:05:28,499
created.

90
00:05:28,500 --> 00:05:33,120
当我们执行stack0并用新的进程替换当前进程时，

91
00:05:33,120 --> 00:05:36,000
like open fildescriptors stay in tact.

92
00:05:36,000 --> 00:05:42,580
So the new process will use the pipes we just connected for reading input and writing output.

93
00:05:42,580 --> 00:05:46,670
然后在父系统中，我们可以简单地读写管道的另一端，

94
00:05:46,669 --> 00:05:49,049
thus communicate with the child process stack0.

95
00:05:49,050 --> 00:05:54,130
A nice thing to do is to close the ends of the pipes you are not using in either process.

96
00:05:54,130 --> 00:05:58,300
例如，我们不需要stdin管道的读取端，因为我们希望

97
00:05:58,300 --> 00:06:01,290
write, send data, to the child process.

98
00:06:01,289 --> 00:06:02,769
Ok.

99
00:06:02,770 --> 00:06:06,760
一旦我们编写了缓冲区溢出输入，就可以等待子进程完成。

100
00:06:06,759 --> 00:06:10,119
and read the output to see if we were successful.

101
00:06:10,120 --> 00:06:13,280
Now here is a first big issue.

102
00:06:13,280 --> 00:06:14,300
Buffering.

103
00:06:14,300 --> 00:06:16,790
Libc will buffer output you write.

104
00:06:16,789 --> 00:06:19,839
So the output of the child process is buffered in the process.

105
00:06:19,840 --> 00:06:24,870
你可以想象，如果我们做了一个缓冲区溢出，用堆栈拧动，得到一个segfault

106
00:06:24,870 --> 00:06:26,390
this buffer is lost.

107
00:06:26,389 --> 00:06:29,509
The program is just dying horribly.

108
00:06:29,509 --> 00:06:33,329
但也许你认为这没什么意义，因为我们在第2部分展示了

109
00:06:33,330 --> 00:06:37,960
exploit theoretically works and we see the output on the shell.

110
00:06:37,960 --> 00:06:40,670
We saw the modified variable message.

111
00:06:40,669 --> 00:06:44,399
那么，shell看到输出有什么意义，但我告诉你

112
00:06:44,400 --> 00:06:47,730
现在，我们不会用刚才编写的代码看到它了吗？

113
00:06:47,730 --> 00:06:48,730
Well.

114
00:06:48,730 --> 00:06:52,980
libc如何缓冲输出取决于它的管道类型

115
00:06:52,979 --> 00:06:53,979
connected to.

116
00:06:53,979 --> 00:06:58,729
在我们的例子中，我们刚刚使用了常规管道，libc将缓冲输出数据。

117
00:06:58,729 --> 00:07:03,549
直到进程调用flush（），或者直到它被很好地填充，或者在1024之后

118
00:07:03,550 --> 00:07:04,550
bytes or so.

119
00:07:04,550 --> 00:07:05,550
I don’t know.

120
00:07:05,550 --> 00:07:10,340
But we have neither, the output is super short and the child process never calls flush().

121
00:07:10,340 --> 00:07:13,040
So what’s different on the shell.

122
00:07:13,040 --> 00:07:17,560
由壳牌公司执行的钻井程序不是通过常规管道连接的，而是通过常规管道连接的。

123
00:07:17,560 --> 00:07:19,500
to a pseudo terminal.

124
00:07:19,500 --> 00:07:20,650
Pty.

125
00:07:20,650 --> 00:07:21,860
And when libc sees.

126
00:07:21,860 --> 00:07:26,550
将输出写入一个伪终端pty，然后它将刷新缓冲区（）。

127
00:07:26,550 --> 00:07:28,220
upon a newline.

128
00:07:28,219 --> 00:07:33,329
因为换行就像是你想要打印一行的最后指示（笑）

129
00:07:33,330 --> 00:07:35,130
on the terminal output.

130
00:07:35,129 --> 00:07:39,909
我认为这就像速度一样，如果不需要的话你不想冲水，但是在

131
00:07:39,909 --> 00:07:43,279
terminal you want to see outputs after a newline.

132
00:07:43,280 --> 00:07:48,390
这意味着，我们也可以在一个pty的上下文中执行stack0程序，以便

133
00:07:48,389 --> 00:07:52,499
fool libc into flushing on every newline.

134
00:07:52,499 --> 00:07:55,329
And there is a convinient libc function that does that for us.

135
00:07:55,330 --> 00:07:58,040
称为forkpty（）。

136
00:07:58,039 --> 00:08:04,349
函数的作用是：结合openpty（open pseudo terminal）、fork（2）（我们知道）。

137
00:08:04,349 --> 00:08:10,179
and login_tty() to create a new process operating in a pseudoterminal.

138
00:08:10,180 --> 00:08:13,700
The file descriptor of the master side of the pseudoterminal is returned in amaster.

139
00:08:13,699 --> 00:08:15,729
So that’s really cool.

140
00:08:15,729 --> 00:08:20,359
我们派生一个子进程，并已经获取文件描述符，以便与

141
00:08:20,360 --> 00:08:21,940
the child process.

142
00:08:21,939 --> 00:08:27,119
然后我禁用终端的一些选项，例如，我不想回显输入。

143
00:08:27,120 --> 00:08:28,460
again.

144
00:08:28,460 --> 00:08:32,650
例如，如果你观看我的嵌入式硬件安全CTF视频，你通常会注意到

145
00:08:32,650 --> 00:08:36,300
每当我在黑板上打些东西时，我都看不到

146
00:08:36,300 --> 00:08:39,980
type, that’s because I didn’t configure the terminal to echo back the characters.

147
00:08:39,980 --> 00:08:43,640
While it would have been nice there, I don’t need it here.

148
00:08:43,640 --> 00:08:47,590
And there are a few other options that could screw with what we want to do.

149
00:08:47,590 --> 00:08:50,370
And then we also don’t have to fiddle with pipes.

150
00:08:50,370 --> 00:08:52,830
So the child is just exec now.

151
00:08:52,830 --> 00:08:57,580
在父级中，我们定义了缓冲溢出输入，这基本上就是我们开发的输入

152
00:08:57,580 --> 00:09:01,860
最后一个视频，然后添加一些random（）函数以获取

153
00:09:01,860 --> 00:09:03,030
cookie.

154
00:09:03,030 --> 00:09:05,920
And place those into the buffer overflow string.

155
00:09:05,920 --> 00:09:11,200
一个简单的丑陋循环来避免换行，因为这将指示输入的结束，

156
00:09:11,200 --> 00:09:12,420
and we dont’ want that.

157
00:09:12,420 --> 00:09:17,400
然后我们将bufferoverflow字符串写入伪终端的主文件描述器

158
00:09:17,400 --> 00:09:21,680
and stack0 will read it and will get exploited.

159
00:09:21,680 --> 00:09:25,860
然后我创建一个简短的循环来检查孩子的状态，但我不想阻止

160
00:09:25,860 --> 00:09:30,870
等等，因为缓冲区溢出，孩子可能会死得很惨，也可能不会死，

161
00:09:30,870 --> 00:09:36,720
所以我只是在一个循环中检查几次状态，如果孩子死了，我们继续，

162
00:09:36,720 --> 00:09:41,060
如果我们已经等了几次，我们决定终止儿童进程，

163
00:09:41,060 --> 00:09:42,990
And otherwise we sleep a bit.

164
00:09:42,990 --> 00:09:46,810
Usually it shouldn’t loop much, as the child program is very short, but it’s a safety-net.

165
00:09:46,810 --> 00:09:52,180
BTW. program ids, pids, are prone to race conditions in linux.

166
00:09:52,180 --> 00:09:56,090
你看，我们没有直接指向子进程的句柄，我们

167
00:09:56,090 --> 00:09:57,310
only have the number.

168
00:09:57,310 --> 00:09:59,270
And numbers can be reused.

169
00:09:59,270 --> 00:10:04,310
所以从理论上讲，我们的孩子可能已经死了，另一个像网络服务器这样的进程可能已经死了。

170
00:10:04,310 --> 00:10:09,120
been executed and assigned our old pid, and then we kill it here.

171
00:10:09,120 --> 00:10:12,660
And there is no better way, linux is just really ugly some times.

172
00:10:12,660 --> 00:10:13,690
Anyway.

173
00:10:13,690 --> 00:10:18,530
我现在要添加的另一件事是信号处理程序，如果孩子

174
00:10:18,530 --> 00:10:19,790
dies or so.

175
00:10:19,790 --> 00:10:24,030
我们可以在等待之后读取输出，但我们不知道为什么以及如何

176
00:10:24,030 --> 00:10:29,080
might die and so forth, and I also found it to be a third slower if I do that.

177
00:10:29,080 --> 00:10:31,220
So used the signal handler instead.

178
00:10:31,220 --> 00:10:36,270
This handler function is called to notify us if anything happens to the child.

179
00:10:36,270 --> 00:10:39,230
So when it receives a SIGCHLD.

180
00:10:39,230 --> 00:10:44,650
And in the handler function we then read from the terminal the output of stack0.

181
00:10:44,650 --> 00:10:46,450
首先我们读到“再试一次？“

182
00:10:46,450 --> 00:10:47,450
message.

183
00:10:47,450 --> 00:10:51,720
然后可能读取堆栈粉碎检测到的错误，或者成功修改

184
00:10:51,720 --> 00:10:53,060
variable message.

185
00:10:53,060 --> 00:10:54,460
Or maybe nothing.

186
00:10:54,460 --> 00:10:59,390
Then I do an ugly check of the second output to see the success message.

187
00:10:59,390 --> 00:11:02,020
If that’s the case we print it and we are done.

188
00:11:02,020 --> 00:11:03,950
So now it’s basically ready.

189
00:11:03,950 --> 00:11:09,610
I add some more debug output to see whats going on, add an argument to supply a seed.

190
00:11:09,610 --> 00:11:11,390
and then we can compile it.

191
00:11:11,390 --> 00:11:16,010
Because we want to use forkpty, we have to also link the utils library.

192
00:11:16,010 --> 00:11:20,770
Here you can see how many executions we get per second per process.

193
00:11:20,770 --> 00:11:26,140
This machine has only one CPU, so this will take a while, let’s come back later.

194
00:11:26,140 --> 00:11:27,220
Let’s see.

195
00:11:27,220 --> 00:11:29,050
Mhhm… nothing happened yet.

196
00:11:29,050 --> 00:11:33,250
Maybe let’s rent a bigger server for a few hours with more CPU cores.

197
00:11:33,250 --> 00:11:34,460
Mmh maybe this one.

198
00:11:34,460 --> 00:11:37,270
Now to run it I do some ghetto parallelisation.

199
00:11:37,270 --> 00:11:38,270
But oh what.

200
00:11:38,270 --> 00:11:41,970
每秒只有9次处决，那是什么垃圾？

201
00:11:41,970 --> 00:11:45,380
If you look at the processes you can see something called apport.

202
00:11:45,380 --> 00:11:49,960
Apport是一个系统，它可以在发生崩溃时截获崩溃。

203
00:11:49,960 --> 00:11:53,250
第一次，收集有关

204
00:11:53,250 --> 00:11:55,960
崩溃和操作系统环境，

205
00:11:55,960 --> 00:12:00,970
啊，所以，因为我们不断地破坏一个过程，这件事就是传递信息和减慢速度。

206
00:12:00,970 --> 00:12:02,110
everything down.

207
00:12:02,110 --> 00:12:07,660
Let’s disable this service.

208
00:12:07,660 --> 00:12:10,510
And then let’s wait for a bit.

209
00:12:10,510 --> 00:12:12,150
是啊！

210
00:12:12,150 --> 00:12:16,200
See, one process output the modified variable message.

211
00:12:16,200 --> 00:12:17,480
How amazing is that.

212
00:12:17,480 --> 00:12:21,250
I admit not the most reliable exploit, but it worked.

213
00:12:21,250 --> 00:12:22,430
I’m happy.

214
00:12:22,430 --> 00:12:25,640
If you have a better exploit strategy for this here, please share it with us.

215
00:12:25,640 --> 00:12:29,270
我真的很好奇还有什么技术可以用来利用这个程序

216
00:12:29,270 --> 00:12:30,820
more reliable way.

217
00:12:30,820 --> 00:12:32,420
Thanks guys, see you next time.

