1
00:00:00,149 --> 00:00:05,679
此视频是第三个也是最后一个视频，我们现在将在其中完成堆栈级别的漏洞攻击

2
00:00:05,680 --> 00:00:10,050
0来自于我们在现代系统上编译的原恒星。

3
00:00:10,049 --> 00:00:14,769
在第一部分中，我们大致了解了编译代码时所做的更改。

4
00:00:14,769 --> 00:00:18,389
使用更现代的编译器，更仔细地查看堆栈cookie。

5
00:00:18,390 --> 00:00:24,390
在第二部分中，我们暂时忽略了cookie，并确定了更多的利用

6
00:00:24,390 --> 00:00:27,800
缓解措施，并为他们开发了一个旁路。

7
00:00:27,800 --> 00:00:30,500
所以只剩下一件事了。

8
00:00:30,499 --> 00:00:39,839
最终打败了堆叠的cookie。

9
00:00:39,840 --> 00:00:44,290
就像我们在第一个视频中提到的，如果二进制文件

10
00:00:44,290 --> 00:00:46,460
是32位二进制。

11
00:00:46,460 --> 00:00:49,680
一个堆栈cookie可能有1600万个值。

12
00:00:49,680 --> 00:00:55,230
没那么多，但1600万次处决也许是你开始想要的一个数字

13
00:00:55,230 --> 00:00:56,780
优化一点。

14
00:00:56,780 --> 00:01:01,440
虽然我不是超级快速计算方面的专家，但我决定我不想写潜在的

15
00:01:01,440 --> 00:01:04,580
python脚本很慢，但是要编写一些C代码。

16
00:01:04,580 --> 00:01:09,250
但就像我说的，我不是最快速度的专家，我怀疑

17
00:01:09,250 --> 00:01:13,860
也许这里的瓶颈不是一个缓慢的脚本，而是需要做很多工作的内核

18
00:01:13,860 --> 00:01:16,860
一次又一次地执行程序。

19
00:01:16,860 --> 00:01:21,670
所以也许没必要写C代码，也许我的C代码也很糟糕。

20
00:01:21,670 --> 00:01:25,940
但我只是想说，决定什么是最好的并不总是容易的。

21
00:01:25,940 --> 00:01:27,050
方法。

22
00:01:27,050 --> 00:01:30,170
既然我们已经说过了，让我们试着一步一步地接近这个问题。

23
00:01:30,170 --> 00:01:31,170
第一。

24
00:01:31,170 --> 00:01:36,870
你如何在C语言中执行一个程序呢，有一个系统调用称为exec。

25
00:01:36,870 --> 00:01:41,320
但通常我们从不直接调用系统调用，而是使用提供的包装函数

26
00:01:41,320 --> 00:01:43,420
像是libc。

27
00:01:43,420 --> 00:01:47,530
所以libc提供了几个不同版本的exec，但它们最终都使用

28
00:01:47,530 --> 00:01:50,060
下面是相同的exec syscall。

29
00:01:50,060 --> 00:01:51,250
在手册页上写着：

30
00:01:51,250 --> 00:01:56,500
“exec() 函数系列将当前进程图像替换为新进程

31
00:01:56,500 --> 00:01:57,500
形象。”

32
00:01:57,500 --> 00:02:01,880
我想如果你以前从来没有想过程序是如何执行的，这听起来真的

33
00:02:01,880 --> 00:02:02,880
奇怪的。

34
00:02:02,880 --> 00:02:06,470
“为什么要替换当前进程而不仅仅是执行它？

35
00:02:06,470 --> 00:02:07,870
太奇怪了”。

36
00:02:07,869 --> 00:02:11,789
这就是它的工作原理，这就是Linux的执行模型。

37
00:02:11,790 --> 00:02:16,540
因此，在我们的案例中，我们不只是想执行并替换我们的程序，而是

38
00:02:16,540 --> 00:02:21,860
希望反复执行stack0二进制文件作为新进程。

39
00:02:21,859 --> 00:02:27,329
为了产生一个新的进程，我们必须在执行前分叉该进程。

40
00:02:27,329 --> 00:02:31,709
fork() 通过复制调用进程来创建新进程。

41
00:02:31,709 --> 00:02:35,519
新进程称为子进程。

42
00:02:35,519 --> 00:02:40,379
调用进程称为父进程。

43
00:02:40,379 --> 00:02:44,899
还有一个有趣的地方是：C库函数和

44
00:02:44,900 --> 00:02:46,230
实际内核。

45
00:02:46,230 --> 00:02:51,950
因为版本2.3.3，而不是调用内核的fork() 系统调用，所以glibc

46
00:02:51,950 --> 00:02:56,750
fork() 包装器[…]使用提供与

47
00:02:56,750 --> 00:02:59,100
传统的系统调用。

48
00:02:59,099 --> 00:03:03,109
因此，要反复执行这个过程，您要做的是：

49
00:03:03,109 --> 00:03:05,159
首先是我们当前的进程。

50
00:03:05,159 --> 00:03:06,829
现在我们有了一个孩子。

51
00:03:06,829 --> 00:03:09,149
一个新的独立过程。

52
00:03:09,150 --> 00:03:14,880
你必须想象这段代码现在被涂鸦了，我们有两个进程在运行相同的代码，

53
00:03:14,879 --> 00:03:17,669
只有一个作为子级运行，另一个作为父级运行。

54
00:03:17,670 --> 00:03:21,920
您可以检查fork的返回值。

55
00:03:21,919 --> 00:03:24,259
在父进程中，您将获得子进程的PID。

56
00:03:24,260 --> 00:03:26,160
在孩子身上，只有0。

57
00:03:26,160 --> 00:03:31,290
然后在子进程中，我们可以调用exec，将当前进程替换为

58
00:03:31,290 --> 00:03:32,650
堆栈0。

59
00:03:32,650 --> 00:03:35,270
现在在我们的例子中，我们想和孩子交流。

60
00:03:35,269 --> 00:03:40,279
这意味着我们要将漏洞输入写入它，并读取它的输出，以确定

61
00:03:40,280 --> 00:03:42,570
如果我们成功的话。

62
00:03:42,569 --> 00:03:45,469
通常，您可以通过创建管道来完成此操作。

63
00:03:45,470 --> 00:03:50,950
pipe() 创建一个管道，一个可用于进程间的单向数据通道

64
00:03:50,950 --> 00:03:52,390
交流。

65
00:03:52,389 --> 00:03:57,349
数组pipefd用于返回引用管道末端的两个文件描述符。

66
00:03:57,349 --> 00:04:00,869
pipefd[0]是指管道的读取端。

67
00:04:00,870 --> 00:04:04,360
pipefd[1]表示管道的写入端。

68
00:04:04,359 --> 00:04:08,159
写入管道写入端的数据由内核缓冲，直到读取为止。

69
00:04:08,160 --> 00:04:11,510
从管道的读取端开始。

70
00:04:11,510 --> 00:04:14,280
基本上与您可以在命令行上使用的管道相同。

71
00:04:14,280 --> 00:04:19,940
您将stdout从一个程序cat导入另一个程序grep的stdin。

72
00:04:19,940 --> 00:04:23,490
这就是为什么我们称这个角色为“管道”。

73
00:04:23,490 --> 00:04:27,580
所以对于基本的stdin和stdout通信，您将创建两个管道。

74
00:04:27,580 --> 00:04:31,870
然后，当您分叉时，由于您克隆了进程，子进程和父进程

75
00:04:31,870 --> 00:04:33,860
进入同一管道。

76
00:04:33,860 --> 00:04:37,980
现在很明显，取决于你是父母还是孩子，你使用其中一个或另一个

77
00:04:37,979 --> 00:04:38,979
一边。

78
00:04:38,979 --> 00:04:44,019
对于这个孩子，我们实际上要替换默认的stdin和stdout

79
00:04:44,020 --> 00:04:45,430
现在用这些管子。

80
00:04:45,430 --> 00:04:47,920
打电话给dup2。

81
00:04:47,919 --> 00:04:51,839
dup2() 系统调用执行与dup() 相同的任务，

82
00:04:51,840 --> 00:04:55,550
dup() 系统调用创建文件描述符的副本。

83
00:04:55,550 --> 00:05:01,020
成功返回后，新的和旧的文件描述符可以互换使用。

84
00:05:01,020 --> 00:05:05,510
它们引用相同的打开文件描述，因此共享所有内容。

85
00:05:05,509 --> 00:05:11,209
但是dup2使用的不是编号最低的未使用文件描述符dup() ，而是

86
00:05:11,210 --> 00:05:15,490
在第二个参数newfd中指定的描述符编号。

87
00:05:15,490 --> 00:05:20,900
如果描述符newfd以前是打开的，那么在被重用之前，它将被静默关闭。

88
00:05:20,900 --> 00:05:27,390
所以dup2关闭当前子进程的stdin和stdout，并插入新的管道

89
00:05:27,389 --> 00:05:28,499
创建。

90
00:05:28,500 --> 00:05:33,120
当我们执行stack0并用新的进程替换当前进程时，

91
00:05:33,120 --> 00:05:36,000
像打开的窃听器一样保持机智。

92
00:05:36,000 --> 00:05:42,580
所以新的过程将使用我们刚刚连接的管道来读取输入和写入输出。

93
00:05:42,580 --> 00:05:46,670
然后在父系统中，我们可以简单地读写管道的另一端，

94
00:05:46,669 --> 00:05:49,049
因此，与子进程stack0通信。

95
00:05:49,050 --> 00:05:54,130
要做的一件好事是关闭在这两个过程中都不使用的管道末端。

96
00:05:54,130 --> 00:05:58,300
例如，我们不需要stdin管道的读取端，因为我们希望

97
00:05:58,300 --> 00:06:01,290
向子进程写入、发送数据。

98
00:06:01,289 --> 00:06:02,769
好啊。

99
00:06:02,770 --> 00:06:06,760
一旦我们编写了缓冲区溢出输入，就可以等待子进程完成。

100
00:06:06,759 --> 00:06:10,119
并读取输出以查看我们是否成功。

101
00:06:10,120 --> 00:06:13,280
现在是第一个大问题。

102
00:06:13,280 --> 00:06:14,300
缓冲。

103
00:06:14,300 --> 00:06:16,790
libc将缓冲您所写的输出。

104
00:06:16,789 --> 00:06:19,839
因此子进程的输出在进程中得到缓冲。

105
00:06:19,840 --> 00:06:24,870
你可以想象，如果我们做了一个缓冲区溢出，用堆栈拧动，得到一个segfault

106
00:06:24,870 --> 00:06:26,390
这个缓冲区丢失。

107
00:06:26,389 --> 00:06:29,509
这个节目真是糟透了。

108
00:06:29,509 --> 00:06:33,329
但也许你认为这没什么意义，因为我们在第2部分展示了

109
00:06:33,330 --> 00:06:37,960
从理论上讲，开发是可行的，我们可以看到shell上的输出。

110
00:06:37,960 --> 00:06:40,670
我们看到了修改后的变量消息。

111
00:06:40,669 --> 00:06:44,399
那么，shell看到输出有什么意义，但我告诉你

112
00:06:44,400 --> 00:06:47,730
现在，我们不会用刚才编写的代码看到它了吗？

113
00:06:47,730 --> 00:06:48,730
好。

114
00:06:48,730 --> 00:06:52,980
libc如何缓冲输出取决于它的管道类型

115
00:06:52,979 --> 00:06:53,979
连接到。

116
00:06:53,979 --> 00:06:58,729
在我们的例子中，我们刚刚使用了常规管道，libc将缓冲输出数据。

117
00:06:58,729 --> 00:07:03,549
直到进程调用flush() ，或者直到它被很好地填充，或者在1024之后

118
00:07:03,550 --> 00:07:04,550
字节左右。

119
00:07:04,550 --> 00:07:05,550
我不知道。

120
00:07:05,550 --> 00:07:10,340
但是我们两者都没有，输出是超短的，子进程从不调用flush() 。

121
00:07:10,340 --> 00:07:13,040
所以外壳上有什么不同。

122
00:07:13,040 --> 00:07:17,560
由壳牌公司执行的钻井程序不是通过常规管道连接的，而是通过常规管道连接的。

123
00:07:17,560 --> 00:07:19,500
到一个伪终端。

124
00:07:19,500 --> 00:07:20,650
Pty。

125
00:07:20,650 --> 00:07:21,860
当libc看到的时候。

126
00:07:21,860 --> 00:07:26,550
将输出写入一个伪终端pty，然后它将刷新缓冲区() 。

127
00:07:26,550 --> 00:07:28,220
换行。

128
00:07:28,219 --> 00:07:33,329
因为换行就像是你想要打印一行的最后指示（笑）

129
00:07:33,330 --> 00:07:35,130
在终端输出上。

130
00:07:35,129 --> 00:07:39,909
我认为这就像速度一样，如果不需要的话你不想冲水，但是在

131
00:07:39,909 --> 00:07:43,279
要在换行后查看输出的终端。

132
00:07:43,280 --> 00:07:48,390
这意味着，我们也可以在一个pty的上下文中执行stack0程序，以便

133
00:07:48,389 --> 00:07:52,499
愚弄libc在每一条新线上发泄。

134
00:07:52,499 --> 00:07:55,329
还有一个很好的libc函数，它可以为我们做到这一点。

135
00:07:55,330 --> 00:07:58,040
称为forkpty() 。

136
00:07:58,039 --> 00:08:04,349
函数的作用是：结合openpty（open pseudo terminal）、fork（2）（我们知道）。

137
00:08:04,349 --> 00:08:10,179
以及登录tty() 以创建一个在伪终端中运行的新进程。

138
00:08:10,180 --> 00:08:13,700
在amaster中返回伪终端主端的文件描述符。

139
00:08:13,699 --> 00:08:15,729
所以这真的很酷。

140
00:08:15,729 --> 00:08:20,359
我们派生一个子进程，并已经获取文件描述符，以便与

141
00:08:20,360 --> 00:08:21,940
子进程。

142
00:08:21,939 --> 00:08:27,119
然后我禁用终端的一些选项，例如，我不想回显输入。

143
00:08:27,120 --> 00:08:28,460
再一次。

144
00:08:28,460 --> 00:08:32,650
例如，如果你观看我的嵌入式硬件安全CTF视频，你通常会注意到

145
00:08:32,650 --> 00:08:36,300
每当我在黑板上打些东西时，我都看不到

146
00:08:36,300 --> 00:08:39,980
类型，这是因为我没有配置终端来回送字符。

147
00:08:39,980 --> 00:08:43,640
虽然那里会很好，但我不需要它。

148
00:08:43,640 --> 00:08:47,590
还有一些其他的选择可以改变我们想要做的事情。

149
00:08:47,590 --> 00:08:50,370
然后我们也不必摆弄管道。

150
00:08:50,370 --> 00:08:52,830
所以这个孩子现在只是行政人员。

151
00:08:52,830 --> 00:08:57,580
在父级中，我们定义了缓冲溢出输入，这基本上就是我们开发的输入

152
00:08:57,580 --> 00:09:01,860
最后一个视频，然后添加一些random() 函数以获取

153
00:09:01,860 --> 00:09:03,030
饼干。

154
00:09:03,030 --> 00:09:05,920
并将它们放入缓冲区溢出字符串中。

155
00:09:05,920 --> 00:09:11,200
一个简单的丑陋循环来避免换行，因为这将指示输入的结束，

156
00:09:11,200 --> 00:09:12,420
我们不想那样。

157
00:09:12,420 --> 00:09:17,400
然后我们将bufferoverflow字符串写入伪终端的主文件描述器

158
00:09:17,400 --> 00:09:21,680
Stack0会阅读它并得到利用。

159
00:09:21,680 --> 00:09:25,860
然后我创建一个简短的循环来检查孩子的状态，但我不想阻止

160
00:09:25,860 --> 00:09:30,870
等等，因为缓冲区溢出，孩子可能会死得很惨，也可能不会死，

161
00:09:30,870 --> 00:09:36,720
所以我只是在一个循环中检查几次状态，如果孩子死了，我们继续，

162
00:09:36,720 --> 00:09:41,060
如果我们已经等了几次，我们决定终止儿童进程，

163
00:09:41,060 --> 00:09:42,990
否则我们会睡一会儿。

164
00:09:42,990 --> 00:09:46,810
通常它不应该循环太多，因为儿童程序非常短，但它是一个安全网。

165
00:09:46,810 --> 00:09:52,180
顺便说一句，程序ID，PIDS，在Linux中很容易出现竞争条件。

166
00:09:52,180 --> 00:09:56,090
你看，我们没有直接指向子进程的句柄，我们

167
00:09:56,090 --> 00:09:57,310
只有号码。

168
00:09:57,310 --> 00:09:59,270
数字可以重复使用。

169
00:09:59,270 --> 00:10:04,310
所以从理论上讲，我们的孩子可能已经死了，另一个像网络服务器这样的进程可能已经死了。

170
00:10:04,310 --> 00:10:09,120
被执行并分配了我们的旧PID，然后我们在这里杀死它。

171
00:10:09,120 --> 00:10:12,660
没有更好的方法，Linux有时真的很难看。

172
00:10:12,660 --> 00:10:13,690
不管怎样。

173
00:10:13,690 --> 00:10:18,530
我现在要添加的另一件事是信号处理程序，如果孩子

174
00:10:18,530 --> 00:10:19,790
模具等。

175
00:10:19,790 --> 00:10:24,030
我们可以在等待之后读取输出，但我们不知道为什么以及如何

176
00:10:24,030 --> 00:10:29,080
可能会死等等，我也发现如果我这样做的话会慢三分之一。

177
00:10:29,080 --> 00:10:31,220
因此使用了信号处理程序。

178
00:10:31,220 --> 00:10:36,270
调用这个处理程序函数来通知我们如果孩子发生了什么事情。

179
00:10:36,270 --> 00:10:39,230
所以当它收到信号时。

180
00:10:39,230 --> 00:10:44,650
然后在handler函数中，我们从终端读取stack0的输出。

181
00:10:44,650 --> 00:10:46,450
首先我们读到“再试一次？“

182
00:10:46,450 --> 00:10:47,450
消息。

183
00:10:47,450 --> 00:10:51,720
然后可能读取堆栈粉碎检测到的错误，或者成功修改

184
00:10:51,720 --> 00:10:53,060
变量消息。

185
00:10:53,060 --> 00:10:54,460
或者什么都没有。

186
00:10:54,460 --> 00:10:59,390
然后我对第二个输出进行丑陋的检查，以查看成功消息。

187
00:10:59,390 --> 00:11:02,020
如果是这样的话，我们就打印出来，然后就完成了。

188
00:11:02,020 --> 00:11:03,950
现在基本上准备好了。

189
00:11:03,950 --> 00:11:09,610
我添加了更多的调试输出来查看发生了什么，添加了一个参数来提供种子。

190
00:11:09,610 --> 00:11:11,390
然后我们可以编译它。

191
00:11:11,390 --> 00:11:16,010
因为我们要使用forkpty，所以还必须链接utils库。

192
00:11:16,010 --> 00:11:20,770
在这里，您可以看到每个进程每秒执行多少次。

193
00:11:20,770 --> 00:11:26,140
这台机器只有一个CPU，所以这需要一段时间，我们稍后再来。

194
00:11:26,140 --> 00:11:27,220
让我们看看。

195
00:11:27,220 --> 00:11:29,050
嗯……还没发生什么事。

196
00:11:29,050 --> 00:11:33,250
也许让我们租一个更大的服务器，用更多的CPU内核，用几个小时。

197
00:11:33,250 --> 00:11:34,460
嗯，也许是这个。

198
00:11:34,460 --> 00:11:37,270
现在，为了运行它，我做了一些犹太人区的平行化。

199
00:11:37,270 --> 00:11:38,270
但是，哦，什么？

200
00:11:38,270 --> 00:11:41,970
每秒只有9次处决，那是什么垃圾？

201
00:11:41,970 --> 00:11:45,380
如果您查看这些流程，您可以看到称为apport的内容。

202
00:11:45,380 --> 00:11:49,960
Apport是一个系统，它可以在发生崩溃时截获崩溃。

203
00:11:49,960 --> 00:11:53,250
第一次，收集有关

204
00:11:53,250 --> 00:11:55,960
崩溃和操作系统环境，

205
00:11:55,960 --> 00:12:00,970
啊，所以，因为我们不断地破坏一个过程，这件事就是传递信息和减慢速度。

206
00:12:00,970 --> 00:12:02,110
一切都结束了。

207
00:12:02,110 --> 00:12:07,660
让我们禁用此服务。

208
00:12:07,660 --> 00:12:10,510
然后我们再等一会儿。

209
00:12:10,510 --> 00:12:12,150
是啊！

210
00:12:12,150 --> 00:12:16,200
请参见，一个进程输出修改后的变量消息。

211
00:12:16,200 --> 00:12:17,480
真是太神奇了。

212
00:12:17,480 --> 00:12:21,250
我承认这不是最可靠的利用，但它起作用了。

213
00:12:21,250 --> 00:12:22,430
我很高兴。

214
00:12:22,430 --> 00:12:25,640
如果您在这里有更好的开发策略，请与我们分享。

215
00:12:25,640 --> 00:12:29,270
我真的很好奇还有什么技术可以用来利用这个程序

216
00:12:29,270 --> 00:12:30,820
更可靠的方法。

217
00:12:30,820 --> 00:12:32,420
谢谢各位，下次见。

