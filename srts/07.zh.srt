1
00:00:07,110 --> 00:00:11,940
在本视频中，我们将重新访问许可证从上次开始检查程序。

2
00:00:11,940 --> 00:00:16,760
您可以得到相同的编译64位二进制文件从Github，你也可以观看最后一个

3
00:00:16,760 --> 00:00:21,020
视频，我详细介绍了如何破解这个简单的程序。

4
00:00:21,020 --> 00:00:25,490
我现在将展示不同的简单工具和分析程序的现有技术

5
00:00:25,490 --> 00:00:28,710
这样做是为了规避许可证检查。

6
00:00:28,710 --> 00:00:33,630
这应该向你表明有很多种如何解决这一挑战。

7
00:00:33,629 --> 00:00:37,749
文件命令对于检查你拥有的文件种类。

8
00:00:37,750 --> 00:00:43,250
所以二进制文件上的"文件"说它是用于Linux的ELF 64位可执行文件。

9
00:00:43,250 --> 00:00:48,980
您还可以执行"文件*"以获取信息目录中的所有文件。

10
00:00:48,980 --> 00:00:51,260
然后它也会在这里找到C源代码。

11
00:00:51,260 --> 00:00:53,450
所以这很有用。

12
00:00:53,450 --> 00:00:57,110
让我们在文本编辑器中打开程序喜欢vim。

13
00:00:57,110 --> 00:00:59,680
如你所见，这看起来很奇怪。

14
00:00:59,680 --> 00:01:05,260
我以前介绍过ASCII，所以你知道每个字符都分配了一个数字。

15
00:01:05,260 --> 00:01:09,030
但有些数字没有已分配可打印字符。

16
00:01:09,030 --> 00:01:15,490
如果你看一下ascii的手册页，你会发现例如，值0到hex 1f是

17
00:01:15,491 --> 00:01:16,851
不是普通字符。

18
00:01:16,850 --> 00:01:22,470
而ASCII也只定义为最高为hex 7f或127。

19
00:01:22,470 --> 00:01:29,240
但是因为我们的计算机可以处理字节，所以8位，这个数字可以从0到

20
00:01:29,240 --> 00:01:32,770
255，而ASCII只使用其中的一半。

21
00:01:32,770 --> 00:01:36,940
所以Vim中所有奇怪的蓝色值都是没有可打印的数字

22
00:01:36,939 --> 00:01:38,699
分配的字符。

23
00:01:38,700 --> 00:01:42,460
您还可以对该文件执行hexdump，以获取实际值。

24
00:01:42,460 --> 00:01:49,120
"hexdump-c许可证1"，您可以看到文件中有许多0。

25
00:01:49,120 --> 00:01:54,120
hexdump将它们显示为点，但在vim中它们是蓝色的东西。

26
00:01:54,119 --> 00:01:57,769
但是当你仔细看的时候一些有意义的字符串。

27
00:01:57,770 --> 00:02:02,450
例如，就在"elf"的开头，这是一个神奇的价值，暗示着

28
00:02:02,450 --> 00:02:06,170
文件是可执行文件。

29
00:02:06,170 --> 00:02:11,040
您还可以找到一些库的字符串例如libc，它定义函数

30
00:02:11,039 --> 00:02:13,609
如printf和strcmp。

31
00:02:13,610 --> 00:02:18,880
在这里我们也看到了我们知道的弦，"正在检查许可证"，"已授予访问权限"，

32
00:02:18,880 --> 00:02:21,250
"错了！"和"用法"消息。

33
00:02:21,250 --> 00:02:26,200
还有这个奇怪的"aaaa-zion-42-ok"字符串。

34
00:02:26,200 --> 00:02:28,100
嗯…

35
00:02:28,099 --> 00:02:31,329
从上一个视频中记得字符串比较？

36
00:02:31,330 --> 00:02:35,410
可能会得到我们输入的许可证密钥这个字符串？

37
00:02:35,410 --> 00:02:38,630
让我们试试看！

38
00:02:38,630 --> 00:02:39,630
准许访问。

39
00:02:39,630 --> 00:02:40,630
的确！

40
00:02:40,630 --> 00:02:42,910
这个程序的许可证密钥在那里一直以来。

41
00:02:42,910 --> 00:02:48,370
有一个很棒的工具叫做"弦"。这就是我们刚刚做的，更好。

42
00:02:48,370 --> 00:02:53,850
它将扫描一个文件并打印出所有可打印的至少有一个特定的字符序列

43
00:02:53,849 --> 00:02:54,849
长度。

44
00:02:54,849 --> 00:02:57,989
所以让我们用"字符串许可证1"来试试。

45
00:02:57,990 --> 00:03:01,770
还有我们的弦。

46
00:03:01,770 --> 00:03:06,770
上次我们用gdb读取反汇编并调试程序。

47
00:03:06,769 --> 00:03:09,789
这次我们就用objdump拆卸。

48
00:03:09,790 --> 00:03:12,910
"objdump-d许可证"1.

49
00:03:12,910 --> 00:03:17,160
你注意到这个文件还有很多代码不仅仅是"main"函数。

50
00:03:17,160 --> 00:03:21,490
这是因为编译器将填充到实际的二进制文件中。

51
00:03:21,489 --> 00:03:25,439
你知道，电脑有点多比一开始看起来复杂。

52
00:03:25,440 --> 00:03:29,530
但所有这些都是标准的东西你基本上可以在任何gcc编译的二进制文件中找到。

53
00:03:29,530 --> 00:03:35,160
通常只有用户创建的函数像梅因一样对我们很有意思。

54
00:03:35,159 --> 00:03:39,349
objdump可用于获取更多有关此程序的信息。

55
00:03:39,349 --> 00:03:44,759
让我们用"objdump-c"打印所有内容许可证"1"，并将其导入较少的管道中，以便于

56
00:03:44,760 --> 00:03:46,350
导航。

57
00:03:46,349 --> 00:03:52,019
所以首先它说这个文件是一个elf二进制文件对于x86-64体系结构。

58
00:03:52,020 --> 00:03:56,350
堆栈不可执行，由指示缺少的"x"，这很有趣

59
00:03:56,349 --> 00:03:59,629
一旦我们看到经典的缓冲区溢出。

60
00:03:59,630 --> 00:04:03,560
也许最后一个有趣的信息是部分。

61
00:04:03,560 --> 00:04:07,770
我们可以在这里看到以后某些数据将在哪里在记忆中结束。

62
00:04:07,769 --> 00:04:10,409
有趣的是.text部分。

63
00:04:10,410 --> 00:04:19,000
这个部分保存了我们的代码，它开始地址4004D0，是十六进制1E2大。

64
00:04:19,000 --> 00:04:22,920
如果你查一下主管道的地址功能是，你会注意到

65
00:04:22,920 --> 00:04:23,920
在那里。

66
00:04:23,920 --> 00:04:29,380
另一个有趣的部分是Rodata，这是只读数据部分。

67
00:04:29,379 --> 00:04:32,089
所以我们的弦可以在那里找到。

68
00:04:32,089 --> 00:04:38,139
如果你打开gdb并在strcmp处断开，你可以查一下登记簿。

69
00:04:38,139 --> 00:04:43,709
其中一个寄存器将有一个地址从这个。Rodata部分。

70
00:04:43,710 --> 00:04:48,700
你可以用X/S打印这个地址，瞧，又有钥匙了。

71
00:04:48,699 --> 00:04:51,719
让我们看看另一个活动工具。

72
00:04:51,719 --> 00:04:56,629
它叫Strace，可以追踪系统呼叫和信号。

73
00:04:56,629 --> 00:05:01,289
当我用C语言介绍编程时，我们使用printf打印文本。

74
00:05:01,289 --> 00:05:06,019
我们增加了一个很好的函数我们的程序来自libc库。

75
00:05:06,020 --> 00:05:11,150
但是printf只是一个函数的包装器Linux系统本身为我们提供的。

76
00:05:11,149 --> 00:05:16,789
Linux本身提供了许多不同类型的函数调用了syscalls。

77
00:05:16,789 --> 00:05:20,179
你可以在手册页上看到更多关于它们的信息。到赛场。

78
00:05:20,180 --> 00:05:22,510
其中一个函数是"write"。

79
00:05:22,509 --> 00:05:26,859
可用于将文本写入标准输出，我们可以在

80
00:05:26,860 --> 00:05:28,690
慰问。

81
00:05:28,689 --> 00:05:31,529
那么让我们用斯特拉斯

82
00:05:31,529 --> 00:05:38,559
第一行是execve，它是函数它告诉Linux内核现在执行

83
00:05:38,559 --> 00:05:41,139
此程序许可证。

84
00:05:41,139 --> 00:05:45,119
我们忽略了很多魔法从现在开始。

85
00:05:45,119 --> 00:05:52,079
在底部的某个地方，我写的代码开始了。

86
00:05:52,080 --> 00:05:57,870
你可以在这里看到写系统调用是用我们知道的文本执行的。

87
00:05:57,869 --> 00:05:59,039
有趣，嗯？

88
00:05:59,039 --> 00:06:03,049
还有一个很酷的工具叫ltrace。

89
00:06:03,050 --> 00:06:06,070
与strace类似，它跟踪某些函数。

90
00:06:06,069 --> 00:06:08,249
但这次它跟踪库函数。

91
00:06:08,249 --> 00:06:12,969
printf或strcmp等函数来自图书馆。

92
00:06:12,970 --> 00:06:15,500
所以种族可以告诉我们它们的发生。

93
00:06:15,500 --> 00:06:17,090
所以首先你可以看到打印件。

94
00:06:17,090 --> 00:06:18,780
然后是strcmp。

95
00:06:18,779 --> 00:06:21,779
它向我们展示了它比较的实际字符串。

96
00:06:21,779 --> 00:06:25,969
这也告诉我们如何检查许可证以一种酷的方式工作。

97
00:06:25,969 --> 00:06:29,199
让我们把这个文件转换成一个图形用户接口。

98
00:06:29,199 --> 00:06:30,979
我将在Mac上使用Hopper。

99
00:06:30,979 --> 00:06:34,259
你可能知道，爱达普很贵。

100
00:06:34,259 --> 00:06:38,589
但是Hopper是一个很好的选择实际上可以负担得起。

101
00:06:38,589 --> 00:06:43,859
Hopper发现它是一个ELF可执行文件，并且它能自动为我们分析。

102
00:06:43,860 --> 00:06:46,740
它将我们的诅咒者置于一个调用开始。

103
00:06:46,740 --> 00:06:49,500
而不是主要的。

104
00:06:49,500 --> 00:06:54,430
就像我们以前看到的奥布登普那样编译器还创建了几个函数吗？

105
00:06:54,429 --> 00:06:58,119
这里是程序。

106
00:06:58,120 --> 00:07:02,020
但这些功能所起的作用并不是现在很重要。

107
00:07:02,020 --> 00:07:04,750
我们只对main 函数感兴趣。

108
00:07:04,749 --> 00:07:08,869
所以我们可以在标签列表。

109
00:07:08,869 --> 00:07:11,339
这是我们的main 函数，就像在gdb中一样。

110
00:07:11,339 --> 00:07:17,159
只要稍微多些颜色，漏斗也可以让我们看看树枝所在的箭头

111
00:07:17,159 --> 00:07:18,549
去。

112
00:07:18,550 --> 00:07:22,910
在最后一个视频的结尾，我已经显示了控制流程图

113
00:07:22,909 --> 00:07:25,139
右上角的通道。

114
00:07:25,139 --> 00:07:28,969
Hopper的一个非常酷的宴会是反编译程序。

115
00:07:28,970 --> 00:07:34,550
反编译听起来像是反汇编代码返回到C代码。

116
00:07:34,550 --> 00:07:36,280
但这并不容易。

117
00:07:36,279 --> 00:07:42,019
编译器更改并优化了内容和你只是不能简单地逆转它。

118
00:07:42,020 --> 00:07:45,380
但是Hopper能猜出它看起来是怎样的喜欢。

119
00:07:45,379 --> 00:07:49,169
有时会出错，但经常看起来不错。

120
00:07:49,169 --> 00:07:54,329
它向我们展示了它如何检查提供了许可证密钥，然后执行

121
00:07:54,330 --> 00:07:57,790
strcmp并打印"已授予访问权限"或者是错的！'.

122
00:07:57,789 --> 00:07:59,449
很酷。

123
00:07:59,449 --> 00:08:03,749
在左边你也可以找到一个按钮显示所有字符串。

124
00:08:03,749 --> 00:08:07,429
正如你所看到的，它也找到了钥匙。

125
00:08:07,430 --> 00:08:11,200
当你点击它时，它会跳到地址钥匙所在位置。

126
00:08:11,199 --> 00:08:15,859
xref代表交叉引用，意味着这个地址在某个地方被引用。

127
00:08:15,860 --> 00:08:20,570
我们可以跟踪外部参照，我们可以看到这是汇编代码，地址

128
00:08:20,569 --> 00:08:24,339
键的移动到ESI寄存器中。

129
00:08:24,339 --> 00:08:28,689
这将为准备函数参数斯特罗姆

130
00:08:28,689 --> 00:08:31,889
有些孩子可能认为Mac用户吮吸。

131
00:08:31,889 --> 00:08:37,959
为了取悦他们，我们现在将安装RADARE2通过使用Git克隆Radare2存储库。

132
00:08:37,960 --> 00:08:40,850
你可能需要安装带有sudo-apt-get的git安装Git。

133
00:08:40,849 --> 00:08:50,269
要安装Radare，请运行sys/install.sh并等待。

134
00:08:50,270 --> 00:08:57,010
安装后，您可以转到许可证1在RADARE中用"R2许可证"编程并打开它。

135
00:08:57,009 --> 00:09:02,119
你可能记得奥布登普的这个地址在前面，这是文本段的开头

136
00:09:02,120 --> 00:09:04,500
包含我们的代码。

137
00:09:04,500 --> 00:09:10,020
首先运行"aaa"，自动分析自动名称函数。

138
00:09:10,020 --> 00:09:14,620
然后使用"afl"打印所有功能找到了雷达。

139
00:09:14,620 --> 00:09:16,810
RADARE中的每个字符都有意义。

140
00:09:16,810 --> 00:09:21,460
然后呢？你总是能得到关于您可以使用哪些字符。

141
00:09:21,459 --> 00:09:24,659
所以"a"执行代码分析。

142
00:09:24,660 --> 00:09:29,700
A？'显示我们可以附加'f'分析功能。

143
00:09:29,699 --> 00:09:32,069
"AFL"列出了这些功能。

144
00:09:32,069 --> 00:09:33,719
有道理，对吧？

145
00:09:33,720 --> 00:09:37,070
好的，AFL告诉我们它找到了一个主要的功能。

146
00:09:37,070 --> 00:09:43,810
让我们用"s"更改当前位置查找函数main的位置。

147
00:09:43,810 --> 00:09:47,130
您也可以在这里使用tab补全。

148
00:09:47,130 --> 00:09:50,320
现在括号中的位置改变了。

149
00:09:50,319 --> 00:09:55,109
使用"pdf"，我们可以打印反汇编当前函数的。

150
00:09:55,110 --> 00:09:59,710
像漏斗一样，它向我们展示了漂亮的箭头指向树枝。

151
00:09:59,709 --> 00:10:03,889
它用字符串为我们创建了评论在那里被引用。

152
00:10:03,889 --> 00:10:07,899
您还可以键入capital vv以进入Visual模式。

153
00:10:07,899 --> 00:10:11,139
这将向您显示此的控制图视图功能。

154
00:10:11,139 --> 00:10:13,649
你可以用箭头键移动它。

155
00:10:13,649 --> 00:10:17,259
蓝色边框表示我们目前选择此框。

156
00:10:17,259 --> 00:10:20,929
使用选项卡和shift选项卡，您可以选择其他阻碍。

157
00:10:20,930 --> 00:10:27,470
选定块后，可以移动带SHIFT+HJKL的区块。

158
00:10:27,470 --> 00:10:30,610
有了"P"，你可以通过不同的循环陈述。

159
00:10:30,610 --> 00:10:33,780
例如，在开始。

160
00:10:33,779 --> 00:10:38,609
或者这个极简主义的观点，这是有用的如果你有一个巨大的功能。

161
00:10:38,610 --> 00:10:40,730
然后呢？您可以显示帮助。

162
00:10:40,730 --> 00:10:45,340
这个帮助告诉你，大写字母R是最重要的捷径

163
00:10:45,339 --> 00:10:46,819
为了RADARE…

164
00:10:46,819 --> 00:10:49,989
所以按SHIFT+R键就可以了。

165
00:10:49,990 --> 00:10:54,280
也可以使用类似于gdb的radare2进行调试这个程序。

166
00:10:54,279 --> 00:10:57,489
为此，用-d标志启动Radare。

167
00:10:57,490 --> 00:11:01,930
寻找main 函数，分析所有"aaa"并显示反汇编

168
00:11:01,930 --> 00:11:03,360
PDF。

169
00:11:03,360 --> 00:11:05,790
现在在"db"开头放置一个断点。

170
00:11:05,790 --> 00:11:10,600
现在再次使用"vv"进入可视视图。

171
00:11:10,600 --> 00:11:17,150
和VIM一样，您可以使用"："，在其中键入"：dc"以运行

172
00:11:17,149 --> 00:11:18,149
程序。

173
00:11:18,149 --> 00:11:20,099
现在我们到达了断点1。

174
00:11:20,100 --> 00:11:24,550
如果你仔细看，你会发现有人闯入第一个盒子。

175
00:11:24,550 --> 00:11:28,600
这向我们展示了指令指针的位置当前指向。

176
00:11:28,600 --> 00:11:30,820
使用S，您可以执行指令。

177
00:11:30,820 --> 00:11:36,150
但是我们应该使用资本，否则我们遵循我们不希望看到的功能。

178
00:11:36,149 --> 00:11:37,669
所以shift+s可以更进一步。

179
00:11:37,670 --> 00:11:38,670
啊，该死的。

180
00:11:38,670 --> 00:11:40,610
我们没有提供许可证密钥。

181
00:11:40,610 --> 00:11:42,600
但你明白了。

182
00:11:42,600 --> 00:11:46,180
我希望这能帮助你探索更多的工具技术。

183
00:11:46,180 --> 00:11:49,310
记住没有什么工具比其他。

184
00:11:49,310 --> 00:11:52,880
它们都有不同的特性和表示形式信息。

185
00:11:52,880 --> 00:11:55,580
掌握它们是有意义的。

186
00:11:55,579 --> 00:11:56,579
除氡外。

187
00:11:56,579 --> 00:11:58,199
有人说拉德尔是最好的。

188
00:11:58,199 --> 00:11:59,949
但没有人能掌控拉达雷。

