1
00:00:07,110 --> 00:00:11,940
在本视频中，我们将重新浏览，上次的许可证检查程序。

2
00:00:11,940 --> 00:00:16,760
从Github，您可以得到相同的编译 64位二进制文件，你也可以观看

3
00:00:16,760 --> 00:00:21,020
上个视频，详细介绍了关于如何破解这个简单的程序。

4
00:00:21,020 --> 00:00:25,490
现在我，将展示分析程序，现有不同的简单工具和技术

5
00:00:25,490 --> 00:00:28,710
以此，规避许可证检查。

6
00:00:28,710 --> 00:00:33,630
这应该能，向你证明其实有很多种方式，可以完成这一挑战。

7
00:00:33,629 --> 00:00:37,749
file 命令，对检查你拥有的文件种类，很有用。

8
00:00:37,750 --> 00:00:43,250
所以，"file"二进制文件，说它是用于 Linux 的 ELF 64位可执行文件。

9
00:00:43,250 --> 00:00:48,980
您还可以执行"file *"，以获取目录中的所有文件信息。

10
00:00:48,980 --> 00:00:51,260
然后它也会，在这里找到 C源代码。

11
00:00:51,260 --> 00:00:53,450
所以，这很有用。

12
00:00:53,450 --> 00:00:57,110
让我们在文本编辑器(像vim)中，打开程序。

13
00:00:57,110 --> 00:00:59,680
如你所见，这看起来很奇怪。

14
00:00:59,680 --> 00:01:05,260
我以前介绍过ASCII，所以你知道每个字符，都分配了一个数字。

15
00:01:05,260 --> 00:01:09,030
但这里有些数字没有，已分配的可打印字符。

16
00:01:09,030 --> 00:01:16,851
如果你看一下ascii的手册(man)页，你会发现例如，(hex)1f 的 值 0   不是普通字符。

17
00:01:15,491 --> 00:01:16,851


18
00:01:16,850 --> 00:01:22,470
而ASCII(规则编码)最高，只定义到了，(hex)7f 或者说 127。

19
00:01:22,470 --> 00:01:29,240
但是因为我们的计算机可以处理字节，所以8位(字节)，这个(数值)范围可以

20
00:01:29,240 --> 00:01:32,770
从 0 到 255 ，而ASCII只使用其中的一半。

21
00:01:32,770 --> 00:01:38,699
所以Vim中所有奇怪的蓝色值，都是没有对应分配字符的数字

22
00:01:36,939 --> 00:01:38,699

23
00:01:38,700 --> 00:01:42,460
您还可以对该文件执行 hexdump，以获取实际值。

24
00:01:42,460 --> 00:01:49,120
"hexdump -C license_1"，您可以看到文件中，有许多 0。

25
00:01:49,120 --> 00:01:54,120
hexdump 将它们显示为 点，但在 vim 中它们是蓝色的东西。

26
00:01:54,119 --> 00:01:57,769
但是，当你仔细看一些有意义的字符串的时候。

27
00:01:57,770 --> 00:02:06,170
例如，就是"ELF"开头，这是一个神奇的值，暗示着文件，是可执行文件。

28
00:02:02,450 --> 00:02:06,170


29
00:02:06,170 --> 00:02:13,609
您还可以找到一些库的字符串，例如 libc，它定义了，如 printf 和 strcmp 函数

30
00:02:11,039 --> 00:02:13,609


31
00:02:13,610 --> 00:02:18,880
在这里，我们也看到了我们知道的字符串，"正在检查许可证"，"已授予访问权限"，

32
00:02:18,880 --> 00:02:21,250
"错了！"和"用法"消息。

33
00:02:21,250 --> 00:02:26,200
还有，这个奇怪的"aaaa-zion-42-ok"字符串。

34
00:02:26,200 --> 00:02:28,100
嗯，噢，哦…

35
00:02:28,099 --> 00:02:31,329
从上一个视频中，记得字符串比较吗？

36
00:02:31,330 --> 00:02:35,410
可能，我们输入的许可证密钥，就是与这个字符串做比较的吗？

37
00:02:35,410 --> 00:02:38,630
让我们试试看！

38
00:02:38,630 --> 00:02:39,630
准许访问。

39
00:02:39,630 --> 00:02:40,630
的确啊！

40
00:02:40,630 --> 00:02:42,910
这个程序的密钥，一直在呀。

41
00:02:42,910 --> 00:02:48,370
有一个很棒的工具叫做"strings"，能做我们刚刚做的事情，但更好。

42
00:02:48,370 --> 00:02:54,849
它将扫描一个文件，并打印出所有可打印的，至少有一个特定长度的字符序列

43
00:02:53,849 --> 00:02:54,849


44
00:02:54,849 --> 00:02:57,989
所以，让我们用"strings license_1"来试试。

45
00:02:57,990 --> 00:03:01,770
没错，这就是我们的字符串。

46
00:03:01,770 --> 00:03:06,770
上次，我们用gdb读取，反汇编，和调试了程序。

47
00:03:06,769 --> 00:03:09,789
这次我们就用 objdump 反汇编。

48
00:03:09,790 --> 00:03:12,910
"objdump -d license_1"

49
00:03:12,910 --> 00:03:17,160
你注意到这个文件，还有很多代码，不仅仅是"main"函数。

50
00:03:17,160 --> 00:03:21,490
这是因为，编译器把一些东西，放入实际的二进制文件中。

51
00:03:21,489 --> 00:03:25,439
你知道，计算机，在一开始看起来复杂。

52
00:03:25,440 --> 00:03:29,530
但这基本上，都是实际的 gcc 二进制文件会有的标准信息。

53
00:03:29,530 --> 00:03:35,160
而通常，只有用户创建的函数，像 main ，我们才会有兴趣。

54
00:03:35,159 --> 00:03:39,349
objdump 可用于获取更多有关此程序的信息。

55
00:03:39,349 --> 00:03:46,350
让我们用"objdump -c license_1"打印它的所有，并将其导入 less 命令管道中，以便于导航查看。

56
00:03:44,760 --> 00:03:46,350


57
00:03:46,349 --> 00:03:52,019
所以首先，它说这个文件是一个 ELF二进制文件，属于 x86-64体系结构。

58
00:03:52,020 --> 00:03:56,350
栈不可执行，指示说缺少了"x"，噢有趣。

59
00:03:56,349 --> 00:03:59,629
一旦，我们看到经典的缓冲区溢出。

60
00:03:59,630 --> 00:04:03,560
也许最后一个感兴趣的信息是 sections。

61
00:04:03,560 --> 00:04:07,770
我们可以在这里，看到某些数据之后，在内存中结束。

62
00:04:07,769 --> 00:04:10,409
感兴趣的是 .text 部分。

63
00:04:10,410 --> 00:04:19,000
这个部分，保存了我们的代码，它从 地址4004D0 开始，是 (hex)1E2 大小。

64
00:04:19,000 --> 00:04:23,920
如果，你查一下 main 函数的地址，你会注意到，就在这里。

65
00:04:22,920 --> 00:04:23,920


66
00:04:23,920 --> 00:04:29,380
另一个感兴趣的部分是 .rodata，这是只读数据部分。

67
00:04:29,379 --> 00:04:32,089
所以我们的字符串，可以在这找到。

68
00:04:32,089 --> 00:04:38,139
如果你打开 gdb，并在strcmp处断点，你可以查一下寄存器。

69
00:04:38,139 --> 00:04:43,709
其中一个寄存器，将有个，这 .rodata部分的地址。

70
00:04:43,710 --> 00:04:48,700
你可以用 x/s 打印这个地址，瞧，又有密钥啦。

71
00:04:48,699 --> 00:04:51,719
让我们看看另一个可行的工具。

72
00:04:51,719 --> 00:04:56,629
它叫strace，可以追踪系统调用和信号。

73
00:04:56,629 --> 00:05:01,289
当我介绍C语言的编程时，我们使用 printf 打印文本。

74
00:05:01,289 --> 00:05:06,019
帮我们的程序增加了一个很好的函数，它来自 libc 库。

75
00:05:06,020 --> 00:05:11,150
但是 printf 只是一个函数的包装器，而这是 Linux系统本身为我们提供的。

76
00:05:11,149 --> 00:05:16,789
Linux本身提供了许多不同类型的函数，都调用了syscalls。

77
00:05:16,789 --> 00:05:20,179
你可以在手册(man)页上，看到更多关于它们（syscalls）的信息。

78
00:05:20,180 --> 00:05:22,510
其中一个函数是"write"。

79
00:05:22,509 --> 00:05:26,859
可用于，将文本写入标准输出，这样我们就可以在控制台读到。

80
00:05:26,860 --> 00:05:28,690

81
00:05:28,689 --> 00:05:31,529
那么让我们用strace，执行我们的检查程序

82
00:05:31,529 --> 00:05:41,139
第一行是 execve，这是函数，它告诉Linux内核，现在执行程序 license_1

83
00:05:38,559 --> 00:05:41,139

84
00:05:41,139 --> 00:05:45,119
不过现在，我们先忽略下开头的魔法。

85
00:05:45,119 --> 00:05:52,079
在底部的某个地方，我写的代码开始了。

86
00:05:52,080 --> 00:05:57,870
你可以在这里，看到 write syscalls 是用我们知道的文本执行的。

87
00:05:57,869 --> 00:05:59,039
有趣，吧？

88
00:05:59,039 --> 00:06:03,049
还有一个很酷的工具，叫 ltrace。

89
00:06:03,050 --> 00:06:06,070
与strace类似，它跟踪某些函数。

90
00:06:06,069 --> 00:06:08,249
但这次它，跟踪库函数。

91
00:06:08,249 --> 00:06:12,969
printf 或strcmp等函数，都来自库。

92
00:06:12,970 --> 00:06:15,500
所以ltrace，可以告诉我们它们的发生状况。

93
00:06:15,500 --> 00:06:17,090
所以首先，你可以看到 printf。

94
00:06:17,090 --> 00:06:18,780
然后是 strcmp。

95
00:06:18,779 --> 00:06:21,779
它向我们展示了，比较的实际字符串。

96
00:06:21,779 --> 00:06:25,969
它还用一种酷的方式，告诉我们程序的工作。

97
00:06:25,969 --> 00:06:29,199
让我们把这个文件，转换成一个图形用户接口。

98
00:06:29,199 --> 00:06:30,979
我将在Mac上使用 Hopper。

99
00:06:30,979 --> 00:06:34,259
你可能知道，IDAPro很贵。

100
00:06:34,259 --> 00:06:38,589
但是 Hopper是一个很好的选择，可以负担得起。

101
00:06:38,589 --> 00:06:43,859
Hopper会发现这文件是一个ELF可执行文件，并且自动为我们分析。

102
00:06:43,860 --> 00:06:49,500
它将我们的光标，放在一个函数调用的开头，不是 main。

103
00:06:46,740 --> 00:06:49,500


104
00:06:49,500 --> 00:06:54,430
就像我们之前看到的 objdump 那样，编译器还创建了几个函数吗？

105
00:06:54,429 --> 00:06:58,119
这里才是程序的真实入口。

106
00:06:58,120 --> 00:07:02,020
但这些函数做的是什么，现在并不是很重要。

107
00:07:02,020 --> 00:07:04,750
我们只对 main 函数感兴趣。

108
00:07:04,749 --> 00:07:08,869
所以我们可以在标签列表，查看 main 函数。

109
00:07:08,869 --> 00:07:11,339
这是我们的 main 函数，就像在 gdb 中一样。

110
00:07:11,339 --> 00:07:17,159
只是稍微多些颜色，hopper也可以让我们看看这些箭头，所指向的分支

111
00:07:17,159 --> 00:07:18,549

112
00:07:18,550 --> 00:07:22,910
在上一视频的结尾，可以在右上角，显示了控制流程图

113
00:07:22,909 --> 00:07:25,139


114
00:07:25,139 --> 00:07:28,969
Hopper的一个非常酷的功能，是反编译程序。

115
00:07:28,970 --> 00:07:34,550
反编译听起来，像将汇编代码，'反'回到C代码的形态。

116
00:07:34,550 --> 00:07:36,280
但这没那么简单。

117
00:07:36,279 --> 00:07:42,019
因编译器更改并优化了内容，以至于你不能简单地'反'转它。

118
00:07:42,020 --> 00:07:45,380
但是，Hopper能猜出它是什么样子的。

119
00:07:45,379 --> 00:07:49,169
有时会出错，但通常情况下，看起来还不错。

120
00:07:49,169 --> 00:07:54,329
它向我们展示了，检查是否提供了许可证密钥，然后

121
00:07:54,330 --> 00:07:57,790
执行 strcmp 并打印 "已授予访问权限"或者是"错的！".

122
00:07:57,789 --> 00:07:59,449
所以，这真的很酷。

123
00:07:59,449 --> 00:08:03,749
在左边你也可以找到一个按钮，会显示所有字符串。

124
00:08:03,749 --> 00:08:07,429
正如你所看到的，它也找到了密钥啦

125
00:08:07,430 --> 00:08:11,200
当你点击它时，它会跳到密钥的地址位置。

126
00:08:11,199 --> 00:08:15,859
xref代表交叉引用，意味着这个地址，在某个地方被引用。

127
00:08:15,860 --> 00:08:20,570
我们可以顺着 xref，往下看，看到这是汇编代码

128
00:08:20,569 --> 00:08:24,339
（说）密钥地址移动到 esi 寄存器中。

129
00:08:24,339 --> 00:08:28,689
这为strcmp，准备函数参数

130
00:08:28,689 --> 00:08:31,889
有些孩子，可能认为 Mac用户 'SUck'。

131
00:08:31,889 --> 00:08:37,959
为了取悦他们，我们现在将安装radare2 ，具体是使用 Git 克隆它存储库。

132
00:08:37,960 --> 00:08:40,850
你可能需要"sudo apt-get install git"，安装下git。

133
00:08:40,849 --> 00:08:50,269
要安装 radare2，请运行"sys/install.sh"并等待。

134
00:08:50,270 --> 00:08:57,010
安装后，您可以去到 license_1 程序那里，用"r2 license_1"打开

135
00:08:57,009 --> 00:09:04,500
你可能记得前面的 objdump 例子中的这个地址，这是我们代码的文本段开头

136
00:09:02,120 --> 00:09:04,500


137
00:09:04,500 --> 00:09:10,020
首先运行"aaa"，自动化分析自动名称函数。

138
00:09:10,020 --> 00:09:14,620
然后使用"afl"，打印找到的所有函数。

139
00:09:14,620 --> 00:09:16,810
radare2 中的每个字符，都有意义。

140
00:09:16,810 --> 00:09:21,460
通过 "?"符号 ，你总是能得到，您可以使用哪些字符的信息。

141
00:09:21,459 --> 00:09:24,659
所以，"a"执行，代码分析。

142
00:09:24,660 --> 00:09:29,700
"a?"显示：我们可以附加'f'，来分析函数。

143
00:09:29,699 --> 00:09:32,069
"afl"列出了这些函数。

144
00:09:32,069 --> 00:09:33,719
有道理，对吧？

145
00:09:33,720 --> 00:09:37,070
好的，'afl' 告诉我们，它找到了一个 main 函数。

146
00:09:37,070 --> 00:09:43,810
让我们用"s"更改当前位置，查找函数 main 的位置。

147
00:09:43,810 --> 00:09:47,130
您也可以在这里，使用 tab补全。

148
00:09:47,130 --> 00:09:50,320
现在括号中的位置，改变了。

149
00:09:50,319 --> 00:09:55,109
使用"pdf"，我们可以打印，当前函数的反汇编代码。

150
00:09:55,110 --> 00:09:59,710
像 hopper 一样，它向我们展示了漂亮的箭头，表明分支的指向。

151
00:09:59,709 --> 00:10:03,889
它为我们创建了字符串注释，放在了被引用的位置。

152
00:10:03,889 --> 00:10:07,899
您还可以键入(大写) VV ，以进入Visual模式。

153
00:10:07,899 --> 00:10:11,139
这将向您显示，此函数控制-流程图的视图。

154
00:10:11,139 --> 00:10:13,649
你可以用箭头键，移动它。

155
00:10:13,649 --> 00:10:17,259
蓝色边框表示，我们目前选择的框。

156
00:10:17,259 --> 00:10:20,929
通过 Tab 和 shift 选项卡，您可以选择其他框。

157
00:10:20,930 --> 00:10:27,470
选定框后，可以用 Shift + hjkl 移动。

158
00:10:27,470 --> 00:10:30,610
"p"，你可以圈住不同的表达式。

159
00:10:30,610 --> 00:10:33,780
例如，不要开头的地址。

160
00:10:33,779 --> 00:10:38,609
或者这个极简的视图，如果你有一个巨大的函数，这会有用。

161
00:10:38,610 --> 00:10:40,730
然后，用'?'，您可以显示帮助。

162
00:10:40,730 --> 00:10:45,340
这个帮助告诉你，(大写) R 是您能 radare2 中，学到的最重要的快捷命令。

163
00:10:45,339 --> 00:10:46,819

164
00:10:46,819 --> 00:10:49,989
所以，按 Shift+R 键，和你高兴就好。

165
00:10:49,990 --> 00:10:54,280
也可以让 radare2，像 gdb 一样进行调试这个程序。

166
00:10:54,279 --> 00:10:57,489
为此，用-d标志，启动 radare2。

167
00:10:57,490 --> 00:11:03,360
寻找 main 函数，分析所有"aaa"，并用"paf"显示反汇编

168
00:11:01,930 --> 00:11:03,360


169
00:11:03,360 --> 00:11:05,790
现在在开头"db"，放置一个断点。

170
00:11:05,790 --> 00:11:10,600
现在再次使用"VV"，进入可视视图。

171
00:11:10,600 --> 00:11:17,150
和Vim一样，您可以使用":"，在其中键入":dc"以运行程序。

172
00:11:17,149 --> 00:11:18,149

173
00:11:18,149 --> 00:11:20,099
现在，我们到达了断点1。

174
00:11:20,100 --> 00:11:24,550
如果你仔细看，你会发现第一个盒子的 rip 。

175
00:11:24,550 --> 00:11:28,600
这向我们展示了，指令指针当前指向的位置。

176
00:11:28,600 --> 00:11:30,820
使用 's'，您可以执行指令。

177
00:11:30,820 --> 00:11:36,150
但是我们应该使用大写 S，否则我们追踪，我们不希望看到的函数。

178
00:11:36,149 --> 00:11:37,669
所以， shift+s 可以前一步。

179
00:11:37,670 --> 00:11:38,670
啊，该死的。

180
00:11:38,670 --> 00:11:40,610
我们没有提供许可证密钥。

181
00:11:40,610 --> 00:11:42,600
但，你明白了。

182
00:11:42,600 --> 00:11:46,180
我希望，这能帮助你，探索更多的工具和技术。

183
00:11:46,180 --> 00:11:49,310
记住，没有什么工具是最强的。

184
00:11:49,310 --> 00:11:52,880
它们都有不同的特性和信息表达。

185
00:11:52,880 --> 00:11:55,580
掌控它们是有意义的。

186
00:11:55,579 --> 00:11:56,579
除 radare2 外。

187
00:11:56,579 --> 00:11:58,199
有人说 radare2 是最好的。

188
00:11:58,199 --> 00:11:59,949
但，从没有人能掌控 radare2。

