1
00:00:06,799 --> 00:00:11,329
假设你在一家公司工作，经理很生气有盗版版本

2
00:00:11,330 --> 00:00:15,630
你的产品。他告诉你保护他们的知识产权

3
00:00:15,629 --> 00:00:22,149
这个程序无法运行。有可能吗？最后一个视频我说每个程序

4
00:00:22,150 --> 00:00:28,200
易碎的但那是老我。也许我学会了在此期间，我们再试试看。

5
00:00:28,199 --> 00:00:32,459
第一个问题是，许可证密钥是在二进制文件中。最简单的技术

6
00:00:32,460 --> 00:00:35,550
我们必须提取所有字符串，然后我们发现关键。

7
00:00:35,550 --> 00:00:36,990
在Github上的存储库中，您还可以找到此简单许可证检查的源代码。

8
00:00:36,989 --> 00:00:41,229
所以我们第一次尝试确保安全不要把钥匙放在里面。我们可以做到这一点

9
00:00:41,230 --> 00:00:46,520
通过编写一个算法关键。你可以提出非常有创意的想法。

10
00:00:46,519 --> 00:00:51,379
然后你可以给你的安全二进制给一个朋友，让他破解它。或写

11
00:00:51,379 --> 00:00:57,169
一个KEGEGEN。那真的很有趣。我的第一个想法是简单地总结

12
00:00:57,170 --> 00:01:03,760
键的ASCII值，并进行比较一个魔法值。所以让我们修改原始的

13
00:01:03,760 --> 00:01:12,480
程序。首先，我们必须定义一个新的整数将存储计算出的和的值。

14
00:01:12,480 --> 00:01:19,010
所以求和并设置为0。然后我们会补充带有计数器变量i的for循环，其中

15
00:01:19,010 --> 00:01:25,970
从0开始，循环条件为它继续重复这个循环，只要我

16
00:01:25,970 --> 00:01:32,310
小于键的字符串长度我们可以通过argv[1]供应。在每一个

17
00:01:32,310 --> 00:01:39,320
重复，我们将使i增加1。现在我们想要总结每个字符的值，

18
00:01:39,320 --> 00:01:48,070
所以sum+=argv[1][i]。如你所知的计算机只懂数字。所以每个角色，

19
00:01:48,070 --> 00:01:54,500
正如您从ASCII表中所知道的，是一个数字。但是编译器知道，argv是被定义的

20
00:01:54,500 --> 00:02:00,390
作为一个字符序列。所以不能得到任何投诉我们将此值强制转换为整数

21
00:02:00,390 --> 00:02:05,980
像那样。现在我们想知道我们原来的钥匙和是。所以让我们添加

22
00:02:05,980 --> 00:02:17,860
格式字符串中包含%d的printf和和作为参数。现在我们可以编译它了

23
00:02:17,860 --> 00:02:24,990
并使用原始密钥执行。所以这里是此的所有字符值的总和

24
00:02:24,990 --> 00:02:30,170
关键。让我们再看一遍代码并更改关键检查。我们移除字符串比较

25
00:02:30,170 --> 00:02:34,670
用一张支票代替它就是那个数字。

26
00:02:34,670 --> 00:02:40,200
删除调试打印件并尝试。所以这里上面说钥匙错了，这里

27
00:02:40,200 --> 00:02:45,950
它说它是一把正确的钥匙。现在尝试字符串，您将无法再找到此密钥。

28
00:02:45,950 --> 00:02:51,120
我们现在怎么能破解这个？让我们用Radare2打开它。分析一切，

29
00:02:51,120 --> 00:02:57,040
查找main 函数并打印拆卸。所以让我们来寻找成功或失败的信息。

30
00:02:57,040 --> 00:03:01,890
在这里。然后我们可以检查分支机构来找支票

31
00:03:01,890 --> 00:03:07,040
如果许可证是否正确。好吧，这样比较和跳跃决定我们是否

32
00:03:07,040 --> 00:03:12,490
print Access授予或者如果我们遵循它错了。您还可以看到使用的此十六进制值

33
00:03:12,490 --> 00:03:17,630
比较。我喜欢使用python进行转换

34
00:03:17,630 --> 00:03:22,820
十六进制和十进制之间这就是确切的

35
00:03:22,819 --> 00:03:29,399
我们在c代码中有什么。因此，在调试模式下再次打开文件并添加

36
00:03:29,400 --> 00:03:37,370
错误的许可证密钥。如果我们启动该计划

37
00:03:37,370 --> 00:03:47,530
它说这是错的。大。

38
00:03:47,530 --> 00:03:55,100
现在让我们来吧这个比较和db的断点

39
00:03:55,099 --> 00:04:00,609
在调试模式下重新打开文件。现在直流继续。

40
00:04:00,610 --> 00:04:05,850
现在我们点击了断点。和博士你可以

41
00:04:05,849 --> 00:04:10,139
看到裂口在跳跃。用dr rip =

42
00:04:10,140 --> 00:04:14,550
我们可以设置rip到我们想要执行的地址下一个。

43
00:04:14,550 --> 00:04:18,470
显然我们想要印刷成功。所以我们再次破解它。

44
00:04:18,470 --> 00:04:24,940
好的，我们已经发现，如果你能找到的话这个比较你决定在哪里

45
00:04:24,939 --> 00:04:29,619
你有没有有效的许可证，你可以简单绕过它。

46
00:04:29,620 --> 00:04:33,130
如果我们提供了许可证，请参阅比较键。

47
00:04:33,129 --> 00:04:39,889
然后是printf。就像我们的c代码一样。

48
00:04:39,889 --> 00:04:44,939
后printf我们将总和设置为0.还有

49
00:04:44,939 --> 00:04:51,819
for循环用索引计数器初始化我到0.你可以在汇编程序中看到它

50
00:04:51,819 --> 00:04:57,459
代码在左边。两个地址设置为

51
00:04:57,460 --> 00:05:04,990
0带有一个mov。并计算地址

52
00:05:04,990 --> 00:05:12,050
用基地指针地址，就是这样另一个花哨的注册。

53
00:05:12,050 --> 00:05:18,310
然后是第一个变量位于偏离-0x18的位置，并且

54
00:05:18,309 --> 00:05:24,079
另一个，好吧，雷达取代了这个数字使用名称并将其称为local_2_4变量。

55
00:05:24,080 --> 00:05:32,030
但这个名字背后只是另一个数字。现在，仔细观察，我们可以找到一个分支

56
00:05:32,029 --> 00:05:45,089
循环回来。那么这些块是

57
00:05:45,089 --> 00:05:50,729
我们的循环。并在for循环结束时

58
00:05:50,729 --> 00:05:57,899
是一个添加指令，向本地添加1先前设置为0的变量。

59
00:05:57,900 --> 00:06:01,560
就是这样i的增量。

60
00:06:01,559 --> 00:06:07,409
而这个局部变量确定的雷达是我。

61
00:06:07,409 --> 00:06:13,179
这只需要一些练习。所以首先它从地址加载一个值。

62
00:06:13,180 --> 00:06:19,150
哪个radare分配了名称。这个名字

63
00:06:19,150 --> 00:06:25,190
在strlen附近出现了。如果你

64
00:06:25,189 --> 00:06:31,109
比较这两个汇编程序块类似。

65
00:06:31,110 --> 00:06:35,580
你可以看到它增加了8负载值。

66
00:06:35,580 --> 00:06:41,660
所以通常这意味着价值加载的是一个地址。

67
00:06:41,659 --> 00:06:47,199
因为我们有64位，我们经常将内存分成8个字节

68
00:06:47,199 --> 00:06:53,359
块。想象一下内存中的数组，它可能会使用多个

69
00:06:53,360 --> 00:06:59,460
8个字节的块。第一块，也就是

70
00:06:59,460 --> 00:07:06,170
数组中的第一个值就在那里地址指向。

71
00:07:06,169 --> 00:07:13,379
这意味着如果你想获得数组中的第二个值

72
00:07:13,379 --> 00:07:18,609
你必须在地址上加8。现在它指出

73
00:07:18,610 --> 00:07:23,250
到第二个数组条目。所以这是argv [1]。

74
00:07:23,249 --> 00:07:30,119
记住我们从0开始计数。所以argv [0]将是第一个数组条目。

75
00:07:30,119 --> 00:07:35,549
argv基本上是包含地址的变量

76
00:07:35,550 --> 00:07:40,560
这个地址。好吧所以rdx在这里现在有地址在哪里

77
00:07:40,559 --> 00:07:47,679
我们的字符串开始现在我们知道了下一个

78
00:07:47,680 --> 00:07:53,330
line将索引计数器i加载到eax中。每

79
00:07:53,330 --> 00:07:57,930
ascii字符大1字节。如此相似

80
00:07:57,929 --> 00:08:04,739
我们如何移动地址指向通过添加8，下一个数组条目，我们可以移动

81
00:08:04,740 --> 00:08:10,000
这个字符串指向下一个字符添加1.所以，当我们采取计数器i，哪个

82
00:08:09,999 --> 00:08:15,939
可能例如具有值3，并添加它指向开始的地址

83
00:08:15,939 --> 00:08:21,459
然后它将指向第3个字符串字符。

84
00:08:21,460 --> 00:08:29,080
接下来我们从当前加载1个字节在rax中的地址。

85
00:08:29,080 --> 00:08:33,850
这就是价值特别的性格。

86
00:08:33,849 --> 00:08:39,249
然后我们添加这个eax中的值到偏移量的局部变量

87
00:08:39,250 --> 00:08:45,450
-0x18我们之前设置为0.所以这是我们的总和！

88
00:08:45,449 --> 00:08:51,459
哇。我知道这似乎很乏味

89
00:08:51,459 --> 00:08:57,999
混乱。和疯狂。

90
00:08:58,000 --> 00:09:03,470
但如果你这样做了几次，还调试这一步

91
00:09:03,470 --> 00:09:09,020
但是这个时候你可以忽略大部分的东西再次通过有根据的猜测向后工作。

92
00:09:09,019 --> 00:09:14,419
所以你看到这个地址被比较了具有一定的价值。

93
00:09:14,420 --> 00:09:21,370
那么看看这个价值所在来自。

94
00:09:21,370 --> 00:09:28,820
啊，它必须做点什么这个补充。

95
00:09:28,819 --> 00:09:38,079
现在您可以重新加载二进制文件了调试模式与ood。

96
00:09:38,079 --> 00:09:45,089
我将使用ABCD作为示例键。

97
00:09:45,089 --> 00:09:51,539
按p显示地址，放置一个断点。

98
00:09:51,540 --> 00:09:58,010
然后用V！换成

99
00:09:58,009 --> 00:10:05,819
花哨的模式。然后执行它。

100
00:10:05,819 --> 00:10:09,459
现在总是继续：dc并查看寄存器

101
00:10:09,459 --> 00:10:15,509
rax被添加。所以在第一个循环中

102
00:10:15,509 --> 00:10:21,299
它的0x41。如果你知道你的ascii表

103
00:10:21,300 --> 00:10:28,210
知道这是大都会A.你也可以使用Python作为转换回来的便利工具

104
00:10:28,209 --> 00:10:32,549
来回。下次是0x42，就是这样

105
00:10:32,550 --> 00:10:37,340
一个资本B.然后它是0x43。所以很清楚

106
00:10:37,339 --> 00:10:43,009
你可以复制一行。用P可以粘贴再说一遍。我故意用A，B，C，D是因为

107
00:10:43,009 --> 00:10:46,309
它们的数值总是增加
1.

108
00:10:46,310 --> 00:10:52,410
酷。你可以看到总和总是1。比前一个大。现在让我们

109
00:10:52,410 --> 00:10:57,990
使用非常NAIV的随机keygen尝试不同的钥匙，直到我们找到一把。很明显

110
00:10:57,990 --> 00:11:02,430
使之更加智能化，因为此函数的线性行为。但它

111
00:11:02,430 --> 00:11:07,190
仍然看起来很酷。所以导入随机模块并创建一个无止境的

112
00:11:07,190 --> 00:11:11,550
循环。我们的密钥以空字符串开始。现在我们

113
00:11:11,550 --> 00:11:18,650
从字母表中选择一个随机字符随机选择并将其附加到密钥。

114
00:11:18,649 --> 00:11:25,499
现在我们检查一下这把钥匙。如果这把钥匙是和已经太大了，我们重新设置键，然后开始

115
00:11:25,500 --> 00:11:29,710
新鲜的。如果我们达到正确的值，我们打印此密钥。

116
00:11:29,709 --> 00:11:37,449
我将在检查键功能中修改打印让它看起来更酷。

117
00:11:37,449 --> 00:11:42,719
现在保存并运行它。哎呀……什么东西是不是……啊……我比较错了

118
00:11:42,720 --> 00:11:48,320
绕道而行。我们重置了钥匙太大了。好吧…

119
00:11:48,319 --> 00:11:54,129
他妈的太快了。即使它是一个非常算法不好，我们很快就能找到很多密钥。

120
00:11:54,129 --> 00:12:00,429
让我们看看它们是否有效。哦，是的，他们工作！很酷，是吧？

121
00:12:00,430 --> 00:12:06,960
所以我们现在知道了，我们可以隐藏许可证密钥通过使用算法来验证是否

122
00:12:06,959 --> 00:12:11,479
密钥有效。整个算法变成了

123
00:12:11,480 --> 00:12:18,230
当我们找到汇编代码时没用决定它是否有效。

124
00:12:18,230 --> 00:12:22,240
在我们的例子中这是一个简单的比较/跳转，我们可以修补。

125
00:12:22,240 --> 00:12:25,350
显然你可以让它更复杂一点，例如，执行不同的许可证密钥检查

126
00:12:25,350 --> 00:12:29,780
地方。但通常你就是这样

127
00:12:29,779 --> 00:12:35,349
打败那个。现在，如果我们喜欢挑战，或者我们不喜欢

128
00:12:35,350 --> 00:12:41,660
想修补二进制文件，因为无论如何，你可能想要的原因有很多

129
00:12:41,660 --> 00:12:46,590
一个有效的密钥。我们可以使用静态分析和

130
00:12:46,589 --> 00:12:52,309
逆向工程许可证检查算法并写一个keygen来生成有效的密钥。

131
00:12:52,310 --> 00:12:57,340
显然这个算法也可以变得非常复杂，但一般如果你把很多

132
00:12:57,339 --> 00:13:02,699
在其中工作，你可以搞清楚。现在你告诉你的经理，但他

133
00:13:02,699 --> 00:13:04,699
是一个自作聪明，告诉你："然后停下来

