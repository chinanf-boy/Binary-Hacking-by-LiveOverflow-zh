1
00:00:06,799 --> 00:00:11,329
假设你在一家公司工作，你的经理对盗版很生气

2
00:00:11,330 --> 00:00:15,630
你的产品。他告诉你要保护他们的知识产权

3
00:00:15,629 --> 00:00:22,149
这个程序无法运行。有可能吗？最后一段视频我说每个节目

4
00:00:22,150 --> 00:00:28,200
crackable. But that was old me. Maybe I learned more in the meantime, so let’s try it out.

5
00:00:28,199 --> 00:00:32,459
第一个问题是，许可证密钥在二进制文件中。最简单的技术

6
00:00:32,460 --> 00:00:35,550
we had was to extract all strings and we found the key.

7
00:00:35,550 --> 00:00:36,990
In the repository on github you can also find the source code of this simple license check.

8
00:00:36,989 --> 00:00:41,229
所以我们第一次尝试确保这个安全，就是不要把钥匙放在里面。我们可以做到这一点

9
00:00:41,230 --> 00:00:46,520
by writing an algorithm that scrambles the key. You can come up with very creative ideas.

10
00:00:46,519 --> 00:00:51,379
然后你可以把你的安全二进制文件交给一个朋友，让他破解它。或写

11
00:00:51,379 --> 00:00:57,169
一个KEGEGEN。那真的很有趣。我的第一个想法是简单地总结一下

12
00:00:57,170 --> 00:01:03,760
键的ASCII值，并将其与一个魔力值进行比较。所以让我们修改原始的

13
00:01:03,760 --> 00:01:12,480
program. First we have to define a new integer value that will store our calculated sum.

14
00:01:12,480 --> 00:01:19,010
所以求和并设置为0。然后我们将添加一个带有计数器变量i的for循环，其中

15
00:01:19,010 --> 00:01:25,970
从0开始，循环条件是它将继续重复此循环，只要我

16
00:01:25,970 --> 00:01:32,310
小于我们可以通过argv[1]提供的密钥的字符串长度。在每一个

17
00:01:32,310 --> 00:01:39,320
重复，我们将使i增加1。现在我们要总结每个字符的值，

18
00:01:39,320 --> 00:01:48,070
所以sum+=argv[1][i]。正如你所知道的，计算机只懂数字。所以每个角色，

19
00:01:48,070 --> 00:01:54,500
正如您从ASCII表中所知道的，是一个数字。但是编译器知道，argv是被定义的

20
00:01:54,500 --> 00:02:00,390
作为一个字符序列。为了不引起任何抱怨，我们将这个值强制转换为一个整数。

21
00:02:00,390 --> 00:02:05,980
像那样。现在我们想知道我们原来的钥匙的和是什么。所以让我们添加

22
00:02:05,980 --> 00:02:17,860
一个printf，其格式字符串为%d，sum为参数。现在我们可以编译它了

23
00:02:17,860 --> 00:02:24,990
并使用原始密钥执行。这里是所有字符值的和

24
00:02:24,990 --> 00:02:30,170
关键。让我们再次转到代码并更改密钥检查。我们移除字符串比较

25
00:02:30,170 --> 00:02:34,670
and replace it with a check that sum has to be that number.

26
00:02:34,670 --> 00:02:40,200
删除调试打印件并尝试。所以这里说钥匙错了，这里

27
00:02:40,200 --> 00:02:45,950
it says that it is a correct key. Now try strings, and you will not find this key anymore.

28
00:02:45,950 --> 00:02:51,120
我们现在怎么能破解这个？让我们用Radare2打开它。分析一切，

29
00:02:51,120 --> 00:02:57,040
seek to the main function and print the disassembly. So let’s look for the Success or Fail message.

30
00:02:57,040 --> 00:03:01,890
在这里。然后我们可以查一下分支机构从哪里来找支票

31
00:03:01,890 --> 00:03:07,040
许可证是否正确。好的，所以这个比较和跳跃决定了我们是否

32
00:03:07,040 --> 00:03:12,490
允许打印访问，或者如果我们执行错误。您还可以看到使用的十六进制值

33
00:03:12,490 --> 00:03:17,630
进行比较。我喜欢使用python在十六进制和十进制之间进行转换。所以这就是

34
00:03:17,630 --> 00:03:22,820
我们的C代码中有什么。所以在调试模式下再次打开文件并添加

35
00:03:22,819 --> 00:03:29,399
许可证密钥错误。如果我们启动程序，它会说这是错误的。伟大的。现在让我们设置

36
00:03:29,400 --> 00:03:37,370
a breakpoint with db at this one compare and reopen the file in debug mode. Now dc to continue.

37
00:03:37,370 --> 00:03:47,530
现在我们到达了断点。有了医生，你可以看到裂口在跳跃。与RIP博士

38
00:03:47,530 --> 00:03:55,100
we can set rip to the address we want to execute next. And obviously we want to print the success.

39
00:03:55,099 --> 00:04:00,609
所以我们又破解了它。好吧，我们已经知道了，如果你能找到

40
00:04:00,610 --> 00:04:05,850
这是一个比较，如果你有一个有效的许可证或没有，你可以简单地

41
00:04:05,849 --> 00:04:10,139
绕过它。但我们是黑客，我们喜欢挑战。和

42
00:04:10,140 --> 00:04:14,550
patching a jump is just boring. So let’s write a keygen.

43
00:04:14,550 --> 00:04:18,470
所以我们首先要反转算法。我将打开它旁边的源代码，所以

44
00:04:18,470 --> 00:04:24,940
we can compare. I Seek to main function. And enter visual mode.

45
00:04:24,939 --> 00:04:29,619
好吧，我们已经从另一个视频中了解了一些关于这个程序的信息。所以在这里我们可以

46
00:04:29,620 --> 00:04:33,130
see the compare if we have supplied a license key.

47
00:04:33,129 --> 00:04:39,889
然后是打印件。就像我们的C代码。打印完后，我们将总和设置为0。还有

48
00:04:39,889 --> 00:04:44,939
用索引计数器i到0初始化for循环。你可以在汇编程序中看到

49
00:04:44,939 --> 00:04:51,819
代码在左边。用MOV将两个地址设置为0。地址是计算出来的

50
00:04:51,819 --> 00:04:57,459
对于基指针地址，这只是另一个奇特的寄存器。然后是第一个

51
00:04:57,460 --> 00:05:04,990
变量的偏移量是-0x18，另一个变量，嗯，radare替换了这个数字。

52
00:05:04,990 --> 00:05:12,050
with a name and calls it local_2_4 variable. But behind this name is just another number.

53
00:05:12,050 --> 00:05:18,310
现在，当我们仔细观察时，我们可以找到一个循环备份的分支。所以这里的街区是

54
00:05:18,309 --> 00:05:24,079
我们的循环。在for循环的末尾是一个add指令，它将1添加到本地

55
00:05:24,080 --> 00:05:32,030
先前设置为0的变量。这是i的增量，这个局部变量

56
00:05:32,029 --> 00:05:45,089
that radare identified is i. We can rename the variable with “afvn locale_2_4 i.

57
00:05:45,089 --> 00:05:50,729
在这个模块中，我们有一个strlen调用。然后我们比较两个寄存器，它要么继续

58
00:05:50,729 --> 00:05:57,899
with this main block or leaves. So that is the for loop condition here.

59
00:05:57,900 --> 00:06:01,560
如果你以前从来没有见过这个，现在有点难看了。但是如果你

60
00:06:01,559 --> 00:06:07,409
practice that it’s easy to see. Don’t worry if you get lost for the next minute.

61
00:06:07,409 --> 00:06:13,179
This just requires some practice. So first it loads a value from an address.

62
00:06:13,180 --> 00:06:19,150
给哪个雷达分配了一个名字。这个名字出现在史特伦附近。如果你

63
00:06:19,150 --> 00:06:25,190
比较这两个汇编程序块，它们是相似的。你可以看到它在

64
00:06:25,189 --> 00:06:31,109
加载值。所以通常这意味着加载的值是一个地址。因为我们

65
00:06:31,110 --> 00:06:35,580
have 64bit, we often divide memory in 8 byte chunks.

66
00:06:35,580 --> 00:06:41,660
设想一个数组在内存中，它可能使用多个8字节的块。第一块，即

67
00:06:41,659 --> 00:06:47,199
数组中的第一个值就是地址指向的地方。这意味着如果

68
00:06:47,199 --> 00:06:53,359
您要在数组中获取第二个值，必须向地址添加8。现在它指出

69
00:06:53,360 --> 00:06:59,460
到第二个数组项。这就是argv[1]。记住我们从0开始计数。所以ARVV〔0〕

70
00:06:59,460 --> 00:07:06,170
将是第一个数组项。argv基本上是一个变量，它包含一个地址，

71
00:07:06,169 --> 00:07:13,379
指向内存中的数组。这个地址被加载到rax中。然后再加上8个，

72
00:07:13,379 --> 00:07:18,609
将其移动到该数组中的第二个条目。现在第二个条目本身就是另一个地址，

73
00:07:18,610 --> 00:07:23,250
它指向一个字符串。在汇编程序代码中，我们可以看到这个字符串的地址

74
00:07:23,249 --> 00:07:30,119
从rax指向的位置加载。记住，寄存器周围的括号

75
00:07:30,119 --> 00:07:35,549
意味着寄存器包含一个地址，我们访问存储在

76
00:07:35,550 --> 00:07:40,560
这个地址。好的，下面的RDX现在有地址

77
00:07:40,559 --> 00:07:47,679
我们的绳子开始了。现在我们知道下一行将索引计数器i加载到EAX中。各

78
00:07:47,680 --> 00:07:53,330
ASCII字符大1字节。类似于我们如何移动地址指向

79
00:07:53,330 --> 00:07:57,930
下一个数组条目通过添加8，我们可以将该字符串点移动到下一个字符

80
00:07:57,929 --> 00:08:04,739
加1。所以当我们取计数器i时，它可能有值3，然后加上

81
00:08:04,740 --> 00:08:10,000
它指向指向字符串开头的地址，然后指向第3个

82
00:08:09,999 --> 00:08:15,939
性格。接下来，我们从rax中的当前地址加载1个字节。这就是这个的价值所在

83
00:08:15,939 --> 00:08:21,459
特殊的性格。然后我们将EAX中的这个值添加到偏移量的局部变量中。

84
00:08:21,460 --> 00:08:29,080
-0x18，我们之前设置为0。这是我们的总数！哇。我知道这看起来很乏味而且

85
00:08:29,080 --> 00:08:33,850
令人困惑的。疯狂。但是如果您这样做了几次，并且还调试了这个步骤

86
00:08:33,849 --> 00:08:39,249
一步一步地使用gdb，并查看每个步骤中的寄存器并检查内存地址。

87
00:08:39,250 --> 00:08:45,450
它变得清晰起来。现在我们知道这是一个循环，它覆盖了

88
00:08:45,449 --> 00:08:51,459
并将字符值添加到变量中。当strlen比较分支

89
00:08:51,459 --> 00:08:57,999
换一种方式，我们离开循环，将和与十六进制0x394进行比较。酷！

90
00:08:58,000 --> 00:09:03,470
如果你的大脑在前一部分关闭了，重新打开。我们再来一次

91
00:09:03,470 --> 00:09:09,020
but thismtime you can ignore most of the stuff again and work backwards with educated guesses.

92
00:09:09,019 --> 00:09:14,419
所以你可以看到这个地址和一个特定的值进行比较。那么看看这个值在哪里

93
00:09:14,420 --> 00:09:21,370
来自。啊，这和这个加法有关系。现在可以在

94
00:09:21,370 --> 00:09:28,820
使用ood调试模式。我将使用abcd作为示例键。按P键显示地址，

95
00:09:28,819 --> 00:09:38,079
放置断点。然后使用V！切换到花式模式。然后执行。现在总是

96
00:09:38,079 --> 00:09:45,089
继续：dc并查看添加的寄存器rax。所以在第一个循环中

97
00:09:45,089 --> 00:09:51,539
它是0x41。如果你知道你的ASCII表，你就知道这是大写字母A，你也可以

98
00:09:51,540 --> 00:09:58,010
使用python作为一个方便的工具来回转换。下次是0x42，也就是

99
00:09:58,009 --> 00:10:05,819
A大写B，然后是0x43。所以它显然只是迭代所提供的字符串。看，

100
00:10:05,819 --> 00:10:09,459
now you know that happens, without having to read assembler line by line.

101
00:10:09,459 --> 00:10:15,509
So let’s recreate this in python. Let’s write a function called check key.

102
00:10:15,509 --> 00:10:21,299
它以一个键作为参数。现在我们定义一个字符和并将其设置为0。然后我们循环

103
00:10:21,300 --> 00:10:28,210
在键中包含for c的所有字符上。然后我们将ASCII值与ORD相加。

104
00:10:28,209 --> 00:10:32,549
of c. Then we print the current key and it’s sum.

105
00:10:32,550 --> 00:10:37,340
然后我们把总数退还。现在我们来做一些示例键。与YY

106
00:10:37,339 --> 00:10:43,009
你可以复制一行。用P你可以再粘贴一次。我故意用A，B，C，D是因为

107
00:10:43,009 --> 00:10:46,309
它们的数值总是增加
1.

108
00:10:46,310 --> 00:10:52,410
酷。你可以看到和总是比前一个大1。现在让我们

109
00:10:52,410 --> 00:10:57,990
使用一个非常NAIV的随机keygen来尝试不同的密钥，直到我们找到一个。很明显

110
00:10:57,990 --> 00:11:02,430
由于这个函数的线性行为，使得它更加智能化。但它

111
00:11:02,430 --> 00:11:07,190
仍然看起来很酷。所以导入随机模块并创建一个无止境的

112
00:11:07,190 --> 00:11:11,550
循环。我们的密钥以空字符串开始。现在我们

113
00:11:11,550 --> 00:11:18,650
select a random character from an alphabet with random choice and append it to the key.

114
00:11:18,649 --> 00:11:25,499
现在我们检查一下这把钥匙。如果这个键的和已经太大了，我们重置键并开始

115
00:11:25,500 --> 00:11:29,710
fresh. And if we hit the correct value, we print this key.

116
00:11:29,709 --> 00:11:37,449
I will modify the print in the check_key function to make it look cooler.

117
00:11:37,449 --> 00:11:42,719
现在保存并运行它。哎呀……有点怪……啊……我比较错了

118
00:11:42,720 --> 00:11:48,320
绕道而行。当钥匙已经太大时，我们重新设置钥匙。好吧…

119
00:11:48,319 --> 00:11:54,129
DAMN that is fast. Even though it’s a very bad algorithm, we quickly find many many keys.

120
00:11:54,129 --> 00:12:00,429
让我们看看它们是否有效。哦，是的，他们工作！很酷，是吧？

121
00:12:00,430 --> 00:12:06,960
因此，我们现在已经了解到，我们可以通过使用算法来验证

122
00:12:06,959 --> 00:12:11,479
密钥是有效的。当我们找到

123
00:12:11,480 --> 00:12:18,230
decides if it was valid or not. In our case it’s a simple compare/jump that we can patch.

124
00:12:18,230 --> 00:12:22,240
显然，您可以使这变得更复杂一些，例如，执行不同的许可证密钥签入

125
00:12:22,240 --> 00:12:25,350
places. But generally that’s how you can defeat that.

126
00:12:25,350 --> 00:12:29,780
如果我们喜欢挑战，或者我们不想修补二进制文件，因为无论什么，

127
00:12:29,779 --> 00:12:35,349
您可能需要有效密钥的原因有很多。我们可以使用静态分析和

128
00:12:35,350 --> 00:12:41,660
reverse engineer the license check algorithm and write a keygen to generate valid keys.

129
00:12:41,660 --> 00:12:46,590
显然，这个算法也会变得非常复杂，但是通常如果你在

130
00:12:46,589 --> 00:12:52,309
在里面工作，你可以弄清楚。现在你告诉你的经理，但是他

131
00:12:52,310 --> 00:12:57,340
是个聪明的家伙，他告诉你：“那就阻止人们进行逆向工程。

132
00:12:57,339 --> 00:13:02,699
二进制“。然后你把自己拉回到桌子上，你就想出了一个新的创意。

133
00:13:02,699 --> 00:13:04,699
如何阻止某人调试和反转它

