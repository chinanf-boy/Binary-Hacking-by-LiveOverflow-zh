1
00:00:06,799 --> 00:00:11,329
假设你在一家公司工作，和你的经理很生气，因为外面市场有公司的盗版

2
00:00:11,330 --> 00:00:15,630
他告诉你，要保护公司的知识产权，

3
00:00:15,629 --> 00:00:22,149
使这个程序无法运行。有可能吗？上一视频我说，

4
00:00:22,150 --> 00:00:28,200
每个程序都是易碎的，但那是旧时的我。也许在这期间，我神功大成，我们再试试看。

5
00:00:28,199 --> 00:00:32,459
第一个问题是，验证密钥是在二进制文件中的。

6
00:00:32,460 --> 00:00:35,550
我们有的最简单的技术方法，就是提取所有字符串，然后，我们就发现密钥。

7
00:00:35,550 --> 00:00:36,990
在 Github 上的存储库中，您还可以找到这个验证检查的源代码。

8
00:00:36,989 --> 00:00:41,229
所以，我们第一次尝试，确保不要把安全密钥放在(代码)里面。

9
00:00:41,230 --> 00:00:46,520
我们通过编写一个算法密钥来完成。你也可以提出非常有创意的想法。

10
00:00:46,519 --> 00:00:51,379
然后，你可以给你的安全二进制文件给一个朋友，让他破解它。

11
00:00:51,379 --> 00:00:57,169
或者编写一个 keygen(序列号生成器)。真的会很有趣。我的第一个想法是

12
00:00:57,170 --> 00:01:03,760
简单把密钥的ASCII值加起来，并与一个'魔法'值比较。所以，动手修改原始的程序吧。

13
00:01:03,760 --> 00:01:12,480
首先，我们必须定义一个新的整数值变量，它存储计算出的总和。

14
00:01:12,480 --> 00:01:19,010
所以，"int sum"，并设置为 0。然后我们再补充，带有计数器变量'i'的for循环，

15
00:01:19,010 --> 00:01:25,970
其中, 'i' 从 0 开始，循环条件是，只要，'i'小于密钥的字符串长度，

16
00:01:25,970 --> 00:01:32,310
就继续重复这个循环。这个密钥是通过"argv[1]"提供的。

17
00:01:32,310 --> 00:01:39,320
每次循环，我们会让"i"增加1。现在，我们想要把每个字符的值总和下，

18
00:01:39,320 --> 00:01:48,070
所以就是 "sum += argv[1][i]"。如你所知，计算机只懂数字。所以每个字符，

19
00:01:48,070 --> 00:01:54,500
对应 ASCII表中，是一个数字。但是编译器明白，"argv"是被定义为一个字符序列。

20
00:01:54,500 --> 00:02:00,390
所以像这样，我们将此值强制转换为整数，就不会得到任何(编译器)投诉。

21
00:02:00,390 --> 00:02:05,980
现在，我们想知道，我们原来的密钥总和是多少。

22
00:02:05,980 --> 00:02:17,860
所以，让我们'printf'的格式字符串中，添加作为"%d"参数的'sum'。

23
00:02:17,860 --> 00:02:24,990
现在我们可以编译它了，并使用原始密钥执行。

24
00:02:24,990 --> 00:02:30,170
所以这里是，密钥中所有字符值的总和。让我们再看一遍代码，并更改密钥检查。

25
00:02:30,170 --> 00:02:34,670
我们移除字符串比较，用数字代替原来的字符检查。

26
00:02:34,670 --> 00:02:40,200
删除调试 printf 并尝试。所以这里上面说，密钥错了，

27
00:02:40,200 --> 00:02:45,950
而这里，却说它是一把正确的密钥。现在尝试 strings(命令)，您将无法再找到此密钥。ngs, and you will not find this key anymore.

28
00:02:45,950 --> 00:02:51,120
我们现在，怎么破解这个？让我们用 radare2 打开它，分析一切，

29
00:02:51,120 --> 00:02:57,040
查找 main 函数，并打印反汇编。所以让我们来寻找这里的，成功或失败的信息。et’s look for the Success or Fail message.

30
00:02:57,040 --> 00:03:01,890
然后，我们可以查看分支的源头，找到

31
00:03:01,890 --> 00:03:07,040
密钥是否正确的检查。好吧，这些个 'compare' 和 'jump'，决定了我们是否

32
00:03:07,040 --> 00:03:12,490
打印"Access Granted "或者，错。您还可以看到，比较所使用的 hex 值。 

33
00:03:12,490 --> 00:03:17,630
我喜欢使用，python进行十六进制和十进制之间的转换所以，这就是，我们在 C代码中的确实值。

34
00:03:17,630 --> 00:03:22,820
因此，在调试模式下，再次打开文件，并添加错误的验证密钥。


35
00:03:22,819 --> 00:03:29,399
如果，我们启动该程序，它会说这是错的。很好。现在让我们在，

36
00:03:29,400 --> 00:03:37,370
这个比较(compare)的位置，"db"放一个断点，和在调试模式下重新打开文件。现在 "dc" 继续。

37
00:03:37,370 --> 00:03:47,530
现在我们到达了断点。通过"dr"。你可以看到 rip 是在跳的。

38
00:03:47,530 --> 00:03:55,100
通过"dr rip="，我们可以把 rip 设为我们下一步想执行的地址。

39
00:03:55,099 --> 00:04:00,609
显然我们想要打印成功信息，所以我们又破解了它。好吧，我们已经知道了，如果你能找到

40
00:04:00,610 --> 00:04:05,850
好的，我们已经发现，只要能找到这个比较的位置，不管你有没有有效的验证，你都可以简单绕过它。

41
00:04:05,849 --> 00:04:10,139
当我们可是 hacker啊，我们喜欢挑战。

42
00:04:10,140 --> 00:04:14,550
和只是简单 jump 一下实在太无聊了，所以，让我们写个密钥生成器吧。

43
00:04:14,550 --> 00:04:18,470
先理清思路，我们要把算法反工程。我会在旁边打开源代码，这样

44
00:04:18,470 --> 00:04:24,940
我们就能比较。找到 main 函数，并进入 visual 模式。

45
00:04:24,939 --> 00:04:29,619
因为，从以前的视频，我们对该程序已经有了一定了解。

46
00:04:29,620 --> 00:04:33,130
如果我们提供了一个验证密钥，就可以比较密钥。

47
00:04:33,129 --> 00:04:39,889
然后是"printf"。就像我们的c代码一样。然后，printf 把 sum 设置为0。还有

48
00:04:39,889 --> 00:04:44,939
for循环的，索引计数器初始为 0。你可以在汇编代码，左边看到它

49
00:04:44,939 --> 00:04:51,819
两个地址，被 mov 设为了 0。

50
00:04:51,819 --> 00:04:57,459
和这个地址是用基指针地址计算的。这只是，另一个花哨的寄存器。

51
00:04:57,460 --> 00:05:04,990
然后是第一个变量位置，是 偏移 -0x18 ，并且另一个，嗯，radare 使用名称取代了这个数字，

52
00:05:04,990 --> 00:05:12,050
并称它为"local_2_4"变量，但这个名字背后只是另一个数字。

53
00:05:12,050 --> 00:05:18,310
现在，当我们仔细观察时，我们可以找到一个循环回来的分支。所以

54
00:05:18,309 --> 00:05:24,079
这里的代码块是我们的循环。在for循环的末尾是一个 add 指令，

55
00:05:24,080 --> 00:05:32,030
它将 1 添加到，先前设置为0的本地变量。这是i的增量，

56
00:05:32,029 --> 00:05:45,089
radare 辨识的这个局部变量 是 i。 我们可通过"afvn locale_2_4 i"来重命名。

57
00:05:45,089 --> 00:05:50,729
在这个模块中，我们有一个 strlen 调用。然后我们比较两个寄存器，它要么继续

58
00:05:50,729 --> 00:05:57,899
执行 main 代码块或者离开。 所以这就是，此处的 for循环情况。

59
00:05:57,900 --> 00:06:01,560
如果你以前从来没有见过这个，会有点难看了。但是

60
00:06:01,559 --> 00:06:07,409
如果你练习多了，会容易看。不用担心下一分钟就忘了，

61
00:06:07,409 --> 00:06:13,179
这只需要一些练习。所以，它首先从一个地址加载一个值。

62
00:06:13,180 --> 00:06:19,150
这时，radare会分配出一个名字。这个名字在在 strlen 之前附近出现。

63
00:06:19,150 --> 00:06:25,190
如果你比较这两个汇编程序块，它们是相似的。你可以看到

64
00:06:25,189 --> 00:06:31,109
它把 8 加到了 加载值。所以通常这意味着，加载值是一个地址。

65
00:06:31,110 --> 00:06:35,580
因为我们有64位，我们经常将内存分块成8个字节。

66
00:06:35,580 --> 00:06:41,660
设想一个数组，在内存中，它可能使用多个8字节的块。

67
00:06:41,659 --> 00:06:47,199
第一块，即指向，数组中的第一个值的地址。这意味着

68
00:06:47,199 --> 00:06:53,359
如果您要在数组中，获取第二个值，必须向地址添加 8。现在它指出到数组的第二个项。

69
00:06:53,360 --> 00:06:59,460
这就是 'argv[1]'。记住我们从0开始计数。所以'argv[0]'，将是数组的第一个项。

70
00:06:59,460 --> 00:07:06,170
'argv'基本上是一个变量，它包含一个指向内存中数组的地址。

71
00:07:06,169 --> 00:07:13,379
这个地址被加载到 'rax' 中。然后再加上 8，

72
00:07:13,379 --> 00:07:18,609
会移动到该数组中的第二个项。现在第二个项本身，就是另一个地址，

73
00:07:18,610 --> 00:07:23,250
它指向一个字符串。在汇编程序代码中，从 rax 指向的位置，

74
00:07:23,249 --> 00:07:30,119
我们可以看到这个加载字符串的地址。记住，寄存器周围的括号，

75
00:07:30,119 --> 00:07:35,549
意味着寄存器包含一个地址，我们是在访问存储在这个地址中的值。

76
00:07:35,550 --> 00:07:40,560
好的，现在下面的 rdx , 有我们字符串开头的地址。

77
00:07:40,559 --> 00:07:47,679
现在我们知道下一行，将 索引计数器 'i' 加载到 eax 中。

78
00:07:47,680 --> 00:07:53,330
每个ASCII字符都是1字节的大小。所以，与数组的地址移动，需要添加 8 类似。

79
00:07:53,330 --> 00:07:57,930
我们可以通过加 1 ，将该字符串指针，移动到下一个字符

80
00:07:57,929 --> 00:08:04,739
所以，当我们拿到计数器 'i' 时，它可能有值 3，然后

81
00:08:04,740 --> 00:08:10,000
(若)把它加上，那指向字符串开头地址的指针，就会指向第3个字符。

82
00:08:09,999 --> 00:08:15,939
接下来，我们从 rax 中的当前地址，加载1个字节。这就是这个特定字符的值。

83
00:08:15,939 --> 00:08:21,459
然后我们将eax中的这个值，添加到，我们之前设置为 0，偏移 -0x18 的局部变量中。

84
00:08:21,460 --> 00:08:29,080
这是我们的总和数(sum)！哇。我知道这看起来很乏味，困惑的，

85
00:08:29,080 --> 00:08:33,850
还有疯狂。但是如果您多做几次，并且一步一步地使用 gdb 调试，

86
00:08:33,849 --> 00:08:39,249
并查看每个步骤中的寄存器，并检查内存地址。它会变得清晰起来(迈出一步吧)。

87
00:08:39,250 --> 00:08:45,450
现在我们知道，这是一个循环，它覆盖了字符串中的每个字符，

88
00:08:45,449 --> 00:08:51,459
并将字符值添加到一个变量中。当 strlen 比较(compare)换了另一分支，

89
00:08:51,459 --> 00:08:57,999
我们会离开循环，sum 就与十六进制 0x394 进行比较。酷！

90
00:08:58,000 --> 00:09:03,470
如果，你的大脑在视频前部分关闭了，现在若重新打开。我们再来一次

91
00:09:03,470 --> 00:09:09,020
但这一次，你可以再次忽略大多数东东和，倒回去梳理梳理。

92
00:09:09,019 --> 00:09:14,419
所以你可以看到，这个地址和一个特定的值进行比较。

93
00:09:14,420 --> 00:09:21,370
那么看看这个值来自哪里。啊，这和这个加法有关系。

94
00:09:21,370 --> 00:09:28,820
现在可以使用 ood，重启二进制文件进入调试模式。我将使用 ABCD 作为示例密钥。

95
00:09:28,819 --> 00:09:38,079
按 p  key 显示地址，放置一个断点。然后使用 V！切换到花式模式。然后执行。

96
00:09:38,079 --> 00:09:45,089
现在总 ":dc" 继续，并查看，在增加的寄存器 rax。所以在第一次循环中，

97
00:09:45,089 --> 00:09:51,539
它是0x41。如果你知道ASCII表，你就知道这是大写字母A，

98
00:09:51,540 --> 00:09:58,010
你也可以用python，作为一个方便的转换工具。下次是 0x42，也就是

99
00:09:58,009 --> 00:10:05,819
一个大写B，然后是 0x43。所以，它显然只是迭代，所提供的(密钥)字符串。

100
00:10:05,819 --> 00:10:09,459
看，现在你悟了, 不用一行行看汇编程序。

101
00:10:09,459 --> 00:10:15,509
让我们在 Python中 复刻下。 编写一个函数，叫做 check key。

102
00:10:15,509 --> 00:10:21,299
它以一个 key(密钥)作为参数。现在我们定义一个字符总和(sum)，并将其设置为 0。

103
00:10:21,300 --> 00:10:28,210
然后用"for c in key"，在密钥字符上循环。然后我们将每个 c 的 ascii值，都加sum。

104
00:10:28,209 --> 00:10:32,549
然后，就可以打印当前密钥与它的 sum。

105
00:10:32,550 --> 00:10:37,340
返回 sum 。现在我们来做一些密钥示例。

106
00:10:37,339 --> 00:10:43,009
用 yy 你可以复制一行。用 p 你可以粘贴。

107
00:10:43,009 --> 00:10:46,309
我故意用A，B，C，D，是因为它们的数值(ascii)，相差 1.

108
00:10:46,310 --> 00:10:52,410
酷。你可以看到当前总和，都比前一个，要大 1。

109
00:10:52,410 --> 00:10:57,990
现在让我们使用一个随机keygen，来尝试不同的密钥，直到我们找到一个。

110
00:10:57,990 --> 00:11:02,430
很明显，由于这个函数的线性行为，使得它更加智能化。

111
00:11:02,430 --> 00:11:07,190
但它仍看起来很酷。所以导入随机模块，并创建一个无止境的循环。

112
00:11:07,190 --> 00:11:11,550
我们的密钥，是以空字符串开始的。

113
00:11:11,550 --> 00:11:18,650
现在，我们从字母表，随缘选择一个随机字符，再把它加入到密钥。

114
00:11:18,649 --> 00:11:25,499
现在，我们检查一下这密钥。如果这个 key  的 sum 已经太大了，我们重置 key 并重新开始。

115
00:11:25,500 --> 00:11:29,710
且当我们找到正确的密钥, 我们把它打印出来。

116
00:11:29,709 --> 00:11:37,449
在 check_key 函数中，我会修改修改，让它更好看。

117
00:11:37,449 --> 00:11:42,719
现在保存并运行它。哎呀，有点怪…，啊… 我走向了错误的比较结果。

118
00:11:42,720 --> 00:11:48,320
当密钥已经太大时，我们重新设置密钥。好吧…

119
00:11:48,319 --> 00:11:54,129
我去，真快。虽然这是个不好的算法, 但我们还是以很快的速度找了很多的 key。

120
00:11:54,129 --> 00:12:00,429
让我们看看，它们是否有效。哦，是的，工作了！很酷，是吧？

121
00:12:00,430 --> 00:12:06,960
因此，我们现在已经了解到，我们可以用算法隐藏密钥，再验证(用户的)密钥是否有效。

122
00:12:06,959 --> 00:12:11,479
但是啊，当我们能通过汇编代码，找到正确的密钥时，这个套路就不管用了。

123
00:12:11,480 --> 00:12:18,230
在这种情况，我们能做的，就是对简单的 compare/jump 修修补补。

124
00:12:18,230 --> 00:12:22,240
显然，您可以使这变得更复杂一些，例如，在多个地方，执行不同的验证密钥。

125
00:12:22,240 --> 00:12:25,350
但，最终，你总能打败它(这种套路)。

126
00:12:25,350 --> 00:12:29,780
如果我们喜欢挑战，或者无论如何，我们都不想对二进制文件修修补补。

127
00:12:29,779 --> 00:12:35,349
需要有效密钥的原因有很多。

128
00:12:35,350 --> 00:12:41,660
具体手段，可以使用静态分析和对验证算法反工程，以及编写密钥生成器。

129
00:12:41,660 --> 00:12:46,590
显然，这个算法也会变得非常复杂，但是

130
00:12:46,589 --> 00:12:52,309
若专心致志地破解，你通过可以弄到(密钥)。现在你可以告诉你的经理啦，但是，

131
00:12:52,310 --> 00:12:57,340
若他是个聪明的家伙，他告诉你：“那就阻止人们对二进制文件，进行反工程"。

132
00:12:57,339 --> 00:13:02,699
然后，你把自己拉回到桌子上，和你就想出了

133
00:13:02,699 --> 00:13:04,699
一个新的，如何阻止某人调试和'反'它的创意。

