1
00:00:06,399 --> 00:00:12,269
在上一集中，我们通过覆盖

2
00:00:12,269 --> 00:00:17,069
堆栈上的返回指针并跳转到我们放置在堆栈上的shellcode

3
00:00:17,070 --> 00:00:18,320
as well.

4
00:00:18,320 --> 00:00:23,760
在本集中，我们将查看第6层堆栈，它将查看当您

5
00:00:23,759 --> 00:00:25,789
restrictions on the return address.

6
00:00:25,789 --> 00:00:31,239
要理解此视频，您必须了解正常缓冲区溢出和跳至

7
00:00:31,240 --> 00:00:32,370
shellcode works.

8
00:00:32,369 --> 00:00:35,369
I hope I explained it well enough in the past videos.

9
00:00:35,370 --> 00:00:38,950
But if there are still open questions, please post them on reddit.

10
00:00:38,949 --> 00:00:42,319
I really need you to have understood that stuff.

11
00:00:42,320 --> 00:00:44,840
作为提示，这个水平告诉我们，

12
00:00:44,840 --> 00:00:49,730
这个级别可以用两种方法完成，例如查找有效负载的副本

13
00:00:49,730 --> 00:00:55,680
(objdump -s), or ret2libc, or even return orientated programming.

14
00:00:55,680 --> 00:00:59,730
In this video we will not be able to explore return oriented programming.

15
00:00:59,730 --> 00:01:04,850
但是我会给你看一些其他的技巧，最终会导致回归导向

16
00:01:04,850 --> 00:01:05,850
programming.

17
00:01:05,850 --> 00:01:07,420
So let’s have a look at the source code.

18
00:01:07,420 --> 00:01:12,860
And again, it’s very similar to the previous levels, just some small changes.

19
00:01:12,860 --> 00:01:18,130
Instead of everything being in main, main calls this function get_path.

20
00:01:18,130 --> 00:01:21,700
Get path allocates a string buffer for 64 characters.

21
00:01:21,700 --> 00:01:23,440
Then reads a string with gets.

22
00:01:23,440 --> 00:01:28,550
我们现在都知道，用get我们可以任意地读许多字符，我们

23
00:01:28,550 --> 00:01:31,310
can use to overwrite the return pointer on the stack.

24
00:01:31,310 --> 00:01:33,480
But the next line is interesting.

25
00:01:33,480 --> 00:01:38,460
_ builtin返回地址是编译器中的一个函数，您可以使用它来读取

26
00:01:38,460 --> 00:01:40,630
current return address from the stack.

27
00:01:40,630 --> 00:01:45,990
And this return address is checked if it starts with hex 0xbf.

28
00:01:45,990 --> 00:01:49,230
The ampersand performs a bitwise AND with the address.

29
00:01:49,230 --> 00:01:53,560
After that only the part where they were same survives.

30
00:01:53,560 --> 00:01:55,520
basically setting the remaining bits to 0.

31
00:01:55,520 --> 00:01:58,500
And checking if the front is still hex bf.

32
00:01:58,500 --> 00:02:05,070
If the return address starts with 0xbf, it prints this return address and exits.

33
00:02:05,070 --> 00:02:06,830
When we use our exploit from last time.

34
00:02:06,830 --> 00:02:11,150
并调整填充以解释这个函数中新的无符号int，我们看到

35
00:02:11,150 --> 00:02:12,750
that it doesn’t work.

36
00:02:12,750 --> 00:02:14,410
It fails with bzzzt.

37
00:02:14,409 --> 00:02:15,409
Ok.

38
00:02:15,409 --> 00:02:19,389
So we cannot use addresses that start with hex bf.

39
00:02:19,389 --> 00:02:22,579
The exit protects this function from being exploited that way.

40
00:02:22,579 --> 00:02:25,799
Because the exit is a syscall that simply quits the program.

41
00:02:25,799 --> 00:02:30,629
So even though we have smashed the return pointer, this function will never return.

42
00:02:30,629 --> 00:02:35,879
所以你可以看到，即使有一个缓冲区溢出也不一定意味着你可以

43
00:02:35,879 --> 00:02:37,099
exploit it.

44
00:02:37,099 --> 00:02:41,909
当我们现在在gdb中打开这个级别时，在getpath处中断，运行它，然后查看映射的

45
00:02:41,909 --> 00:02:43,919
memory with `info proc map`.

46
00:02:43,920 --> 00:02:48,690
We can see that the only addresses that start with bf are on the stack.

47
00:02:48,689 --> 00:02:52,109
So basically we cannot return to a stack address.

48
00:02:52,109 --> 00:02:57,829
这太疯狂了，如果我们不能返回到堆栈中

49
00:02:57,829 --> 00:02:59,379
放置我们的代码？

50
00:02:59,379 --> 00:03:01,989
So first of all, we can still control the return pointer.

51
00:03:01,989 --> 00:03:04,119
As long as it doesn’t start with bf.

52
00:03:04,120 --> 00:03:08,620
And now comes this sick idea, of returning into known code.

53
00:03:08,620 --> 00:03:10,140
Let’s think about this.

54
00:03:10,140 --> 00:03:15,730
返回指令只查看堆栈顶部的当前地址，将其移除，然后

55
00:03:15,730 --> 00:03:17,280
just jumps there.

56
00:03:17,279 --> 00:03:24,309
… What would happen if you return to the address 0x080484f9.

57
00:03:24,310 --> 00:03:27,240
Which is the return instruction itself.

58
00:03:27,239 --> 00:03:28,239
Think about this.

59
00:03:28,239 --> 00:03:32,279
We overwrite the return pointer with hex 0x080.

60
00:03:32,279 --> 00:03:37,499
We reach the return instruction, it will pop this address from the stack and jump to it.

61
00:03:37,500 --> 00:03:39,360
Basically just jump to itself.

62
00:03:39,360 --> 00:03:44,130
And now it will read the next address on the stack and jump there.

63
00:03:44,129 --> 00:03:45,589
Now you could repeat that.

64
00:03:45,590 --> 00:03:48,260
Make the next address on the stack again 0x080.

65
00:03:48,260 --> 00:03:51,540
Or place the address of the stack here.

66
00:03:51,540 --> 00:03:53,210
And we can return into the stack again.

67
00:03:53,209 --> 00:03:55,599
And in theory that should work.

68
00:03:55,599 --> 00:03:59,669
Because the original return address got overwritten with an address that starts with 0x080.

69
00:03:59,670 --> 00:04:02,350
Ok let’s try that.

70
00:04:02,349 --> 00:04:04,439
let’s modify our exploit code.

71
00:04:04,439 --> 00:04:08,659
Instead of the shellcode let’s use int 3, CC instruction again.

72
00:04:08,659 --> 00:04:09,729
For a trap.

73
00:04:09,730 --> 00:04:13,710
我们现在都知道，当我们攻击它们时，我们有代码执行，我们只需要找到

74
00:04:13,709 --> 00:04:14,789
suitable shellcode.

75
00:04:14,790 --> 00:04:17,720
So let’s focus on the interesting part.

76
00:04:17,720 --> 00:04:23,590
Set a breakpoint at the return of getpath, and then run it with our exploit input.

77
00:04:23,590 --> 00:04:24,590
We hit the breakpoint.

78
00:04:24,590 --> 00:04:27,020
And we got past the return pointer check.

79
00:04:27,020 --> 00:04:29,140
So let’s look at the stack ourselves.

80
00:04:29,139 --> 00:04:34,589
We can see that the address on top of the stack is now the 0x080.

81
00:04:34,590 --> 00:04:36,400
Which is the return instruction.

82
00:04:36,400 --> 00:04:38,280
So now single step forward.

83
00:04:38,280 --> 00:04:40,960
This should pop this address from the stack and jump there.

84
00:04:40,960 --> 00:04:41,970
And indeed.

85
00:04:41,970 --> 00:04:46,230
We hit the breakpoint again, because we jumped to itself.

86
00:04:46,230 --> 00:04:50,720
When you now look at the stack, the next address on the stack is the stack address.

87
00:04:50,720 --> 00:04:53,340
And we will return into this address now.

88
00:04:53,340 --> 00:04:58,810
因此，当我们继续时，我们将返回到堆栈中，就像在前面的漏洞中一样，

89
00:04:58,810 --> 00:05:00,430
we hit our traps.

90
00:05:00,430 --> 00:05:01,430
繁荣！

91
00:05:01,430 --> 00:05:03,030
任意代码执行！

92
00:05:03,030 --> 00:05:04,030
By the way.

93
00:05:04,030 --> 00:05:07,360
This address where we jumped to, the 0x080 is a gadget.

94
00:05:07,360 --> 00:05:11,200
When you read about return oriented programming, you are looking for gadgets.

95
00:05:11,199 --> 00:05:13,649
And that was a simple no operation gadget.

96
00:05:13,650 --> 00:05:15,900
It was just a return, doing nothing.

97
00:05:15,900 --> 00:05:20,620
对于全回报导向的编程，你会寻找能做更多事情的小工具，

98
00:05:20,620 --> 00:05:22,430
before returning to the next address.

99
00:05:22,430 --> 00:05:28,300
Now when we do this kind of stuff, you hear me saying “return into”, or “jump to”.

100
00:05:28,300 --> 00:05:30,590
Those become equivalent in this case.

101
00:05:30,590 --> 00:05:35,860
因为是的，我们执行一个返回指令，但不返回到原始函数

102
00:05:35,860 --> 00:05:36,860
anymore.

103
00:05:36,860 --> 00:05:39,310
We are returning into something else.

104
00:05:39,310 --> 00:05:41,980
Effectively just jumping somewhere else.

105
00:05:41,979 --> 00:05:55,589
So I hope that doesn’t confuse you.

106
00:05:55,590 --> 00:06:04,630
Let’s have a look at another trick.

107
00:06:04,629 --> 00:06:22,249
It’s very similar to what we did in stack level 4.

108
00:06:22,250 --> 00:06:25,480
So where else could we jump to.

109
00:06:25,480 --> 00:06:52,840
其中之一

110
00:06:52,840 --> 00:06:56,350
hints said we could look into ret2libc.

111
00:06:56,350 --> 00:07:03,330
Now that you are almost a pro in exploitation, you understand what that means.

112
00:07:03,330 --> 00:07:04,970
Return into libc.

113
00:07:04,970 --> 00:07:09,990
Like we just returned into some code, we could also return into the huge library libc.

114
00:07:09,990 --> 00:07:13,990
There must be something interesting that we could abuse.

115
00:07:13,990 --> 00:07:16,860
One interesting function from libc is system.

116
00:07:16,860 --> 00:07:19,470
Which executes a shell command.

117
00:07:19,470 --> 00:07:22,150
With print system, we can find the address of it.

118
00:07:22,150 --> 00:07:25,100
But simply returning into it will probably not work.

119
00:07:25,100 --> 00:07:28,080
We need to make sure to control a couple of things.

120
00:07:28,080 --> 00:07:32,430
Let’s create a simple C program that calls the libc system for us.

121
00:07:32,430 --> 00:07:36,170
In the end we want to somehow execute system with /bin/sh.

122
00:07:36,169 --> 00:07:39,349
Because then we get a shell.

123
00:07:39,349 --> 00:07:41,339
If we try that here, that works well.

124
00:07:41,340 --> 00:07:43,540
Now let’s look at this in gdb.

125
00:07:43,539 --> 00:07:49,069
我们可以看到，在调用系统之前，我们要执行的命令的地址

126
00:07:49,069 --> 00:07:51,279
is put on top of the stack.

127
00:07:51,280 --> 00:07:56,010
如我们所知，对函数的调用将把返回地址作为

128
00:07:56,009 --> 00:07:57,009
well.

129
00:07:57,009 --> 00:08:01,159
因此，如果我们画出这个，这就是当我们开始时堆栈的样子。

130
00:08:01,159 --> 00:08:02,289
system.

131
00:08:02,289 --> 00:08:04,729
First the address of the command is placed on the stack.

132
00:08:04,729 --> 00:08:08,689
And then the address we want to return to.

133
00:08:08,690 --> 00:08:12,640
Now imagine if we use our buffer overflow to return into system.

134
00:08:12,639 --> 00:08:15,769
Firstof all we didn’t execute a call instruction.

135
00:08:15,770 --> 00:08:18,620
Thus there was no return address pushed.

136
00:08:18,620 --> 00:08:20,760
But we fully control the stack.

137
00:08:20,759 --> 00:08:24,139
So system expects the stack to look like this.

138
00:08:24,139 --> 00:08:25,969
我们可以手工建造！

139
00:08:25,970 --> 00:08:29,800
So first we have to put the return address for system on the stack.

140
00:08:29,800 --> 00:08:32,680
But actually we don’t care about this right now.

141
00:08:32,680 --> 00:08:35,370
But that is still cool and important, and remember that.

142
00:08:35,370 --> 00:08:38,040
Because you can chain those things together.

143
00:08:38,039 --> 00:08:43,669
就像我们以前一个接一个地链接了两个返回，我们可以链接多个函数调用

144
00:08:43,669 --> 00:08:48,769
或其他小工具，通过始终控制下一个的返回指针

145
00:08:48,770 --> 00:08:49,770
step.

146
00:08:49,770 --> 00:08:55,390
所以在我们的例子中，当系统完成时，我们会遇到一个segfault，因为它会返回

147
00:08:55,390 --> 00:08:57,400
into 0x41414141.

148
00:08:57,400 --> 00:09:03,010
the next address on the stack has to be a string we want to execute.

149
00:09:03,010 --> 00:09:05,250
Preferably “/bin/sh”.

150
00:09:05,250 --> 00:09:08,280
There are many options how to get a reference to such a string.

151
00:09:08,280 --> 00:09:10,460
one option would be to use a stack address.

152
00:09:10,460 --> 00:09:11,900
Because there are strings we control.

153
00:09:11,900 --> 00:09:13,930
Or environment variables.

154
00:09:13,930 --> 00:09:16,680
Because they are at the bottom of the stack and a bit easier to predict.

155
00:09:16,680 --> 00:09:20,150
But as you remember, the stack is a bit unreliable and shifting around.

156
00:09:20,150 --> 00:09:22,920
A more reliable technique is this here.

157
00:09:22,920 --> 00:09:27,880
We can use find to search in the mapped memory of libc for a string.

158
00:09:27,880 --> 00:09:30,970
Cool, apparently at this address we can find /bin/sh.

159
00:09:30,970 --> 00:09:33,390
Let’s check if that is true.

160
00:09:33,390 --> 00:09:35,620
Examine memory as string at this address.

161
00:09:35,620 --> 00:09:36,620
令人惊叹的！

162
00:09:36,620 --> 00:09:37,950
What the frak! gdb.

163
00:09:37,950 --> 00:09:39,720
What the hell are you doing.

164
00:09:39,720 --> 00:09:43,390
你为什么说你在那里找到了垃圾桶，如果没有呢？

165
00:09:43,390 --> 00:09:45,800
I have no idea why this happens.

166
00:09:45,800 --> 00:09:47,300
Couldn’t find anything online.

167
00:09:47,300 --> 00:09:48,300
Anyway.

168
00:09:48,300 --> 00:09:49,300
Ignore this.

169
00:09:49,300 --> 00:09:50,300
Here is another technique.

170
00:09:50,300 --> 00:09:53,940
We can use strings to find all strings in libc.

171
00:09:53,940 --> 00:09:58,160
And with -t we can print the offset inside this file as hex.

172
00:09:58,160 --> 00:10:02,450
And then we can simply add this offset to the address libc is loaded to.

173
00:10:02,450 --> 00:10:05,070
And that is the real address of /bin/sh.

174
00:10:05,070 --> 00:10:07,620
Ok so let’s copy this address into our exploit.

175
00:10:07,620 --> 00:10:11,250
And then let’s try it.

176
00:10:11,250 --> 00:10:15,210
Remember to use the trick from the previous video with the parenthesis and cat.

177
00:10:15,210 --> 00:10:18,450
Because the exploit script will close the input again.

178
00:10:18,450 --> 00:10:19,450
酷！

179
00:10:19,450 --> 00:10:20,450
It works.

180
00:10:20,450 --> 00:10:23,200
What we just did was the technique called ret2libc.

181
00:10:23,200 --> 00:10:25,440
我们从未在堆栈上执行过任何代码！

182
00:10:25,441 --> 00:10:26,441
Maybe you ask yourself why the hell the stack was executable in the first place.

183
00:10:26,441 --> 00:10:27,441
There is no valid reason why the stack should be executable.

184
00:10:27,441 --> 00:10:28,441
That’s why there exists a general memory policy nowadays.

185
00:10:28,441 --> 00:10:29,441
Write xor Execute.

186
00:10:29,441 --> 00:10:30,441
Basically it means, never have a memory page that is writeable AND executable.

187
00:10:30,441 --> 00:10:31,441
因为这样攻击者就不能执行他能够在

188
00:10:31,441 --> 00:10:32,441
process memory.

189
00:10:32,441 --> 00:10:33,441
因此，我们希望今天每个现代系统都使用DEP、数据执行预防和集合

190
00:10:33,441 --> 00:10:34,441
the NX bit, the non executable bit for memory pages like the stack.

191
00:10:34,441 --> 00:10:35,441
But reality is not so simple.

192
00:10:35,441 --> 00:10:36,441
随着物联网的兴起，嵌入式设备也在兴起，但它们通常不会

193
00:10:36,441 --> 00:10:37,441
support features like that.

194
00:10:37,441 --> 00:10:38,441
Or modern programming languages like javascript use JIT.

195
00:10:38,441 --> 00:10:39,441
Just in time compiler.

196
00:10:39,441 --> 00:10:40,441
So they have to compile code on the fly in memory when needed and execute that.

197
00:10:40,441 --> 00:10:41,441
So they need writeable and executable memory regions.

198
00:10:41,441 --> 00:10:42,441
但是，即使我们有DEP，我们也可以使用像ret2libc这样的技术来从不执行实际的shellcode，

199
00:10:42,441 --> 00:10:43,441
but still pwn a system.

200
00:10:43,441 --> 00:10:44,441
And at some point in the future, I will make a video about return oriented programming.

201
00:10:44,441 --> 00:10:44,451
Which is the next advanced step for this kind of technique.

