1
00:00:06,399 --> 00:00:12,269
在上一集中，我们通过覆盖

2
00:00:12,269 --> 00:00:17,069
堆栈上的返回指针并跳转到我们放置在堆栈上的shellcode

3
00:00:17,070 --> 00:00:18,320
也。

4
00:00:18,320 --> 00:00:23,760
在本集中，我们将查看第6层堆栈，它将查看当您

5
00:00:23,759 --> 00:00:25,789
对寄信人地址的限制。

6
00:00:25,789 --> 00:00:31,239
要理解此视频，您必须了解正常缓冲区溢出和跳至

7
00:00:31,240 --> 00:00:32,370
Shellcode工作。

8
00:00:32,369 --> 00:00:35,369
我希望我在过去的视频中解释得足够好。

9
00:00:35,370 --> 00:00:38,950
但如果还有未解决的问题，请将其张贴在Reddit上。

10
00:00:38,949 --> 00:00:42,319
我真的需要你理解那些东西。

11
00:00:42,320 --> 00:00:44,840
作为提示，这个水平告诉我们，

12
00:00:44,840 --> 00:00:49,730
这个级别可以用两种方法完成，例如查找有效负载的副本

13
00:00:49,730 --> 00:00:55,680
（objdump-s），或ret2libc，甚至返回定向编程。

14
00:00:55,680 --> 00:00:59,730
在本视频中，我们将无法探索面向返回的编程。

15
00:00:59,730 --> 00:01:04,850
但是我会给你看一些其他的技巧，最终会导致回归导向

16
00:01:04,850 --> 00:01:05,850
编程。

17
00:01:05,850 --> 00:01:07,420
让我们来看一下源代码。

18
00:01:07,420 --> 00:01:12,860
同样，它与之前的水平非常相似，只是一些小的变化。

19
00:01:12,860 --> 00:01:18,130
不是所有东西都在主目录中，主目录调用这个函数get_path。

20
00:01:18,130 --> 00:01:21,700
get path为64个字符分配字符串缓冲区。

21
00:01:21,700 --> 00:01:23,440
然后用get读取字符串。

22
00:01:23,440 --> 00:01:28,550
我们现在都知道，用get我们可以任意地读许多字符，我们

23
00:01:28,550 --> 00:01:31,310
可用于覆盖堆栈上的返回指针。

24
00:01:31,310 --> 00:01:33,480
但下一行很有趣。

25
00:01:33,480 --> 00:01:38,460
_ builtin返回地址是编译器中的一个函数，您可以使用它来读取

26
00:01:38,460 --> 00:01:40,630
堆栈中的当前返回地址。

27
00:01:40,630 --> 00:01:45,990
如果返回地址以hex 0xbf开头，则检查该返回地址。

28
00:01:45,990 --> 00:01:49,230
和号对地址执行位“与”。

29
00:01:49,230 --> 00:01:53,560
在那之后，只有他们相同的部分存活下来。

30
00:01:53,560 --> 00:01:55,520
基本上将剩余的位设置为0。

31
00:01:55,520 --> 00:01:58,500
检查前面是否仍然是六角高炉。

32
00:01:58,500 --> 00:02:05,070
如果返回地址以0xBF开头，则打印此返回地址并退出。

33
00:02:05,070 --> 00:02:06,830
当我们使用上次的漏洞时。

34
00:02:06,830 --> 00:02:11,150
并调整填充以解释这个函数中新的无符号int，我们看到

35
00:02:11,150 --> 00:02:12,750
它不起作用。

36
00:02:12,750 --> 00:02:14,410
BZZT失败了。

37
00:02:14,409 --> 00:02:15,409
好啊。

38
00:02:15,409 --> 00:02:19,389
所以我们不能使用以hex-bf开头的地址。

39
00:02:19,389 --> 00:02:22,579
出口保护这个功能不被这样利用。

40
00:02:22,579 --> 00:02:25,799
因为exit是一个系统调用，只需退出程序。

41
00:02:25,799 --> 00:02:30,629
所以即使我们破坏了返回指针，这个函数也不会返回。

42
00:02:30,629 --> 00:02:35,879
所以你可以看到，即使有一个缓冲区溢出也不一定意味着你可以

43
00:02:35,879 --> 00:02:37,099
利用它。

44
00:02:37,099 --> 00:02:41,909
当我们现在在gdb中打开这个级别时，在getpath处中断，运行它，然后查看映射的

45
00:02:41,909 --> 00:02:43,919
内存中有“info proc map”。

46
00:02:43,920 --> 00:02:48,690
我们可以看到，只有以bf开头的地址在堆栈上。

47
00:02:48,689 --> 00:02:52,109
所以基本上我们不能返回到堆栈地址。

48
00:02:52,109 --> 00:02:57,829
这太疯狂了，如果我们不能返回到堆栈中

49
00:02:57,829 --> 00:02:59,379
放置我们的代码？

50
00:02:59,379 --> 00:03:01,989
所以首先，我们仍然可以控制返回指针。

51
00:03:01,989 --> 00:03:04,119
只要不是从男朋友开始。

52
00:03:04,120 --> 00:03:08,620
现在出现了一个病态的想法，回到已知的代码中。

53
00:03:08,620 --> 00:03:10,140
让我们想想这个。

54
00:03:10,140 --> 00:03:15,730
返回指令只查看堆栈顶部的当前地址，将其移除，然后

55
00:03:15,730 --> 00:03:17,280
就跳到那里。

56
00:03:17,279 --> 00:03:24,309
…如果您返回地址0x080484f9会发生什么。

57
00:03:24,310 --> 00:03:27,240
这是返回指令本身。

58
00:03:27,239 --> 00:03:28,239
想想这个。

59
00:03:28,239 --> 00:03:32,279
我们用十六进制0x080覆盖返回指针。

60
00:03:32,279 --> 00:03:37,499
我们到达返回指令，它将从堆栈中弹出这个地址并跳转到它。

61
00:03:37,500 --> 00:03:39,360
基本上就是跳到自己身上。

62
00:03:39,360 --> 00:03:44,130
现在它将读取堆栈上的下一个地址并跳到那里。

63
00:03:44,129 --> 00:03:45,589
现在你可以重复一遍。

64
00:03:45,590 --> 00:03:48,260
再次将堆栈上的下一个地址设置为0x080。

65
00:03:48,260 --> 00:03:51,540
或者把栈的地址放在这里。

66
00:03:51,540 --> 00:03:53,210
我们可以再次回到堆栈中。

67
00:03:53,209 --> 00:03:55,599
从理论上讲，这是可行的。

68
00:03:55,599 --> 00:03:59,669
因为原始返回地址被以0x080开头的地址覆盖。

69
00:03:59,670 --> 00:04:02,350
好吧，我们试试看。

70
00:04:02,349 --> 00:04:04,439
让我们修改我们的漏洞代码。

71
00:04:04,439 --> 00:04:08,659
我们不再使用shellcode，而是使用int 3，cc指令。

72
00:04:08,659 --> 00:04:09,729
陷阱。

73
00:04:09,730 --> 00:04:13,710
我们现在都知道，当我们攻击它们时，我们有代码执行，我们只需要找到

74
00:04:13,709 --> 00:04:14,789
合适的外壳代码。

75
00:04:14,790 --> 00:04:17,720
所以让我们集中在有趣的部分。

76
00:04:17,720 --> 00:04:23,590
在getpath的返回处设置一个断点，然后使用我们的漏洞输入运行它。

77
00:04:23,590 --> 00:04:24,590
我们到达了断点。

78
00:04:24,590 --> 00:04:27,020
我们通过了返回指针检查。

79
00:04:27,020 --> 00:04:29,140
那么让我们自己来看看这个堆栈。

80
00:04:29,139 --> 00:04:34,589
我们可以看到堆栈顶部的地址现在是0x080。

81
00:04:34,590 --> 00:04:36,400
这是返回指令。

82
00:04:36,400 --> 00:04:38,280
所以现在向前迈出一步。

83
00:04:38,280 --> 00:04:40,960
这应该从堆栈中弹出这个地址并跳转到那里。

84
00:04:40,960 --> 00:04:41,970
确实如此。

85
00:04:41,970 --> 00:04:46,230
我们又碰到了断点，因为我们跳到了自己身上。

86
00:04:46,230 --> 00:04:50,720
现在查看堆栈时，堆栈上的下一个地址是堆栈地址。

87
00:04:50,720 --> 00:04:53,340
我们现在就回这个地址。

88
00:04:53,340 --> 00:04:58,810
因此，当我们继续时，我们将返回到堆栈中，就像在前面的漏洞中一样，

89
00:04:58,810 --> 00:05:00,430
我们击中了陷阱。

90
00:05:00,430 --> 00:05:01,430
繁荣！

91
00:05:01,430 --> 00:05:03,030
任意代码执行！

92
00:05:03,030 --> 00:05:04,030
顺便说一句。

93
00:05:04,030 --> 00:05:07,360
我们跳到的这个地址，0x080是一个小工具。

94
00:05:07,360 --> 00:05:11,200
当你读到关于面向返回的编程时，你在寻找小工具。

95
00:05:11,199 --> 00:05:13,649
这是一个简单的禁止操作的小工具。

96
00:05:13,650 --> 00:05:15,900
这只是一种回报，什么都不做。

97
00:05:15,900 --> 00:05:20,620
对于全回报导向的编程，你会寻找能做更多事情的小工具，

98
00:05:20,620 --> 00:05:22,430
在返回下一个地址之前。

99
00:05:22,430 --> 00:05:28,300
现在当我们做这种事情的时候，你听到我说“回到”，或者“跳到”。

100
00:05:28,300 --> 00:05:30,590
在这种情况下，它们是等价的。

101
00:05:30,590 --> 00:05:35,860
因为是的，我们执行一个返回指令，但不返回到原始函数

102
00:05:35,860 --> 00:05:36,860
不再。

103
00:05:36,860 --> 00:05:39,310
我们又回到了别的地方。

104
00:05:39,310 --> 00:05:41,980
实际上只是跳到别的地方。

105
00:05:41,979 --> 00:05:55,589
所以我希望这不会让你困惑。

106
00:05:55,590 --> 00:06:04,630
让我们看一看另一个技巧。

107
00:06:04,629 --> 00:06:22,249
这与我们在第4层堆栈中所做的非常相似。

108
00:06:22,250 --> 00:06:25,480
那么我们还能跳到哪里呢？

109
00:06:25,480 --> 00:06:52,840
其中之一

110
00:06:52,840 --> 00:06:56,350
提示说我们可以调查ret2libc。

111
00:06:56,350 --> 00:07:03,330
既然你几乎是剥削的行家，你就明白这意味着什么了。

112
00:07:03,330 --> 00:07:04,970
返回libc。

113
00:07:04,970 --> 00:07:09,990
就像我们刚刚返回到一些代码中一样，我们也可以返回到巨大的libc库中。

114
00:07:09,990 --> 00:07:13,990
一定有什么有趣的东西我们可以滥用。

115
00:07:13,990 --> 00:07:16,860
libc中一个有趣的函数是system。

116
00:07:16,860 --> 00:07:19,470
执行shell命令。

117
00:07:19,470 --> 00:07:22,150
通过打印系统，我们可以找到它的地址。

118
00:07:22,150 --> 00:07:25,100
但是简单地回到它里面可能不会起作用。

119
00:07:25,100 --> 00:07:28,080
我们需要确保控制一些事情。

120
00:07:28,080 --> 00:07:32,430
让我们创建一个简单的C程序，它为我们调用libc系统。

121
00:07:32,430 --> 00:07:36,170
最后，我们希望以某种方式使用/bin/sh执行系统。

122
00:07:36,169 --> 00:07:39,349
因为这样我们就有了外壳。

123
00:07:39,349 --> 00:07:41,339
如果我们在这里试一下，效果很好。

124
00:07:41,340 --> 00:07:43,540
现在让我们看看gdb中的这个。

125
00:07:43,539 --> 00:07:49,069
我们可以看到，在调用系统之前，我们要执行的命令的地址

126
00:07:49,069 --> 00:07:51,279
放在堆栈的顶部。

127
00:07:51,280 --> 00:07:56,010
如我们所知，对函数的调用将把返回地址作为

128
00:07:56,009 --> 00:07:57,009
好。

129
00:07:57,009 --> 00:08:01,159
因此，如果我们画出这个，这就是当我们开始时堆栈的样子。

130
00:08:01,159 --> 00:08:02,289
系统。

131
00:08:02,289 --> 00:08:04,729
首先，命令的地址放在堆栈上。

132
00:08:04,729 --> 00:08:08,689
然后我们要返回的地址。

133
00:08:08,690 --> 00:08:12,640
现在想象一下，如果我们使用缓冲区溢出返回到系统中。

134
00:08:12,639 --> 00:08:15,769
首先，我们没有执行调用指令。

135
00:08:15,770 --> 00:08:18,620
因此没有推送返回地址。

136
00:08:18,620 --> 00:08:20,760
但是我们完全控制了堆栈。

137
00:08:20,759 --> 00:08:24,139
所以系统希望堆栈看起来像这样。

138
00:08:24,139 --> 00:08:25,969
我们可以手工建造！

139
00:08:25,970 --> 00:08:29,800
所以首先我们必须将系统的返回地址放在堆栈上。

140
00:08:29,800 --> 00:08:32,680
但实际上我们现在不在乎这个。

141
00:08:32,680 --> 00:08:35,370
但这仍然很酷也很重要，记住这一点。

142
00:08:35,370 --> 00:08:38,040
因为你可以把这些东西连在一起。

143
00:08:38,039 --> 00:08:43,669
就像我们以前一个接一个地链接了两个返回，我们可以链接多个函数调用

144
00:08:43,669 --> 00:08:48,769
或其他小工具，通过始终控制下一个的返回指针

145
00:08:48,770 --> 00:08:49,770
步骤。

146
00:08:49,770 --> 00:08:55,390
所以在我们的例子中，当系统完成时，我们会遇到一个segfault，因为它会返回

147
00:08:55,390 --> 00:08:57,400
进入0x41414141。

148
00:08:57,400 --> 00:09:03,010
堆栈上的下一个地址必须是要执行的字符串。

149
00:09:03,010 --> 00:09:05,250
最好是“/bin/sh”。

150
00:09:05,250 --> 00:09:08,280
如何获取对此类字符串的引用有许多选项。

151
00:09:08,280 --> 00:09:10,460
一种选择是使用堆栈地址。

152
00:09:10,460 --> 00:09:11,900
因为有我们控制的字符串。

153
00:09:11,900 --> 00:09:13,930
或环境变量。

154
00:09:13,930 --> 00:09:16,680
因为它们位于堆栈的底部，并且更容易预测。

155
00:09:16,680 --> 00:09:20,150
但是，正如您所记得的，这个堆栈有点不可靠，而且会四处移动。

156
00:09:20,150 --> 00:09:22,920
这里有一种更可靠的技术。

157
00:09:22,920 --> 00:09:27,880
我们可以使用find在libc的映射内存中搜索字符串。

158
00:09:27,880 --> 00:09:30,970
很酷，显然在这个地址我们可以找到/bin/sh。

159
00:09:30,970 --> 00:09:33,390
我们来看看这是不是真的。

160
00:09:33,390 --> 00:09:35,620
在此地址以字符串形式检查内存。

161
00:09:35,620 --> 00:09:36,620
令人惊叹的！

162
00:09:36,620 --> 00:09:37,950
弗拉克！GDB。

163
00:09:37,950 --> 00:09:39,720
你到底在干什么？

164
00:09:39,720 --> 00:09:43,390
你为什么说你在那里找到了垃圾桶，如果没有呢？

165
00:09:43,390 --> 00:09:45,800
我不知道为什么会这样。

166
00:09:45,800 --> 00:09:47,300
在网上找不到任何东西。

167
00:09:47,300 --> 00:09:48,300
不管怎样。

168
00:09:48,300 --> 00:09:49,300
忽略这一点。

169
00:09:49,300 --> 00:09:50,300
这是另一种技术。

170
00:09:50,300 --> 00:09:53,940
我们可以使用字符串来查找libc中的所有字符串。

171
00:09:53,940 --> 00:09:58,160
使用-t，我们可以将文件中的偏移量打印为十六进制。

172
00:09:58,160 --> 00:10:02,450
然后我们可以简单地将这个偏移量添加到libc加载到的地址。

173
00:10:02,450 --> 00:10:05,070
这是/bin/sh的真实地址。

174
00:10:05,070 --> 00:10:07,620
好吧，让我们把这个地址复制到我们的漏洞中。

175
00:10:07,620 --> 00:10:11,250
然后我们试试看。

176
00:10:11,250 --> 00:10:15,210
记住要用上一个视频中带括号和cat的技巧。

177
00:10:15,210 --> 00:10:18,450
因为漏洞脚本将再次关闭输入。

178
00:10:18,450 --> 00:10:19,450
酷！

179
00:10:19,450 --> 00:10:20,450
它起作用了。

180
00:10:20,450 --> 00:10:23,200
我们刚刚做的是一种叫做ret2libc的技术。

181
00:10:23,200 --> 00:10:25,440
我们从未在堆栈上执行过任何代码！

182
00:10:25,441 --> 00:10:26,441
也许你会问自己，为什么这个堆栈一开始是可执行的。

183
00:10:26,441 --> 00:10:27,441
堆栈应该是可执行的，没有合理的理由。

184
00:10:27,441 --> 00:10:28,441
这就是为什么现在有一个通用的记忆策略。

185
00:10:28,441 --> 00:10:29,441
写入XOR执行。

186
00:10:29,441 --> 00:10:30,441
基本上，它意味着永远没有可写和可执行的内存页。

187
00:10:30,441 --> 00:10:31,441
因为这样攻击者就不能执行他能够在

188
00:10:31,441 --> 00:10:32,441
进程内存。

189
00:10:32,441 --> 00:10:33,441
因此，我们希望今天每个现代系统都使用DEP、数据执行预防和集合

190
00:10:33,441 --> 00:10:34,441
nx位，是内存页（如堆栈）的不可执行位。

191
00:10:34,441 --> 00:10:35,441
但现实并非如此简单。

192
00:10:35,441 --> 00:10:36,441
随着物联网的兴起，嵌入式设备也在兴起，但它们通常不会

193
00:10:36,441 --> 00:10:37,441
支持这样的功能。

194
00:10:37,441 --> 00:10:38,441
或者像javascript这样的现代编程语言使用jit。

195
00:10:38,441 --> 00:10:39,441
实时编译器。

196
00:10:39,441 --> 00:10:40,441
因此，当需要时，他们必须在内存中即时编译代码并执行它。

197
00:10:40,441 --> 00:10:41,441
因此，它们需要可写和可执行的内存区域。

198
00:10:41,441 --> 00:10:42,441
但是，即使我们有DEP，我们也可以使用像ret2libc这样的技术来从不执行实际的shellcode，

199
00:10:42,441 --> 00:10:43,441
但仍然需要一个系统。

200
00:10:43,441 --> 00:10:44,441
在将来的某个时候，我会制作一个关于面向返回编程的视频。

201
00:10:44,441 --> 00:10:44,451
这是这种技术的下一个高级步骤。

