1
00:00:00,110 --> 00:00:04,920
以前的堆利用视频是关于滥用应用程序逻辑的。基本上

2
00:00:04,920 --> 00:00:09,840
因为程序使用了堆中的错误数据。但这次我们利用堆

3
00:00:09,839 --> 00:00:14,959
算法本身。在这段视频中，我想从漏洞利用练习中探索堆级别3

4
00:00:14,959 --> 00:00:25,719
protostar which is about the infamous unlink() macro.

5
00:00:25,720 --> 00:00:30,090
这段视频是基于一篇优秀的短语文章“Once on a free（）”。正如你所能

6
00:00:30,090 --> 00:00:36,540
这篇文章是从2001年开始的。所以我们仍然落后15年，还没有

7
00:00:36,540 --> 00:00:42,130
赶上了现代的剥削状态。我们将利用的堆实现

8
00:00:42,130 --> 00:00:46,880
多年来为了防止这种攻击而改变。但目前的版本仍然是

9
00:00:46,880 --> 00:00:52,030
based on this old algorithm, so it’s important to understand this easy version here.

10
00:00:52,030 --> 00:00:54,760
So let’s start by looking at the code of this level.

11
00:00:54,760 --> 00:01:00,860
这个级别介绍了doug lea malloc（dlmalloc）以及如何修改堆元数据。

12
00:01:00,860 --> 00:01:05,390
更改程序执行。目标显然是调用函数

13
00:01:05,390 --> 00:01:09,740
winner. First we malloc 3 objects with 32 byte. A.

14
00:01:09,740 --> 00:01:14,290
B. and C. Then we copy the program arguments to A. B.

15
00:01:14,290 --> 00:01:18,170
显然strcpy很脆弱，因为它

16
00:01:18,170 --> 00:01:22,910
doesn’t stop us from copying more than 32 byte. So that is our overflow.

17
00:01:22,910 --> 00:01:27,880
And then we free again the objects in reverse order, C, B and A.

18
00:01:27,880 --> 00:01:32,930
最后还有打印件。所以你可以看到，没有明显的应用

19
00:01:32,930 --> 00:01:38,880
我们可以利用的逻辑。释放后不使用，堆上没有易受攻击的指针。但仍然

20
00:01:38,880 --> 00:01:43,440
可以重定向代码执行。正如描述所说，这个水平是

21
00:01:43,439 --> 00:01:48,849
关于损坏堆元数据。所以堆算法有一个问题，在这里

22
00:01:48,850 --> 00:01:54,460
case in the free() function, that we can use to redirect execution to winner().

23
00:01:54,460 --> 00:02:00,670
Let’s start by looking at the heap in gdb. To do this let’s add a couple of breakpoints.

24
00:02:00,670 --> 00:02:06,370
每个图书馆的功能如何？所以在malloc，strcpy，free和printf中断

25
00:02:06,370 --> 00:02:10,810
实际上是放在最后。让我们快跑吧，别忘了

26
00:02:10,810 --> 00:02:15,620
3个参数，继续，直到到达第一个strcpy。然后检查映射的

27
00:02:15,620 --> 00:02:22,330
此进程的内存并查找堆。这表明我们的堆区来自

28
00:02:22,330 --> 00:02:29,790
804c到804d。我们可以定义一个钩子挡块来打印这个区域的56个字。

29
00:02:29,790 --> 00:02:34,660
当我们到达一个断点时。当我们现在重新运行程序时，我们可以看到

30
00:02:34,660 --> 00:02:39,180
堆发展起来了。我们来做吧。在我们执行第一个malloc之前，我们没有

31
00:02:39,180 --> 00:02:44,630
有堆了。在malloc之后，我们现在可以看到堆上的第一个对象。所以记住

32
00:02:44,629 --> 00:02:49,489
堆块的外观如何？这是当前块的大小。它是十六进制29。这个

33
00:02:49,490 --> 00:02:55,260
最后一位指示前一个块是否正在使用。因为这是特别的第一次

34
00:02:55,260 --> 00:03:00,280
块，在此之前没有有效的内存，因此它的位集指示

35
00:03:00,280 --> 00:03:06,160
内存不可用，不可用。这意味着块的实际大小是hex 28，它

36
00:03:06,160 --> 00:03:12,310
is 40 bytes, so malloc allocated a bit more than 32 bytes. But doesn’t matter to us.

37
00:03:12,310 --> 00:03:16,480
After this chunk we have the wilderness, which is like the first chunk - a little bit special.

38
00:03:16,480 --> 00:03:21,920
但是你可以把它想象成一个巨大的可供分配的自由块，这就是

39
00:03:21,920 --> 00:03:26,080
它的大小。它显然有最后一个位集，因为前一个块在

40
00:03:26,080 --> 00:03:31,210
使用。我们错落了第二个物体。大小相同。最后一个位集，因为前一个块是

41
00:03:31,209 --> 00:03:36,089
在使用中。原野被更新了，现在的自由空间减少了，但仍然是以前的

42
00:03:36,090 --> 00:03:41,200
区块正在使用中。最后一个物体。另一个同样大小的。最后一位集，

43
00:03:41,200 --> 00:03:45,740
because the previous is in use. And less space available in the wilderness.

44
00:03:45,739 --> 00:03:50,539
接下来我们执行字符串复制。所以我们复制了第一个论点

45
00:03:50,540 --> 00:03:56,500
第一块。从bs到第二个块，从cs到第三个块。很明显我们可以

46
00:03:56,500 --> 00:04:00,960
已经写了很多，并且完全覆盖了所有内容。包括块大小，其中

47
00:04:00,959 --> 00:04:03,179
is the heap metadata.

48
00:04:03,180 --> 00:04:08,150
接下来我们要再次释放它们，所以最后一块被释放了。CS被覆盖

49
00:04:08,150 --> 00:04:13,330
零，因为这里的这两个词对于一个自由块有特殊的意义。所以以前我们

50
00:04:13,330 --> 00:04:18,220
已经分配了块。现在我们又有了一个可用的块。免费。没什么别的

51
00:04:18,219 --> 00:04:22,789
changed. Infact those chunks are very small and are considered “fastbins” by malloc.

52
00:04:22,789 --> 00:04:26,149
They behave a little bit different. We will learn about that a little bit later.

53
00:04:26,150 --> 00:04:30,670
但是让我们继续并释放下一个，所以我们有两个空闲块。这次我们

54
00:04:30,669 --> 00:04:35,069
B被地址覆盖，它指向另一个空闲块。那就是

55
00:04:35,069 --> 00:04:38,729
被覆盖词的特殊含义，它们是指针，指向下一个空闲词

56
00:04:38,729 --> 00:04:40,199
block. A linked list.

57
00:04:40,199 --> 00:04:44,749
好的，继续并释放下一个，然后扩展链接列表。第一个空闲块

58
00:04:44,749 --> 00:04:47,839
指向第二个，第二个指向第三个，即

59
00:04:47,840 --> 00:04:51,800
荒原前最后一个街区。你可能会问自己为什么最后一点

60
00:04:51,800 --> 00:04:56,950
大小中的一个，表示使用的前一个块未设置为0。它的

61
00:04:56,949 --> 00:05:01,709
有点混乱，但想一下就好像算法一样。在这种情况下，它们很小

62
00:05:01,710 --> 00:05:06,540
快速的垃圾箱，我们要超快速处理它们。以及我们如何在这个反向中释放块

63
00:05:06,539 --> 00:05:10,729
点菜，没关系。不必要浪费时间

64
00:05:10,729 --> 00:05:15,899
that bit. Just imagining this pointer somewhere, which always points to the first free chunk.

65
00:05:15,899 --> 00:05:20,049
当我现在想找点东西，找个空闲的地方，我就可以简单地按照

66
00:05:20,050 --> 00:05:24,080
链接列表以查找所有可用块，从而查找上一块可用的信息

67
00:05:24,080 --> 00:05:29,290
只是无关紧要，对吧？但是，如果块的大小

68
00:05:29,289 --> 00:05:34,199
更大。然后malloc和free会清理更多，使用更多堆元数据。

69
00:05:34,199 --> 00:05:38,459
用于家庭护理。但我们不要挂断电话。我们会走过一些地方

70
00:05:38,460 --> 00:05:41,790
of the algirthm later and clear up some parts.

71
00:05:41,789 --> 00:05:47,009
让我们看看代码。当您为这个案例寻找dlmalloc算法时，

72
00:05:47,009 --> 00:05:50,599
确保你有一个超过15年的版本，否则你会看到一个补丁

73
00:05:50,599 --> 00:05:51,789
version.

74
00:05:51,789 --> 00:05:56,279
现在，在我们开始阅读代码之前，先考虑一下我们在寻找什么。我们看

75
00:05:56,279 --> 00:06:01,969
对于允许我们执行任意写入的原语。这样我们就可以

76
00:06:01,969 --> 00:06:08,319
覆盖全局偏移量表中的条目。一种可能的方法

77
00:06:08,319 --> 00:06:15,369
被滥用的原因看起来像，是在跟踪我们控制的指针，对吗？如果有的话

78
00:06:15,369 --> 00:06:22,219
of code here that performs a write based on pointers on the heap we can overflow, we win.

79
00:06:22,219 --> 00:06:26,069
Let’s keep that in mind when we look at the code.

80
00:06:26,070 --> 00:06:31,640
函数以参数mem开始，这是我们想要释放的地址。不久

81
00:06:31,639 --> 00:06:36,489
然后，mem2chunk被调用，它在mem前面两个字得到地址，即

82
00:06:36,490 --> 00:06:42,280
块的实际起始地址。我们到达的第一个只有一点点

83
00:06:42,280 --> 00:06:47,560
代码位。它指的是快速垃圾箱。这正是我们获释时所看到的

84
00:06:47,560 --> 00:06:53,070
我们的32字节小块。它更新了第一个指针fd指针。创造了

85
00:06:53,069 --> 00:06:57,429
linked list. But otherwise not much happens and thus it’s not interesting.

86
00:06:57,429 --> 00:07:02,319
这意味着我们只是想确定，我们的尺寸大于最大值

87
00:07:02,319 --> 00:07:08,919
fastbin块大小，定义为80。我们的块大小是32，所以我们要确保

88
00:07:08,919 --> 00:07:12,709
that we overflow the size of the chunk we handle.

89
00:07:12,709 --> 00:07:16,539
如果我们进入“如果”，我们会得到一个有趣的评论：

90
00:07:16,539 --> 00:07:21,249
“合并其他非mmaped块”。如果我们检查通过这个的必要条件

91
00:07:21,250 --> 00:07:27,030
测试，我们看块_是一个简单的宏，它的大小是p，它的大小是

92
00:07:27,029 --> 00:07:32,829
并检查is-mmapped标志。非常类似于前一位，

93
00:07:32,830 --> 00:07:37,890
这是最后一个，is-mmap标志是最后一个第二位。所以当我们想要的时候

94
00:07:37,889 --> 00:07:42,899
reach the code in here, we have to make sure that the 2nd last bit is not set.

95
00:07:42,900 --> 00:07:46,690
然后我们得到下一个块的地址，我们可以根据

96
00:07:46,689 --> 00:07:52,029
我们当前的块。因此，如果出现溢出，那么大小已经是我们可以控制的了，

97
00:07:52,029 --> 00:07:57,779
这意味着，在这里我们有第一次机会愚弄free（）去思考其他数据。

98
00:07:57,779 --> 00:08:02,299
是下一块。在那之后，我们检查一下

99
00:08:02,300 --> 00:08:07,130
如果前一个块不在使用中，则块正在使用中，该块由最低的块定义

100
00:08:07,129 --> 00:08:11,979
位设置为0，我们将遵循上一个大小，我们还没有介绍，但它

101
00:08:11,979 --> 00:08:17,219
this word before our chunk size. And thus calculates the address of the previous chunk.

102
00:08:17,219 --> 00:08:23,289
同样，一个我们可以控制的值。然后我们执行取消链接。这就是魔法

103
00:08:23,289 --> 00:08:26,709
word I mentioned at the beginning. So let’s see what that means.

104
00:08:26,710 --> 00:08:32,000
第一个参数p是当前块之前的块，我们通过以下方法得到

105
00:08:31,999 --> 00:08:37,429
PrimeSe大小。我们取块的前后指针，这是第一个

106
00:08:37,430 --> 00:08:43,680
and second word after the size and remember it in FD and BK.

107
00:08:43,680 --> 00:08:50,130
为了简单起见，忽略-&gt；bk和-&gt；fd，因为它只引用了

108
00:08:50,130 --> 00:08:57,310
地址在这里。我们在后面加上这些偏移量。所以现在我们把地址bk写到地址

109
00:08:57,310 --> 00:09:00,430
fd指向的位置。然后我们写fd到地址

110
00:09:00,430 --> 00:09:01,740
BK指向。或者精确到它们各自的偏移量

111
00:09:01,740 --> 00:09:02,740
where the prev and next pointer is stored.

112
00:09:02,740 --> 00:09:05,990
好了，住手！bk可以是winner函数的地址。fd+12可能是我们的

113
00:09:05,990 --> 00:09:09,530
Puts（）的表条目。这将覆盖全局中的条目

114
00:09:09,529 --> 00:09:12,899
带Winner函数的偏移表。这听起来很完美！！！！

115
00:09:12,899 --> 00:09:18,279
但是我们忘记了下一部分，我们将在fd中获取我们的got地址并尝试

116
00:09:18,279 --> 00:09:24,279
写到赢家的地址（+8）。嗯……那就错了。我们不能写

117
00:09:24,280 --> 00:09:30,600
进入代码段。该死的……但现在你必须要有创造力。思考

118
00:09:30,601 --> 00:09:36,751
关于。如果我们有两个内存段。段A和段B。我们可以从段写地址

119
00:09:36,750 --> 00:09:41,280
A到B段，我们把B段的地址写进A段。全局

120
00:09:41,279 --> 00:09:45,719
偏移表是可写的，因此它可能是这些段中的一个，只是代码段

121
00:09:45,720 --> 00:09:51,120
can’t be the other one. But the HEAP could be our second one. We can write to the heap.

122
00:09:51,120 --> 00:09:55,160
这将允许我们将地址从堆写入全局偏移量表，以及

123
00:09:55,160 --> 00:09:59,580
全局偏移表中不重要的地址将写入堆中！这个

124
00:09:59,581 --> 00:10:05,031
意味着我们可以通过全局偏移量表将代码执行重定向到我们可以

125
00:10:05,029 --> 00:10:09,749
place on the Heap. and then this shellcode calls winner for us.

126
00:10:09,750 --> 00:10:14,440
听起来是个很棒的计划。我们以堆的状态为例

127
00:10:14,440 --> 00:10:18,420
it and think about how we would want to construct the case we just explained.

128
00:10:18,420 --> 00:10:22,800
因此，我们可以决定释放最后一个块，并确保prev in-use位

129
00:10:22,800 --> 00:10:28,270
设置为0。以便它尝试合并前一个块。让我们真的

130
00:10:28,269 --> 00:10:33,639
这些变化就在gdb中，这样我们就可以直接测试它了。设置块大小

131
00:10:33,640 --> 00:10:40,120
大于80，并将prev-in-use位设置为0。为什么不100呢？现在我们要设置

132
00:10:40,120 --> 00:10:46,040
上一个大小，指向要合并的上一个块。让我们做一个

133
00:10:46,040 --> 00:10:48,220
small block. So maybe hex 10.

134
00:10:48,220 --> 00:10:57,180
这意味着在-0x10我们必须创建一个假块。那么大。所以设置0x11，因为

135
00:10:57,180 --> 00:11:03,540
we want to indicate that the chunk before this fake chunk would be in use. great.

136
00:11:03,540 --> 00:11:09,290
现在我们需要在全局偏移表中输入的地址。这将是向前指针

137
00:11:09,290 --> 00:11:15,900
第二个指针将在+12写入。这就是为什么你要做Puts-12，

138
00:11:15,899 --> 00:11:21,409
因为它将被写入地址+12。另一个指针是地址

139
00:11:21,410 --> 00:11:25,510
我们写入全局偏移量表，这样就应该指向

140
00:11:25,509 --> 00:11:30,199
heap where we can place some shellcode. Why not go here.

141
00:11:30,199 --> 00:11:35,419
在我们测试它之前，还有一件事要考虑，尺寸是用来计算的

142
00:11:35,420 --> 00:11:41,040
下一块和下一个大小。在取消链接后，使用这些值。所以如果我们

143
00:11:41,040 --> 00:11:46,650
使用大小100，我们指向一些未使用的内存，我们必须确保

144
00:11:46,649 --> 00:11:52,279
那里表现得很好。否则我们会撞车的。如果下一个

145
00:11:52,279 --> 00:11:58,039
chunk is the top, or what we call wilderness. But our size is overshooting that address.

146
00:11:58,040 --> 00:12:03,870
这意味着我们在这种情况下着陆。现在它计算下一个块，

147
00:12:03,870 --> 00:12:08,910
检查prev-in-use位，以确定块之前是否空闲。所以如果

148
00:12:08,910 --> 00:12:14,130
它不在使用中，我们执行另一个取消链接以在当前块之后合并未使用的块

149
00:12:14,129 --> 00:12:17,459
one. Which copies around those pointers.

150
00:12:17,459 --> 00:12:22,759
嘿，这是来自未来的活生生的。我只是在编辑这部分，我意识到

151
00:12:22,759 --> 00:12:27,759
我误读了这里的代码。我想我可以在这段短时间内选择

152
00:12:27,760 --> 00:12:32,480
案例，或者下面的整个案例。但我错过了没有花括号，这是

153
00:12:32,481 --> 00:12:39,231
也就是说，其他情况就是在偏移量处使用这个清晰的位。当我开发这个概念证明的时候

154
00:12:39,230 --> 00:12:44,340
我对自己说，我不想用下面的代码过度复杂化它。事实上我做了

155
00:12:44,339 --> 00:12:49,589
这太复杂了，因为我们现在必须构建另一个假块来处理这一秒

156
00:12:49,589 --> 00:12:54,459
在这里取消链接。但不管怎样，我认为这是一次很好的学习经历。让我们的头

157
00:12:54,459 --> 00:12:58,699
back into the episode.

158
00:12:58,700 --> 00:13:01,870
此时，我们应该已经成功地将堆地址写入全局

159
00:13:01,870 --> 00:13:06,000
偏移表与上一个取消链接，因此我们可以只选取两个随机堆值

160
00:13:06,000 --> 00:13:08,330
not crash here.

161
00:13:08,330 --> 00:13:12,750
所以这是另外两个假块。向前和向后指针指向

162
00:13:12,750 --> 00:13:15,200
the heap which we don’t care about.

163
00:13:15,200 --> 00:13:19,960
这是未来的生活溢出。再一次。我刚刚意识到我又犯了一个小错误

164
00:13:19,959 --> 00:13:23,639
which negates my false assumption about the big else case from earlier.

165
00:13:23,639 --> 00:13:30,229
I actually did set the prev_in_use bit, which means it does NOT consolidate this fake chunk.

166
00:13:30,230 --> 00:13:34,650
更不用说我为错误的块设置了fd和bk指针。应该是

167
00:13:34,649 --> 00:13:38,269
on the other chunk before. I’m sorry guys. I’m just a noob.

168
00:13:38,269 --> 00:13:44,309
总结一下。我们改变我们将要释放的块的大小。我们创造了一个假货

169
00:13:44,310 --> 00:13:50,530
在当前块之前释放块以触发取消链接并覆盖got。我们创造了

170
00:13:50,529 --> 00:13:54,989
之后两块假块，第二块写的是前一块

171
00:13:54,990 --> 00:14:00,500
use. Thus not triggering another unlink. And those two values here were unecessary.

172
00:14:00,499 --> 00:14:06,409
现在，如果我们继续执行第一个自由，我们可以检查输入的看跌期权，然后我们看到

173
00:14:06,410 --> 00:14:10,760
函数地址已成功写入。当我们看到堆的时候，我们可以看到

174
00:14:10,759 --> 00:14:17,859
在偏移量+8处，我们有一个写入的地址。令人惊叹的。当我们继续看跌时

175
00:14:17,860 --> 00:14:22,680
向前迈出一步，我们跳进了一堆。令人惊叹的！

176
00:14:22,680 --> 00:14:26,670
这是有效的！现在我们只需要用strcpy将这些值放入堆中…

177
00:14:26,670 --> 00:14:36,050
哦，不，不，不。我很笨。strcpy无法复制nullbytes。定义了C中的字符串

178
00:14:36,050 --> 00:14:43,150
以空结尾。所以我们不能把十六进制10这样的大小写进内存。至少不是多重的

179
00:14:43,149 --> 00:14:49,929
时代。哦，该死的。在这种情况下，整个计划都不起作用…如果它是read（）它

180
00:14:49,930 --> 00:14:52,390
would work. But not with strcpy.

181
00:14:52,389 --> 00:14:57,179
I go sit in my corner now and think about all the failures in life. See you soon. Maybe.

