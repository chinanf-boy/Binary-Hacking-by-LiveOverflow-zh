1
00:00:00,110 --> 00:00:04,920
以前的堆漏洞视频，是关于破解应用程序逻辑的。

2
00:00:04,920 --> 00:00:09,840
基本原理是因为，程序使用了堆中的错误数据。但这次我们利用堆算法本身。

3
00:00:09,839 --> 00:00:14,959
在这段视频中，向你展示 exploit-exercises ProtoStar 的第三级堆漏洞，

4
00:00:14,959 --> 00:00:25,719
是臭名昭著的 unlink() 宏。

5
00:00:25,720 --> 00:00:30,090
这段视频是基于一篇优秀的短语文章“Once upon a free() ”。

6
00:00:30,090 --> 00:00:36,540
正如你看到的，这篇文章是2001年的。所以，我们仍然落后15年，

7
00:00:36,540 --> 00:00:42,130
还没有赶上了现代的漏洞形态。
8
00:00:42,130 --> 00:00:46,880
堆实现，多年来为了防止这种漏洞攻击而改变。

9
00:00:46,880 --> 00:00:52,030
但目前的版本仍然是基于这个旧算法，所以，当前理解这个简单的版本是很重要的。

10
00:00:52,030 --> 00:00:54,760
所以，让我们从这个代码开始。

11
00:00:54,760 --> 00:01:00,860
第3级，介绍了dlmalloc，以及如何修改堆元数据，

12
00:01:00,860 --> 00:01:05,390
以更改程序的执行。最终的目标，显然是调用函数winner

13
00:01:05,390 --> 00:01:09,740
首先，我们 malloc 3个大小为32字节的对象A，B，C。

14
00:01:09,740 --> 00:01:14,290
然后我们把程序参数复制到A，B，C。

15
00:01:14,290 --> 00:01:18,170
显然strcpy是个漏洞，

16
00:01:18,170 --> 00:01:22,910
因为它不阻止我们，复制超过32字节的内容。这就是我们的溢出。

17
00:01:22,910 --> 00:01:27,880
然后，我们以相反的顺序，再次释放(free)对象，C，B和A。

18
00:01:27,880 --> 00:01:32,930
还有 printf 在最后。所以你可以看到，没有明显的应用逻辑漏洞

19
00:01:32,930 --> 00:01:38,880
没有 use-after-free 都懂，堆上，没有漏洞指针。

20
00:01:38,880 --> 00:01:43,440
但仍有重定向代码执行的机会。正如描述所说，这个级别是

21
00:01:43,439 --> 00:01:48,849
关于损坏堆元数据。因为，这个堆算法有一个问题，

22
00:01:48,850 --> 00:01:54,460
本例子，就是在free() 函数中，我们可以使用它，将执行重定向到winner() 。

23
00:01:54,460 --> 00:02:00,670
让我们先看看 gdb中的堆。为此，我们添加几个断点。

24
00:02:00,670 --> 00:02:06,370
放置在每个库函数上，如何？所以，断点在 malloc，strcpy，free，和printf(虽说，实际上是 puts 函数)。

25
00:02:06,370 --> 00:02:10,810
让我们快速运行吧，

26
00:02:10,810 --> 00:02:15,620
别忘了程序的3个参数，继续，到达第一个strcpy。

27
00:02:15,620 --> 00:02:22,330
然后检查此进程的映射内存，并查看堆。数据表明，我们的堆区域，

28
00:02:22,330 --> 00:02:29,790
从 804c 到了 804d。我们可以定义一个 hook-stop，当我们到达一个断点时，

29
00:02:29,790 --> 00:02:34,660
每次都打印这个区域的56个字。当我们现在重新运行程序时，

30
00:02:34,660 --> 00:02:39,180
我们可以看到堆是如何扩展开的。好，定义开始。在我们执行第一个 malloc之前，

31
00:02:39,180 --> 00:02:44,630
我们还没有堆。在malloc之后，我们现在可以看到堆上的第一个对象。

32
00:02:44,629 --> 00:02:49,489
所以还记得堆块的样子吗？这是当前块的大小。它是十六进制 29。

33
00:02:49,490 --> 00:02:55,260
而最后一位，指示前一个块是否正在使用。

34
00:02:55,260 --> 00:03:00,280
因为这是特殊的，第一区块，在此之前，没有有效的内存，

35
00:03:00,280 --> 00:03:06,160
因此它有一个设置位，指示该内存不可用，不空闲。这意味着，块的实际大小其实是 hex 28，

36
00:03:06,160 --> 00:03:12,310
它有40个字节，所以，malloc分配了32个以上的字节。但对我们来说，并不重要。

37
00:03:12,310 --> 00:03:16,480
在这一块之后，我们有了荒野(剩余内存)，这就像第一块 —— 但有点特别。

38
00:03:16,480 --> 00:03:21,920
你可以把它想象成一个巨大的，可供分配的空闲区块，

39
00:03:21,920 --> 00:03:26,080
而这就是它的大小。它显然有最后一个设置位，

40
00:03:26,080 --> 00:03:31,210
因为前一个块是在使用。我们 malloc 了第二个对象。大小相同。最后一个位集，

41
00:03:31,209 --> 00:03:36,089
因为前一个块是在使用中。荒野被更新了，现在的空闲空间减少了，

42
00:03:36,090 --> 00:03:41,200
但还是一样，之前的区块正在使用中。那么，最后一个。另一个同样大小的。最后一位集，

43
00:03:41,200 --> 00:03:45,740
因为前一个正在使用中。在荒野中，可用空间更少。

44
00:03:45,739 --> 00:03:50,539
接下来，我们执行字符串复制。所以，我们复制了第一个参数A们，到第一个块，

45
00:03:50,540 --> 00:03:56,500
B们到第二个块，C们到第三个块。很明显，

46
00:03:56,500 --> 00:04:00,960
我们可以写很多且复杂的(字)，来覆盖了所有内容。

47
00:04:00,959 --> 00:04:03,179
包括块大小，这可是堆的元数据。

48
00:04:03,180 --> 00:04:08,150
接下来，我们要再次释放它们，所以，最后一块被释放了。

49
00:04:08,150 --> 00:04:13,330
C们被零覆盖，因为这里的这两个词，对于一个空闲块有特殊的意义。

50
00:04:13,330 --> 00:04:18,220
所以，之前我们有一个分配块。现在，我们的这个区块再次可用。空闲。

51
00:04:18,219 --> 00:04:22,789
没什么别的改变。事实上，这些块非常小，被 malloc 认为是“fastbin”。

52
00:04:22,789 --> 00:04:26,149
他们的行为有点不同。稍后我们会了解这一点。

53
00:04:26,150 --> 00:04:30,670
但是，让我们继续，并释放下一个，所以我们有两个空闲块。

54
00:04:30,669 --> 00:04:35,069
这次是我们的B被一个地址覆盖，它指向一个其他的空闲块。

55
00:04:35,069 --> 00:04:38,729
而这就是覆盖词的特殊含义，它们是指针，

56
00:04:38,729 --> 00:04:40,199
指向下一个空闲块。一个链表。

57
00:04:40,199 --> 00:04:44,749
好的，继续并释放下一个，然后，扩展链表。

58
00:04:44,749 --> 00:04:47,839
第一个空闲块指向第二个，第二个指向第三个，

59
00:04:47,840 --> 00:04:51,800
即荒野前的最后一个块。你可能会问自己为什么

60
00:04:51,800 --> 00:04:56,950
最后一位的大小是这个，明明前一个块使用，却不是 0。

61
00:04:56,949 --> 00:05:01,709
它有点混乱，但仔细想想。在这种情况下，

62
00:05:01,710 --> 00:05:06,540
有个很小，但要快的垃圾箱，我们要超快速地处理它们。以及

63
00:05:06,539 --> 00:05:10,729
要在这个反顺序释放块，这其实没关系的。

64
00:05:10,729 --> 00:05:15,899
不必要浪费时间那个位。想象一下，这个指针在什么地方，它总是指向第一个空闲块。

65
00:05:15,899 --> 00:05:20,049
当我现在想 malloc 某些东西，要找个空闲的地方的时候，

66
00:05:20,050 --> 00:05:24,080
我就可以简单按照链表，查找所有空闲块，而前一个块是否空闲的信息，

67
00:05:24,080 --> 00:05:29,290
对我来说，都无关紧要，对吧？但是，如果块的大小更大，就会有点不同。

68
00:05:29,289 --> 00:05:34,199
malloc和free之后要清理更多，并使用更多的堆元数据来清除干净。

69
00:05:34,199 --> 00:05:38,459
但，我们不要总停在这里。

70
00:05:38,460 --> 00:05:41,790
后面，我们再走过一部分算法，和清理一些部分。

71
00:05:41,789 --> 00:05:47,009
让我们看看代码。当您为这个案例，寻找dlmalloc算法时，

72
00:05:47,009 --> 00:05:50,599
确保你有一个超过15年的版本，

73
00:05:50,599 --> 00:05:51,789
否则你会看到一个补丁版本。

74
00:05:51,789 --> 00:05:56,279
现在，在我们开始阅读代码之前，先考虑一下我们在寻找什么。

75
00:05:56,279 --> 00:06:01,969
我们在找哪些，能允许我们执行任意写入的标语。

76
00:06:01,969 --> 00:06:08,319
这样我们就可以，覆盖GOT中的条目。

77
00:06:08,319 --> 00:06:15,369
一种可能方法说，有漏洞的代码的样子，就是跟踪我们控制的指针，对吗？

78
00:06:15,369 --> 00:06:22,219
如果这里的代码，可以基于溢出堆上的指针，来执行写操作，我们就赢了。

79
00:06:22,219 --> 00:06:26,069
查看代码时，请记住这一点。

80
00:06:26,070 --> 00:06:31,640
函数，以参数 mem 开始，这是我们想要释放的地址。

81
00:06:31,639 --> 00:06:36,489
不久后，mem2chunk 被调用，它在 mem 前面，得到两个字地址，

82
00:06:36,490 --> 00:06:42,280
就是 块的实际起始地址。我们到达的第一个，

83
00:06:42,280 --> 00:06:47,560
只有一点点代码。快速垃圾箱的代码。当我们让32字节小块空闲时，

84
00:06:47,560 --> 00:06:53,070
正是我们期待的。它更新了第一个指针 fd指针，

85
00:06:53,069 --> 00:06:57,429
会创建这个链表。但除此之外，不会发生太多事情，因此也不有趣。

86
00:06:57,429 --> 00:07:02,319
这意味着，我们只是想确定，我们的尺寸大于Fastbin块大小的最大值，定义为80。

87
00:07:02,319 --> 00:07:08,919
我们的块大小是32，

88
00:07:08,919 --> 00:07:12,709
所以我们要确保，我们溢出，处理块的大小。

89
00:07:12,709 --> 00:07:16,539
如果，我们进到这个“else if”，我们会得到一个有趣的注释：

90
00:07:16,539 --> 00:07:21,249
“合并，其他非映射块”。如果我们检查通过这个测试的必要条件

91
00:07:21,250 --> 00:07:27,030
这 chunk_is_mmaped 一个简单的宏，拿着 p 的 大小，就是当前块的大小，

92
00:07:27,029 --> 00:07:32,829
并检查 IS_MMAPPPED 标志。非常类似于 PREV_INUSE 位，就是最后一，

93
00:07:32,830 --> 00:07:37,890
IS_MMAPPED 标志是最后第二位。所以，当我们想要到达这里的代码，

94
00:07:37,889 --> 00:07:42,899
我们必须确保没有设置最后第二位。

95
00:07:42,900 --> 00:07:46,690
然后，我们得到下一个块的地址，我们可以基于当前块的大小计算而来。

96
00:07:46,689 --> 00:07:52,029
因此，如果出现一个溢出，那么，大小就是我们已经可以控制的了，

97
00:07:52,029 --> 00:07:57,779
这意味着，在这里我们有了第一次机会，

98
00:07:57,779 --> 00:08:02,299
愚弄 free() 把其他数据是下一块。在那之后，我们要检查一下，前一个块是否在使用中，

99
00:08:02,300 --> 00:08:07,130
如果前一块不是在使用中，则由最低设置位定义为 0，

100
00:08:07,129 --> 00:08:11,979
我们将遵循 prev_size，我们还没有介绍，

101
00:08:11,979 --> 00:08:17,219
但它时在我们的块大小之前的词，从而计算前一块的地址。

102
00:08:17,219 --> 00:08:23,289
同样，一个我们可以控制的值。然后，我们执行一个 unlink。

103
00:08:23,289 --> 00:08:26,709
这就是，我在开头提到的魔法咒语。让我们看看这意味着什么。

104
00:08:26,710 --> 00:08:32,000
第一个参数 p，是在当前块之前的块，我们通过 prev_size 方法得到 。

105
00:08:31,999 --> 00:08:37,429
我们取得，块的前后指针，

106
00:08:37,430 --> 00:08:43,680
这是在大小之后的第一个和第二个词，在fd 和 bk中，记住它。

107
00:08:43,680 --> 00:08:50,130
为了简单起见，忽略 -&gt; bk和 -&gt; fd，因为它这个地址引用的小偏移距离。

108
00:08:50,130 --> 00:08:57,310
我们在后面，加上这些偏移量。所以现在我们把地址bk，写到fd指向的地址

109
00:08:57,310 --> 00:09:00,430
然后，我们把FD 写到BK指向的地址。

110
00:09:00,430 --> 00:09:01,740
或者精确到各自的偏移量，

111
00:09:01,740 --> 00:09:02,740
这是存储前一个和下一个指针的位置。

112
00:09:02,740 --> 00:09:05,990
好了，停！bk 可以是 winner函数的地址。fd+12可能是我们GOT中，puts()的条目。

113
00:09:05,990 --> 00:09:09,530
这用Winner函数去覆盖条目。

114
00:09:09,529 --> 00:09:12,899
这听起来很完美！！！！

115
00:09:12,899 --> 00:09:18,279
但是，我们忘记了下一部分，我们将在fd中，获取我们的got地址，

116
00:09:18,279 --> 00:09:24,279
并尝试把它写在 winner 地址（+8 偏移）。嗯… 会有个分段错误了。

117
00:09:24,280 --> 00:09:30,600
我们不能写入这个代码段。该死的… 但现在你必须要有创造力。思考它。

118
00:09:30,601 --> 00:09:36,751
如果，我们有两个内存段。段A和段B。我们可以把地址从，段A写入段B

119
00:09:36,750 --> 00:09:41,280
和我们把B段的地址，写进A段。

120
00:09:41,279 --> 00:09:45,719
GOT是可写的，因此它可能是这些段中的一个，

121
00:09:45,720 --> 00:09:51,120
只是代码段不能是另一个。但堆可以是我们的第二堆。我们可以写入堆。

122
00:09:51,120 --> 00:09:55,160
这将允许我们将地址，从堆写入GOT，以及

123
00:09:55,160 --> 00:09:59,580
全局偏移表中不重要的地址,将写入堆中！

124
00:09:59,581 --> 00:10:05,031
意味着，我们可以通过GOT，将代码执行重定向到，

125
00:10:05,029 --> 00:10:09,749
我们放在堆里的 shellcode。然后，这个shellcode为我们调用winner。

126
00:10:09,750 --> 00:10:14,440
听起来是个很棒的计划。拿上我们知道的堆状态，

127
00:10:14,440 --> 00:10:18,420
想想我们会如何构建我们刚刚解释的案例。

128
00:10:18,420 --> 00:10:22,800
因此，我们可以决定释放最后一个块，并确保前一个 in_use 位设置为0。

129
00:10:22,800 --> 00:10:28,270
以便它尝试合并前一个块。让我们用 gdb，让这些改变落实，

130
00:10:28,269 --> 00:10:33,639
这样我们就可以直接测试它了。

131
00:10:33,640 --> 00:10:40,120
设置块大小大于80，并将前一个 in_use 位设置为0。为什么不100呢？

132
00:10:40,120 --> 00:10:46,040
现在，我们要设置 prev_size，指向要合并的前一个块。

133
00:10:46,040 --> 00:10:48,220
让我们做一个小块。也许是十六进制10。

134
00:10:48,220 --> 00:10:57,180
这意味着，在-0x10 我们必须创建一个假块。至于大小。就设置 0x11，

135
00:10:57,180 --> 00:11:03,540
因为我们，想指出在这个假块之前的块是在用的。都挺好。

136
00:11:03,540 --> 00:11:09,290
现在我们需要在全局偏移表中 puts 的地址。这将是向前的指针，

137
00:11:09,290 --> 00:11:15,900
这里第二个指针会在 +12 写入。这就是为什么你必须是 puts-12，

138
00:11:15,899 --> 00:11:21,409
因为它将被写入 地址 +12。另一个指针，是我们写入GOT的地址

139
00:11:21,410 --> 00:11:25,510
这样，就应该指向堆的某个地方，

140
00:11:25,509 --> 00:11:30,199
在那里，我们可以放置一些shellcode。为什么不到了呢？

141
00:11:30,199 --> 00:11:35,419
在我们测试它之前，只需要考虑另外一件事，

142
00:11:35,420 --> 00:11:41,040
大小用于计算下一块和下一个大小。在 unlink 后，这些值会使用到。

143
00:11:41,040 --> 00:11:46,650
所以如果我们使用100大小，我们会指向一些未使用的内存，

144
00:11:46,649 --> 00:11:52,279
这样我们必须确保这些内存是好的。否则我们会撞车的。

145
00:11:52,279 --> 00:11:58,039
这有个if 检查，关于下一块是顶部，或是荒野。若是我们的规模，超过了那个地址。

146
00:11:58,040 --> 00:12:03,870
这意味着，我们进入了这种情况。现在它计算下一个块，

147
00:12:03,870 --> 00:12:08,910
检查 prev-in-use 位，以确定之前的块，是否空闲。

148
00:12:08,910 --> 00:12:14,130
所以如果它不在使用中，我们执行另一个 unlink ，以便在当前块之后，合并未使用的块。

149
00:12:14,129 --> 00:12:17,459
在这些指针周围复制。

150
00:12:17,459 --> 00:12:22,759
嘿，这是来自未来的我。我只是在编辑这部分，

151
00:12:22,759 --> 00:12:27,759
我意识到，我误读了这里的代码。我想我可以在这段短时间内，

152
00:12:27,760 --> 00:12:32,480
选择 短的 unlink if 案例，或者下面的整个案例。但我看错了，这是没有花括号，

153
00:12:32,481 --> 00:12:39,231
也就是说，else 情况就是 clear_inuse_bit_at_offset。当我开发这个概念证明的时候，

154
00:12:39,230 --> 00:12:44,340
我对自己说，我不想用下面的代码，过度复杂化它。

155
00:12:44,339 --> 00:12:49,589
事实上我做的太复杂了，因为我们现在必须构建另一个假块，

156
00:12:49,589 --> 00:12:54,459
来处理在这里第二个 unlink 。但不管怎样，我认为这是一次很好的学习经历。

157
00:12:54,459 --> 00:12:58,699
让我们回到这一集。

158
00:12:58,700 --> 00:13:01,870
此时，我们应该已经成功地用 前一个 unlink，

159
00:13:01,870 --> 00:13:06,000
把堆地址写入GOT，因此我们可以只选取两个随机堆值，

160
00:13:06,000 --> 00:13:08,330
放在这里没有损坏的。

161
00:13:08,330 --> 00:13:12,750
所以，这是另外两个假块。

162
00:13:12,750 --> 00:13:15,200
向前和向后指针指向我们不关心的那堆。

163
00:13:15,200 --> 00:13:19,960
这是未来的LiveOverflow。再一次。我刚刚意识到，我又犯了一个小错误

164
00:13:19,959 --> 00:13:23,639
这否定了，我之前对大 else 的错误假设。

165
00:13:23,639 --> 00:13:30,229
我确实设置了prev-in-use位，这意味着，它不会合并这个假块。

166
00:13:30,230 --> 00:13:34,650
更不用说，我为错误的块，设置了fd和bk指针。

167
00:13:34,649 --> 00:13:38,269
应该是在之前那另一块上。对不起，伙计们。我只是个笨蛋。

168
00:13:38,269 --> 00:13:44,309
总结一下。我们改变，我们将要释放的块的大小。

169
00:13:44,310 --> 00:13:50,530
我们创造了一个假释放块，在当前块触发 unlink 之前，用来覆盖got。

170
00:13:50,529 --> 00:13:54,989
之后，我们创造了两个假块，

171
00:13:54,990 --> 00:14:00,500
第二块写的是，前一块在使用。因此不会触发另一个 unlink 。这两个值是不必要的。

172
00:14:00,499 --> 00:14:06,409
现在，如果我们继续执行第一个 gree，我们可以检查，puts的条目，

173
00:14:06,410 --> 00:14:10,760
然后我们看到函数地址已成功写入。当我们看到堆的时候，

174
00:14:10,759 --> 00:14:17,859
我们可以看到在偏移量+8处，我们有一个写入GOT的地址。雕。

175
00:14:17,860 --> 00:14:22,680
当我们继续 puts 和 步进，我们跳进了堆。雕！

176
00:14:22,680 --> 00:14:26,670
这是有效的！现在我们，只需要用strcpy，将这些值放入堆中…

177
00:14:26,670 --> 00:14:36,050
哦，不，不，不。我很笨。strcpy 无法复制 nullbytes。

178
00:14:36,050 --> 00:14:43,150
C定义的字符串，是以 null 结尾。所以，我们不能把十六进制10这样的大小，写进内存。

179
00:14:43,149 --> 00:14:49,929
至少不是多数。哦，该死的。在这种情况下，整个计划都不起作用… 

180
00:14:49,930 --> 00:14:52,390
如果它是 read()的话 会起作用。但用的是 strcpy。

181
00:14:52,389 --> 00:14:57,179
我现在坐在角落里，想着生活中的所有失败。期待很快与您见面。也许吧。

