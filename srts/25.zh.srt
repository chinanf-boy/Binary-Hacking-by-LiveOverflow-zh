1
00:00:00,110 --> 00:00:04,920
以前的堆利用视频是关于滥用应用程序逻辑。基本上

2
00:00:04,920 --> 00:00:09,840
因为程序使用了来自堆。但这次我们利用堆

3
00:00:09,839 --> 00:00:14,959
算法本身。在这个视频里我想从利用练习中探索堆级别3

4
00:00:14,959 --> 00:00:25,719
关于臭名昭著的unlink（）的原恒星宏。

5
00:00:25,720 --> 00:00:30,090
这段视频是根据文章"Once on a free（）"。正如你所能

6
00:00:30,090 --> 00:00:36,540
这篇文章是从2001年开始的。所以我们仍然落后了15年还没有

7
00:00:36,540 --> 00:00:42,130
赶上了现代的剥削状态。我们将利用的堆实现

8
00:00:42,130 --> 00:00:46,880
多年来为了防止这种情况的发生进攻的。但目前的版本仍然是

9
00:00:46,880 --> 00:00:52,030
基于这个老算法，所以它很重要来理解这个简单的版本。

10
00:00:52,030 --> 00:00:54,760
那么让我们先看一下这个水平。

11
00:00:54,760 --> 00:01:00,860
此级别介绍Doug Lea Malloc（dlmalloc）以及如何修改堆元数据

12
00:01:00,860 --> 00:01:05,390
更改程序执行。目标显然是调用函数

13
00:01:05,390 --> 00:01:09,740
胜利者。首先，我们使用32字节的malloc 3对象。a.

14
00:01:09,740 --> 00:01:14,290
和C.然后我们将程序参数复制到A.B。

15
00:01:14,290 --> 00:01:18,170
C.显然，strcpy很脆弱，因为它

16
00:01:18,170 --> 00:01:22,910
不能阻止我们复制超过32个字节。这就是我们的溢出。

17
00:01:22,910 --> 00:01:27,880
然后我们再反向释放物体订单，C、B和A。

18
00:01:27,880 --> 00:01:32,930
最后还有打印件。所以你可以看到，没有明显的应用

19
00:01:32,930 --> 00:01:38,880
我们可以利用的逻辑。免费后不用，堆上没有易受攻击的指针。但仍然

20
00:01:38,880 --> 00:01:43,440
可以重定向代码执行。正如描述所说，这个水平是

21
00:01:43,439 --> 00:01:48,849
关于损坏堆元数据。所以那里是堆算法的问题，在这里

22
00:01:48,850 --> 00:01:54,460
在free（）函数中，我们可以使用将执行重定向到winner（）。

23
00:01:54,460 --> 00:02:00,670
让我们先看看gdb中的堆。为此，我们添加几个断点。

24
00:02:00,670 --> 00:02:06,370
每个图书馆的功能如何？所以打破在malloc，strcpy，free和printf，

25
00:02:06,370 --> 00:02:10,810
实际上是放在最后。让我们快跑吧，别忘了

26
00:02:10,810 --> 00:02:15,620
3个参数并继续，直到您到达在第一街。然后检查映射的

27
00:02:15,620 --> 00:02:22,330
此进程的内存并查找堆。这表明我们的堆区来自

28
00:02:22,330 --> 00:02:29,790
804c到804d。我们可以定义一个钩挡总是像这个地区的56个字一样打印

29
00:02:29,790 --> 00:02:34,660
当我们到达一个断点时。当我们现在重新运行程序时，我们可以看到

30
00:02:34,660 --> 00:02:39,180
堆发展起来了。我们来做吧。在我们执行第一个malloc之前，我们没有

31
00:02:39,180 --> 00:02:44,630
有堆了。在malloc之后，我们现在可以查看堆上的第一个对象。所以记住

32
00:02:44,629 --> 00:02:49,489
堆块的外观如何？这是尺寸当前块的。它是十六进制29。这个

33
00:02:49,490 --> 00:02:55,260
最后一位指示前一个块是否在使用中。因为这是特别的第一次

34
00:02:55,260 --> 00:03:00,280
chunk之前没有有效的内存，因此，它的位集表明

35
00:03:00,280 --> 00:03:06,160
内存不可用，不可用。这意味着块的实际大小是hex 28，其中

36
00:03:06,160 --> 00:03:12,310
是40字节，所以malloc分配了更多超过32字节。但对我们来说并不重要。

37
00:03:12,310 --> 00:03:16,480
在这片土地之后，我们有了荒野，就像第一块-有点特别。

38
00:03:16,480 --> 00:03:21,920
但你可以把它想象成一个巨大的自由块仍然可以分配，这是

39
00:03:21,920 --> 00:03:26,080
它的大小。很明显是最后一个位集，因为前一个块在

40
00:03:26,080 --> 00:03:31,210
使用。我们错落了第二个物体。大小相同。最后一个位集，因为前一个块是

41
00:03:31,209 --> 00:03:36,089
在使用中。原野被更新了现在的可用空间更少，但仍然是以前的

42
00:03:36,090 --> 00:03:41,200
区块正在使用中。最后一个物体。另一个同样大小的。最后一位集，

43
00:03:41,200 --> 00:03:45,740
因为前一个正在使用中。更少的空间在荒野中可用。

44
00:03:45,739 --> 00:03:50,539
接下来我们执行字符串复制。所以我们复制第一个争论是关于

45
00:03:50,540 --> 00:03:56,500
第一块。从B到第二块C到第三块。很明显我们可以

46
00:03:56,500 --> 00:04:00,960
已经写了很多并且完全覆盖了一切。包括块大小，其中

47
00:04:00,959 --> 00:04:03,179
是堆元数据。

48
00:04:03,180 --> 00:04:08,150
接下来我们要再次释放他们，所以最后一个大块被释放。CS被覆盖

49
00:04:08,150 --> 00:04:13,330
零，因为这两个词有特殊意义自由块的意思。所以以前我们

50
00:04:13,330 --> 00:04:18,220
已经分配了块。现在我们有一个街区又有了。免费。没什么别的

51
00:04:18,219 --> 00:04:22,789
改变。事实上，这些块很小被malloc视为"快速垃圾箱"。

52
00:04:22,789 --> 00:04:26,149
他们的行为有点不同。我们将稍后再了解。

53
00:04:26,150 --> 00:04:30,670
但让我们继续释放下一个，所以我们有两个自由街区。这次我们

54
00:04:30,669 --> 00:04:35,069
B被地址覆盖，它指向另一个空闲块。那就是

55
00:04:35,069 --> 00:04:38,729
重写词的特殊含义，它们是指向下一个自由的指针

56
00:04:38,729 --> 00:04:40,199
块。链表。

57
00:04:40,199 --> 00:04:44,749
好的，继续释放下一个，然后我们扩展链接列表。第一个空闲块

58
00:04:44,749 --> 00:04:47,839
指向第二个，第二个一点到第三点，就是

59
00:04:47,840 --> 00:04:51,800
荒原前最后一个街区。你可能会问自己为什么最后一点

60
00:04:51,800 --> 00:04:56,950
大小，表示上一个正在使用的块未设置为0。它的

61
00:04:56,949 --> 00:05:01,709
有点混乱，但像算法一样思考一秒钟。在这种情况下，它们很小

62
00:05:01,710 --> 00:05:06,540
快速的垃圾箱，我们要超快速的处理他们。以及我们如何在这个反向中释放块

63
00:05:06,539 --> 00:05:10,729
点菜，没关系。不必要浪费时间

64
00:05:10,729 --> 00:05:15,899
那个位子。想象一下这个指针，它总是指向第一个空闲块。

65
00:05:15,899 --> 00:05:20,049
当我现在想找点东西看的时候对于自由空间，我可以简单地按照

66
00:05:20,050 --> 00:05:24,080
链接列表以查找所有空闲块，因此上一个块是空闲的信息

67
00:05:24,080 --> 00:05:29,290
只是无关紧要，对吗？但是，它也会如果块大小有点不同

68
00:05:29,289 --> 00:05:34,199
更大。然后malloc和free会清理增加一点，使用更多堆元数据

69
00:05:34,199 --> 00:05:38,459
用于家庭护理。但我们不要挂断在此之上。我们会走过一些地方

70
00:05:38,460 --> 00:05:41,790
后来又清理了阿尔及尔坦的一些部分。

71
00:05:41,789 --> 00:05:47,009
让我们看看代码。当你寻找这个案例的dlmalloc算法，

72
00:05:47,009 --> 00:05:50,599
确保您的版本已结束15岁，否则你会看到

73
00:05:50,599 --> 00:05:51,789
版本。

74
00:05:51,789 --> 00:05:56,279
现在在我们开始阅读代码之前，想想我们正在寻找的东西。我们看

75
00:05:56,279 --> 00:06:01,969
对于一个允许我们执行任意写入。这样我们就可以

76
00:06:01,969 --> 00:06:08,319
覆盖全局偏移量表中的条目。一种可能的方法

77
00:06:08,319 --> 00:06:15,369
被滥用的原因看起来像是，在跟踪指针我们控制的，对吧？如果有的话

78
00:06:15,369 --> 00:06:22,219
在这里执行基于堆上的指针我们可以溢出，我们赢了。

79
00:06:22,219 --> 00:06:26,069
当我们看到代码。

80
00:06:26,070 --> 00:06:31,640
函数从参数mem开始，这是我们要释放的地址。不久

81
00:06:31,639 --> 00:06:36,489
后来叫mem2chunk，得到在mem前面加上两个单词，即

82
00:06:36,490 --> 00:06:42,280
块的实际起始地址。我们到达的第一个只有一点点

83
00:06:42,280 --> 00:06:47,560
代码位。它指的是快速垃圾箱。这个这正是我们获释时所看到的

84
00:06:47,560 --> 00:06:53,070
我们的32字节小块。它第一次更新指针，fd指针。创造了

85
00:06:53,069 --> 00:06:57,429
链表。但除此之外没什么事发生所以这并不有趣。

86
00:06:57,429 --> 00:07:02,319
所以这意味着我们真的想当然，我们的尺寸大于最大值

87
00:07:02,319 --> 00:07:08,919
Fastbin块大小，定义为80。我们的块大小是32，所以我们要确保

88
00:07:08,919 --> 00:07:12,709
我们溢出块的大小把手。

89
00:07:12,709 --> 00:07:16,539
如果我们去别的地方，如果，我们到达有趣的评论：

90
00:07:16,539 --> 00:07:21,249
"合并其他非mmaped块"。如果我们检查通过这个的必要条件

91
00:07:21,250 --> 00:07:27,030
测试，我们看块是一个简单的宏它的大小是p，大小是

92
00:07:27,029 --> 00:07:32,829
并检查是否已映射旗帜。非常类似于前一位，

93
00:07:32,830 --> 00:07:37,890
最后一个，是标记是最后一位。所以当我们想要的时候

94
00:07:37,889 --> 00:07:42,899
到达这里的密码，我们必须确保第二个最后一位没有设置。

95
00:07:42,900 --> 00:07:46,690
然后我们得到下一块的地址，我们可以根据

96
00:07:46,689 --> 00:07:52,029
我们当前的块。所以当溢出时，尺寸已经是我们可以控制的了，

97
00:07:52,029 --> 00:07:57,779
这意味着，我们有了第一次机会愚弄free（）思考其他数据

98
00:07:57,779 --> 00:08:02,299
是下一块。在那之后，我们检查一下

99
00:08:02,300 --> 00:08:07,130
块正在使用中，如果前一个块将未使用，由最低级别定义

100
00:08:07,129 --> 00:08:11,979
位设置为0，我们将按照上一个大小，我们还没有介绍，但是

101
00:08:11,979 --> 00:08:17,219
这个词在我们的块大小之前。因此计算上一个块的地址。

102
00:08:17,219 --> 00:08:23,289
同样，一个我们可以控制的值。然后我们执行取消链接。这就是魔法

103
00:08:23,289 --> 00:08:26,709
我在开头提到的话。所以让我们看看这意味着什么。

104
00:08:26,710 --> 00:08:32,000
第一个参数p，是前面的块我们现在的街区

105
00:08:31,999 --> 00:08:37,429
PrimeSe大小。我们向前和向后走块的指针，这是第一个

106
00:08:37,430 --> 00:08:43,680
第二个字在大小后面，记住在fd和bk中。

107
00:08:43,680 --> 00:08:50,130
为了简单起见，请忽略-&gt；bk和-&gt；fd，因为它只是引用了

108
00:08:50,130 --> 00:08:57,310
地址在这里。我们在后面加上这些偏移量。所以现在我们把地址bk写到地址

109
00:08:57,310 --> 00:09:00,430
fd指向的位置。然后我们写fd到地址

110
00:09:00,430 --> 00:09:01,740
BK指向。或者精确到它们各自的偏移量

111
00:09:01,740 --> 00:09:02,740
存储上一个和下一个指针的位置。

112
00:09:02,740 --> 00:09:05,990
好了，住手！BK可能是Winner函数。fd+12可能是我们的

113
00:09:05,990 --> 00:09:09,530
Puts（）的表条目。这将覆盖全局中的条目

114
00:09:09,529 --> 00:09:12,899
带Winner函数的偏移表。这个听起来很完美！！！！

115
00:09:12,899 --> 00:09:18,279
但是我们忘记了下一部分，我们会在哪里把我们的地址记在fd里，然后尝试

116
00:09:18,279 --> 00:09:24,279
写到赢家的地址（+8）。嗯……那就错了。我们不能写

117
00:09:24,280 --> 00:09:30,600
进入代码段。该死的…但现在你只需要有创造力。思考

118
00:09:30,601 --> 00:09:36,751
关于。如果我们有两个内存段。段A和B。我们可以从段中写入地址

119
00:09:36,750 --> 00:09:41,280
A进入B段，我们写一个地址从B段到A段。全球

120
00:09:41,279 --> 00:09:45,719
偏移表是可写的，因此其中一段，只是代码段

121
00:09:45,720 --> 00:09:51,120
不能是另一个。但是堆可以做我们的第二个。我们可以写入堆。

122
00:09:51,120 --> 00:09:55,160
这样我们就可以从堆到全局偏移量表，以及一些

123
00:09:55,160 --> 00:09:59,580
来自全局偏移量的不重要地址表将写入堆中！这个

124
00:09:59,581 --> 00:10:05,031
意味着我们可以通过全局偏移量表到shellcode

125
00:10:05,029 --> 00:10:09,749
放在堆里。然后这个外壳代码为我们呼叫赢家。

126
00:10:09,750 --> 00:10:14,440
听起来是个很棒的计划。我们以堆的状态为例

127
00:10:14,440 --> 00:10:18,420
想想我们要如何建造我们刚才解释的这个案子。

128
00:10:18,420 --> 00:10:22,800
所以我们可以决定释放最后一个块并确保前一个在用位

129
00:10:22,800 --> 00:10:28,270
设置为0。因此它试图巩固上一个块。让我们真正地

130
00:10:28,269 --> 00:10:33,639
这些变化就在这里和gdb一起，这样我们可以直接测试它。设置块大小

131
00:10:33,640 --> 00:10:40,120
大于80，上一位在用设置为0。为什么不100呢？现在我们要设置

132
00:10:40,120 --> 00:10:46,040
上一个大小，指向上一个块我们想和合并。让我们做一个

133
00:10:46,040 --> 00:10:48,220
小块。所以也许是十六进制10。

134
00:10:48,220 --> 00:10:57,180
这意味着在-0x10我们必须创建一个假块。那么大。所以设置0x11，因为

135
00:10:57,180 --> 00:11:03,540
我们想指出之前这个假块会被使用。伟大的。

136
00:11:03,540 --> 00:11:09,290
现在我们需要Puts在全球的地址偏移表。这将是向前指针

137
00:11:09,290 --> 00:11:15,900
第二个指针将写入的位置+ 12。这就是为什么你要做Puts-12，

138
00:11:15,899 --> 00:11:21,409
因为它会写在地址上+ 12。另一个指针是地址

139
00:11:21,410 --> 00:11:25,510
写入全局偏移表，所以你应该指向

140
00:11:25,509 --> 00:11:30,199
堆在我们可以放置一些shellcode的地方。为什么？不要到这里去。

141
00:11:30,199 --> 00:11:35,419
在我们之前，还有一件事要考虑可以测试，大小用来计算

142
00:11:35,420 --> 00:11:41,040
下一块和下一个大小。之后使用"取消链接"这些值。所以如果我们

143
00:11:41,040 --> 00:11:46,650
用100号，我们指一些没用的记忆，我们必须确保

144
00:11:46,649 --> 00:11:52,279
那里表现得很好。否则我们会撞车的有些人在这里。如果下一个

145
00:11:52,279 --> 00:11:58,039
大块是顶部，或者我们称之为荒野。但我们的规模超过了那个地址。

146
00:11:58,040 --> 00:12:03,870
这意味着我们在这种情况下着陆。现在它计算下一个块，然后

147
00:12:03,870 --> 00:12:08,910
检查prev-in-use位以确定前一块是否空闲。所以如果

148
00:12:08,910 --> 00:12:14,130
它不在使用中，我们执行另一个取消链接在当前块之后合并未使用的块

149
00:12:14,129 --> 00:12:17,459
一个。在这些指针周围复制。

150
00:12:17,459 --> 00:12:22,759
嘿，这是来自未来的活生生的。我只是在编辑这部分，我意识到

151
00:12:22,759 --> 00:12:27,759
我误读了这里的代码。我以为我在这种短距离断开连接的情况下

152
00:12:27,760 --> 00:12:32,480
案例，或者下面的整个案例。但我错过了没有花括号，这是

153
00:12:32,481 --> 00:12:39,231
也就是说，其他情况就是在偏移量处使用这个清晰的位。当我开发这个概念证明的时候

154
00:12:39,230 --> 00:12:44,340
我心里想我不想过分复杂这里有密码。事实上我做了

155
00:12:44,339 --> 00:12:49,589
它太复杂了，因为我们必须另一块假块现在处理这一秒

156
00:12:49,589 --> 00:12:54,459
在这里取消链接。但不管怎样，我认为是一次很好的学习经历。让我们的头

157
00:12:54,459 --> 00:12:58,699
回到这一集。

158
00:12:58,700 --> 00:13:01,870
现在我们应该已经成功了将堆地址写入全局

159
00:13:01,870 --> 00:13:06,000
上一个取消链接的偏移表，因此我们可以选择两个随机堆值

160
00:13:06,000 --> 00:13:08,330
这里不坠毁。

161
00:13:08,330 --> 00:13:12,750
所以这是另外两个假块。与指向的前后指针

162
00:13:12,750 --> 00:13:15,200
我们不关心的那堆。

163
00:13:15,200 --> 00:13:19,960
这是未来的生活溢出。再一次。我刚刚意识到我又犯了一个小错误

164
00:13:19,959 --> 00:13:23,639
这否定了我关于以前的大案子。

165
00:13:23,639 --> 00:13:30,229
我确实设置了prev-in-use位，这意味着它不会合并这个伪块。

166
00:13:30,230 --> 00:13:34,650
更不用说我设置了fd和bk指针不管怎么说都是为了错误的块。应该是

167
00:13:34,649 --> 00:13:38,269
在另一块上。对不起，伙计们。我只是个笨蛋。

168
00:13:38,269 --> 00:13:44,309
总结一下。我们改变了我们要去自由的街区。我们创造了一个假货

169
00:13:44,310 --> 00:13:50,530
在触发当前块之前释放块取消链接并覆盖got。我们创造了

170
00:13:50,529 --> 00:13:54,989
两块假货，第二块一个说的是它所处的前一个

171
00:13:54,990 --> 00:14:00,500
使用。因此不会触发另一个取消链接。和这两种价值观是不必要的。

172
00:14:00,499 --> 00:14:06,409
如果我们继续执行第一个自由，我们可以查看输入的看跌期权

173
00:14:06,410 --> 00:14:10,760
函数地址已成功写入。当我们看到堆的时候，我们可以看到

174
00:14:10,759 --> 00:14:17,859
在偏移量+8处，我们有一个写入的地址。令人惊叹的。当我们继续看跌时

175
00:14:17,860 --> 00:14:22,680
向前迈出一步，我们跳进了一堆。令人惊叹的！

176
00:14:22,680 --> 00:14:26,670
这是有效的！现在我们只需要这些值与strcpy一起放入堆中…

177
00:14:26,670 --> 00:14:36,050
哦，不，不，不。我很笨。斯特里皮无法复制空字节。定义了C中的字符串

178
00:14:36,050 --> 00:14:43,150
以空结尾。所以我们不能写尺寸像十六进制10一样进入内存。至少不是多重的

179
00:14:43,149 --> 00:14:49,929
时代。哦，该死的。整个计划没有在这种情况下工作…如果它是read（）它

180
00:14:49,930 --> 00:14:52,390
会起作用。但不是用strcpy。

181
00:14:52,389 --> 00:14:57,179
我现在坐在角落里想生活中所有的失败。期待很快与您见面。也许吧。

