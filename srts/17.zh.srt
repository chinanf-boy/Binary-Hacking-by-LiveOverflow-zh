1
00:00:07,490 --> 00:00:11,940
我们已经看过很多集了，我们阅读汇编代码和逆向工程。

2
00:00:11,940 --> 00:00:13,440
how a program works.

3
00:00:13,440 --> 00:00:17,680
我们甚至通过使用缓冲区溢出漏洞在

4
00:00:17,680 --> 00:00:21,700
一个用C语言写的节目。在这一集里，我想向你展示

5
00:00:21,700 --> 00:00:24,980
can learn how to read assembler produced by C code yourself.

6
00:00:24,980 --> 00:00:27,390
The idea is simple.

7
00:00:27,390 --> 00:00:31,670
只需编写一些具有不同C语言特性的C代码，然后查看汇编程序代码

8
00:00:31,670 --> 00:00:34,230
that is produced by compiling it.

9
00:00:34,230 --> 00:00:36,760
This is often part of normal research.

10
00:00:36,760 --> 00:00:41,760
例如，听谷歌零号项目的伊恩·比尔在一次关于他的谈话中所说的话。

11
00:00:41,760 --> 00:00:44,820
research on Inter Process Calls on OSX.

12
00:00:44,820 --> 00:00:50,630
要想扭转局面，或者理解这类事情是如何运作的，一个方法就是坐着

13
00:00:50,629 --> 00:00:56,729
在IDA中，只需反转序列化和反序列化代码，然后慢慢构建

14
00:00:56,730 --> 00:00:58,640
up a picture of how it works.

15
00:00:58,640 --> 00:01:03,000
但另一种很好的方法是，编写一个测试程序来发送

16
00:01:03,000 --> 00:01:11,160
messages and then find the right place using lldb to break and just start dumping hex.

17
00:01:11,159 --> 00:01:16,139
因此，由于他必须理解相当复杂的数据结构，他只需编写一个

18
00:01:16,140 --> 00:01:19,990
test program to analyse it, instead of reversing a full application.

19
00:01:19,990 --> 00:01:27,590
或者是在2007从黑头美国的一篇关于如何逆转C++程序的演讲和论文，

20
00:01:27,590 --> 00:01:32,420
by looking at C++ concepts and how they look like in assembler.

21
00:01:32,420 --> 00:01:37,710
所以现在我已经创建了三个不同的C代码测试用例，您可以在我的Github中找到它们。

22
00:01:37,710 --> 00:01:40,180
repository, or just write it yourself.

23
00:01:40,179 --> 00:01:42,819
One is about variables and datatypes.

24
00:01:42,820 --> 00:01:44,570
One is about function calls.

25
00:01:44,569 --> 00:01:48,319
And one is about control flow stuff like loops and ifs.

26
00:01:48,319 --> 00:01:51,649
So let’s start with the variables.c.

27
00:01:51,649 --> 00:01:54,729
First thing I want to point out are those triple Xs.

28
00:01:54,729 --> 00:01:59,419
Those triple Xs are defined as an assembler NOP instruction.

29
00:01:59,420 --> 00:02:04,830
原因是，稍后当我们研究拆卸时，我们可以找到那些NOP

30
00:02:04,829 --> 00:02:08,799
which are separating our tests, and that is pretty neat.

31
00:02:08,800 --> 00:02:13,960
所以这使得我们更容易看到C代码的哪一行负责其中的哪一行

32
00:02:13,959 --> 00:02:14,989
assembler.

33
00:02:14,990 --> 00:02:20,010
I will not go over every single test, this is something you could do yourself.

34
00:02:20,010 --> 00:02:22,850
Simply pause the video at certain points or clone the repository.

35
00:02:22,850 --> 00:02:23,850
Anyway.

36
00:02:23,850 --> 00:02:24,850
Let’s get started.

37
00:02:24,850 --> 00:02:25,880
First of all you can see here a couple of simple numbers.

38
00:02:25,880 --> 00:02:28,230
First we define a couple of numbers.

39
00:02:28,230 --> 00:02:31,550
Unsigned and signed, integers and floating numbers.

40
00:02:31,550 --> 00:02:35,440
And different sizes with uint32 or uint64.

41
00:02:35,440 --> 00:02:40,690
后者很重要，因为正整数的大小取决于32位

42
00:02:40,690 --> 00:02:43,980
or 64bit, so it can lead to bugs.

43
00:02:43,980 --> 00:02:48,170
So better use datatypes you are guaranteed to get a certain size.

44
00:02:48,170 --> 00:02:52,620
如果你想进一步了解如何正确地编程C，有一个很棒的博客条目叫做

45
00:02:52,620 --> 00:02:55,670
“How to C in 2015”.

46
00:02:55,670 --> 00:03:02,320
然后我们创建一个包含32位无符号整数的数组，并访问其中的一个元素

47
00:03:02,320 --> 00:03:03,320
array.

48
00:03:03,320 --> 00:03:05,420
Then we look at a single character.

49
00:03:05,420 --> 00:03:06,840
And then also a string.

50
00:03:06,840 --> 00:03:11,790
也许你知道星星*在c中的意思是“指针”，所以我们定义了一个指向

51
00:03:11,790 --> 00:03:13,590
to a string.

52
00:03:13,590 --> 00:03:18,220
我添加了一个makefile，所以您可以简单地在终端中键入'make'来编译所有

53
00:03:18,220 --> 00:03:19,220
files.

54
00:03:19,220 --> 00:03:21,310
Or make clean to remove the binaries.

55
00:03:21,310 --> 00:03:25,390
This will create a 32bit and a 64bit version of the variables program.

56
00:03:25,390 --> 00:03:31,670
但是正如你所看到的，我在编译32位版本时遇到了一个错误，其中包含了-m32

57
00:03:31,670 --> 00:03:33,790
64bit machine.

58
00:03:33,790 --> 00:03:38,150
So I have to install the 32bit libraries first, to be able to build the code.

59
00:03:38,150 --> 00:03:41,870
After installing those, the build works fine.

60
00:03:41,870 --> 00:03:49,770
A Makefile is just a little script that defines how a project has to be compiled.

61
00:03:49,770 --> 00:03:55,220
那么让我们打开gdb中彼此相邻的代码、32位和64位版本并反汇编

62
00:03:55,220 --> 00:03:56,220
main.

63
00:03:56,220 --> 00:04:02,860
And also open the code.

64
00:04:02,860 --> 00:04:08,090
好了，现在让我们来看第一个带负值、有符号和无符号的整数示例。

65
00:04:08,090 --> 00:04:09,090
values.

66
00:04:09,090 --> 00:04:13,550
首先，所有这些局部变量都存储在堆栈的某个地方，您可以看到

67
00:04:13,550 --> 00:04:18,310
that because they are referenced relative to the base-pointer.

68
00:04:18,310 --> 00:04:21,890
Then you notice that the assembler code doesn’t know negative numbers.

69
00:04:21,890 --> 00:04:24,170
They are fff something.

70
00:04:24,169 --> 00:04:28,449
如果你对负数的显示方式感兴趣，请看我的第10集

71
00:04:28,449 --> 00:04:29,449
numbers.

72
00:04:29,449 --> 00:04:35,719
And also there is no difference between variables that are signed or unsigned.

73
00:04:35,720 --> 00:04:40,120
But there is one difference between the 32bit and the 64bit code.

74
00:04:40,120 --> 00:04:45,270
因为我们定义了一个64位长的数字，但是32位的寄存器只有

75
00:04:45,270 --> 00:04:46,270
32bit.

76
00:04:46,270 --> 00:04:51,730
So if you want to write full 64bit, you have to write two times.

77
00:04:51,729 --> 00:04:53,829
The floating point numbers are also interesting.

78
00:04:53,830 --> 00:04:56,120
Because they got stored somewhere else in the program.

79
00:04:56,120 --> 00:05:01,140
And that value is then moved into the local variable.

80
00:05:01,139 --> 00:05:02,549
The array is also interesting.

81
00:05:02,550 --> 00:05:08,110
We created an array with 10 values but only set the first 5 values to a default value.

82
00:05:08,110 --> 00:05:11,550
As you can see those values are stored on the stack.

83
00:05:11,550 --> 00:05:15,850
And then it is moved from that location on the stack to the real array location.

84
00:05:15,849 --> 00:05:19,889
Instead of writing it directly to the array it does it this way.

85
00:05:19,889 --> 00:05:20,889
No idea why.

86
00:05:20,889 --> 00:05:24,259
And you can see down here when we reference the 3rd entry.

87
00:05:24,259 --> 00:05:30,209
So you can see that this is the real location of the array on the stack.

88
00:05:30,210 --> 00:05:31,470
Next come the strings.

89
00:05:31,469 --> 00:05:33,739
You can see that a character is just a byte.

90
00:05:33,740 --> 00:05:39,140
It doesn’t matter if we have an unsigned int with 8bit or a char.

91
00:05:39,139 --> 00:05:40,469
It’s the same.

92
00:05:40,470 --> 00:05:42,930
And strings are also referenced over an address.

93
00:05:42,930 --> 00:05:47,190
So the local variable is not an array of charactes.

94
00:05:47,189 --> 00:05:50,529
the local variable contains an address pointing to a string.

95
00:05:50,529 --> 00:05:52,929
Now let’s have a look at the control_flows.

96
00:05:52,930 --> 00:05:55,300
Open it in radare.

97
00:05:55,300 --> 00:05:59,330
Analyse all, seek to main function and enter Visual mode.

98
00:05:59,330 --> 00:06:01,080
First we set a variable to zero.

99
00:06:01,080 --> 00:06:02,590
And then comes the if.

100
00:06:02,590 --> 00:06:08,890
This is done by loading this local variable in a register and comparing to hex ff.

101
00:06:08,889 --> 00:06:11,679
And then jump if it was less or equal.

102
00:06:11,680 --> 00:06:15,250
So you can see which branch it may take.

103
00:06:15,250 --> 00:06:16,680
Then comes a while loop.

104
00:06:16,680 --> 00:06:22,940
我们在寄存器中再次加载局部变量，将其与一个值进行比较，然后跳进去

105
00:06:22,939 --> 00:06:25,849
the block or leave.

106
00:06:25,849 --> 00:06:31,709
And inside the block we load this value again, increment it and write it back.

107
00:06:31,710 --> 00:06:33,690
Now compare it to the foor loop.

108
00:06:33,689 --> 00:06:35,619
基本上是一样的！

109
00:06:35,620 --> 00:06:37,950
We start by setting the variable to 0.

110
00:06:37,949 --> 00:06:41,289
Then we compare if the loop condition is still true.

111
00:06:41,289 --> 00:06:43,739
And inside the loop block, we can see our NOP.

112
00:06:43,740 --> 00:06:47,730
And at the end of the block we increment the variable by 1.

113
00:06:47,729 --> 00:06:50,279
Exactly the same like the while loop.

114
00:06:50,280 --> 00:06:55,800
So you can see that a for and a while loop in C are basically the same.

115
00:06:55,800 --> 00:06:58,520
Next let’s have a look at how functions are called.

116
00:06:58,520 --> 00:07:03,910
Again open both the 32bit and 64bit version.

117
00:07:03,910 --> 00:07:08,410
First thing you notice that the 64bit version moves a 0 in eax.

118
00:07:08,409 --> 00:07:09,549
No idea why.

119
00:07:09,550 --> 00:07:11,870
Otherwise the function call looks the same.

120
00:07:11,870 --> 00:07:13,500
Except look at the addresses.

121
00:07:13,499 --> 00:07:18,759
If you have no ASLR, then 64bit code is generally at hex 40 something.

122
00:07:18,759 --> 00:07:22,859
While 32bit code is at hex 80 something.

123
00:07:22,860 --> 00:07:27,510
知道这样的东西是有帮助的，因为如果你看到一个地址有40多岁，你

124
00:07:27,509 --> 00:07:31,739
know immediately that it’s pointing into your code.

125
00:07:31,740 --> 00:07:35,210
So the next function returns a value and we save it in a variable.

126
00:07:35,210 --> 00:07:40,590
And you can see that in both cases, the value is taken from the eax register.

127
00:07:40,589 --> 00:07:45,869
Ok, so apparently return values are handled via eax.

128
00:07:45,870 --> 00:07:50,380
Now function 3 is interesting, because we pass a parameter to it.

129
00:07:50,379 --> 00:07:56,699
在32位中，您可以看到该值是从某个位置加载的，然后存储在

130
00:07:56,699 --> 00:07:57,839
stack.

131
00:07:57,840 --> 00:08:00,000
And then the function is called.

132
00:07:59,999 --> 00:08:05,329
But on 64bit we see that the value is loaded into the edi register.

133
00:08:05,330 --> 00:08:07,970
This is our first big difference.

134
00:08:07,969 --> 00:08:13,589
64位中的函数似乎是用寄存器中的参数调用的，而32位中的

135
00:08:13,589 --> 00:08:16,749
parameters are stored on the stack.

136
00:08:16,749 --> 00:08:18,219
Next function uses 2 parameters.

137
00:08:18,220 --> 00:08:22,930
And again, you can see how 32bit just places the value on the stack.

138
00:08:22,930 --> 00:08:26,060
First parameter on top of the stack, the second a bit further down.

139
00:08:26,060 --> 00:08:30,160
But in 64bit you can see that it uses esi and edi for that.

140
00:08:30,159 --> 00:08:32,079
Now we get curious.

141
00:08:32,080 --> 00:08:38,480
当我们有这么多参数，我们不能将它们全部保存在寄存器中时，64位会做什么？

142
00:08:38,479 --> 00:08:40,349
First of all 32bit code again.

143
00:08:40,349 --> 00:08:42,979
You can see how the parameters are stored on the stack.

144
00:08:42,979 --> 00:08:46,759
And the first parameter is on top of the stack, and the last value moved.

145
00:08:46,759 --> 00:08:48,389
That’s what we would expect.

146
00:08:48,389 --> 00:08:53,769
在64位中，我们可以看到前两个参数存储在寄存器edi中，

147
00:08:53,769 --> 00:08:55,769
esi, edx, and so forth.

148
00:08:55,770 --> 00:09:00,530
But from the 7th parameter on, they get stored on the stack as well.

149
00:09:00,530 --> 00:09:02,240
令人惊叹的！

150
00:09:02,240 --> 00:09:06,130
Now you can identify all kind of different assembler patterns.

151
00:09:06,130 --> 00:09:08,220
You don’t need a decompiler all the time.

152
00:09:08,220 --> 00:09:10,040
You can do this all in your head.

153
00:09:10,040 --> 00:09:14,420
当你逆转越来越多的程序时，这些模式变得更容易识别，

154
00:09:14,420 --> 00:09:18,740
and you will not feel overwhelmed again with the mass of weird instructions.

155
00:09:18,740 --> 00:09:23,690
You will be able to scan over a function and say: “ah here is a local variable.

156
00:09:23,690 --> 00:09:26,640
Then calls this other function with this variable as parameter.

157
00:09:26,639 --> 00:09:28,549
And the return value is used in a loop”.

158
00:09:28,550 --> 00:09:33,790
你可以用同样的方法来理解不同的拆卸器，比如Hopper，Radare，

159
00:09:33,790 --> 00:09:35,600
gdb display code.

160
00:09:35,600 --> 00:09:41,010
Or for example how different the at&amp;t assembler syntax is from the intel syntax.

161
00:09:41,009 --> 00:09:43,629
I hope you have a lot of fun next time reversing a program.

