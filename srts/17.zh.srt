1
00:00:07,490 --> 00:00:11,940
我们已经有很多剧集
读取汇编程序代码并进行反向工程

2
00:00:11,940 --> 00:00:13,440
程序如何工作。

3
00:00:13,440 --> 00:00:17,680
我们甚至写了我们的第一篇文章
通过使用缓冲区溢出漏洞

4
00:00:17,680 --> 00:00:21,700
用C语言编写的程序。
在这一集里，我想告诉你

5
00:00:21,700 --> 00:00:24,980
可以学习如何读取由
C编码你自己。

6
00:00:24,980 --> 00:00:27,390
这个想法很简单。

7
00:00:27,390 --> 00:00:31,670
只需用不同的C语言编写一些C代码
特性，然后查看汇编程序代码

8
00:00:31,670 --> 00:00:34,230
它是通过编译产生的。

9
00:00:34,230 --> 00:00:36,760
这通常是正常研究的一部分。

10
00:00:36,760 --> 00:00:41,760
例如，听什么是来自谷歌的伊恩啤酒
零号计划在一次关于他的谈话中说

11
00:00:41,760 --> 00:00:44,820
OSX进程间调用研究。

12
00:00:44,820 --> 00:00:50,630
一种逆转或理解的方法
坐着干这种事

13
00:00:50,629 --> 00:00:56,729
在IDA中，只需反转序列化
和反序列化代码，并缓慢生成

14
00:00:56,730 --> 00:00:58,640
把它的工作原理拍下来。

15
00:00:58,640 --> 00:01:03,000
但另一种非常好的方法，
只是写一个测试程序

16
00:01:03,000 --> 00:01:11,160
然后使用
lldb断开并开始转储hex。

17
00:01:11,159 --> 00:01:16,139
所以，因为他必须明白
复杂的数据结构，他简单地写了一个

18
00:01:16,140 --> 00:01:19,990
测试程序来分析它，而不是反转
完整的申请。

19
00:01:19,990 --> 00:01:27,590
或者有一篇来自黑帽的演讲和论文
美国2007关于如何逆转C++程序，

20
00:01:27,590 --> 00:01:32,420
通过查看C++概念及其外观
就像装配工一样。

21
00:01:32,420 --> 00:01:37,710
所以现在我已经创建了三个不同的C代码
测试用例，你可以在我的Github中找到它们

22
00:01:37,710 --> 00:01:40,180
或者自己写。

23
00:01:40,179 --> 00:01:42,819
一个是关于变量和数据类型。

24
00:01:42,820 --> 00:01:44,570
一个是关于函数调用。

25
00:01:44,569 --> 00:01:48,319
一个是关于控制流程的，比如循环
和IFS。

26
00:01:48,319 --> 00:01:51,649
让我们从变量c开始。

27
00:01:51,649 --> 00:01:54,729
我首先要指出的是
三重xs。

28
00:01:54,729 --> 00:01:59,419
这些三倍x被定义为汇编程序
NOP指令。

29
00:01:59,420 --> 00:02:04,830
原因是，后来当我们
在拆卸过程中，我们可以找到那些NOP

30
00:02:04,829 --> 00:02:08,799
把我们的测试分开，那就是
相当整洁。

31
00:02:08,800 --> 00:02:13,960
这样就更容易看到哪条线了
C代码负责

32
00:02:13,959 --> 00:02:14,989
汇编程序。

33
00:02:14,990 --> 00:02:20,010
我不会把每一个测试都复习一遍，这个
是你自己能做的事。

34
00:02:20,010 --> 00:02:22,850
只需在特定点暂停视频或
克隆存储库。

35
00:02:22,850 --> 00:02:23,850
不管怎样。

36
00:02:23,850 --> 00:02:24,850
我们开始吧。

37
00:02:24,850 --> 00:02:25,880
首先，你可以在这里看到一些
简单数字。

38
00:02:25,880 --> 00:02:28,230
首先我们定义几个数字。

39
00:02:28,230 --> 00:02:31,550
无符号和有符号，整数和浮点
数字。

40
00:02:31,550 --> 00:02:35,440
以及不同尺寸的uint32或uint64。

41
00:02:35,440 --> 00:02:40,690
后者很重要，因为正整数
可能有不同的大小取决于32位

42
00:02:40,690 --> 00:02:43,980
或者64位，这样就可以导致错误。

43
00:02:43,980 --> 00:02:48,170
所以最好使用保证的数据类型
以获得一定的尺寸。

44
00:02:48,170 --> 00:02:52,620
如果你想进一步了解如何编程
正确地说，有一个伟大的博客条目叫做

45
00:02:52,620 --> 00:02:55,670
"2015年如何实现C"。

46
00:02:55,670 --> 00:03:02,320
然后我们创建一个32位无符号数组
整数，我们访问其中的一个元素

47
00:03:02,320 --> 00:03:03,320
数组。

48
00:03:03,320 --> 00:03:05,420
然后我们看一个角色。

49
00:03:05,420 --> 00:03:06,840
还有一根绳子。

50
00:03:06,840 --> 00:03:11,790
也许你知道星星*的意思是"指针"
所以我们定义了一个指向

51
00:03:11,790 --> 00:03:13,590
一个字符串。

52
00:03:13,590 --> 00:03:18,220
我添加了一个makefile，所以您可以
在终端中键入"make"以编译所有

53
00:03:18,220 --> 00:03:19,220
文件夹。

54
00:03:19,220 --> 00:03:21,310
或者清除以删除二进制文件。

55
00:03:21,310 --> 00:03:25,390
这将创建32位和64位版本
变量程序的。

56
00:03:25,390 --> 00:03:31,670
但正如你所看到的，我尝试时出错了
编译32位版本，其中包含-m32

57
00:03:31,670 --> 00:03:33,790
64位机。

58
00:03:33,790 --> 00:03:38,150
所以我必须先安装32位库，
以便能够构建代码。

59
00:03:38,150 --> 00:03:41,870
安装这些之后，构建工作正常。

60
00:03:41,870 --> 00:03:49,770
makefile只是一个定义
如何编译项目。

61
00:03:49,770 --> 00:03:55,220
那么让我们打开代码，32位和64位
GDB中彼此相邻的版本和反汇编

62
00:03:55,220 --> 00:03:56,220
主要的。

63
00:03:56,220 --> 00:04:02,860
同时打开代码。

64
00:04:02,860 --> 00:04:08,090
好了，现在让我们来看第一个整数示例
带负值和有符号和无符号

65
00:04:08,090 --> 00:04:09,090
价值观。

66
00:04:09,090 --> 00:04:13,550
首先，所有这些局部变量
存储在堆栈的某个位置，您可以看到

67
00:04:13,550 --> 00:04:18,310
因为它们是相对引用的
指向基指针。

68
00:04:18,310 --> 00:04:21,890
然后您注意到汇编程序代码没有
知道负数。

69
00:04:21,890 --> 00:04:24,170
他们是FFF什么的。

70
00:04:24,169 --> 00:04:28,449
如果你对负数有兴趣的话
显示，观看我的第10集关于

71
00:04:28,449 --> 00:04:29,449
数字。

72
00:04:29,449 --> 00:04:35,719
变量之间也没有区别
有签名或无签名的。

73
00:04:35,720 --> 00:04:40,120
但是32位之间有一个区别
以及64位代码。

74
00:04:40,120 --> 00:04:45,270
因为我们定义了一个64位的数字
长，但在32位上，寄存器只有

75
00:04:45,270 --> 00:04:46,270
32位。

76
00:04:46,270 --> 00:04:51,730
所以如果你想写完整的64位，你可以
写两次。

77
00:04:51,729 --> 00:04:53,829
浮点数也很有趣。

78
00:04:53,830 --> 00:04:56,120
因为它们被存放在别的地方
程序。

79
00:04:56,120 --> 00:05:01,140
然后将该值移动到本地
变量。

80
00:05:01,139 --> 00:05:02,549
这个数组也很有趣。

81
00:05:02,550 --> 00:05:08,110
我们创建了一个具有10个值的数组，但仅
将前5个值设置为默认值。

82
00:05:08,110 --> 00:05:11,550
如您所见，这些值存储在
堆栈。

83
00:05:11,550 --> 00:05:15,850
然后从那个位置移到
堆栈到实际数组位置。

84
00:05:15,849 --> 00:05:19,889
而不是直接将其写入数组
它是这样做的。

85
00:05:19,889 --> 00:05:20,889
不知道为什么。

86
00:05:20,889 --> 00:05:24,259
当我们提到
第三条目。

87
00:05:24,259 --> 00:05:30,209
所以你可以看到这是真实的位置
堆栈上的数组。

88
00:05:30,210 --> 00:05:31,470
接下来是弦乐。

89
00:05:31,469 --> 00:05:33,739
您可以看到一个字符只是一个字节。

90
00:05:33,740 --> 00:05:39,140
我们有没有签名没关系
int加8位或1个字符。

91
00:05:39,139 --> 00:05:40,469
是一样的。

92
00:05:40,470 --> 00:05:42,930
字符串也在地址上被引用。

93
00:05:42,930 --> 00:05:47,190
因此局部变量不是字符数组。

94
00:05:47,189 --> 00:05:50,529
局部变量包含一个指向
一个字符串。

95
00:05:50,529 --> 00:05:52,929
现在让我们看看控制流。

96
00:05:52,930 --> 00:05:55,300
在Radare打开它。

97
00:05:55,300 --> 00:05:59,330
分析全部，寻求主要功能并进入
视觉模式。

98
00:05:59,330 --> 00:06:01,080
首先，我们将变量设置为零。

99
00:06:01,080 --> 00:06:02,590
然后是如果。

100
00:06:02,590 --> 00:06:08,890
这是通过加载这个局部变量来完成的。
在寄存器中，并与十六进制FF进行比较。

101
00:06:08,889 --> 00:06:11,679
如果小于或等于，则跳。

102
00:06:11,680 --> 00:06:15,250
所以你可以看到它可能需要哪个分支。

103
00:06:15,250 --> 00:06:16,680
然后是一个小循环。

104
00:06:16,680 --> 00:06:22,940
我们在寄存器中再次加载局部变量，
将它与一个值进行比较，然后跳进去

105
00:06:22,939 --> 00:06:25,849
要么封锁要么离开。

106
00:06:25,849 --> 00:06:31,709
在这个块中，我们再次加载这个值，
递增并写回。

107
00:06:31,710 --> 00:06:33,690
现在将其与foor循环进行比较。

108
00:06:33,689 --> 00:06:35,619
基本上是一样的！

109
00:06:35,620 --> 00:06:37,950
我们首先将变量设置为0。

110
00:06:37,949 --> 00:06:41,289
然后比较循环条件是否仍然存在
真的。

111
00:06:41,289 --> 00:06:43,739
在循环块中，我们可以看到
NOP。

112
00:06:43,740 --> 00:06:47,730
在块的末尾，我们增加
变量为1。

113
00:06:47,729 --> 00:06:50,279
与while循环完全相同。

114
00:06:50,280 --> 00:06:55,800
所以你可以看到一个for和while循环
在C中基本相同。

115
00:06:55,800 --> 00:06:58,520
接下来，让我们来看看如何工作
被称为。

116
00:06:58,520 --> 00:07:03,910
再次打开32位和64位版本。

117
00:07:03,910 --> 00:07:08,410
首先你注意到64位版本
在EAX中移动0。

118
00:07:08,409 --> 00:07:09,549
不知道为什么。

119
00:07:09,550 --> 00:07:11,870
否则，函数调用看起来是相同的。

120
00:07:11,870 --> 00:07:13,500
除了看看地址。

121
00:07:13,499 --> 00:07:18,759
如果没有aslr，则64位代码通常是
在十六进制40左右。

122
00:07:18,759 --> 00:07:22,859
32位代码是十六进制80左右。

123
00:07:22,860 --> 00:07:27,510
知道这样的事情是有帮助的，因为
如果你看到一个地址有40多岁，你

124
00:07:27,509 --> 00:07:31,739
立即知道它指向
您的代码。

125
00:07:31,740 --> 00:07:35,210
所以下一个函数返回一个值，
将其保存在变量中。

126
00:07:35,210 --> 00:07:40,590
你可以看到在这两种情况下
取自EAX寄存器。

127
00:07:40,589 --> 00:07:45,869
好的，所以很明显返回值被处理了
通过EAX。

128
00:07:45,870 --> 00:07:50,380
现在函数3很有趣，因为我们
向其传递参数。

129
00:07:50,379 --> 00:07:56,699
在32位中，您可以看到该值已加载
从某个地方，然后存储在

130
00:07:56,699 --> 00:07:57,839
栈。

131
00:07:57,840 --> 00:08:00,000
然后调用函数。

132
00:07:59,999 --> 00:08:05,329
但是在64位上，我们看到值被加载
进入EDI寄存器。

133
00:08:05,330 --> 00:08:07,970
这是我们的第一大区别。

134
00:08:07,969 --> 00:08:13,589
64位中的函数似乎是用
寄存器中的参数，而在32位中

135
00:08:13,589 --> 00:08:16,749
参数存储在堆栈上。

136
00:08:16,749 --> 00:08:18,219
下一个函数使用两个参数。

137
00:08:18,220 --> 00:08:22,930
同样，你可以看到32位的位置
堆栈上的值。

138
00:08:22,930 --> 00:08:26,060
堆栈顶部的第一个参数，第二个参数
再往下一点。

139
00:08:26,060 --> 00:08:30,160
但是在64位中，您可以看到它使用ESI
还有全民教育发展指数。

140
00:08:30,159 --> 00:08:32,079
现在我们开始好奇了。

141
00:08:32,080 --> 00:08:38,480
当我们有这么多参数时，64位的作用是什么？
我们不能把它们都登记在册？

142
00:08:38,479 --> 00:08:40,349
首先是32位代码。

143
00:08:40,349 --> 00:08:42,979
您可以看到参数是如何存储的。
在堆栈上。

144
00:08:42,979 --> 00:08:46,759
第一个参数在堆栈的顶部，
最后一个值移动了。

145
00:08:46,759 --> 00:08:48,389
这就是我们所期望的。

146
00:08:48,389 --> 00:08:53,769
在64位中，我们可以看到第一对夫妇
参数存储在寄存器edi中，

147
00:08:53,769 --> 00:08:55,769
ESI、EDX等。

148
00:08:55,770 --> 00:09:00,530
但从第7个参数开始，它们被存储
也在堆栈上。

149
00:09:00,530 --> 00:09:02,240
令人惊叹的！

150
00:09:02,240 --> 00:09:06,130
现在你可以识别出所有不同的
汇编程序模式。

151
00:09:06,130 --> 00:09:08,220
你不需要一个反编译器。

152
00:09:08,220 --> 00:09:10,040
你可以在脑子里做这一切。

153
00:09:10,040 --> 00:09:14,420
当你逆转越来越多的程序时，
这些模式变得更容易识别，

154
00:09:14,420 --> 00:09:18,740
你不会再感到不知所措了
大量奇怪的指示。

155
00:09:18,740 --> 00:09:23,690
您将能够扫描一个函数并
说："这是一个局部变量。

156
00:09:23,690 --> 00:09:26,640
然后用这个变量调用另一个函数
作为参数。

157
00:09:26,639 --> 00:09:28,549
返回值在循环中使用。

158
00:09:28,550 --> 00:09:33,790
你可以用同样的方法来理解
像Hopper、Radare等不同的拆卸器

159
00:09:33,790 --> 00:09:35,600
GDB显示代码。

160
00:09:35,600 --> 00:09:41,010
或者例如，AT&T汇编程序有多不同
语法来自Intel语法。

161
00:09:41,009 --> 00:09:43,629
希望你下次倒车时玩得开心
一个程序。

