1
00:00:07,490 --> 00:00:11,940
我们已经看过很多，关于阅读汇编代码。

2
00:00:11,940 --> 00:00:13,440
以及逆转工程程序如何工作的视频。

3
00:00:13,440 --> 00:00:17,680
我们甚至编写了第一个利用缓冲区溢出漏洞的利用脚本

4
00:00:17,680 --> 00:00:21,700
一个用C语言写的程序。在这一集里，我想向你展示

5
00:00:21,700 --> 00:00:24,980
自我学习，如何读取由C代码生成的汇编程序。

6
00:00:24,980 --> 00:00:27,390
这个想法很简单。

7
00:00:27,390 --> 00:00:31,670
只需编写一些具有，不同C语言特性的C代码，然后查看

8
00:00:31,670 --> 00:00:34,230
由编译产生的汇编程序代码。

9
00:00:34,230 --> 00:00:36,760
这通常是正常研究的一部分。

10
00:00:36,760 --> 00:00:41,760
例如，听谷歌零号项目的伊恩·比尔，在一次关于，

11
00:00:41,760 --> 00:00:44,820
OSX进程间调用研究的采访中，所说的话。

12
00:00:44,820 --> 00:00:50,630
要进行反工程，或者理解这类事情是如何运作的，一个方法就

13
00:00:50,629 --> 00:00:56,729
是坐在IDA中，只需逆转序列化和反序列化代码，

14
00:00:56,730 --> 00:00:58,640
然后慢慢构建起一幅关于它的工作原理的图像。

15
00:00:58,640 --> 00:01:03,000
但另一种很好的方法是，编写一个测试程序

16
00:01:03,000 --> 00:01:11,160
来发送信息，然后使用 lldb 找到正确的位置，断点，并开始转储 hex。

17
00:01:11,159 --> 00:01:16,139
因此，由于他能理解相当复杂的数据结构，

18
00:01:16,140 --> 00:01:19,990
只需编写一个测试程序来分析它，而不是逆转一个完整的应用程序。

19
00:01:19,990 --> 00:01:27,590
或者是在2007，来自黑帽美国(blackhat USA)的，一篇关于如何逆转C++程序的演讲和论文，

20
00:01:27,590 --> 00:01:32,420
通过查看C++概念，以及它们在汇编程序中的样子。

21
00:01:32,420 --> 00:01:37,710
所以，现在我已经创建了三个不同的C代码测试用例，您可以在我的Github中，找到它们。

22
00:01:37,710 --> 00:01:40,180
或者自己写。

23
00:01:40,179 --> 00:01:42,819
一个是关于变量和数据类型。

24
00:01:42,820 --> 00:01:44,570
一个是关于函数调用。

25
00:01:44,569 --> 00:01:48,319
一个是关于控制流的东西，比如 loop 和 if 。

26
00:01:48,319 --> 00:01:51,649
让我们从variables.c 开始。

27
00:01:51,649 --> 00:01:54,729
首先我要指出的是，那些三个 x。

28
00:01:54,729 --> 00:01:59,419
这些三个 x，被定义为汇编程序 nop指令。

29
00:01:59,420 --> 00:02:04,830
具体的原因，稍后当我们研究反汇编时，我们可以发现那些nop，

30
00:02:04,829 --> 00:02:08,799
将我们的测试分隔开，这非常好。

31
00:02:08,800 --> 00:02:13,960
所以，这使得我们更容易看到C代码的哪一行，负责

32
00:02:13,959 --> 00:02:14,989
汇编程序的哪一行。

33
00:02:14,990 --> 00:02:20,010
我不会每次测试都详细来一遍，这其实是你自己能做的。

34
00:02:20,010 --> 00:02:22,850
只需在视频特定讲解来上几遍，或是克隆存储库。

35
00:02:22,850 --> 00:02:23,850
不管怎样。

36
00:02:23,850 --> 00:02:24,850
让我们开始吧。

37
00:02:24,850 --> 00:02:25,880
首先，你可以在这里，看到几个简单的数字。

38
00:02:25,880 --> 00:02:28,230
我们先定义几个数字。

39
00:02:28,230 --> 00:02:31,550
无符号和有符号，整数和浮点数。

40
00:02:31,550 --> 00:02:35,440
以及，不同尺寸的 uint32或 uint64。

41
00:02:35,440 --> 00:02:40,690
后面的(数字)很重要，因为正常整数的大小，

42
00:02:40,690 --> 00:02:43,980
取决于32位或者64位（系统），不然可能导致错误。

43
00:02:43,980 --> 00:02:48,170
所以，最好使用数据类型，这样可以保证获得一定的大小。

44
00:02:48,170 --> 00:02:52,620
如果你想进一步，了解如何正确编程C，有一个很棒的博客叫做

45
00:02:52,620 --> 00:02:55,670
“How to C in 2015”。

46
00:02:55,670 --> 00:03:02,320
然后我们创建一个包含32位无符号整数的数组，并访问

47
00:03:02,320 --> 00:03:03,320
数组中的一个元素。

48
00:03:03,320 --> 00:03:05,420
然后，我们看到一个字符。

49
00:03:05,420 --> 00:03:06,840
还有一个字符串。

50
00:03:06,840 --> 00:03:11,790
也许你知道星星*，在c中的意思是“指针”，所以我们定义了

51
00:03:11,790 --> 00:03:13,590
一个变量，用来指向一个字符串。

52
00:03:13,590 --> 00:03:18,220
我添加了一个makefile，所以您可以在终端中，

53
00:03:18,220 --> 00:03:19,220
简单键入'make'来编译所有文件。

54
00:03:19,220 --> 00:03:21,310
或者，make clean 删除二进制文件。

55
00:03:21,310 --> 00:03:25,390
这将创建32位和64位版本的 variables 程序。

56
00:03:25,390 --> 00:03:31,670
但是，正如你所看到的，我在用 64位系统，带有 -m32 编译32位版本时，

57
00:03:31,670 --> 00:03:33,790
遇到了一个错误。

58
00:03:33,790 --> 00:03:38,150
所以我必须先安装32位库，才能构建代码。

59
00:03:38,150 --> 00:03:41,870
安装这些之后，构建工作正常。

60
00:03:41,870 --> 00:03:49,770
makefile，只是一个定义，应如何编译项目的小脚本。

61
00:03:49,770 --> 00:03:55,220
那么，让我们在gdb中，打开32位和64位版本(同框)，

62
00:03:55,220 --> 00:03:56,220
并反汇编 main。

63
00:03:56,220 --> 00:04:02,860
同时打开源代码。

64
00:04:02,860 --> 00:04:08,090
好了，现在让我们来看第一个带负值、有符号和无符号的整数值示例。

65
00:04:08,090 --> 00:04:09,090
。

66
00:04:09,090 --> 00:04:13,550
首先，所有这些局部变量都存储在栈的某个地方，

67
00:04:13,550 --> 00:04:18,310
您可以看到它们，因为它们是相对基指针，所引用的。

68
00:04:18,310 --> 00:04:21,890
然后，您注意到汇编程序代码不知道负数。

69
00:04:21,890 --> 00:04:24,170
他们是 fff 什么的。

70
00:04:24,169 --> 00:04:28,449
如果你对负数的显示方式感兴趣，请看第10集，

71
00:04:28,449 --> 00:04:29,449
有关数字。

72
00:04:29,449 --> 00:04:35,719
有符号变量和无符号变量之间，也没有区别。

73
00:04:35,720 --> 00:04:40,120
但是32位代码和64位代码之间，有一个区别。

74
00:04:40,120 --> 00:04:45,270
因为，若我们定义了一个64位长的数字，

75
00:04:45,270 --> 00:04:46,270
但是，32位的寄存器只有32位。

76
00:04:46,270 --> 00:04:51,730
所以如果你想写完整的64位，你必须写两次。

77
00:04:51,729 --> 00:04:53,829
浮点数也很有趣。

78
00:04:53,830 --> 00:04:56,120
因为它们被存储在程序的其他地方。

79
00:04:56,120 --> 00:05:01,140
然后，将该值移到局部变量中。

80
00:05:01,139 --> 00:05:02,549
这个数组，也很有趣。

81
00:05:02,550 --> 00:05:08,110
我们创建了一个有10个值的数组，但只将前5个值，设置为默认值。

82
00:05:08,110 --> 00:05:11,550
如您所见，这些值存储在栈上。

83
00:05:11,550 --> 00:05:15,850
然后将它从栈上的那个位置，移动到实际的数组位置。

84
00:05:15,849 --> 00:05:19,889
它不是直接将它写到数组中，

85
00:05:19,889 --> 00:05:20,889
这样做的原因，我不知道为什么。

86
00:05:20,889 --> 00:05:24,259
当我们引用第三个项时，您可以在下面看到。

87
00:05:24,259 --> 00:05:30,209
所以，您可以看到这，就是数组在栈上的实际位置。

88
00:05:30,210 --> 00:05:31,470
接下来是 字符串。

89
00:05:31,469 --> 00:05:33,739
您可以看到一个字符，只是一个字节。

90
00:05:33,740 --> 00:05:39,140
是否为 一个 8位 或 char 的无符号int，都无关紧要。

91
00:05:39,139 --> 00:05:40,469
因为都是一样的。

92
00:05:40,470 --> 00:05:42,930
字符串也引用一个地址。

93
00:05:42,930 --> 00:05:47,190
因此，这个局部变量不是字符数组。

94
00:05:47,189 --> 00:05:50,529
这个局部变量，包含指向一个字符串的地址。

95
00:05:50,529 --> 00:05:52,929
现在，让我们看看控制流 control_flows。

96
00:05:52,930 --> 00:05:55,300
用 Radare 打开它。

97
00:05:55,300 --> 00:05:59,330
分析全部，寻找 main 函数，进入视觉模式。

98
00:05:59,330 --> 00:06:01,080
首先，我们将一个变量设置为零。

99
00:06:01,080 --> 00:06:02,590
然后是来到，if 语句。

100
00:06:02,590 --> 00:06:08,890
这是通过在寄存器中，加载该局部变量，并与 hex ff 进行比较，来完成的。

101
00:06:08,889 --> 00:06:11,679
如果小于或等于，则跳。

102
00:06:11,680 --> 00:06:15,250
所以，你可以看到它可能选哪个分支。

103
00:06:15,250 --> 00:06:16,680
然后，是一个 while 循环。

104
00:06:16,680 --> 00:06:22,940
我们在寄存器中，再次加载局部变量，将其与一个值进行比较，

105
00:06:22,939 --> 00:06:25,849
然后要么跳进区块，要么离开。

106
00:06:25,849 --> 00:06:31,709
在这个区块中，我们再次加载这个值，递增并写回给它。

107
00:06:31,710 --> 00:06:33,690
现在，将其与 foor 循环 进行比较。

108
00:06:33,689 --> 00:06:35,619
基本上，行为是一样的！

109
00:06:35,620 --> 00:06:37,950
我们先将变量设置为0。

110
00:06:37,949 --> 00:06:41,289
然后我，们比较循环条件，是否仍然是真的。

111
00:06:41,289 --> 00:06:43,739
在循环区块中，我们可以看到我们的 nop。

112
00:06:43,740 --> 00:06:47,730
在区块的末尾，我们将变量增加 1。

113
00:06:47,729 --> 00:06:50,279
与while循环，完全相同。

114
00:06:50,280 --> 00:06:55,800
所以，你可以看到C中的一个 for和一个 while循环，基本上是相同的。

115
00:06:55,800 --> 00:06:58,520
接下来，让我们看看函数是如何调用的。

116
00:06:58,520 --> 00:07:03,910
再次打开32位和64位版本。

117
00:07:03,910 --> 00:07:08,410
首先，您注意到64位版本的，在 EAX 中 移动了一个 0。

118
00:07:08,409 --> 00:07:09,549
具体原因不是很清楚。

119
00:07:09,550 --> 00:07:11,870
而剩下的，函数调用看起来是相同的。

120
00:07:11,870 --> 00:07:13,500
除了，地址。

121
00:07:13,499 --> 00:07:18,759
如果没有 aslr，那么64位代码，通常是 hex 40左右。

122
00:07:18,759 --> 00:07:22,859
32位代码是 hex 80左右。

123
00:07:22,860 --> 00:07:27,510
知道这样的东西是有帮助的，因为如果你看到一个地址带有 40 什么的，

124
00:07:27,509 --> 00:07:31,739
你立即知道它指向您的代码。

125
00:07:31,740 --> 00:07:35,210
所以，下一个函数返回一个值，我们将它保存在一个变量中。

126
00:07:35,210 --> 00:07:40,590
您可以看到，在这两种情况下，值都是从 EAX寄存器 获取的。

127
00:07:40,589 --> 00:07:45,869
很明显，返回值是，通过eax处理的。

128
00:07:45,870 --> 00:07:50,380
现在 函数3 很有趣，因为我们向它，传递了一个参数。

129
00:07:50,379 --> 00:07:56,699
在32位中，您可以看到该值，是从某个位置加载的，

130
00:07:56,699 --> 00:07:57,839
然后存储在栈的顶部。

131
00:07:57,840 --> 00:08:00,000
再之后，是函数调用了。

132
00:07:59,999 --> 00:08:05,329
但在64位上，我们看到该值被加载到 edi 寄存器中。

133
00:08:05,330 --> 00:08:07,970
这是我们的第一大区别。

134
00:08:07,969 --> 00:08:13,589
64位中的函数，似乎是用寄存器中的参数调用的，

135
00:08:13,589 --> 00:08:16,749
而32位中的参数存储在栈上。

136
00:08:16,749 --> 00:08:18,219
下一个函数，使用两个参数。

137
00:08:18,220 --> 00:08:22,930
同样，您可以看到32位是将值放在栈上的。

138
00:08:22,930 --> 00:08:26,060
第一个参数在栈的顶部，第二个参数在下面一点。

139
00:08:26,060 --> 00:08:30,160
但是在64位中，您可以看到它使用 esi 和 edi 。

140
00:08:30,159 --> 00:08:32,079
我们好奇。

141
00:08:32,080 --> 00:08:38,480
如果有过多的参数，不能全部保存在寄存器中时，64位会做什么？

142
00:08:38,479 --> 00:08:40,349
先给出32位代码的。

143
00:08:40,349 --> 00:08:42,979
您可以看到参数，是如何存储在栈上的。

144
00:08:42,979 --> 00:08:46,759
第一个参数在栈的顶部，最后一个值被移动。

145
00:08:46,759 --> 00:08:48,389
这就是我们所知道的。

146
00:08:48,389 --> 00:08:53,769
在64位中，我们可以看到前两个参数，存储在，

147
00:08:53,769 --> 00:08:55,769
寄存器 edi ，esi 、edx 等中。

148
00:08:55,770 --> 00:09:00,530
但从第7个参数开始，它们也被存储在栈上。

149
00:09:00,530 --> 00:09:02,240
原来如此！

150
00:09:02,240 --> 00:09:06,130
现在，您可以识别各种不同的汇编程序模式。

151
00:09:06,130 --> 00:09:08,220
不再需要一个反编译器，因为你就是。

152
00:09:08,220 --> 00:09:10,040
你可以心算，这一切。

153
00:09:10,040 --> 00:09:14,420
当你对越来越多的程序反工程时，这些模式变得更容易识别，

154
00:09:14,420 --> 00:09:18,740
你不会再被大量奇怪的指令迷惑。

155
00:09:18,740 --> 00:09:23,690
您将能够做到，眼扫描一个函数后说："这是一个局部变量。

156
00:09:23,690 --> 00:09:26,640
然后这个变量，作为另一个调用函数的参数。

157
00:09:26,639 --> 00:09:28,549
且返回值，在一个循环中被使用"。

158
00:09:28,550 --> 00:09:33,790
你可以用同样的方法，来理解不同的反汇编器，比如

159
00:09:33,790 --> 00:09:35,600
能显示代码的 Hopper，Radare，GDB，

160
00:09:35,600 --> 00:09:41,010
或者例如，对AT&T汇编程序语法，与Intel语法不同有所了解。

161
00:09:41,009 --> 00:09:43,629
我希望，你下次反工程，能怀有更多乐趣。

