1
00:00:07,490 --> 00:00:11,940
我们已经看过很多集了，我们阅读汇编代码和逆向工程。

2
00:00:11,940 --> 00:00:13,440
程序如何工作。

3
00:00:13,440 --> 00:00:17,680
我们甚至编写了第一个利用缓冲区溢出漏洞的漏洞

4
00:00:17,680 --> 00:00:21,700
一个用C语言写的节目。在这一集里，我想向你展示

5
00:00:21,700 --> 00:00:24,980
可以自己学习如何读取由C代码生成的汇编程序。

6
00:00:24,980 --> 00:00:27,390
这个想法很简单。

7
00:00:27,390 --> 00:00:31,670
只需编写一些具有不同C语言特性的C代码，然后查看汇编程序代码

8
00:00:31,670 --> 00:00:34,230
它是通过编译产生的。

9
00:00:34,230 --> 00:00:36,760
这通常是正常研究的一部分。

10
00:00:36,760 --> 00:00:41,760
例如，听谷歌零号项目的伊恩·比尔在一次关于他的谈话中所说的话。

11
00:00:41,760 --> 00:00:44,820
OSX进程间调用研究。

12
00:00:44,820 --> 00:00:50,630
要想扭转局面，或者理解这类事情是如何运作的，一个方法就是坐着

13
00:00:50,629 --> 00:00:56,729
在IDA中，只需反转序列化和反序列化代码，然后慢慢构建

14
00:00:56,730 --> 00:00:58,640
把它的工作原理拍下来。

15
00:00:58,640 --> 00:01:03,000
但另一种很好的方法是，编写一个测试程序来发送

16
00:01:03,000 --> 00:01:11,160
然后使用lldb找到正确的位置，断开并开始转储hex。

17
00:01:11,159 --> 00:01:16,139
因此，由于他必须理解相当复杂的数据结构，他只需编写一个

18
00:01:16,140 --> 00:01:19,990
测试程序来分析它，而不是反转一个完整的应用程序。

19
00:01:19,990 --> 00:01:27,590
或者是在2007从黑头美国的一篇关于如何逆转C++程序的演讲和论文，

20
00:01:27,590 --> 00:01:32,420
通过查看C++概念以及它们在汇编程序中的样子。

21
00:01:32,420 --> 00:01:37,710
所以现在我已经创建了三个不同的C代码测试用例，您可以在我的Github中找到它们。

22
00:01:37,710 --> 00:01:40,180
或者自己写。

23
00:01:40,179 --> 00:01:42,819
一个是关于变量和数据类型。

24
00:01:42,820 --> 00:01:44,570
一个是关于函数调用。

25
00:01:44,569 --> 00:01:48,319
一个是关于控制流的东西，比如循环和ifs。

26
00:01:48,319 --> 00:01:51,649
让我们从变量c开始。

27
00:01:51,649 --> 00:01:54,729
首先我要指出的是那些三重x。

28
00:01:54,729 --> 00:01:59,419
这些三重xs被定义为汇编程序nop指令。

29
00:01:59,420 --> 00:02:04,830
原因是，稍后当我们研究拆卸时，我们可以找到那些NOP

30
00:02:04,829 --> 00:02:08,799
它将我们的测试分隔开，这非常好。

31
00:02:08,800 --> 00:02:13,960
所以这使得我们更容易看到C代码的哪一行负责其中的哪一行

32
00:02:13,959 --> 00:02:14,989
汇编程序。

33
00:02:14,990 --> 00:02:20,010
我不会每次考试都复习，这是你自己能做的。

34
00:02:20,010 --> 00:02:22,850
只需在特定点暂停视频或克隆存储库。

35
00:02:22,850 --> 00:02:23,850
不管怎样。

36
00:02:23,850 --> 00:02:24,850
我们开始吧。

37
00:02:24,850 --> 00:02:25,880
首先，你可以在这里看到几个简单的数字。

38
00:02:25,880 --> 00:02:28,230
首先我们定义几个数字。

39
00:02:28,230 --> 00:02:31,550
无符号和有符号，整数和浮点数。

40
00:02:31,550 --> 00:02:35,440
以及不同尺寸的uint32或uint64。

41
00:02:35,440 --> 00:02:40,690
后者很重要，因为正整数的大小取决于32位

42
00:02:40,690 --> 00:02:43,980
或者64位，这样就可以导致错误。

43
00:02:43,980 --> 00:02:48,170
所以最好使用数据类型，这样可以保证获得一定的大小。

44
00:02:48,170 --> 00:02:52,620
如果你想进一步了解如何正确地编程C，有一个很棒的博客条目叫做

45
00:02:52,620 --> 00:02:55,670
“2015年如何实现C”。

46
00:02:55,670 --> 00:03:02,320
然后我们创建一个包含32位无符号整数的数组，并访问其中的一个元素

47
00:03:02,320 --> 00:03:03,320
数组。

48
00:03:03,320 --> 00:03:05,420
然后我们看一个角色。

49
00:03:05,420 --> 00:03:06,840
还有一根绳子。

50
00:03:06,840 --> 00:03:11,790
也许你知道星星*在c中的意思是“指针”，所以我们定义了一个指向

51
00:03:11,790 --> 00:03:13,590
一个字符串。

52
00:03:13,590 --> 00:03:18,220
我添加了一个makefile，所以您可以简单地在终端中键入'make'来编译所有

53
00:03:18,220 --> 00:03:19,220
文件夹。

54
00:03:19,220 --> 00:03:21,310
或者清除以删除二进制文件。

55
00:03:21,310 --> 00:03:25,390
这将创建32位和64位版本的变量程序。

56
00:03:25,390 --> 00:03:31,670
但是正如你所看到的，我在编译32位版本时遇到了一个错误，其中包含了-m32

57
00:03:31,670 --> 00:03:33,790
64位机。

58
00:03:33,790 --> 00:03:38,150
所以我必须先安装32位库，才能构建代码。

59
00:03:38,150 --> 00:03:41,870
安装这些之后，构建工作正常。

60
00:03:41,870 --> 00:03:49,770
makefile只是一个定义如何编译项目的小脚本。

61
00:03:49,770 --> 00:03:55,220
那么让我们打开gdb中彼此相邻的代码、32位和64位版本并反汇编

62
00:03:55,220 --> 00:03:56,220
主要的。

63
00:03:56,220 --> 00:04:02,860
同时打开代码。

64
00:04:02,860 --> 00:04:08,090
好了，现在让我们来看第一个带负值、有符号和无符号的整数示例。

65
00:04:08,090 --> 00:04:09,090
价值观。

66
00:04:09,090 --> 00:04:13,550
首先，所有这些局部变量都存储在堆栈的某个地方，您可以看到

67
00:04:13,550 --> 00:04:18,310
因为它们是相对于基指针引用的。

68
00:04:18,310 --> 00:04:21,890
然后您注意到汇编程序代码不知道负数。

69
00:04:21,890 --> 00:04:24,170
他们是FFF什么的。

70
00:04:24,169 --> 00:04:28,449
如果你对负数的显示方式感兴趣，请看我的第10集

71
00:04:28,449 --> 00:04:29,449
数字。

72
00:04:29,449 --> 00:04:35,719
有符号变量和无符号变量之间也没有区别。

73
00:04:35,720 --> 00:04:40,120
但是32位代码和64位代码之间有一个区别。

74
00:04:40,120 --> 00:04:45,270
因为我们定义了一个64位长的数字，但是32位的寄存器只有

75
00:04:45,270 --> 00:04:46,270
32位。

76
00:04:46,270 --> 00:04:51,730
所以如果你想写完整的64位，你必须写两次。

77
00:04:51,729 --> 00:04:53,829
浮点数也很有趣。

78
00:04:53,830 --> 00:04:56,120
因为它们被存储在程序的其他地方。

79
00:04:56,120 --> 00:05:01,140
然后将该值移到局部变量中。

80
00:05:01,139 --> 00:05:02,549
这个数组也很有趣。

81
00:05:02,550 --> 00:05:08,110
我们创建了一个有10个值的数组，但只将前5个值设置为默认值。

82
00:05:08,110 --> 00:05:11,550
如您所见，这些值存储在堆栈上。

83
00:05:11,550 --> 00:05:15,850
然后将它从堆栈上的那个位置移动到实际的数组位置。

84
00:05:15,849 --> 00:05:19,889
它不是直接将它写到数组中，而是这样做的。

85
00:05:19,889 --> 00:05:20,889
不知道为什么。

86
00:05:20,889 --> 00:05:24,259
当我们引用第三个条目时，您可以在下面看到。

87
00:05:24,259 --> 00:05:30,209
所以您可以看到这是数组在堆栈上的实际位置。

88
00:05:30,210 --> 00:05:31,470
接下来是弦乐。

89
00:05:31,469 --> 00:05:33,739
您可以看到一个字符只是一个字节。

90
00:05:33,740 --> 00:05:39,140
如果我们有一个带8bit或char的无符号int，这无关紧要。

91
00:05:39,139 --> 00:05:40,469
是一样的。

92
00:05:40,470 --> 00:05:42,930
字符串也在地址上被引用。

93
00:05:42,930 --> 00:05:47,190
因此局部变量不是字符数组。

94
00:05:47,189 --> 00:05:50,529
局部变量包含指向字符串的地址。

95
00:05:50,529 --> 00:05:52,929
现在让我们看看控制流。

96
00:05:52,930 --> 00:05:55,300
在Radare打开它。

97
00:05:55,300 --> 00:05:59,330
分析全部，寻找主要功能，进入视觉模式。

98
00:05:59,330 --> 00:06:01,080
首先，我们将变量设置为零。

99
00:06:01,080 --> 00:06:02,590
然后是如果。

100
00:06:02,590 --> 00:06:08,890
这是通过在寄存器中加载该局部变量并与hex ff进行比较来完成的。

101
00:06:08,889 --> 00:06:11,679
如果小于或等于，则跳。

102
00:06:11,680 --> 00:06:15,250
所以你可以看到它可能需要哪个分支。

103
00:06:15,250 --> 00:06:16,680
然后是一个小循环。

104
00:06:16,680 --> 00:06:22,940
我们在寄存器中再次加载局部变量，将其与一个值进行比较，然后跳进去

105
00:06:22,939 --> 00:06:25,849
要么封锁要么离开。

106
00:06:25,849 --> 00:06:31,709
在这个块中，我们再次加载这个值，递增并写回它。

107
00:06:31,710 --> 00:06:33,690
现在将其与foor循环进行比较。

108
00:06:33,689 --> 00:06:35,619
基本上是一样的！

109
00:06:35,620 --> 00:06:37,950
我们首先将变量设置为0。

110
00:06:37,949 --> 00:06:41,289
然后我们比较循环条件是否仍然是真的。

111
00:06:41,289 --> 00:06:43,739
在循环块中，我们可以看到我们的nop。

112
00:06:43,740 --> 00:06:47,730
在块的末尾，我们将变量增加1。

113
00:06:47,729 --> 00:06:50,279
与while循环完全相同。

114
00:06:50,280 --> 00:06:55,800
所以你可以看到C中的a for和a while循环基本上是相同的。

115
00:06:55,800 --> 00:06:58,520
接下来，让我们看看如何调用函数。

116
00:06:58,520 --> 00:07:03,910
再次打开32位和64位版本。

117
00:07:03,910 --> 00:07:08,410
首先，您注意到64位版本在EAX中移动了0。

118
00:07:08,409 --> 00:07:09,549
不知道为什么。

119
00:07:09,550 --> 00:07:11,870
否则，函数调用看起来是相同的。

120
00:07:11,870 --> 00:07:13,500
除了看看地址。

121
00:07:13,499 --> 00:07:18,759
如果没有aslr，那么64位代码通常是十六进制40左右。

122
00:07:18,759 --> 00:07:22,859
32位代码是十六进制80左右。

123
00:07:22,860 --> 00:07:27,510
知道这样的东西是有帮助的，因为如果你看到一个地址有40多岁，你

124
00:07:27,509 --> 00:07:31,739
立即知道它指向您的代码。

125
00:07:31,740 --> 00:07:35,210
所以下一个函数返回一个值，我们将它保存在一个变量中。

126
00:07:35,210 --> 00:07:40,590
您可以看到，在这两种情况下，值都是从EAX寄存器获取的。

127
00:07:40,589 --> 00:07:45,869
很明显，返回值是通过eax处理的。

128
00:07:45,870 --> 00:07:50,380
现在函数3很有趣，因为我们向它传递了一个参数。

129
00:07:50,379 --> 00:07:56,699
在32位中，您可以看到该值是从某个位置加载的，然后存储在

130
00:07:56,699 --> 00:07:57,839
栈。

131
00:07:57,840 --> 00:08:00,000
然后调用函数。

132
00:07:59,999 --> 00:08:05,329
但在64位上，我们看到该值被加载到EDI寄存器中。

133
00:08:05,330 --> 00:08:07,970
这是我们的第一大区别。

134
00:08:07,969 --> 00:08:13,589
64位中的函数似乎是用寄存器中的参数调用的，而32位中的

135
00:08:13,589 --> 00:08:16,749
参数存储在堆栈上。

136
00:08:16,749 --> 00:08:18,219
下一个函数使用两个参数。

137
00:08:18,220 --> 00:08:22,930
同样，您可以看到32位是如何将值放在堆栈上的。

138
00:08:22,930 --> 00:08:26,060
第一个参数在堆栈的顶部，第二个参数在下面一点。

139
00:08:26,060 --> 00:08:30,160
但是在64位中，您可以看到它使用ESI和EDI。

140
00:08:30,159 --> 00:08:32,079
现在我们开始好奇了。

141
00:08:32,080 --> 00:08:38,480
当我们有这么多参数，我们不能将它们全部保存在寄存器中时，64位会做什么？

142
00:08:38,479 --> 00:08:40,349
首先是32位代码。

143
00:08:40,349 --> 00:08:42,979
您可以看到参数是如何存储在堆栈上的。

144
00:08:42,979 --> 00:08:46,759
第一个参数在堆栈的顶部，最后一个值被移动。

145
00:08:46,759 --> 00:08:48,389
这就是我们所期望的。

146
00:08:48,389 --> 00:08:53,769
在64位中，我们可以看到前两个参数存储在寄存器edi中，

147
00:08:53,769 --> 00:08:55,769
ESI、EDX等。

148
00:08:55,770 --> 00:09:00,530
但从第7个参数开始，它们也被存储在堆栈上。

149
00:09:00,530 --> 00:09:02,240
令人惊叹的！

150
00:09:02,240 --> 00:09:06,130
现在您可以识别各种不同的汇编程序模式。

151
00:09:06,130 --> 00:09:08,220
你不需要一个反编译器。

152
00:09:08,220 --> 00:09:10,040
你可以在脑子里做这一切。

153
00:09:10,040 --> 00:09:14,420
当你逆转越来越多的程序时，这些模式变得更容易识别，

154
00:09:14,420 --> 00:09:18,740
你不会再被大量奇怪的指示所淹没。

155
00:09:18,740 --> 00:09:23,690
您将能够扫描一个函数并说：“这是一个局部变量。

156
00:09:23,690 --> 00:09:26,640
然后用这个变量作为参数调用另一个函数。

157
00:09:26,639 --> 00:09:28,549
返回值在循环中使用。

158
00:09:28,550 --> 00:09:33,790
你可以用同样的方法来理解不同的拆卸器，比如Hopper，Radare，

159
00:09:33,790 --> 00:09:35,600
GDB显示代码。

160
00:09:35,600 --> 00:09:41,010
或者例如，AT&T汇编程序语法与Intel语法有多大不同。

161
00:09:41,009 --> 00:09:43,629
我希望你下次能有很多乐趣来改变计划。

