1
00:00:06,399 --> 00:00:12,269
在上一集中，我们创造了我们的第一集
通过重写，利用全堆栈缓冲区溢出

2
00:00:12,269 --> 00:00:17,069
堆栈上的返回指针并跳转
将我们放置在堆栈上的代码解壳

3
00:00:17,070 --> 00:00:18,320
也。

4
00:00:18,320 --> 00:00:23,760
在本集中，我们将查看堆栈级别
6.看看当你

5
00:00:23,759 --> 00:00:25,789
对寄信人地址的限制。

6
00:00:25,789 --> 00:00:31,239
要理解此视频，您必须理解
如何正常的缓冲区溢出和跳转到

7
00:00:31,240 --> 00:00:32,370
Shellcode工作。

8
00:00:32,369 --> 00:00:35,369
我希望我过去解释得足够好
视频。

9
00:00:35,370 --> 00:00:38,950
但是如果还有未解决的问题，请
在Reddit上发布。

10
00:00:38,949 --> 00:00:42,319
我真的需要你明白
东西。

11
00:00:42,320 --> 00:00:44,840
作为提示，这个水平告诉我们，

12
00:00:44,840 --> 00:00:49,730
这一级别可以通过多种方式实现，
例如找到有效载荷的副本

13
00:00:49,730 --> 00:00:55,680
（objdump-s），或ret2libc，甚至返回
定向编程。

14
00:00:55,680 --> 00:00:59,730
在这段视频中，我们将无法探索
面向返回的编程。

15
00:00:59,730 --> 00:01:04,850
但是我会给你看一些其他的技巧
这最终将导致以回报为导向

16
00:01:04,850 --> 00:01:05,850
编程。

17
00:01:05,850 --> 00:01:07,420
让我们来看一下源代码。

18
00:01:07,420 --> 00:01:12,860
再说一次，它和前一个非常相似
级别，只是一些小的更改。

19
00:01:12,860 --> 00:01:18,130
不是所有的东西都在主，主
调用此函数获取路径。

20
00:01:18,130 --> 00:01:21,700
get path为64分配字符串缓冲区
字符。

21
00:01:21,700 --> 00:01:23,440
然后用get读取字符串。

22
00:01:23,440 --> 00:01:28,550
现在我们都知道了，有了这些，我们可以
任意阅读许多字符，我们

23
00:01:28,550 --> 00:01:31,310
可用于覆盖上的返回指针
堆栈。

24
00:01:31,310 --> 00:01:33,480
但下一行很有趣。

25
00:01:33,480 --> 00:01:38,460
_内置返回地址是来自
编译器，可用于读取

26
00:01:38,460 --> 00:01:40,630
堆栈中的当前返回地址。

27
00:01:40,630 --> 00:01:45,990
如果这个寄信人地址是从
带有十六进制的XXBF。

28
00:01:45,990 --> 00:01:49,230
与号执行位与
地址。

29
00:01:49,230 --> 00:01:53,560
在那之后，只有他们相同的部分
幸存下来。

30
00:01:53,560 --> 00:01:55,520
基本上将剩余的位设置为0。

31
00:01:55,520 --> 00:01:58,500
检查前面是否仍然是六角高炉。

32
00:01:58,500 --> 00:02:05,070
如果返回地址以0xBF开头，则为
打印此返回地址并退出。

33
00:02:05,070 --> 00:02:06,830
当我们使用上次的漏洞时。

34
00:02:06,830 --> 00:02:11,150
调整填充以适应
在这个函数中，我们看到了新的无符号int

35
00:02:11,150 --> 00:02:12,750
它不起作用。

36
00:02:12,750 --> 00:02:14,410
BZZT失败了。

37
00:02:14,409 --> 00:02:15,409
好啊。

38
00:02:15,409 --> 00:02:19,389
所以我们不能使用以开头的地址
六角高炉。

39
00:02:19,389 --> 00:02:22,579
出口保护此功能不受
以这种方式开发。

40
00:02:22,579 --> 00:02:25,799
因为出口是一个系统调用
退出程序。

41
00:02:25,799 --> 00:02:30,629
所以，即使我们已经粉碎了回报
指针，此函数将永远不会返回。

42
00:02:30,629 --> 00:02:35,879
所以你可以看到，即使有一个缓冲区
溢出并不一定意味着你可以

43
00:02:35,879 --> 00:02:37,099
利用它。

44
00:02:37,099 --> 00:02:41,909
当我们现在在gdb中打开这个级别时，中断
在getpath，运行它，然后查看映射的

45
00:02:41,909 --> 00:02:43,919
内存中有“info proc map”。

46
00:02:43,920 --> 00:02:48,690
我们可以看到唯一开始的地址
和BF在一起。

47
00:02:48,689 --> 00:02:52,109
所以基本上我们不能返回到堆栈地址。

48
00:02:52,109 --> 00:02:57,829
这太疯狂了，那么我们如何运行我们的代码，
如果我们不能回到

49
00:02:57,829 --> 00:02:59,379
放置我们的代码？

50
00:02:59,379 --> 00:03:01,989
所以首先，我们仍然可以控制
返回指针。

51
00:03:01,989 --> 00:03:04,119
只要不是从男朋友开始。

52
00:03:04,120 --> 00:03:08,620
现在又出现了一个病态的想法，回归
进入已知代码。

53
00:03:08,620 --> 00:03:10,140
让我们想想这个。

54
00:03:10,140 --> 00:03:15,730
返回指令只查看当前
地址在堆栈顶部，将其移除，然后

55
00:03:15,730 --> 00:03:17,280
就跳到那里。

56
00:03:17,279 --> 00:03:24,309
…如果你回到
地址0x080484f9。

57
00:03:24,310 --> 00:03:27,240
这是返回指令本身。

58
00:03:27,239 --> 00:03:28,239
想想这个。

59
00:03:28,239 --> 00:03:32,279
我们用十六进制0x080覆盖返回指针。

60
00:03:32,279 --> 00:03:37,499
我们到达返回指令，它将弹出
这个地址从堆栈中跳到它。

61
00:03:37,500 --> 00:03:39,360
基本上就是跳到自己身上。

62
00:03:39,360 --> 00:03:44,130
现在它将读取
堆叠并跳到那里。

63
00:03:44,129 --> 00:03:45,589
现在你可以重复一遍。

64
00:03:45,590 --> 00:03:48,260
再次将堆栈上的下一个地址设置为0x080。

65
00:03:48,260 --> 00:03:51,540
或者把栈的地址放在这里。

66
00:03:51,540 --> 00:03:53,210
我们可以再次回到堆栈中。

67
00:03:53,209 --> 00:03:55,599
从理论上讲，这是可行的。

68
00:03:55,599 --> 00:03:59,669
因为原来的寄信人地址被覆盖了
地址以0x080开头。

69
00:03:59,670 --> 00:04:02,350
好吧，我们试试看。

70
00:04:02,349 --> 00:04:04,439
让我们修改我们的漏洞代码。

71
00:04:04,439 --> 00:04:08,659
我们用int 3代替shellcode，
再次发出CC指令。

72
00:04:08,659 --> 00:04:09,729
陷阱。

73
00:04:09,730 --> 00:04:13,710
我们现在都知道，当我们击中他们时，
执行代码，我们只需要找到

74
00:04:13,709 --> 00:04:14,789
合适的外壳代码。

75
00:04:14,790 --> 00:04:17,720
所以让我们集中在有趣的部分。

76
00:04:17,720 --> 00:04:23,590
在返回getpath时设置断点，
然后用我们的漏洞输入运行它。

77
00:04:23,590 --> 00:04:24,590
我们到达了断点。

78
00:04:24,590 --> 00:04:27,020
我们通过了返回指针检查。

79
00:04:27,020 --> 00:04:29,140
那么让我们自己来看看这个堆栈。

80
00:04:29,139 --> 00:04:34,589
我们可以看到上面的地址
堆栈现在是0x080。

81
00:04:34,590 --> 00:04:36,400
这是返回指令。

82
00:04:36,400 --> 00:04:38,280
所以现在向前迈出一步。

83
00:04:38,280 --> 00:04:40,960
这应该从堆栈中弹出这个地址
然后跳下去。

84
00:04:40,960 --> 00:04:41,970
确实如此。

85
00:04:41,970 --> 00:04:46,230
我们又碰到了断点，因为我们跳了
对自己。

86
00:04:46,230 --> 00:04:50,720
当您现在查看堆栈时，下一个地址
堆栈上是堆栈地址。

87
00:04:50,720 --> 00:04:53,340
我们现在就回这个地址。

88
00:04:53,340 --> 00:04:58,810
所以当我们继续的时候，我们会回到
堆栈，就像前面的漏洞一样，

89
00:04:58,810 --> 00:05:00,430
我们击中了陷阱。

90
00:05:00,430 --> 00:05:01,430
繁荣！

91
00:05:01,430 --> 00:05:03,030
任意代码执行！

92
00:05:03,030 --> 00:05:04,030
顺便说一句。

93
00:05:04,030 --> 00:05:07,360
我们跳到的这个地址，0x080
是个小玩意儿。

94
00:05:07,360 --> 00:05:11,200
当你读到面向返回的编程时，
您正在查找小工具。

95
00:05:11,199 --> 00:05:13,649
这是一个简单的禁止操作的小工具。

96
00:05:13,650 --> 00:05:15,900
这只是一种回报，什么都不做。

97
00:05:15,900 --> 00:05:20,620
对于面向返回的编程，
你要找能做更多事情的小玩意儿，

98
00:05:20,620 --> 00:05:22,430
在返回下一个地址之前。

99
00:05:22,430 --> 00:05:28,300
当我们做这种事情的时候，你会听到
我说“回到”，或者“跳到”。

100
00:05:28,300 --> 00:05:30,590
在这种情况下，它们是等价的。

101
00:05:30,590 --> 00:05:35,860
因为是的，我们执行一个返回指令，
但我们不会回到原来的功能

102
00:05:35,860 --> 00:05:36,860
不再。

103
00:05:36,860 --> 00:05:39,310
我们又回到了别的地方。

104
00:05:39,310 --> 00:05:41,980
实际上只是跳到别的地方。

105
00:05:41,979 --> 00:05:55,589
所以我希望这不会让你困惑。

106
00:05:55,590 --> 00:06:04,630
让我们看一看另一个技巧。

107
00:06:04,629 --> 00:06:22,249
这和我们在Stack里做的很相似
4级。

108
00:06:22,250 --> 00:06:25,480
那么我们还能跳到哪里呢？

109
00:06:25,480 --> 00:06:52,840
什么之中的一个
这个

110
00:06:52,840 --> 00:06:56,350
提示说我们可以调查ret2libc。

111
00:06:56,350 --> 00:07:03,330
既然你几乎是剥削的行家，
你明白这意味着什么。

112
00:07:03,330 --> 00:07:04,970
返回libc。

113
00:07:04,970 --> 00:07:09,990
就像我们刚回到一些代码中，我们可以
也回到巨大的图书馆libc。

114
00:07:09,990 --> 00:07:13,990
一定有什么有趣的事情我们
可能会滥用。

115
00:07:13,990 --> 00:07:16,860
libc中一个有趣的函数是system。

116
00:07:16,860 --> 00:07:19,470
执行shell命令。

117
00:07:19,470 --> 00:07:22,150
使用打印系统，我们可以找到地址
其中。

118
00:07:22,150 --> 00:07:25,100
但简单地回到它里面很可能
不工作。

119
00:07:25,100 --> 00:07:28,080
我们需要确保控制
东西。

120
00:07:28,080 --> 00:07:32,430
让我们创建一个简单的C程序来调用
我们的libc系统。

121
00:07:32,430 --> 00:07:36,170
最后，我们想以某种方式执行系统
用/bin /SH。

122
00:07:36,169 --> 00:07:39,349
因为这样我们就有了外壳。

123
00:07:39,349 --> 00:07:41,339
如果我们在这里试一下，效果很好。

124
00:07:41,340 --> 00:07:43,540
现在让我们看看gdb中的这个。

125
00:07:43,539 --> 00:07:49,069
我们可以在呼叫系统之前看到，
要执行的命令的地址

126
00:07:49,069 --> 00:07:51,279
放在堆栈的顶部。

127
00:07:51,280 --> 00:07:56,010
如我们所知，对函数的调用
将返回地址作为

128
00:07:56,009 --> 00:07:57,009
好。

129
00:07:57,009 --> 00:08:01,159
所以如果我们画这个，这就是堆栈
一旦我们开始

130
00:08:01,159 --> 00:08:02,289
系统。

131
00:08:02,289 --> 00:08:04,729
首先放置命令的地址
在堆栈上。

132
00:08:04,729 --> 00:08:08,689
然后我们要返回的地址。

133
00:08:08,690 --> 00:08:12,640
现在想象一下如果我们使用缓冲区溢出
返回系统。

134
00:08:12,639 --> 00:08:15,769
首先，我们没有执行调用指令。

135
00:08:15,770 --> 00:08:18,620
因此没有推送返回地址。

136
00:08:18,620 --> 00:08:20,760
但是我们完全控制了堆栈。

137
00:08:20,759 --> 00:08:24,139
所以系统希望堆栈看起来像这样。

138
00:08:24,139 --> 00:08:25,969
我们可以手工建造！

139
00:08:25,970 --> 00:08:29,800
所以首先我们要把寄信人的地址
用于堆栈上的系统。

140
00:08:29,800 --> 00:08:32,680
但实际上我们不在乎这个权利
现在。

141
00:08:32,680 --> 00:08:35,370
但这仍然很酷也很重要，而且
记住这一点。

142
00:08:35,370 --> 00:08:38,040
因为你可以把这些东西连在一起。

143
00:08:38,039 --> 00:08:43,669
就像我们一个接一个地连着两份回报
以前，我们可以链接多个函数调用

144
00:08:43,669 --> 00:08:48,769
或是其他的小玩意儿
控制下一个的返回指针

145
00:08:48,770 --> 00:08:49,770
步骤。

146
00:08:49,770 --> 00:08:55,390
所以在我们的例子中，当系统完成时，我们会
遇到SegFault，因为它会返回

147
00:08:55,390 --> 00:08:57,400
进入0x41414141。

148
00:08:57,400 --> 00:09:03,010
堆栈上的下一个地址必须是
我们要执行的字符串。

149
00:09:03,010 --> 00:09:05,250
最好是“/bin/sh”。

150
00:09:05,250 --> 00:09:08,280
有很多选择如何获取参考
这样的一根绳子。

151
00:09:08,280 --> 00:09:10,460
一种选择是使用堆栈地址。

152
00:09:10,460 --> 00:09:11,900
因为有我们控制的字符串。

153
00:09:11,900 --> 00:09:13,930
或环境变量。

154
00:09:13,930 --> 00:09:16,680
因为它们在堆栈的底部
更容易预测。

155
00:09:16,680 --> 00:09:20,150
但你记得，这个堆栈有点不可靠
然后四处移动。

156
00:09:20,150 --> 00:09:22,920
这里有一种更可靠的技术。

157
00:09:22,920 --> 00:09:27,880
我们可以用find在映射的内存中搜索
字符串的libc。

158
00:09:27,880 --> 00:09:30,970
很酷，显然在这个地址我们可以找到
BI/SH。

159
00:09:30,970 --> 00:09:33,390
我们来看看这是不是真的。

160
00:09:33,390 --> 00:09:35,620
在此地址以字符串形式检查内存。

161
00:09:35,620 --> 00:09:36,620
令人惊叹的！

162
00:09:36,620 --> 00:09:37,950
弗拉克！GDB。

163
00:09:37,950 --> 00:09:39,720
你到底在干什么？

164
00:09:39,720 --> 00:09:43,390
你为什么说你在那里找到了垃圾桶？
它不在那里？

165
00:09:43,390 --> 00:09:45,800
我不知道为什么会这样。

166
00:09:45,800 --> 00:09:47,300
在网上找不到任何东西。

167
00:09:47,300 --> 00:09:48,300
不管怎样。

168
00:09:48,300 --> 00:09:49,300
忽略这一点。

169
00:09:49,300 --> 00:09:50,300
这是另一种技术。

170
00:09:50,300 --> 00:09:53,940
我们可以使用字符串查找
LBC。

171
00:09:53,940 --> 00:09:58,160
使用-t，我们可以在内部打印偏移量
这个文件是十六进制的。

172
00:09:58,160 --> 00:10:02,450
然后我们可以简单地将这个偏移量添加到
libc地址已加载到。

173
00:10:02,450 --> 00:10:05,070
这是/bin/sh的真实地址。

174
00:10:05,070 --> 00:10:07,620
好吧，让我们把这个地址复制到我们的漏洞中。

175
00:10:07,620 --> 00:10:11,250
然后我们试试看。

176
00:10:11,250 --> 00:10:15,210
记住使用前面的技巧
带括号和cat的视频。

177
00:10:15,210 --> 00:10:18,450
因为漏洞脚本将关闭
再次输入。

178
00:10:18,450 --> 00:10:19,450
酷！

179
00:10:19,450 --> 00:10:20,450
它起作用了。

180
00:10:20,450 --> 00:10:23,200
我们刚做的是一种叫做
ReT2LBC。

181
00:10:23,200 --> 00:10:25,440
我们从未在堆栈上执行过任何代码！

182
00:10:25,441 --> 00:10:26,441
也许你会问你自己为什么要这么做
首先是可执行的。

183
00:10:26,441 --> 00:10:27,441
没有合理的理由说明堆栈应该
可执行。

184
00:10:27,441 --> 00:10:28,441
这就是为什么有一个普遍的记忆
现在的政策。

185
00:10:28,441 --> 00:10:29,441
写入XOR执行。

186
00:10:29,441 --> 00:10:30,441
基本上，它意味着永远没有内存页
这是可写和可执行的。

187
00:10:30,441 --> 00:10:31,441
因为这样攻击者就不能执行任何
他能写的代码

188
00:10:31,441 --> 00:10:32,441
进程内存。

189
00:10:32,441 --> 00:10:33,441
所以我们希望今天的每一个现代系统
使用DEP、数据执行保护和集合

190
00:10:33,441 --> 00:10:34,441
nx位，内存的非可执行位
像堆栈一样的页面。

191
00:10:34,441 --> 00:10:35,441
但现实并非如此简单。

192
00:10:35,441 --> 00:10:36,441
嵌入式设备随着
物联网，但通常不会

193
00:10:36,441 --> 00:10:37,441
支持这样的功能。

194
00:10:37,441 --> 00:10:38,441
或者像javascript这样的现代编程语言
使用JIT。

195
00:10:38,441 --> 00:10:39,441
实时编译器。

196
00:10:39,441 --> 00:10:40,441
所以他们必须快速编译代码
在需要时存储并执行。

197
00:10:40,441 --> 00:10:41,441
所以他们需要可写和可执行的内存
区域。

198
00:10:41,441 --> 00:10:42,441
但是即使我们有DEP，我们也可以使用技术
就像ret2libc从不执行实际的shellcode一样，

199
00:10:42,441 --> 00:10:43,441
但仍然需要一个系统。

200
00:10:43,441 --> 00:10:44,441
在将来的某个时候，我会
有关面向返回的编程的视频。

201
00:10:44,441 --> 00:10:44,451
这类的下一步是什么
技术。

