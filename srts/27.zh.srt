1
00:00:00,260 --> 00:00:04,900
最后几段视频已经变得很难理解，

2
00:00:04,899 --> 00:00:07,919
需要很多专心和耐心去理解他们。

3
00:00:07,920 --> 00:00:12,020
因此，我很高兴我们开始来到网络挑战。

4
00:00:12,020 --> 00:00:19,120
同样 来自 exploit-exercises protostar，这会更容易，因为我们必须要先来点基础知识。

5
00:00:19,119 --> 00:00:26,149
让我们快速了解一下第0级网络漏洞。

6
00:00:26,150 --> 00:00:31,380
说明中指出，必须将字符串转换为小尾数整数。

7
00:00:31,380 --> 00:00:35,830
这个级别很容易，但是要完全理解发生了什么，

8
00:00:35,829 --> 00:00:36,899
单看代码是不够的。

9
00:00:36,899 --> 00:00:38,749
我告诉你为什么。

10
00:00:38,750 --> 00:00:44,920
main调用一个函数 background_process ，并传递一个name、

11
00:00:44,920 --> 00:00:46,570
且会带着用户和组ID运行。

12
00:00:46,569 --> 00:00:50,509
但此函数不是常见的libc函数。

13
00:00:50,510 --> 00:00:56,010
您还可以检查 /etc/passwd 中的用户ID 999，您ID

14
00:00:56,010 --> 00:00:57,010
会发现没有这样的用户。

15
00:00:57,010 --> 00:01:01,170
这可能看起来很奇怪，但不要对计算机，太过抽象地思考。

16
00:01:01,170 --> 00:01:04,260
在Linux系统上，一个用户意味着什么？

17
00:01:04,260 --> 00:01:09,810
最后，用户只是一个ID、内存中的一个数字，例如文件的所有者。

18
00:01:09,810 --> 00:01:13,750
这意味着，这个文件将这个编号，作为所有者设置。

19
00:01:13,750 --> 00:01:19,320
现在，如果用户列在 /etc/passwd 文件中，

20
00:01:19,320 --> 00:01:24,270
Linux 很好地显示名称，而不是数字，但在引擎盖下，它仍然只是一个整数。

21
00:01:24,270 --> 00:01:28,730
因此，即使没有为该ID分配名称，您仍然可以自由使用它。

22
00:01:28,730 --> 00:01:30,750
不管怎样，回到代码。

23
00:01:30,750 --> 00:01:36,430
其他函数，如 serve_forever 和 set_io，也不是已知的函数。

24
00:01:36,430 --> 00:01:42,200
当您查看 includes 时，您会注意到它引用了一个 common.c 文件。

25
00:01:42,200 --> 00:01:46,820
所以，这个挑战的作者，在不同的文件中，实现了很多代码，

26
00:01:46,820 --> 00:01:48,910
我们不知道这是在干什么。

27
00:01:48,910 --> 00:01:52,170
但这里有一个函数，就是 run() 函数。

28
00:01:52,170 --> 00:01:55,690
您可以看到它是在 main() 的末尾调用的。

29
00:01:55,690 --> 00:02:01,460
run 生成了一个随机数，告诉我们应该以小字节序的形式，发送该数字。

30
00:02:01,460 --> 00:02:06,350
然后，从 filedescriptor 执行一个 read，在本例中是从标准输入读取，解释

31
00:02:06,350 --> 00:02:11,500
把这个输入作为一个数字，并与之前的随机数比较，是否相同。

32
00:02:11,500 --> 00:02:12,840
所以，只是一个简单的测试。

33
00:02:12,840 --> 00:02:18,320
正如我之前所说，我们可以在不知道下面这些未知函数的情况下，完成这个挑战，

34
00:02:18,319 --> 00:02:23,229
，因为仅仅阅读注释和函数名，就可以告诉我们需要知道的一切，

35
00:02:23,230 --> 00:02:28,620
但是，正如您所知，当我们忽略基础概念时，我们对这个 channel 并不满意。

36
00:02:28,620 --> 00:02:30,810
我们想更好地理解计算机。

37
00:02:30,810 --> 00:02:36,350
这些函数，实现了这里提到的两个有趣概念，

38
00:02:36,349 --> 00:02:40,609
1：运行中进程是一个守护进程，另一个是关于网络和套接字的。

39
00:02:40,609 --> 00:02:43,469
那么，我们如何才能弄清楚它的作用呢？

40
00:02:43,469 --> 00:02:48,469
好吧，我们已经知道了，我们所需要的一切，足够逆向工程了。

41
00:02:48,469 --> 00:02:52,579
因此，让我们先研究一下程序的行为，然后再深入研究。

42
00:02:52,579 --> 00:02:55,119
当你试图运行程序时，什么也不会发生。

43
00:02:55,120 --> 00:03:01,270
但是，当您查看正在运行的进程时，您可以看到 net0 已经在运行。

44
00:03:01,269 --> 00:03:05,889
所以，让我们快速切换到根用户，这样我们就可以终止该进程，

45
00:03:05,890 --> 00:03:07,160
并自己启动它。

46
00:03:07,159 --> 00:03:10,399
这个虚拟机的默认根密码，是“godmode”。

47
00:03:10,400 --> 00:03:14,950
现在，我们可以杀死 net0，并验证它是不再运行的。

48
00:03:14,950 --> 00:03:17,570
所以，让我们再次执行它。

49
00:03:17,569 --> 00:03:19,389
什么都没发生？

50
00:03:19,390 --> 00:03:22,470
但，如果我们检查这些进程，就会发现它又在运行了。

51
00:03:22,469 --> 00:03:23,469
发生了什么？

52
00:03:23,469 --> 00:03:27,089
让我们再杀了它，带上 strace 开始。

53
00:03:27,090 --> 00:03:30,770
所以，结尾完成是一个exit，但是,之前发生了什么？

54
00:03:30,769 --> 00:03:35,869
它似乎打开了一个具有写权限的 net0.pid 文件。

55
00:03:35,870 --> 00:03:41,920
然后，将用户和组ID更改为999，并设置了有效的 uid 和 gid 。

56
00:03:41,920 --> 00:03:45,360
因此，这意味着，进程把它的根权限，就是 uid 1 拉下到，

57
00:03:45,359 --> 00:03:46,359
用户id 999。

58
00:03:46,359 --> 00:03:47,459
然后，它调用 clone() 。

59
00:03:47,459 --> 00:03:51,799
手册页说，clone 创建了一个类似于 fork 的新进程。

60
00:03:51,799 --> 00:03:57,339
因此，这将产生一个新的进程，作为其自身的一个克隆、副本。

61
00:03:57,340 --> 00:04:02,570
返回值是这个新进程的进程ID，

62
00:04:02,569 --> 00:04:04,639
也就，与写入 .pid 文件的值相等。

63
00:04:04,640 --> 00:04:09,510
所以，这个文件只是帮您跟踪，您创建的新进程。

64
00:04:09,510 --> 00:04:14,920
然之后，父进程退出，并将子进程孤立。

65
00:04:14,920 --> 00:04:19,530
这就是所谓的孤立进程，因为我们是故意这样做的。

66
00:04:19,530 --> 00:04:22,160
我们，现在也将其称为守护进程。

67
00:04:22,160 --> 00:04:24,390
现在这是一个 background process (后台进程) 。

68
00:04:24,390 --> 00:04:30,320
所以，我们可以做的是，使用 -f 标志运行 strace，

69
00:04:30,320 --> 00:04:32,240
跟踪创建的子进程，而不是停留在父进程中。

70
00:04:32,240 --> 00:04:37,050
当我们这样做时，我们在 clone 之后，

71
00:04:37,050 --> 00:04:39,670
我们附加新的进程，并在后台，看到旧进程退出。

72
00:04:39,670 --> 00:04:44,490
然后，我们更改目录并打开 /dev/null，这是另一个特殊的伪文件，

73
00:04:44,490 --> 00:04:46,560
就像一个黑洞，吸入一切。

74
00:04:46,560 --> 00:04:52,330
然后，我们复制这个进程的 stdinput、stdoutput和stderror，

75
00:04:52,330 --> 00:04:56,510
基本意味着，我们让所有这些标准流，指向黑洞。

76
00:04:56,510 --> 00:04:58,920
可以说，我们只是扔掉任何输出的东西。

77
00:04:58,920 --> 00:05:04,110
然后，我们将子进程ID，写入之前

78
00:05:04,110 --> 00:05:05,410
具有文件描述符 3 的 .pid 文件。。

79
00:05:05,410 --> 00:05:08,350
现在，有趣的部分开始了，一个新的套接字创建了。

80
00:05:08,350 --> 00:05:13,020
套接字用于网络通信，您可以选择，

81
00:05:13,020 --> 00:05:15,870
希望使用这些标志和设置的哪种套接字。

82
00:05:15,870 --> 00:05:21,190
但最重要的是调用 bind，它试图将，

83
00:05:21,190 --> 00:05:23,620
这个进程绑定到端口2999。

84
00:05:23,620 --> 00:05:28,970
这意味着，如果操作系统，在该进程中，接收到一个想要建立连接的包，

85
00:05:28,970 --> 00:05:33,680
它会建立连接，然后将包含数据的包，转发到

86
00:05:33,680 --> 00:05:34,680
该进程。

87
00:05:34,680 --> 00:05:40,070
但是！，此函数调用失败，因为地址和端口，

88
00:05:40,070 --> 00:05:41,070
已被另一个进程使用。

89
00:05:41,070 --> 00:05:44,840
说得通，因为我们早就调用 net0 了。

90
00:05:44,840 --> 00:05:47,570
所以，让我们再次终止这个进程，然后重试。

91
00:05:47,570 --> 00:05:48,570
可以！

92
00:05:48,570 --> 00:05:49,570
不错。

93
00:05:49,570 --> 00:05:53,940
现在，我们监听我们打开的端口，经过 accept syscall ，

94
00:05:53,940 --> 00:05:54,940
等待数据包的到来。

95
00:05:54,940 --> 00:06:00,120
因此，让我们打开第二个终端，并使用 netstat 查找这个监听进程。

96
00:06:00,120 --> 00:06:01,510
这里，看到了吗。

97
00:06:01,510 --> 00:06:05,460
在端口2999上，进程 net0 正在监听。

98
00:06:05,460 --> 00:06:06,460
酷。

99
00:06:06,460 --> 00:06:10,580
现在，让我们使用netcat与这个端口，建立一个TCP连接。

100
00:06:10,580 --> 00:06:15,790
这将导致 accept 调用返回，因为一个新的连接建立了。

101
00:06:15,790 --> 00:06:21,570
在接受之后，您会立即看到另一个 clone 调用，这将创建另一个进程。

102
00:06:21,570 --> 00:06:23,940
现在是，处理 服务器-客户端 连接。

103
00:06:23,940 --> 00:06:28,580
这样，另一个用户，也可以建立连接，

104
00:06:28,580 --> 00:06:33,010
并且不必等到你完成了，因为，你现在有了自己的专用进程。

105
00:06:33,010 --> 00:06:36,970
同时，accept返回了一个，引用此套接字的新文件描述符。

106
00:06:36,970 --> 00:06:43,320
就像常规文件一样，您现在可以用这个文件描述符，执行读写操作，比如

107
00:06:43,320 --> 00:06:45,030
你可以用其他文件。

108
00:06:45,030 --> 00:06:51,890
下面的内核，确保将您写入的数据，作为TCP包，发送到客户端。

109
00:06:51,890 --> 00:06:56,230
当它接收到数据时，它将确保您可以从这个套接字中，读取数据。

110
00:06:56,230 --> 00:07:01,800
所以，现在它将把标准的输入、输出和错误流，从/dev/null更改为新的

111
00:07:01,800 --> 00:07:02,800
文件描述符。

112
00:07:02,800 --> 00:07:07,790
然后，程序就可以读取 stdinput，并读取您发送的数据。

113
00:07:07,790 --> 00:07:10,090
这就是 run函数的作用。

114
00:07:10,090 --> 00:07:16,430
如果您将 run与最后两个syscall进行比较，我们首先对 stdout 进行了一次写入，

115
00:07:16,430 --> 00:07:22,750
它来自这里的 printf，然后是一个来自 stdin 的 fread，这就是我们现在的位置。

116
00:07:22,750 --> 00:07:28,180
现在，若我们在 netcat 中键入一行时，netcat 会把一个包着文本的包，

117
00:07:28,180 --> 00:07:30,810
通过网络发给程序，服务器。

118
00:07:30,810 --> 00:07:35,920
在服务器端，您可以看到它，读取您发送给它的字符串，然后

119
00:07:35,921 --> 00:07:38,591
执行了写操作，告诉您数字不对。

120
00:07:38,590 --> 00:07:41,890
这就是 run() 中，失败 printf。

121
00:07:41,890 --> 00:07:45,000
那么，让我们总结一下隐藏代码在做什么。

122
00:07:45,000 --> 00:07:50,220
它首先通过克隆自己和杀死父进程，来使自己成为守护进程，成为孤立进程。

123
00:07:50,220 --> 00:07:54,580
然后，它开始监听端口2999上的TCP连接。

124
00:07:54,580 --> 00:07:59,430
一旦建立了连接，还有，我们另外找时间详细了解TCP协议，现在继续

125
00:07:59,431 --> 00:08:06,401
它将创建进程的另一个克隆，来处理这个已建立的连接。

126
00:08:06,400 --> 00:08:11,030
当父进程再次准备好，接受另一个并行连接时。

127
00:08:11,030 --> 00:08:16,430
处理连接的子进程，现在基本上只是调用run() 。

128
00:08:16,430 --> 00:08:22,010
所以简单地说，程序作为一个后台进程运行

129
00:08:22,010 --> 00:08:24,580
为每个连接到它的客户端，执行 run() 。

130
00:08:24,580 --> 00:08:25,580
雕！

131
00:08:25,580 --> 00:08:26,990
我们理解这一点。

132
00:08:26,990 --> 00:08:28,840
现在，让我们来解决这个挑战。

133
00:08:28,840 --> 00:08:31,530
首先，我们需要得到这个数字的字符串表示形式。

134
00:08:31,530 --> 00:08:37,200
我们可以使用 python，特别是我们以前已经使用过的 struct 包。

135
00:08:37,200 --> 00:08:41,850
因此，使用 struct.pack，我们可以将数字转换为，字节字符串表示形式。

136
00:08:41,849 --> 00:08:47,259
但正如您所看到的，得出的字符串，不使用我们可以用键盘键入的字符。

137
00:08:47,260 --> 00:08:53,200
我们可以用 echo 和 -e 打印这些字节值，

138
00:08:53,200 --> 00:08:55,080
但简单地将其管道到 nc，并不能工作，因为这个数字是随机的。

139
00:08:55,080 --> 00:08:56,880
但我们可以使用一个简单的技巧。

140
00:08:56,880 --> 00:09:04,210
我们可以使用 echo -e，但在引号中，我们使用反勾号，来执行cat的减号，

141
00:09:04,210 --> 00:09:10,390
它只是将我们键入的任何内容，重新定向到输出，

142
00:09:10,390 --> 00:09:12,160
然后将输出放置在 echo 的引号中。

143
00:09:12,160 --> 00:09:18,420
所以，当我们现在把它管道到 netcat时，我们看到了数字，cat 正在等待输入，

144
00:09:18,420 --> 00:09:23,000
我们使用 python 转换数字，然后简单地将转义字符串，

145
00:09:23,000 --> 00:09:29,130
粘贴回另一个终端，点击 enter，然后使用 ctrl+d，表示我们已经完成了输入。

146
00:09:29,130 --> 00:09:32,650
它关闭 cat，echo 将把字符串发送给netcat。

147
00:09:32,650 --> 00:09:35,830
这样，我们就得到了“谢谢您，先生/女士”的成功信息。

