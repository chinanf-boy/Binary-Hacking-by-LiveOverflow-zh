1
00:00:00,260 --> 00:00:04,900
最后几段视频已经变得很难理解，需要很多

2
00:00:04,899 --> 00:00:07,919
concentration and patience to understand them.

3
00:00:07,920 --> 00:00:12,020
因此，我很高兴我们现在可以继续利用演习中的网络挑战。

4
00:00:12,020 --> 00:00:19,120
protostar, which will be a lot easier because we have to establish some basics first.

5
00:00:19,119 --> 00:00:26,149
让我们快速了解一下网络级别
0.

6
00:00:26,150 --> 00:00:31,380
The description says you have to convert strings to little endian integers.

7
00:00:31,380 --> 00:00:35,830
这个级别很容易，但是要完全理解发生了什么，代码是

8
00:00:35,829 --> 00:00:36,899
not quite enough.

9
00:00:36,899 --> 00:00:38,749
I show you why.

10
00:00:38,750 --> 00:00:44,920
所以main调用一个函数后台进程，并将其传递一个名称、用户和组

11
00:00:44,920 --> 00:00:46,570
ID it will run with.

12
00:00:46,569 --> 00:00:50,509
But this function is not a common libc function.

13
00:00:50,510 --> 00:00:56,010
您还可以检查/etc/passwd中的用户ID 999，您会发现没有这样的用户ID

14
00:00:56,010 --> 00:00:57,010
user.

15
00:00:57,010 --> 00:01:01,170
This might seem weird but just don’t think so abstractly about computers.

16
00:01:01,170 --> 00:01:04,260
在Linux系统上拥有用户意味着什么？

17
00:01:04,260 --> 00:01:09,810
最后，用户只是一个ID、内存中的一个数字，例如文件的所有者。

18
00:01:09,810 --> 00:01:13,750
just means that this file has this number as owner set.

19
00:01:13,750 --> 00:01:19,320
现在，如果用户列在/etc/passwd文件中，Linux将非常好，并显示

20
00:01:19,320 --> 00:01:24,270
name instead of the number, but under the hood it is still just an integer.

21
00:01:24,270 --> 00:01:28,730
So even though there is no name assigned to that ID, you are still free to use it.

22
00:01:28,730 --> 00:01:30,750
Anyway, back to the code.

23
00:01:30,750 --> 00:01:36,430
The other functions such as serve_forever and set_io are also not known functions.

24
00:01:36,430 --> 00:01:42,200
And when you look at the includes, you will notice that it references a common.c file.

25
00:01:42,200 --> 00:01:46,820
所以这个挑战的作者在一个不同的文件中实现了很多代码，

26
00:01:46,820 --> 00:01:48,910
we don’t know what it does.

27
00:01:48,910 --> 00:01:52,170
But one function is here, and that is the run() function.

28
00:01:52,170 --> 00:01:55,690
You can see that it is called at the end of main().

29
00:01:55,690 --> 00:02:01,460
Run generated a random number, tells us that you should send that number as little endian.

30
00:02:01,460 --> 00:02:06,350
然后执行从文件描述符读取，在本例中是从标准输入读取，解释

31
00:02:06,350 --> 00:02:11,500
this input as a number and compares if it’s the same as the random number before.

32
00:02:11,500 --> 00:02:12,840
So just a simple test.

33
00:02:12,840 --> 00:02:18,320
正如我之前所说，我们可以在不知道下面这些未知功能的情况下解决这个挑战

34
00:02:18,319 --> 00:02:23,229
，因为仅仅阅读注释和函数名就可以告诉我们需要知道的一切，

35
00:02:23,230 --> 00:02:28,620
but as you know, we are not satisfied on this channel when we ignore underlying concepts.

36
00:02:28,620 --> 00:02:30,810
We want to understand computers better.

37
00:02:30,810 --> 00:02:36,350
这些函数实现了这里提到的两个有趣的概念，一个正在运行

38
00:02:36,349 --> 00:02:40,609
the process as a daemon, and the other one is about networking and sockets.

39
00:02:40,609 --> 00:02:43,469
那么我们如何才能弄清楚它的作用呢？

40
00:02:43,469 --> 00:02:48,469
Well we know already everything we need, to be able to reverse engineer this.

41
00:02:48,469 --> 00:02:52,579
So let’s start by exploring the behaviour of the program before digging deeper.

42
00:02:52,579 --> 00:02:55,119
When you try to run the program, nothing happens.

43
00:02:55,120 --> 00:03:01,270
But when you look at the running processes you can see that net0 is already running.

44
00:03:01,269 --> 00:03:05,889
所以让我们快速切换到根用户，这样我们就可以终止该进程并启动它。

45
00:03:05,890 --> 00:03:07,160
ourselves.

46
00:03:07,159 --> 00:03:10,399
The default root password for this VM is “godmode”.

47
00:03:10,400 --> 00:03:14,950
Now we can kill net0 and we can verify that it is not running anymore.

48
00:03:14,950 --> 00:03:17,570
So, let’s execute it again.

49
00:03:17,569 --> 00:03:19,389
什么都没发生？

50
00:03:19,390 --> 00:03:22,470
But if we check the processes we can see that it’s running again.

51
00:03:22,469 --> 00:03:23,469
那发生了什么？

52
00:03:23,469 --> 00:03:27,089
Let’s kill it again and start it with strace.

53
00:03:27,090 --> 00:03:30,770
所以最后是一个出口，但是之前发生了什么？

54
00:03:30,769 --> 00:03:35,869
It seems to open a net0.pid file with write permissions.

55
00:03:35,870 --> 00:03:41,920
Then it changes the user and group id to 999 with set effective uid and gid.

56
00:03:41,920 --> 00:03:45,360
因此，这意味着进程将删除它的根权限，即uid 1向下到用户

57
00:03:45,359 --> 00:03:46,359
id 999.

58
00:03:46,359 --> 00:03:47,459
After that it calls clone().

59
00:03:47,459 --> 00:03:51,799
The manpages says that clone creates a new process similar to fork.

60
00:03:51,799 --> 00:03:57,339
So this will spawn a new process as a clone, a copy, of itself.

61
00:03:57,340 --> 00:04:02,570
返回值是这个新进程的进程ID，等于这个值

62
00:04:02,569 --> 00:04:04,639
written into the .pid file.

63
00:04:04,640 --> 00:04:09,510
So that file just helps you keeping track of the new process you created.

64
00:04:09,510 --> 00:04:14,920
And after that the parent process exits and leaves the child process orphaned.

65
00:04:14,920 --> 00:04:19,530
这就是所谓的孤立过程，因为我们是故意这样做的。

66
00:04:19,530 --> 00:04:22,160
we also refer to this now as a daemon.

67
00:04:22,160 --> 00:04:24,390
It’s now a background process.

68
00:04:24,390 --> 00:04:30,320
所以我们可以做的是，使用-f标志运行strace，跟踪创建的子进程

69
00:04:30,320 --> 00:04:32,240
instead of staying in the parent process.

70
00:04:32,240 --> 00:04:37,050
当我们这样做时，我们看到在克隆之后，我们附加到新的进程和

71
00:04:37,050 --> 00:04:39,670
background the old process exits.

72
00:04:39,670 --> 00:04:44,490
然后我们更改目录并打开/dev/null，这是另一个特殊的伪文件，

73
00:04:44,490 --> 00:04:46,560
acts like a blackhole.

74
00:04:46,560 --> 00:04:52,330
然后我们复制这个过程的stdinput、stdoutput和stderror，基本上

75
00:04:52,330 --> 00:04:56,510
means we bend all these standard streams to point into the blackhole.

76
00:04:56,510 --> 00:04:58,920
Basically we just throw away anything.

77
00:04:58,920 --> 00:05:04,110
然后，我们将子进程ID写入之前具有文件描述符的.pid文件。

78
00:05:04,110 --> 00:05:05,410
number 3.

79
00:05:05,410 --> 00:05:08,350
Now the fun part starts, a new socket is created.

80
00:05:08,350 --> 00:05:13,020
套接字用于网络通信，您可以选择哪种套接字

81
00:05:13,020 --> 00:05:15,870
want with those flags and settings.

82
00:05:15,870 --> 00:05:21,190
但最重要的是调用bind，它试图将这个进程绑定到

83
00:05:21,190 --> 00:05:23,620
the port 2999.

84
00:05:23,620 --> 00:05:28,970
这意味着如果操作系统接收到一个想要建立连接的包

85
00:05:28,970 --> 00:05:33,680
在这个过程中，它会这样做，然后将包含数据的包转发到

86
00:05:33,680 --> 00:05:34,680
process.

87
00:05:34,680 --> 00:05:40,070
但是！，此函数调用失败，因为地址和端口已被另一个使用

88
00:05:40,070 --> 00:05:41,070
process.

89
00:05:41,070 --> 00:05:44,840
Which makes sense because we called net0 already way earlier.

90
00:05:44,840 --> 00:05:47,570
So let’s kill the process again and retry this.

91
00:05:47,570 --> 00:05:48,570
可以！

92
00:05:48,570 --> 00:05:49,570
This looks great.

93
00:05:49,570 --> 00:05:53,940
现在我们监听我们打开的端口，等待接收到的数据包到达。

94
00:05:53,940 --> 00:05:54,940
syscall.

95
00:05:54,940 --> 00:06:00,120
So let’s open a second terminal and use netstat to find this listening process.

96
00:06:00,120 --> 00:06:01,510
And here it is.

97
00:06:01,510 --> 00:06:05,460
On port 2999 the process net0 is listening.

98
00:06:05,460 --> 00:06:06,460
Cool.

99
00:06:06,460 --> 00:06:10,580
Now let’s use netcat to establish a TCP connection with this port.

100
00:06:10,580 --> 00:06:15,790
This will cause the accept call to return, because a new connection got established.

101
00:06:15,790 --> 00:06:21,570
在接受之后，您会立即看到另一个克隆调用，这将创建另一个进程。

102
00:06:21,570 --> 00:06:23,940
to now handle this server-client connection.

103
00:06:23,940 --> 00:06:28,580
这样，另一个用户也可以建立连接，并且不必等到

104
00:06:28,580 --> 00:06:33,010
you are done, because you have now your own dedicated process.

105
00:06:33,010 --> 00:06:36,970
Also accept returned a new filedescriptor that references this socket.

106
00:06:36,970 --> 00:06:43,320
就像常规文件一样，您现在可以用这个文件描述符执行读写操作，比如

107
00:06:43,320 --> 00:06:45,030
you would with any other file.

108
00:06:45,030 --> 00:06:51,890
The kernel underneath makes sure to send the data you write as a TCP packet to the client.

109
00:06:51,890 --> 00:06:56,230
And when it receives data it will make sure that you can read it from this socket.

110
00:06:56,230 --> 00:07:01,800
所以现在它将把std输入、输出和错误流从/dev/null更改为新的

111
00:07:01,800 --> 00:07:02,800
filedescriptor.

112
00:07:02,800 --> 00:07:07,790
And the program can then just read from stdinput and will read the data you sent it.

113
00:07:07,790 --> 00:07:10,090
And that is what the run function does.

114
00:07:10,090 --> 00:07:16,430
如果您将run与最后两个syscall进行比较，我们首先对stdout进行了一次写入，它是

115
00:07:16,430 --> 00:07:22,750
from this printf here, and then an fread from stdin and this is where we are right now.

116
00:07:22,750 --> 00:07:28,180
当我们现在在netcat中键入一行时，netcat将通过

117
00:07:28,180 --> 00:07:30,810
the network to the program, the server.

118
00:07:30,810 --> 00:07:35,920
在服务器端，您可以看到它读取您发送给它的字符串，然后

119
00:07:35,921 --> 00:07:38,591
performed the write telling you that it is the wrong number.

120
00:07:38,590 --> 00:07:41,890
That’s the failed printf in run().

121
00:07:41,890 --> 00:07:45,000
So let’s summarize what the hidden code is doing.

122
00:07:45,000 --> 00:07:50,220
It first deamonizes by cloning itself and killing the parent, to become an orphan.

123
00:07:50,220 --> 00:07:54,580
Then it starts listening on port 2999 for TCP connections.

124
00:07:54,580 --> 00:07:59,430
一旦建立了连接，我们将详细了解TCP协议

125
00:07:59,431 --> 00:08:06,401
other time, it will create another clone of the process to handle this established connection.

126
00:08:06,400 --> 00:08:11,030
While the parent is ready again to accept another connection in parallel.

127
00:08:11,030 --> 00:08:16,430
The child process that handles the connection is now basically just calling run().

128
00:08:16,430 --> 00:08:22,010
所以简单地说，程序作为一个后台进程运行

129
00:08:22,010 --> 00:08:24,580
run() for every client that connects to it.

130
00:08:24,580 --> 00:08:25,580
令人惊叹的！

131
00:08:25,580 --> 00:08:26,990
We understood that.

132
00:08:26,990 --> 00:08:28,840
Now let’s solve the challenge.

133
00:08:28,840 --> 00:08:31,530
First of all we need to get the string representation of that number.

134
00:08:31,530 --> 00:08:37,200
We can use python for that, specifically the struct package - which we already used before.

135
00:08:37,200 --> 00:08:41,850
So with struct.pack we can convert a number to the byte string representation.

136
00:08:41,849 --> 00:08:47,259
But as you can see, the resulting string doesn’t use characters we can type with the keyboard.

137
00:08:47,260 --> 00:08:53,200
我们可以用echo和-e打印这些字节值，但简单地将其导入nc并不能

138
00:08:53,200 --> 00:08:55,080
work, because the number is randomized.

139
00:08:55,080 --> 00:08:56,880
But we can use a simple trick.

140
00:08:56,880 --> 00:09:04,210
我们可以使用echo-e，但在引号中，我们使用反勾号来执行cat的减号，

141
00:09:04,210 --> 00:09:10,390
它只是将我们键入的任何内容重新定向到输出，然后将输出放置

142
00:09:10,390 --> 00:09:12,160
in the quotes of echo.

143
00:09:12,160 --> 00:09:18,420
所以当我们现在把它输入netcat时，我们看到了数字，cat正在等待输入，我们

144
00:09:18,420 --> 00:09:23,000
使用python转换数字，然后简单地将转义字符串粘贴回

145
00:09:23,000 --> 00:09:29,130
另一个终端，点击回车，然后使用ctrl+d，表示我们已经完成了输入。

146
00:09:29,130 --> 00:09:32,650
which closes cat and echo will send the string to netcat.

147
00:09:32,650 --> 00:09:35,830
And that works, we get the sucess “thank you sir/madam message”.

