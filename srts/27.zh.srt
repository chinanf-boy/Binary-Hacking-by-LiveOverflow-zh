1
00:00:00,260 --> 00:00:04,900
最后几段视频已经变得很难理解，需要很多

2
00:00:04,899 --> 00:00:07,919
专心和耐心去理解他们。

3
00:00:07,920 --> 00:00:12,020
因此，我很高兴我们现在可以继续利用演习中的网络挑战。

4
00:00:12,020 --> 00:00:19,120
原恒星，这会更容易，因为我们必须先建立一些基础知识。

5
00:00:19,119 --> 00:00:26,149
让我们快速了解一下网络级别
0。

6
00:00:26,150 --> 00:00:31,380
说明中指出必须将字符串转换为小尾数整数。

7
00:00:31,380 --> 00:00:35,830
这个级别很容易，但是要完全理解发生了什么，代码是

8
00:00:35,829 --> 00:00:36,899
还不够。

9
00:00:36,899 --> 00:00:38,749
我告诉你为什么。

10
00:00:38,750 --> 00:00:44,920
所以main调用一个函数后台进程，并将其传递一个名称、用户和组

11
00:00:44,920 --> 00:00:46,570
它将运行。

12
00:00:46,569 --> 00:00:50,509
但此函数不是常见的libc函数。

13
00:00:50,510 --> 00:00:56,010
您还可以检查/etc/passwd中的用户ID 999，您会发现没有这样的用户ID

14
00:00:56,010 --> 00:00:57,010
用户。

15
00:00:57,010 --> 00:01:01,170
这可能看起来很奇怪，但不要对计算机如此抽象地思考。

16
00:01:01,170 --> 00:01:04,260
在Linux系统上拥有用户意味着什么？

17
00:01:04,260 --> 00:01:09,810
最后，用户只是一个ID、内存中的一个数字，例如文件的所有者。

18
00:01:09,810 --> 00:01:13,750
这意味着这个文件将这个编号作为所有者集。

19
00:01:13,750 --> 00:01:19,320
现在，如果用户列在/etc/passwd文件中，Linux将非常好，并显示

20
00:01:19,320 --> 00:01:24,270
名称而不是数字，但在引擎盖下它仍然只是一个整数。

21
00:01:24,270 --> 00:01:28,730
因此，即使没有为该ID分配名称，您仍然可以自由使用它。

22
00:01:28,730 --> 00:01:30,750
不管怎样，回到代码。

23
00:01:30,750 --> 00:01:36,430
其他功能，如永远服务和设置IO，也不是已知的功能。

24
00:01:36,430 --> 00:01:42,200
当您查看include时，您会注意到它引用了一个公共的.c文件。

25
00:01:42,200 --> 00:01:46,820
所以这个挑战的作者在一个不同的文件中实现了很多代码，

26
00:01:46,820 --> 00:01:48,910
我们不知道它是干什么的。

27
00:01:48,910 --> 00:01:52,170
但这里有一个函数，那就是run() 函数。

28
00:01:52,170 --> 00:01:55,690
您可以看到它是在main() 的末尾调用的。

29
00:01:55,690 --> 00:02:01,460
run生成了一个随机数，告诉我们应该以小endian的形式发送该数。

30
00:02:01,460 --> 00:02:06,350
然后执行从文件描述符读取，在本例中是从标准输入读取，解释

31
00:02:06,350 --> 00:02:11,500
这个输入作为一个数字，并比较它是否与之前的随机数相同。

32
00:02:11,500 --> 00:02:12,840
所以只是一个简单的测试。

33
00:02:12,840 --> 00:02:18,320
正如我之前所说，我们可以在不知道下面这些未知功能的情况下解决这个挑战

34
00:02:18,319 --> 00:02:23,229
，因为仅仅阅读注释和函数名就可以告诉我们需要知道的一切，

35
00:02:23,230 --> 00:02:28,620
但是，正如您所知，当我们忽略基础概念时，我们对这个通道并不满意。

36
00:02:28,620 --> 00:02:30,810
我们想更好地理解计算机。

37
00:02:30,810 --> 00:02:36,350
这些函数实现了这里提到的两个有趣的概念，一个正在运行

38
00:02:36,349 --> 00:02:40,609
进程是一个守护进程，另一个是关于网络和套接字的。

39
00:02:40,609 --> 00:02:43,469
那么我们如何才能弄清楚它的作用呢？

40
00:02:43,469 --> 00:02:48,469
好吧，我们已经知道了我们所需要的一切，能够逆向工程。

41
00:02:48,469 --> 00:02:52,579
因此，让我们先研究一下程序的行为，然后再深入研究。

42
00:02:52,579 --> 00:02:55,119
当你试图运行程序时，什么也不会发生。

43
00:02:55,120 --> 00:03:01,270
但是当您查看正在运行的进程时，您可以看到net0已经在运行。

44
00:03:01,269 --> 00:03:05,889
所以让我们快速切换到根用户，这样我们就可以终止该进程并启动它。

45
00:03:05,890 --> 00:03:07,160
我们自己。

46
00:03:07,159 --> 00:03:10,399
这个虚拟机的默认根密码是“godmode”。

47
00:03:10,400 --> 00:03:14,950
现在，我们可以杀死net0，并验证它是否不再运行。

48
00:03:14,950 --> 00:03:17,570
所以，让我们再次执行它。

49
00:03:17,569 --> 00:03:19,389
什么都没发生？

50
00:03:19,390 --> 00:03:22,470
但如果我们检查这些进程，就会发现它又在运行了。

51
00:03:22,469 --> 00:03:23,469
那发生了什么？

52
00:03:23,469 --> 00:03:27,089
让我们再杀了它，从斯特拉斯开始。

53
00:03:27,090 --> 00:03:30,770
所以最后是一个出口，但是之前发生了什么？

54
00:03:30,769 --> 00:03:35,869
它似乎打开了一个具有写权限的net0.pid文件。

55
00:03:35,870 --> 00:03:41,920
然后将用户和组ID更改为999，并设置有效的uid和gid。

56
00:03:41,920 --> 00:03:45,360
因此，这意味着进程将删除它的根权限，即uid 1向下到用户

57
00:03:45,359 --> 00:03:46,359
身份证999。

58
00:03:46,359 --> 00:03:47,459
然后它调用clone() 。

59
00:03:47,459 --> 00:03:51,799
手册页说，克隆创建了一个类似于fork的新进程。

60
00:03:51,799 --> 00:03:57,339
因此，这将产生一个新的进程，作为其自身的克隆、副本。

61
00:03:57,340 --> 00:04:02,570
返回值是这个新进程的进程ID，等于这个值

62
00:04:02,569 --> 00:04:04,639
写入.pid文件。

63
00:04:04,640 --> 00:04:09,510
所以这个文件只是帮助您跟踪您创建的新流程。

64
00:04:09,510 --> 00:04:14,920
然后，父进程退出并将子进程孤立。

65
00:04:14,920 --> 00:04:19,530
这就是所谓的孤立过程，因为我们是故意这样做的。

66
00:04:19,530 --> 00:04:22,160
我们现在也将其称为守护进程。

67
00:04:22,160 --> 00:04:24,390
现在这是一个后台进程。

68
00:04:24,390 --> 00:04:30,320
所以我们可以做的是，使用-f标志运行strace，跟踪创建的子进程

69
00:04:30,320 --> 00:04:32,240
而不是停留在父进程中。

70
00:04:32,240 --> 00:04:37,050
当我们这样做时，我们看到在克隆之后，我们附加到新的进程和

71
00:04:37,050 --> 00:04:39,670
后台旧进程退出。

72
00:04:39,670 --> 00:04:44,490
然后我们更改目录并打开/dev/null，这是另一个特殊的伪文件，

73
00:04:44,490 --> 00:04:46,560
就像一个黑洞。

74
00:04:46,560 --> 00:04:52,330
然后我们复制这个过程的stdinput、stdoutput和stderror，基本上

75
00:04:52,330 --> 00:04:56,510
意味着我们弯曲所有这些标准流，指向黑洞。

76
00:04:56,510 --> 00:04:58,920
基本上，我们只是扔掉任何东西。

77
00:04:58,920 --> 00:05:04,110
然后，我们将子进程ID写入之前具有文件描述符的.pid文件。

78
00:05:04,110 --> 00:05:05,410
3号。

79
00:05:05,410 --> 00:05:08,350
现在有趣的部分开始了，创建了一个新的套接字。

80
00:05:08,350 --> 00:05:13,020
套接字用于网络通信，您可以选择哪种套接字

81
00:05:13,020 --> 00:05:15,870
希望使用这些标志和设置。

82
00:05:15,870 --> 00:05:21,190
但最重要的是调用bind，它试图将这个进程绑定到

83
00:05:21,190 --> 00:05:23,620
端口2999。

84
00:05:23,620 --> 00:05:28,970
这意味着如果操作系统接收到一个想要建立连接的包

85
00:05:28,970 --> 00:05:33,680
在这个过程中，它会这样做，然后将包含数据的包转发到

86
00:05:33,680 --> 00:05:34,680
过程。

87
00:05:34,680 --> 00:05:40,070
但是！，此函数调用失败，因为地址和端口已被另一个使用

88
00:05:40,070 --> 00:05:41,070
过程。

89
00:05:41,070 --> 00:05:44,840
这很有意义，因为我们早就给net0打过电话了。

90
00:05:44,840 --> 00:05:47,570
所以让我们再次终止这个过程，然后重试。

91
00:05:47,570 --> 00:05:48,570
可以！

92
00:05:48,570 --> 00:05:49,570
这看起来不错。

93
00:05:49,570 --> 00:05:53,940
现在我们监听我们打开的端口，等待接收到的数据包到达。

94
00:05:53,940 --> 00:05:54,940
系统调用。

95
00:05:54,940 --> 00:06:00,120
因此，让我们打开第二个终端，并使用netstat查找这个侦听过程。

96
00:06:00,120 --> 00:06:01,510
就在这里。

97
00:06:01,510 --> 00:06:05,460
在端口2999上，进程net0正在侦听。

98
00:06:05,460 --> 00:06:06,460
酷。

99
00:06:06,460 --> 00:06:10,580
现在让我们使用netcat与这个端口建立一个TCP连接。

100
00:06:10,580 --> 00:06:15,790
这将导致accept调用返回，因为建立了新的连接。

101
00:06:15,790 --> 00:06:21,570
在接受之后，您会立即看到另一个克隆调用，这将创建另一个进程。

102
00:06:21,570 --> 00:06:23,940
现在处理此服务器客户端连接。

103
00:06:23,940 --> 00:06:28,580
这样，另一个用户也可以建立连接，并且不必等到

104
00:06:28,580 --> 00:06:33,010
你完成了，因为你现在有了自己的专用过程。

105
00:06:33,010 --> 00:06:36,970
同时accept返回了一个引用此套接字的新文件描述符。

106
00:06:36,970 --> 00:06:43,320
就像常规文件一样，您现在可以用这个文件描述符执行读写操作，比如

107
00:06:43,320 --> 00:06:45,030
你可以用其他文件。

108
00:06:45,030 --> 00:06:51,890
下面的内核确保将您作为TCP包写入的数据发送到客户机。

109
00:06:51,890 --> 00:06:56,230
当它接收到数据时，它将确保您可以从这个套接字中读取数据。

110
00:06:56,230 --> 00:07:01,800
所以现在它将把std输入、输出和错误流从/dev/null更改为新的

111
00:07:01,800 --> 00:07:02,800
文件描述符。

112
00:07:02,800 --> 00:07:07,790
然后程序就可以从stdinput中读取，并读取您发送的数据。

113
00:07:07,790 --> 00:07:10,090
这就是run函数的作用。

114
00:07:10,090 --> 00:07:16,430
如果您将run与最后两个syscall进行比较，我们首先对stdout进行了一次写入，它是

115
00:07:16,430 --> 00:07:22,750
从这里的印刷品，然后是一个来自stdin的fread，这就是我们现在的位置。

116
00:07:22,750 --> 00:07:28,180
当我们现在在netcat中键入一行时，netcat将通过

117
00:07:28,180 --> 00:07:30,810
网络到程序，服务器。

118
00:07:30,810 --> 00:07:35,920
在服务器端，您可以看到它读取您发送给它的字符串，然后

119
00:07:35,921 --> 00:07:38,591
执行了写操作，告诉您号码不对。

120
00:07:38,590 --> 00:07:41,890
这是run() 中失败的printf。

121
00:07:41,890 --> 00:07:45,000
那么让我们总结一下隐藏代码在做什么。

122
00:07:45,000 --> 00:07:50,220
它首先通过克隆自己和杀死父母来使自己失去理智，成为孤儿。

123
00:07:50,220 --> 00:07:54,580
然后它开始监听端口2999上的TCP连接。

124
00:07:54,580 --> 00:07:59,430
一旦建立了连接，我们将详细了解TCP协议

125
00:07:59,431 --> 00:08:06,401
另一次，它将创建进程的另一个克隆来处理这个已建立的连接。

126
00:08:06,400 --> 00:08:11,030
当父级再次准备好接受另一个并行连接时。

127
00:08:11,030 --> 00:08:16,430
处理连接的子进程现在基本上只是调用run() 。

128
00:08:16,430 --> 00:08:22,010
所以简单地说，程序作为一个后台进程运行

129
00:08:22,010 --> 00:08:24,580
为每个连接到它的客户机运行() 。

130
00:08:24,580 --> 00:08:25,580
令人惊叹的！

131
00:08:25,580 --> 00:08:26,990
我们理解这一点。

132
00:08:26,990 --> 00:08:28,840
现在让我们来解决这个挑战。

133
00:08:28,840 --> 00:08:31,530
首先，我们需要得到这个数字的字符串表示。

134
00:08:31,530 --> 00:08:37,200
我们可以使用python，特别是我们以前已经使用过的结构包。

135
00:08:37,200 --> 00:08:41,850
因此，使用struct.pack，我们可以将数字转换为字节字符串表示形式。

136
00:08:41,849 --> 00:08:47,259
但正如您所看到的，结果字符串不使用我们可以用键盘键入的字符。

137
00:08:47,260 --> 00:08:53,200
我们可以用echo和-e打印这些字节值，但简单地将其导入nc并不能

138
00:08:53,200 --> 00:08:55,080
因为这个数字是随机的。

139
00:08:55,080 --> 00:08:56,880
但我们可以使用一个简单的技巧。

140
00:08:56,880 --> 00:09:04,210
我们可以使用echo-e，但在引号中，我们使用反勾号来执行cat的减号，

141
00:09:04,210 --> 00:09:10,390
它只是将我们键入的任何内容重新定向到输出，然后将输出放置

142
00:09:10,390 --> 00:09:12,160
在回音的引言中。

143
00:09:12,160 --> 00:09:18,420
所以当我们现在把它输入netcat时，我们看到了数字，cat正在等待输入，我们

144
00:09:18,420 --> 00:09:23,000
使用python转换数字，然后简单地将转义字符串粘贴回

145
00:09:23,000 --> 00:09:29,130
另一个终端，点击回车，然后使用ctrl+d，表示我们已经完成了输入。

146
00:09:29,130 --> 00:09:32,650
它关闭cat，echo将把字符串发送给netcat。

147
00:09:32,650 --> 00:09:35,830
这样，我们就得到了“谢谢您，先生/女士留言”的成功。

