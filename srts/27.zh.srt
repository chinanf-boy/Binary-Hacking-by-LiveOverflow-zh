1
00:00:00,260 --> 00:00:04,900
最后几段视频已经开始
很难理解，需要很多

2
00:00:04,899 --> 00:00:07,919
专心和耐心去理解他们。

3
00:00:07,920 --> 00:00:12,020
所以我很高兴我们现在可以继续
利用演习带来的网络挑战

4
00:00:12,020 --> 00:00:19,120
原恒星，因为
我们必须先建立一些基础知识。

5
00:00:19,119 --> 00:00:26,149
让我们快速了解一下网络级别
0.

6
00:00:26,150 --> 00:00:31,380
说明说您必须转换字符串
小尾数整数。

7
00:00:31,380 --> 00:00:35,830
这个水平很容易，但是
明白发生了什么，代码是

8
00:00:35,829 --> 00:00:36,899
还不够。

9
00:00:36,899 --> 00:00:38,749
我告诉你为什么。

10
00:00:38,750 --> 00:00:44,920
所以main调用一个函数后台进程
传递一个名称和用户和组

11
00:00:44,920 --> 00:00:46,570
它将运行。

12
00:00:46,569 --> 00:00:50,509
但此函数不是常见的libc函数。

13
00:00:50,510 --> 00:00:56,010
您还可以为用户检查/etc/passwd
你会发现没有这样的

14
00:00:56,010 --> 00:00:57,010
用户。

15
00:00:57,010 --> 00:01:01,170
这可能看起来很奇怪，但不要认为
抽象地讲计算机。

16
00:01:01,170 --> 00:01:04,260
在Linux上拥有用户意味着什么？
系统？

17
00:01:04,260 --> 00:01:09,810
最后，用户只是一个ID，一个数字
在内存中，例如文件的所有者

18
00:01:09,810 --> 00:01:13,750
就是说这个文件有这个号码
作为所有者设置。

19
00:01:13,750 --> 00:01:19,320
现在，如果用户列在/etc/passwd中，
文件，Linux将非常好，并显示

20
00:01:19,320 --> 00:01:24,270
名称而不是数字，但在
它仍然只是一个整数。

21
00:01:24,270 --> 00:01:28,730
所以即使没有名字分配给
那个身份证，你仍然可以自由使用。

22
00:01:28,730 --> 00:01:30,750
不管怎样，回到代码。

23
00:01:30,750 --> 00:01:36,430
其他功能，如永远服务于
和set-io也是未知函数。

24
00:01:36,430 --> 00:01:42,200
当你看包厢的时候，你会
请注意，它引用了一个公共的.c文件。

25
00:01:42,200 --> 00:01:46,820
所以这个挑战的作者实施了
不同文件中的很多代码

26
00:01:46,820 --> 00:01:48,910
我们不知道它是干什么的。

27
00:01:48,910 --> 00:01:52,170
但是这里有一个函数，那就是
运行（）函数。

28
00:01:52,170 --> 00:01:55,690
你可以看到它在
（）

29
00:01:55,690 --> 00:02:01,460
运行生成一个随机数，告诉我们
你应该用小尾数发送这个号码。

30
00:02:01,460 --> 00:02:06,350
然后执行从文件描述符读取，
在这种情况下，从标准输入，解释

31
00:02:06,350 --> 00:02:11,500
此输入作为数字，并比较
与之前的随机数相同。

32
00:02:11,500 --> 00:02:12,840
所以只是一个简单的测试。

33
00:02:12,840 --> 00:02:18,320
正如我之前所说，我们可以解决这个挑战
不知道下面这些未知功能

34
00:02:18,319 --> 00:02:23,229
，因为只需阅读注释和函数
名字告诉我们需要知道的一切，

35
00:02:23,230 --> 00:02:28,620
但你知道，我们对此并不满意
当我们忽略了基础概念时。

36
00:02:28,620 --> 00:02:30,810
我们想更好地理解计算机。

37
00:02:30,810 --> 00:02:36,350
这些函数实现了两个有趣的
这里提到的概念，其中一个正在运行

38
00:02:36,349 --> 00:02:40,609
作为守护进程的进程，另一个进程
是关于网络和套接字的。

39
00:02:40,609 --> 00:02:43,469
那么我们如何才能弄清楚它的作用呢？

40
00:02:43,469 --> 00:02:48,469
我们已经知道我们需要的一切
能够逆向工程。

41
00:02:48,469 --> 00:02:52,579
所以让我们从探索行为开始
在深入挖掘之前。

42
00:02:52,579 --> 00:02:55,119
当你试图运行程序时，什么也不会发生。

43
00:02:55,120 --> 00:03:01,270
但是当你看到正在运行的进程时
您可以看到Net0已经在运行。

44
00:03:01,269 --> 00:03:05,889
所以让我们快速切换到根用户
所以我们可以终止这个过程并启动它

45
00:03:05,890 --> 00:03:07,160
我们自己。

46
00:03:07,159 --> 00:03:10,399
这个虚拟机的默认根密码是"godmode"。

47
00:03:10,400 --> 00:03:14,950
现在我们可以杀死net0，我们可以验证
它不再运行了。

48
00:03:14,950 --> 00:03:17,570
所以，让我们再次执行它。

49
00:03:17,569 --> 00:03:19,389
什么都没发生？

50
00:03:19,390 --> 00:03:22,470
但是如果我们检查过程，我们可以看到
它又跑了。

51
00:03:22,469 --> 00:03:23,469
那发生了什么？

52
00:03:23,469 --> 00:03:27,089
让我们再杀了它，从斯特拉斯开始。

53
00:03:27,090 --> 00:03:30,770
所以最后是一个出口，但是发生了什么
以前？

54
00:03:30,769 --> 00:03:35,869
它似乎打开了一个net0.pid文件
权限。

55
00:03:35,870 --> 00:03:41,920
然后将用户和组ID更改为999
设置有效的uid和gid。

56
00:03:41,920 --> 00:03:45,360
所以这意味着这个过程会失去它的根
权限，从uid 1到用户

57
00:03:45,359 --> 00:03:46,359
身份证999。

58
00:03:46,359 --> 00:03:47,459
然后它调用clone（）。

59
00:03:47,459 --> 00:03:51,799
手册页上说克隆会创建一个新的
流程类似于fork。

60
00:03:51,799 --> 00:03:57,339
所以这将产生一个新的克隆过程，
一份副本。

61
00:03:57,340 --> 00:04:02,570
返回值是
这个新过程，等于

62
00:04:02,569 --> 00:04:04,639
写入.pid文件。

63
00:04:04,640 --> 00:04:09,510
所以那个文件只是帮你跟踪
您创建的新进程。

64
00:04:09,510 --> 00:04:14,920
然后，父进程退出并
使子进程保持孤立。

65
00:04:14,920 --> 00:04:19,530
这就是所谓的孤儿
因为我们是故意这样做的

66
00:04:19,530 --> 00:04:22,160
我们现在也将其称为守护进程。

67
00:04:22,160 --> 00:04:24,390
现在这是一个后台进程。

68
00:04:24,390 --> 00:04:30,320
所以我们可以做的是，我们可以和
-f标志，用于跟踪创建的子进程

69
00:04:30,320 --> 00:04:32,240
而不是停留在父进程中。

70
00:04:32,240 --> 00:04:37,050
当我们这样做的时候，我们看到克隆之后
我们依附于新的流程

71
00:04:37,050 --> 00:04:39,670
后台旧进程退出。

72
00:04:39,670 --> 00:04:44,490
然后我们更改目录并打开/dev/null，
这是另一个特殊的伪文件

73
00:04:44,490 --> 00:04:46,560
就像一个黑洞。

74
00:04:46,560 --> 00:04:52,330
然后我们复制stdinput、stdOutput和
这个过程的标准误差，基本上

75
00:04:52,330 --> 00:04:56,510
意味着我们将所有这些标准流
指向黑洞。

76
00:04:56,510 --> 00:04:58,920
基本上，我们只是扔掉任何东西。

77
00:04:58,920 --> 00:05:04,110
然后我们写下孩子的进程ID
到以前的.pid文件，该文件具有文件描述符

78
00:05:04,110 --> 00:05:05,410
3号。

79
00:05:05,410 --> 00:05:08,350
现在有趣的部分开始了，创建了一个新的套接字。

80
00:05:08,350 --> 00:05:13,020
套接字用于网络通信
你可以选择哪种插座

81
00:05:13,020 --> 00:05:15,870
希望使用这些标志和设置。

82
00:05:15,870 --> 00:05:21,190
但最重要的是要绑定的调用，
尝试将此进程绑定到

83
00:05:21,190 --> 00:05:23,620
端口2999。

84
00:05:23,620 --> 00:05:28,970
这意味着如果操作系统接收到
希望建立连接的数据包

85
00:05:28,970 --> 00:05:33,680
在这个过程中，它会这样做，然后
将包含数据的包转发到

86
00:05:33,680 --> 00:05:34,680
过程。

87
00:05:34,680 --> 00:05:40,070
但是！，此函数调用失败，因为
地址和端口已被另一个使用

88
00:05:40,070 --> 00:05:41,070
过程。

89
00:05:41,070 --> 00:05:44,840
这是有道理的，因为我们已经给net0打过电话了
方式较早。

90
00:05:44,840 --> 00:05:47,570
所以让我们再次终止这个过程，然后重试。
这个。

91
00:05:47,570 --> 00:05:48,570
可以！

92
00:05:48,570 --> 00:05:49,570
这看起来不错。

93
00:05:49,570 --> 00:05:53,940
现在我们收听我们打开的港口
等待接收到的数据包到达

94
00:05:53,940 --> 00:05:54,940
系统调用。

95
00:05:54,940 --> 00:06:00,120
所以我们打开第二个终端用
netstat查找此侦听过程。

96
00:06:00,120 --> 00:06:01,510
就在这里。

97
00:06:01,510 --> 00:06:05,460
在端口2999上，进程net0正在侦听。

98
00:06:05,460 --> 00:06:06,460
酷。

99
00:06:06,460 --> 00:06:10,580
现在让我们用netcat建立一个TCP
与此端口的连接。

100
00:06:10,580 --> 00:06:15,790
这将导致接受呼叫返回，
因为建立了新的连接。

101
00:06:15,790 --> 00:06:21,570
接受后立即看到另一个
调用克隆，这将创建另一个进程

102
00:06:21,570 --> 00:06:23,940
现在处理此服务器客户端连接。

103
00:06:23,940 --> 00:06:28,580
这样，另一个用户也可以建立
连接，不必等到

104
00:06:28,580 --> 00:06:33,010
你完成了，因为你现在拥有了自己的
专用流程。

105
00:06:33,010 --> 00:06:36,970
also accept返回了一个新的文件描述符
引用了这个套接字。

106
00:06:36,970 --> 00:06:43,320
就像现在可以执行的常规文件一样
用这个文件描述符读写，比如

107
00:06:43,320 --> 00:06:45,030
你可以用其他文件。

108
00:06:45,030 --> 00:06:51,890
下面的内核确保发送
作为TCP数据包写入客户端的数据。

109
00:06:51,890 --> 00:06:56,230
当它接收到数据时，它会确保
你可以从这个插座里读出来。

110
00:06:56,230 --> 00:07:01,800
所以现在它将改变标准输入，输出
错误流从/dev/null流到这个新的

111
00:07:01,800 --> 00:07:02,800
文件描述符。

112
00:07:02,800 --> 00:07:07,790
然后程序就可以从stdinput中读取
并读取您发送的数据。

113
00:07:07,790 --> 00:07:10,090
这就是run函数的作用。

114
00:07:10,090 --> 00:07:16,430
如果将运行与最后两个系统调用进行比较
我们先给stdout写信

115
00:07:16,430 --> 00:07:22,750
从这张照片，然后是一个来自
这就是我们现在的位置。

116
00:07:22,750 --> 00:07:28,180
当我们在netcat中输入一行时，netcat
将通过发送包含此文本的数据包

117
00:07:28,180 --> 00:07:30,810
网络到程序，服务器。

118
00:07:30,810 --> 00:07:35,920
在服务器端，您可以看到
读取您发送给它的字符串，然后读取

119
00:07:35,921 --> 00:07:38,591
写的东西告诉你
号码不对。

120
00:07:38,590 --> 00:07:41,890
这是run（）中失败的printf。

121
00:07:41,890 --> 00:07:45,000
那么让我们总结一下隐藏的代码
正在做。

122
00:07:45,000 --> 00:07:50,220
它首先通过克隆自身来失磁，然后
杀死父母，成为孤儿。

123
00:07:50,220 --> 00:07:54,580
然后它开始监听端口2999
TCP连接。

124
00:07:54,580 --> 00:07:59,430
一旦建立了联系，我们将
详细了解一下TCP协议

125
00:07:59,431 --> 00:08:06,401
另一次，它将创建
处理此已建立连接的过程。

126
00:08:06,400 --> 00:08:11,030
当家长再次准备接受时
另一个平行连接。

127
00:08:11,030 --> 00:08:16,430
处理连接的子进程
现在基本上只是调用run（）。

128
00:08:16,430 --> 00:08:22,010
所以简单地说，程序
作为执行的后台进程运行

129
00:08:22,010 --> 00:08:24,580
为每个连接到它的客户机运行（）。

130
00:08:24,580 --> 00:08:25,580
令人惊叹的！

131
00:08:25,580 --> 00:08:26,990
我们理解这一点。

132
00:08:26,990 --> 00:08:28,840
现在让我们来解决这个挑战。

133
00:08:28,840 --> 00:08:31,530
首先，我们需要得到字符串表示
那个数字。

134
00:08:31,530 --> 00:08:37,200
我们可以使用python，特别是
结构包-我们以前已经使用过。

135
00:08:37,200 --> 00:08:41,850
因此，使用struct.pack，我们可以转换一个数字
字节字符串表示。

136
00:08:41,849 --> 00:08:47,259
但正如您所看到的，结果字符串
使用我们可以用键盘输入的字符。

137
00:08:47,260 --> 00:08:53,200
我们可以用echo和
-E，但简单地将其导入NC不会

138
00:08:53,200 --> 00:08:55,080
因为这个数字是随机的。

139
00:08:55,080 --> 00:08:56,880
但我们可以使用一个简单的技巧。

140
00:08:56,880 --> 00:09:04,210
我们可以使用echo-e，但在引号内
我们用倒计时执行cat的减号，

141
00:09:04,210 --> 00:09:10,390
它只是将我们键入的任何内容重定向到
再次输出，然后放置输出

142
00:09:10,390 --> 00:09:12,160
在回音的引言中。

143
00:09:12,160 --> 00:09:18,420
所以当我们现在把它输入netcat时，我们看到
数字和cat正在等待输入，我们

144
00:09:18,420 --> 00:09:23,000
使用python转换数字，然后
我们只需将转义字符串粘贴回

145
00:09:23,000 --> 00:09:29,130
另一个终端，按Enter，然后使用
ctrl+d，表示我们已经完成了输入，

146
00:09:29,130 --> 00:09:32,650
关闭cat和echo将发送字符串
给NETCAT。

147
00:09:32,650 --> 00:09:35,830
这样我们就成功了"谢谢"
先生/女士留言。

