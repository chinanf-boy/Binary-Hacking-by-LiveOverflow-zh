1
00:00:00,280 --> 00:00:04,640
在本视频中，我们将从
exploit-exercises.com/protostar。

2
00:00:04,640 --> 00:00:10,470
这是堆利用的介绍
挑战很容易。

3
00:00:10,469 --> 00:00:17,129
我们再次在Ubuntu 16.04 LTS上编译这个
版本，所以基本上是一个现代系统，到

4
00:00:17,130 --> 00:00:20,120
看看它是否还是可以被利用的或者如何被利用的。

5
00:00:20,120 --> 00:00:24,630
剧透警报，没什么变化
挑战，这是超直的。

6
00:00:24,630 --> 00:00:29,230
但我对这个视频有一个特别的想法
即使对你来说有点容易，你也可以

7
00:00:29,230 --> 00:00:38,520
想结帐我们在
结束。

8
00:00:38,520 --> 00:00:43,410
在本系列之前的视频中，我通常
创造出一种方法

9
00:00:43,409 --> 00:00:45,909
如何向你解释和展示。

10
00:00:45,910 --> 00:00:50,980
但这太简单了，我以为会
如果我不记录自己的解决方法，那就冷静点。

11
00:00:50,980 --> 00:00:54,070
它，有点像盲解或快跑。

12
00:00:54,070 --> 00:00:58,540
但我没有试着超快，但它
非常直截了当，我包括了所有

13
00:00:58,539 --> 00:01:01,109
我犯的错误和停顿。

14
00:01:01,109 --> 00:01:04,969
现在我们将通过视频
我向你解释我的想法

15
00:01:04,970 --> 00:01:08,380
在不同的时刻指出
东西。

16
00:01:08,380 --> 00:01:12,520
在右上角，您还可以看到
记录时间的计时器

17
00:01:12,520 --> 00:01:14,400
实时带我去。

18
00:01:14,399 --> 00:01:17,789
但在我们开始利用之前，让我们
再次查看代码。

19
00:01:17,789 --> 00:01:21,259
有两个函数winner（）和nowinner（）。

20
00:01:21,259 --> 00:01:23,789
显然，我们必须以某种方式称之为winner（）。

21
00:01:23,789 --> 00:01:29,989
我们还可以看到有两个结构
在堆上为它们分配空间。

22
00:01:29,990 --> 00:01:34,860
这里的fp构造看起来很复杂，
但你可以忽略这种奇怪，因为

23
00:01:34,859 --> 00:01:38,059
当你看代码的时候，很明显什么
是的。

24
00:01:38,060 --> 00:01:40,500
我们将fp设置为nowinner。

25
00:01:40,500 --> 00:01:45,380
注意到现在内心没有妄想症，这
意思是没有人叫它。

26
00:01:45,380 --> 00:01:50,830
这实际上是函数指针，
添加parenthese会导致调用。

27
00:01:50,829 --> 00:01:54,579
然后我们就有了这些副座
对于FP。

28
00:01:54,579 --> 00:02:00,229
FP被设置为指向nowinner，
所以nowinner被执行（）。

29
00:02:00,229 --> 00:02:05,179
我们的目标是以某种方式使用strcpy，
它将溢出名称缓冲区，

30
00:02:05,179 --> 00:02:09,699
只有64字节大并覆盖函数
指针。

31
00:02:09,700 --> 00:02:12,310
听起来很简单。

32
00:02:12,310 --> 00:02:15,010
我首先打开gdb中的二进制文件。

33
00:02:15,010 --> 00:02:21,310
并执行第一次测试，但我遇到
一个让我吃惊了几秒钟的断层，

34
00:02:21,310 --> 00:02:25,010
但后来我意识到我忘记了争论
再次输入参数。

35
00:02:25,010 --> 00:02:29,010
strcpy使用第一个参数来复制
化名。

36
00:02:29,010 --> 00:02:32,080
好吧，现在我们干净利落地处决了。

37
00:02:32,080 --> 00:02:35,720
现在我想设置一个好的断点，这样我就可以分解
主要的。

38
00:02:35,720 --> 00:02:39,910
我正在快速扫描汇编程序代码
这里，主要看不同的功能

39
00:02:39,910 --> 00:02:43,890
调用以确定与什么对应
在C代码中。

40
00:02:43,890 --> 00:02:49,490
起初我在考虑设置
strcpy之前或之后的断点，到

41
00:02:49,490 --> 00:02:55,030
抓住溢出前后，
但在最后一刻，我发现

42
00:02:55,030 --> 00:03:00,370
可能不需要仔细看，
我可以直接进入魔法状态

43
00:03:00,370 --> 00:03:01,370
马上。

44
00:03:01,370 --> 00:03:03,370
呼叫RDX。

45
00:03:03,370 --> 00:03:07,050
这将调用函数指针，
包含nowinner（）。

46
00:03:07,050 --> 00:03:11,490
好的，所以我再次执行它，我们到达了断点。

47
00:03:11,489 --> 00:03:15,879
现在的挑战是堆溢出，
所以我首先检查了

48
00:03:15,879 --> 00:03:18,149
使用vmmap的进程。

49
00:03:18,150 --> 00:03:22,520
在这里你可以看到我们的记忆区域
使二进制文件本身具有代码和数据

50
00:03:22,520 --> 00:03:27,150
段，我们还可以看到堆栈的位置
像libc这样的共享库在哪里？

51
00:03:27,150 --> 00:03:30,580
也加载了，这里还有堆。

52
00:03:30,580 --> 00:03:34,370
所以很明显我想看看
看起来像。

53
00:03:34,370 --> 00:03:38,050
从开始检查32个64位十六进制值
堆的。

54
00:03:38,050 --> 00:03:43,900
我马上找我们输入的名字
作为一个论点，这是“aaaa”，所以这里

55
00:03:43,900 --> 00:03:44,900
他们是。

56
00:03:44,900 --> 00:03:47,910
我也会立即查找函数
指针。

57
00:03:47,909 --> 00:03:50,039
这像是地址。

58
00:03:50,040 --> 00:03:53,180
使用disassemble命令快速进行健全性检查。

59
00:03:53,180 --> 00:03:58,100
这是一个使用这个地址的看跌期权
一个paremter，这就是我们现在的内部字符串。

60
00:03:58,099 --> 00:04:00,439
所以是的，这就是现在的内在。

61
00:04:00,439 --> 00:04:04,639
所以现在我们想用winner覆盖它，
所以我们需要那个地址。

62
00:04:04,640 --> 00:04:06,220
在这里。

63
00:04:06,219 --> 00:04:10,839
下一步我要弄清楚我们有多少
为了溢出，为了做到这一点，我只需看看

64
00:04:10,840 --> 00:04:13,280
地址在左边。

65
00:04:13,280 --> 00:04:20,680
名称起始地址以0x10结尾，
函数指针为ATH 0x60。

66
00:04:20,680 --> 00:04:23,710
所以我们有一个0x50的偏移量。

67
00:04:23,710 --> 00:04:28,220
所以现在我有信心
退出gdb，希望有工作

68
00:04:28,220 --> 00:04:30,080
立即利用。

69
00:04:30,080 --> 00:04:34,550
所以我从编写一个简短的python内联开始
用于打印漏洞攻击字符串的脚本。

70
00:04:34,550 --> 00:04:39,520
基本上我们需要几个角色
作为到达函数指针和

71
00:04:39,520 --> 00:04:41,520
所以我打印了一些。

72
00:04:41,520 --> 00:04:47,690
再次快速检查有多少个，0x60-0x10
所以我们需要0x50。

73
00:04:47,690 --> 00:04:50,240
之后我们需要获胜者的地址。

74
00:04:50,240 --> 00:04:52,610
所以0x40，哎呀！

75
00:04:52,610 --> 00:04:56,620
几乎犯了一个错误-这种情况发生了
对我来说，很明显我们必须开始

76
00:04:56,620 --> 00:05:00,290
使用0xF6、0x05，然后是0x40。

77
00:05:00,290 --> 00:05:01,980
因为有大麻。

78
00:05:01,979 --> 00:05:06,789
现在，为了使第一步管道正常运行和调试
输出到hexdump中查看它是否是

79
00:05:06,790 --> 00:05:07,890
我期待。

80
00:05:07,889 --> 00:05:13,039
但我注意到末尾有一个0x0A，这是
换行符

81
00:05:13,040 --> 00:05:16,950
python print将在末尾添加新行
我们不想要。

82
00:05:16,949 --> 00:05:22,069
所以现在我把脚本改成使用sys
模块而不是直接写入

83
00:05:22,069 --> 00:05:25,429
一个字符串到stdout，所以我们没有换行符。

84
00:05:25,430 --> 00:05:29,570
我用hexdump再次验证了这一点。

85
00:05:29,569 --> 00:05:35,809
然后我基本上完成了，试着穿上它
目标二进制文件。

86
00:05:35,810 --> 00:05:43,730
所以输入作为参数传递，所以我使用
执行内部python命令的倒计时，

87
00:05:43,729 --> 00:05:49,479
然后输出基本上被替换
放在这里作为论据。

88
00:05:49,479 --> 00:05:50,659
平地通过！

89
00:05:50,660 --> 00:05:51,660
令人惊叹的！

90
00:05:51,660 --> 00:05:54,480
我执行了winner函数（）。

91
00:05:54,479 --> 00:05:57,049
你看这太简单了。

92
00:05:57,050 --> 00:06:01,550
所以当我用
评论我的录音，我注意到一个小

93
00:06:01,550 --> 00:06:03,890
我没想到的细节。

94
00:06:03,889 --> 00:06:06,239
我以前从来没有想过。

95
00:06:06,240 --> 00:06:08,510
这里是堆输出。

96
00:06:08,509 --> 00:06:10,449
你看到下面的数据了吗？

97
00:06:10,449 --> 00:06:12,079
这显然是ASCII码。

98
00:06:12,080 --> 00:06:17,520
这很奇怪，在我们的计划中我们做到了
不要在堆上分配这样的字符串。

99
00:06:17,520 --> 00:06:19,260
这是怎么发生的？

100
00:06:19,259 --> 00:06:24,629
当你看到这个ASCII文本时，你
会意识到它实际上是printf输出。

101
00:06:24,630 --> 00:06:26,270
但为什么会这样？

102
00:06:26,270 --> 00:06:28,090
让我们调查一下。

103
00:06:28,090 --> 00:06:31,300
首先，我想我们可以去看看瓦尔格林。

104
00:06:31,300 --> 00:06:35,120
Valgrind是
构建动态分析工具。

105
00:06:35,120 --> 00:06:39,540
有Valgrind工具可以自动
检测许多内存管理和线程

106
00:06:39,540 --> 00:06:41,770
错误，并详细介绍您的程序。

107
00:06:41,770 --> 00:06:45,750
我真的应该更经常地使用Valgrind，我
用它的方式来小。

108
00:06:45,750 --> 00:06:50,470
但这里是Valgrind输出
启用跟踪mallocs。

109
00:06:50,470 --> 00:06:52,660
然后我们运行heap0级别。

110
00:06:52,660 --> 00:06:58,160
我们真的可以在这里看到我们的两个malloc
我们做的结构，也是一个malloc我们

111
00:06:58,160 --> 00:07:00,440
不是1024年的事。

112
00:07:00,440 --> 00:07:04,140
这也是唯一被释放的内存
再一次。

113
00:07:04,139 --> 00:07:06,659
我们没有自由的马洛克人。

114
00:07:06,660 --> 00:07:08,780
为什么会这样？

115
00:07:08,780 --> 00:07:11,400
另一个有趣的输出是strace。

116
00:07:11,400 --> 00:07:13,280
strace跟踪系统调用。

117
00:07:13,280 --> 00:07:18,340
虽然我们在这里看不到Mallocs，因为
malloc只是一些算法和内存管理

118
00:07:18,340 --> 00:07:24,740
在libc中实现，我们可以看到brk系统调用，
从操作系统获取内存

119
00:07:24,740 --> 00:07:26,190
首先。

120
00:07:26,190 --> 00:07:30,750
所以这就是我们获得记忆的地方
由libc用于堆。

121
00:07:30,750 --> 00:07:36,590
所以如果malloc是libc函数，我们也可以
签出LTrace，跟踪链接的动态

122
00:07:36,590 --> 00:07:38,430
库函数调用。

123
00:07:38,430 --> 00:07:42,740
但奇怪的是，我们只看到两个malloc
这两个结构。

124
00:07:42,740 --> 00:07:45,610
关于神秘的第三个malloc什么都没有。

125
00:07:45,610 --> 00:07:50,100
可能不是很明显，但是
实际上已经是一个很好的提示

126
00:07:50,099 --> 00:07:55,399
神秘的malloc不是从
动态链接的库调用。

127
00:07:55,400 --> 00:08:00,520
也就是说，这个malloc肯定已经被执行了
例如由libc本身。

128
00:08:00,520 --> 00:08:05,910
Valgrind更聪明，也更能追踪
这些内部的malloc。

129
00:08:05,909 --> 00:08:11,759
对于第三个测试，我创建了一个简单的程序
那个调用输入，所以它打印一个字符串。

130
00:08:11,760 --> 00:08:16,490
因为我们知道堆确实包含printf
输出，因此它必须与

131
00:08:16,490 --> 00:08:17,540
那。

132
00:08:17,539 --> 00:08:22,199
然后我们可以调试程序并设置
BRK上的断点。

133
00:08:22,199 --> 00:08:26,389
记住，brk是调用的syscall
当程序请求附加虚拟

134
00:08:26,389 --> 00:08:30,049
内存，所以当堆
成立。

135
00:08:30,050 --> 00:08:33,640
堆并不总是设置的，只有在
这是必需的。

136
00:08:33,640 --> 00:08:40,250
所以如果我们假设printf或puts调用malloc，
它必须首先设置堆。

137
00:08:40,250 --> 00:08:44,630
这也是为什么我创造了这个小
测试程序，因为原始堆0

138
00:08:44,630 --> 00:08:49,380
显然，在打印前有规则的malloc，
这让它有点烦人，所以这是

139
00:08:49,380 --> 00:08:51,280
一个干净的例子。

140
00:08:51,280 --> 00:08:56,760
在第二个注释中，当您设置断点时
符号名如brk，必须

141
00:08:56,760 --> 00:08:58,300
成为它的符号名。

142
00:08:58,300 --> 00:09:01,070
系统调用没有符号名。

143
00:09:01,070 --> 00:09:05,900
系统调用是一个Asembler Interrup指令
用一个数字作为参数来表示

144
00:09:05,900 --> 00:09:08,460
你想要的系统调用。

145
00:09:08,460 --> 00:09:12,310
但是有一个BRK符号，但不是
最初发现。

146
00:09:12,310 --> 00:09:17,560
你首先必须按顺序执行程序
加载动态库libc，

147
00:09:17,560 --> 00:09:19,840
包含BRK符号。

148
00:09:19,840 --> 00:09:25,400
它是作为
包装BRK系统调用。

149
00:09:25,400 --> 00:09:30,580
所以libc里面的任何东西都不会直接
执行系统调用中断，它将调用

150
00:09:30,580 --> 00:09:32,780
内部BRK功能。

151
00:09:32,780 --> 00:09:37,070
所以我们可以轻松地设置断点
这样地。

152
00:09:37,070 --> 00:09:41,460
长话短说，我们现在可以继续打
然后检查函数

153
00:09:41,460 --> 00:09:47,420
回溯，它告诉我们哪些函数
被称为导致这个BRK呼叫。

154
00:09:47,420 --> 00:09:49,480
我会清理一下。

155
00:09:49,480 --> 00:09:50,480
我们走吧。

156
00:09:50,480 --> 00:09:53,500
正如你所看到的，它从输入输出开始。

157
00:09:53,500 --> 00:09:58,210
您也可以查看libc代码
东西，我刚刚打开了一个Libc的镜子

158
00:09:58,210 --> 00:10:01,410
在Github上，您可以在那里读取代码。

159
00:10:01,410 --> 00:10:06,290
不调用函数的原因
但是，即使我们只使用

160
00:10:06,290 --> 00:10:10,990
我们称之为“投入”，这与很多事情有关。
libc中的c宏。

161
00:10:10,990 --> 00:10:13,860
我发现读这段代码真的很困难。

162
00:10:13,860 --> 00:10:20,520
例如，我们知道下一个函数
具有符号名称“IO”新文件“Xspun”，但

163
00:10:20,520 --> 00:10:22,770
这不会出现在C代码中。

164
00:10:22,770 --> 00:10:29,060
但有一个类似的名字叫“IO-SPUTN”，
当你向上看的时候，会得到一个宏

165
00:10:29,060 --> 00:10:32,530
也就是说它实际上是输入。

166
00:10:32,530 --> 00:10:39,660
它本身就是另一个宏Jump2
以\uxspun作为第一个参数，以及

167
00:10:39,660 --> 00:10:41,530
Jump2显然是另一个宏。

168
00:10:41,530 --> 00:10:43,750
就这样继续下去。

169
00:10:43,750 --> 00:10:45,510
你可以自己做。

170
00:10:45,510 --> 00:10:50,610
但如果我们相信我们的踪迹，我们就能看到
在某种程度上，它称之为doallocbuffer。

171
00:10:50,610 --> 00:10:54,780
还有一条评论说：“分配
如果需要，提供一个缓冲区”。

172
00:10:54,780 --> 00:11:00,690
所以这个1024字节的malloc与
标准输出缓冲器。

173
00:11:00,690 --> 00:11:06,460
printf不会立即导致
但是libc实现了很多

174
00:11:06,460 --> 00:11:11,750
为了达到更高的目标
通过缓冲输出而不是

175
00:11:11,750 --> 00:11:16,950
等待文件，或者写一些更大的文件
大块而不是很多小块。

176
00:11:16,950 --> 00:11:17,950
是啊。

177
00:11:17,950 --> 00:11:20,750
我认为这是一个已解开的谜。

178
00:11:20,750 --> 00:11:23,750
只是稍微深入到内部工作
程序。

179
00:11:23,750 --> 00:11:25,230
希望你喜欢。

180
00:11:25,230 --> 00:11:25,730
下周见。

