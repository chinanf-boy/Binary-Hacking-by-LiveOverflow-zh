1
00:00:00,149 --> 00:00:04,749
上一个视频我们，看了 free() 的 dlmalloc实现。

2
00:00:04,750 --> 00:00:10,030
我们发现了 unlink() 宏，可以用来将几乎任意的数据写入

3
00:00:10,030 --> 00:00:11,420
另一个地址。

4
00:00:11,419 --> 00:00:16,779
我们用gdb构造了一个堆的实践，

5
00:00:16,779 --> 00:00:18,399
并观察到了，一个对全局偏移表的成功写入。

6
00:00:18,400 --> 00:00:24,300
但最终我们意识到，我们的计划行不通，因为它包含了太多

7
00:00:24,300 --> 00:00:30,510
null字节，我们不能用strcpy编写这些字节。

8
00:00:30,510 --> 00:00:38,880
让我们快速回顾和总结一下，我们对堆和free 算法的了解，

9
00:00:38,880 --> 00:00:41,040
完善我们的开发计划。

10
00:00:41,040 --> 00:00:47,090
上一视频更具探索性，让你可以自己发现漏洞。

11
00:00:47,090 --> 00:00:50,520
但这段视频更像是一个演示。

12
00:00:50,520 --> 00:00:55,570
这样，我们就有了关于同一主题，不同风格的视频，

13
00:00:55,570 --> 00:00:58,580
我希望能增加，了解它工作原理的人数。

14
00:00:58,580 --> 00:01:01,620
我们再来看看堆区块的样子。

15
00:01:01,620 --> 00:01:05,780
当您分配某大小的块时，

16
00:01:05,780 --> 00:01:09,560
该块的大小将写入第二个字，和 malloc将在这里返回地址。

17
00:01:09,560 --> 00:01:13,190
意味着，您拥有了用户数据的区域。

18
00:01:13,190 --> 00:01:17,000
块大小的最后一位，具有特殊意义。

19
00:01:17,000 --> 00:01:21,270
最重要的是，最后一位，是前一个是否正在使用的描述。

20
00:01:21,270 --> 00:01:24,160
这是关于当前块，前面的块信息。

21
00:01:24,159 --> 00:01:27,139
所以在开始的时候，把头包起来有点奇怪。

22
00:01:27,140 --> 00:01:31,660
这意味着，如果这分配了第一个块，

23
00:01:31,659 --> 00:01:33,039
那么后面的块，将具有最后一个设置位。

24
00:01:33,040 --> 00:01:35,640
因为，它前面的块，正在使用中。

25
00:01:35,640 --> 00:01:38,790
现在，一个空闲块可以包含更多信息。

26
00:01:38,790 --> 00:01:44,310
所以，一旦我们释放了这个块，很明显我们可以

27
00:01:44,310 --> 00:01:45,310
将块的最后一位设置为0。

28
00:01:45,310 --> 00:01:47,760
以指示上一块不再使用。

29
00:01:47,760 --> 00:01:50,430
现在，假设有第三块。

30
00:01:50,430 --> 00:01:55,120
第二个块之后的块，它的最后位没有设置。

31
00:01:55,120 --> 00:01:57,380
这意味着，第二个块是空闲的。

32
00:01:57,380 --> 00:02:01,480
现在，算法要合并，合并这两个块。

33
00:02:01,479 --> 00:02:04,799
这就是 size 后的两个词，开始变得重要的地方。

34
00:02:04,800 --> 00:02:07,730
它们其实是向前和向后的指针。

35
00:02:07,730 --> 00:02:12,990
正如旁注，只适用于，大于fastbin大小的块。

36
00:02:12,989 --> 00:02:16,349
因为，FastBins是非常小的块，它们不使用双链表。

37
00:02:16,349 --> 00:02:17,879
所以，我们的块更大。

38
00:02:17,879 --> 00:02:20,139
让我们考虑一下，这个堆设置。

39
00:02:20,140 --> 00:02:24,530
我们有一个要释放的块，后面跟着一个已经释放的块。

40
00:02:24,530 --> 00:02:29,240
这个空闲块有两个指针，向前和向后(指针)指向另一个空闲块

41
00:02:29,239 --> 00:02:30,239
块。

42
00:02:30,239 --> 00:02:32,139
所以，它们在这个双链表中。

43
00:02:32,140 --> 00:02:37,130
现在会发生的是，free 算法将这两个块合并在一起。

44
00:02:37,129 --> 00:02:42,059
它将首先用“unlink”宏，从链表中断开空闲块。

45
00:02:42,060 --> 00:02:43,080
宏。

46
00:02:43,080 --> 00:02:47,780
我们学过了它所做的，它拿起向前指针的地址，

47
00:02:47,780 --> 00:02:50,350
写入前一个块的向前指针。

48
00:02:50,349 --> 00:02:55,109
再把向后指针的地址，写入

49
00:02:55,109 --> 00:02:56,109
下一个块的向后指针。

50
00:02:56,109 --> 00:03:00,739
当我们明确控制了一个空闲块的指针，它将被断链，

51
00:03:00,739 --> 00:03:06,549
我们可以指向GOT，并在其中写入向前地址。

52
00:03:06,549 --> 00:03:10,339
在上一段视频中，我们停在这里，没有查看接下来会发生什么。

53
00:03:10,340 --> 00:03:11,740
但，我现在告诉你。

54
00:03:11,739 --> 00:03:17,019
接下来，我们用已经空闲块的size，

55
00:03:17,019 --> 00:03:18,209
增加我们正要释放的块大小。

56
00:03:18,209 --> 00:03:21,719
然之后，我们将这个块插入到双链表中。

57
00:03:21,719 --> 00:03:24,469
这意味着，我们取了一块，并查找它的前一个块。

58
00:03:24,469 --> 00:03:28,789
然后，我们更新相应的指针，让其现在包含块。

59
00:03:28,790 --> 00:03:30,480
这就是堆的全部魔力。

60
00:03:30,480 --> 00:03:36,350
现在让我们回到，著名的短语文章“Once upon a free”和“Vudo malloc 诡计“

61
00:03:36,349 --> 00:03:40,059
看看他们，告诉我们关于 unlink 的漏洞。

62
00:03:40,060 --> 00:03:45,270
这两篇文章，都包含一个很酷的小技巧，来克服null字节的限制。

63
00:03:45,269 --> 00:03:49,829
因此，当我们想要构造一个可以 unlink 的假块时，

64
00:03:49,829 --> 00:03:52,569
我们要确保任何字段，都不包含null字节。

65
00:03:52,569 --> 00:03:56,799
这意味着，我们必须对大小使用非常大的值。

66
00:03:56,799 --> 00:04:00,219
但这似乎没用，因为堆没那么大。

67
00:04:00,219 --> 00:04:01,239
呃

68
00:04:01,239 --> 00:04:06,879
但是在文章中展示的聪明做法是，

69
00:04:06,879 --> 00:04:08,039
让计算机处理负值。

70
00:04:08,040 --> 00:04:12,950
因此，让我们快速探索32位整数值，会发生什么，

71
00:04:12,950 --> 00:04:14,390
当我们添加一个很好的数。

72
00:04:14,390 --> 00:04:17,260
例如，fffffffc。

73
00:04:17,260 --> 00:04:19,320
那将超过40亿。

74
00:04:19,319 --> 00:04:25,739
现在，当你加上0x64时，会发生什么，它是十进制的 100 加到40亿上？

75
00:04:25,740 --> 00:04:27,610
这不适合32位。

76
00:04:27,610 --> 00:04:29,950
加在一起的东西，会丢失。

77
00:04:29,949 --> 00:04:33,039
现在，你又有了一个非常小的值。

78
00:04:33,040 --> 00:04:35,270
事实上，它是0x60。

79
00:04:35,270 --> 00:04:38,150
比 0x64 小 4。

80
00:04:38,150 --> 00:04:47,050
这意味着，加上40亿，ffffffc加100，我们实际上，剩下4。

81
00:04:47,050 --> 00:04:49,730
这对我们来说，是非常有用的行为。

82
00:04:49,729 --> 00:04:55,329
因为这个不包含任何null字节的值，它的行为类似一个非常小的减法。

83
00:04:55,330 --> 00:04:59,630
所以，当我们再次浏览源代码时，我们现在可以制定一个计划。

84
00:04:59,629 --> 00:05:03,439
首先，我们必须用一个溢出块大小的值，

85
00:05:03,440 --> 00:05:04,440
大于80。

86
00:05:04,440 --> 00:05:07,850
所以让我们像上一个视频一样使用100。

87
00:05:07,850 --> 00:05:11,890
但是，我们也不关心前一块的合并尝试

88
00:05:11,889 --> 00:05:12,889
块。

89
00:05:12,889 --> 00:05:15,009
这样，我们就不必设置另一个假块。

90
00:05:15,009 --> 00:05:19,509
所以，我们要确保我们要释放的块的，最后一个位设置为1。

91
00:05:19,509 --> 00:05:21,479
所以，它还在使用中。

92
00:05:21,479 --> 00:05:24,839
但，我们可以合并向前部分。

93
00:05:24,840 --> 00:05:29,070
在这里，我们拿起下一个块，检查它的下一个块的前in_use位，

94
00:05:29,070 --> 00:05:32,370
如果没有设置，我们将尝试 unlink，合并该块。

95
00:05:32,370 --> 00:05:37,470
这意味着，我们需要两个假块，一个包含向前和向后指针，

96
00:05:37,470 --> 00:05:41,570
用堆中的地址覆盖got。

97
00:05:41,569 --> 00:05:46,829
第二个块，必须有一个最低位设置为0的size。

98
00:05:46,830 --> 00:05:50,050
但,我们不能使用小尺寸的值。

99
00:05:50,050 --> 00:05:54,720
但是，如果您在代码中，查看 size 是如何使用的，它只是用作一个偏移量，

100
00:05:54,720 --> 00:05:55,910
添加到一个地址。

101
00:05:55,910 --> 00:05:59,360
代码并没有检查，它是否是一个荒谬的超大块。

102
00:05:59,360 --> 00:06:01,310
它只是增加了这个值。

103
00:06:01,310 --> 00:06:03,130
这就是诡计发挥的地方。

104
00:06:03,130 --> 00:06:09,500
我们可以使用 fffffc 作为块的大小，结果是-4。

105
00:06:09,500 --> 00:06:11,220
现在，想想会发生什么。

106
00:06:11,219 --> 00:06:15,429
它将占用该块的 size，并将其添加到当前地址，以查找下一个块，

107
00:06:15,430 --> 00:06:20,290
愚弄 free ，让它认为下一个块在这里的 -4。

108
00:06:20,289 --> 00:06:26,309
现在，它将读取该块的大小，我们也可以将其设置为 fffffffc，

109
00:06:26,310 --> 00:06:31,580
不会设置最后一个位并断定，之前块没有使用，。

110
00:06:31,580 --> 00:06:32,580
所以让我们 unlink它吧。

111
00:06:32,580 --> 00:06:33,580
爆炸！

112
00:06:33,580 --> 00:06:35,330
漂亮，聪明的手段。

113
00:06:35,330 --> 00:06:37,200
并且，不包含任何null字节。

114
00:06:37,199 --> 00:06:43,029
那么，让我们看看我们是否可以用strcpy，来填充这个堆。

115
00:06:43,030 --> 00:06:45,540
所以，strcpy 在一个null字节处 停止。

116
00:06:45,539 --> 00:06:49,849
这意味着，我们必须使用其中一个 strcpy，来溢出我们想要释放的块大小。

117
00:06:49,850 --> 00:06:51,710
100，0x64。

118
00:06:51,710 --> 00:06:58,020
嗯… 显然，我们想要前块的设置位，所以，我们需要用0x65溢出它。

119
00:06:58,020 --> 00:07:03,160
有效，因为我们不想写更多，它以一个null字节结束，

120
00:07:03,159 --> 00:07:05,039
并且保持 size 干净。

121
00:07:05,039 --> 00:07:09,239
另一个 strcpy 可以用来填充100字节，直到奇怪的，假的，连体块

122
00:07:09,240 --> 00:07:14,270
ffffc，之后，就是我们要写的两个地址。

123
00:07:14,270 --> 00:07:19,330
现在，就像在上一个视频中一样，我们将把一个地址设置为全局偏移表，

124
00:07:19,330 --> 00:07:24,530
这样我们就覆盖了puts，而另一个，将指向第一个堆。

125
00:07:24,530 --> 00:07:28,630
这意味着，我们将把代码执行重定向到这个堆地址，

126
00:07:28,629 --> 00:07:31,609
并且可以使用第一个strcpy，在这里放置一些shellcode。

127
00:07:31,610 --> 00:07:35,760
请记住，unlink 也会将一些数据，从全局偏移表写入这堆区域，

128
00:07:35,759 --> 00:07:40,989
所以我们要么保持 shellcode 简短，

129
00:07:40,990 --> 00:07:43,710
要么跳过粉碎的，之后继续 shellcode。

130
00:07:43,710 --> 00:07:45,460
但我们只想调用 winner。

131
00:07:45,460 --> 00:07:48,960
那么让我们来构建这个漏洞。

132
00:07:48,960 --> 00:07:53,360
你可以一行搞定，但让我把它拆开，让它更容易。

133
00:07:53,360 --> 00:07:59,070
这些窗口中，我们将为每个strcpy，构造一个参数和一个字符串。

134
00:07:59,069 --> 00:08:04,459
所以，也许我们先来处理中间块的strcpy，

135
00:08:04,460 --> 00:08:09,510
因为它应该是，被第三个块的101覆盖的。

136
00:08:09,509 --> 00:08:14,239
我用 echo 来表示，我计算了触碰到块 size 的字符数，

137
00:08:14,240 --> 00:08:17,730
然后，我们在这里写101，0x65。

138
00:08:17,729 --> 00:08:22,949
我将输出重定向到一个文件B中，然后，我们可以将它，带上 backticks和cat一起，

139
00:08:22,949 --> 00:08:25,179
用作 gdb中的参数。

140
00:08:25,180 --> 00:08:28,580
然后，我们可以运行它，并调查堆。

141
00:08:28,580 --> 00:08:32,700
看起来很完美，第三个块的大小现在是 0x65。

142
00:08:32,700 --> 00:08:38,170
接下来，我们来处理第三个块，它现在是溢出之后，

143
00:08:38,170 --> 00:08:39,390
所以是，100字节大。

144
00:08:39,390 --> 00:08:44,090
所以，我们想写100个字符来填充块，

145
00:08:44,090 --> 00:08:50,250
然后最终到达下一块，这里我们用前面的技巧 fffffc 写入，

146
00:08:50,250 --> 00:08:54,380
后面是全局偏移表地址，和堆地址。

147
00:08:54,380 --> 00:08:58,090
这里我得到了 puts 的表地址，并从中减去-12。

148
00:08:58,090 --> 00:09:01,540
因为堆地址写成 +12。

149
00:09:01,540 --> 00:09:06,760
然后，是最后一个strcpy，第一个块，我们想在其中，包含shellcode

150
00:09:06,760 --> 00:09:07,920
调用winner 。

151
00:09:07,920 --> 00:09:11,450
我很快在谷歌上，搜索了一个在线汇编程序，来创建shellcode。

152
00:09:11,450 --> 00:09:16,200
我们要调用一个绝对地址，要做到这一点，我们必须通过一个寄存器。

153
00:09:16,200 --> 00:09:22,140
所以，我们可以把 winner 的地址移到eax中，然后调用eax。

154
00:09:22,140 --> 00:09:27,380
我们可以简单复制这个shellcode的字符串表示形式，

155
00:09:27,380 --> 00:09:28,850
并将其写入文件A。

156
00:09:28,850 --> 00:09:30,330
酷。

157
00:09:30,330 --> 00:09:33,450
既然我们有了所有的三个参数，就可以重新运行程序了。

158
00:09:33,450 --> 00:09:34,590
让我们来看看堆。

159
00:09:34,590 --> 00:09:35,590
看起来不错。

160
00:09:35,590 --> 00:09:37,920
让我们执行 free ，并单步进到 puts调用中。

161
00:09:37,920 --> 00:09:39,090
哦。

162
00:09:39,090 --> 00:09:42,810
太好了，我们继续往下看，但不知何故，我们的 shellcode 是错误的。

163
00:09:42,810 --> 00:09:45,580
你可以看到它完全是垃圾。

164
00:09:45,580 --> 00:09:48,710
这里没有我们的 shellcode ，而是有一些地址。

165
00:09:48,710 --> 00:09:49,710
哎哟！

166
00:09:49,710 --> 00:09:53,300
当然，我们执行多个 free，而不仅仅是一个。

167
00:09:53,300 --> 00:09:56,790
所以，我们显然是在这些值上写元数据的。

168
00:09:56,790 --> 00:10:00,560
但，我们可以简单解决这个问题，通过指向堆的不同区域。

169
00:10:00,560 --> 00:10:02,600
14，怎么样？

170
00:10:02,600 --> 00:10:07,080
现在我们更改地址，并在 shellcode 前面加上一些字符。然后再试一次。

171
00:10:07,080 --> 00:10:12,480
我们一路运行，步进到 puts，最终获得 winner。

172
00:10:12,480 --> 00:10:13,480
哈哈哈。

173
00:10:13,480 --> 00:10:17,530
让我们在没有gdb的情况下，试试吧！

174
00:10:17,530 --> 00:10:18,530
它奏效了。

175
00:10:18,530 --> 00:10:19,950
天哪，我喜欢这个！

