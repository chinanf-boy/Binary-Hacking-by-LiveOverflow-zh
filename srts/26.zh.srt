1
00:00:00,149 --> 00:00:04,749
上一个视频我们看了dlmalloc的实现
的（）

2
00:00:04,750 --> 00:00:10,030
我们发现unlink（）宏可以
用于将几乎任意的数据写入

3
00:00:10,030 --> 00:00:11,420
另一个地址。

4
00:00:11,419 --> 00:00:16,779
我们用
并观察到成功写入

5
00:00:16,779 --> 00:00:18,399
全局偏移表。

6
00:00:18,400 --> 00:00:24,300
但最终我们意识到，我们的计划
不起作用，因为里面太多了

7
00:00:24,300 --> 00:00:30,510
空字节，我们不能用
斯特里皮

8
00:00:30,510 --> 00:00:38,880
让我们快速回顾和总结一下
了解堆和自由算法

9
00:00:38,880 --> 00:00:41,040
完善我们的开发计划。

10
00:00:41,040 --> 00:00:47,090
最后一段视频更具探索性，
你以及你如何发现这一漏洞

11
00:00:47,090 --> 00:00:50,520
你自己，但这段视频更像是
演示。

12
00:00:50,520 --> 00:00:55,570
这样我们就有了不同风格的视频
关于同一主题，我希望增加

13
00:00:55,570 --> 00:00:58,580
了解它的人数
作品。

14
00:00:58,580 --> 00:01:01,620
我们再来看看堆块
看起来像。

15
00:01:01,620 --> 00:01:05,780
当您分配一个特定大小的块时，
块的大小将写入

16
00:01:05,780 --> 00:01:09,560
第二个字和malloc将返回地址
在这里。

17
00:01:09,560 --> 00:01:13,190
这意味着您有这个用户数据区域。

18
00:01:13,190 --> 00:01:17,000
块大小的最后一位具有特殊的
意义。

19
00:01:17,000 --> 00:01:21,270
最重要的是最后一位是前一位
在使用位。

20
00:01:21,270 --> 00:01:24,160
这是以前关于块的信息
当前块。

21
00:01:24,159 --> 00:01:27,139
所以把你的
在开始的时候绕过去。

22
00:01:27,140 --> 00:01:31,660
这意味着如果在这里分配了这个块，
病房后面的街区是最后一个

23
00:01:31,659 --> 00:01:33,039
位集。

24
00:01:33,040 --> 00:01:35,640
因为它前面的块正在使用中。

25
00:01:35,640 --> 00:01:38,790
现在，一个自由块可以包含更多信息。

26
00:01:38,790 --> 00:01:44,310
所以一旦我们释放了这一块，我们显然可以
将块的最后一位设置为

27
00:01:44,310 --> 00:01:45,310
0.

28
00:01:45,310 --> 00:01:47,760
以指示上一个块不是
在使用中。

29
00:01:47,760 --> 00:01:50,430
现在假设有第三块。

30
00:01:50,430 --> 00:01:55,120
第二块后面有一块
上一个使用中的位未设置。

31
00:01:55,120 --> 00:01:57,380
这意味着第二个块是空闲的。

32
00:01:57,380 --> 00:02:01,480
现在算法要合并，合并
那两个街区。

33
00:02:01,479 --> 00:02:04,799
这是大小后面的两个字
开始变得重要。

34
00:02:04,800 --> 00:02:07,730
它们是向前和向后的指针。

35
00:02:07,730 --> 00:02:12,990
就像旁注一样，这只适用于块
比快仓大。

36
00:02:12,989 --> 00:02:16,349
因为FastBins是非常小的块
他们不使用双链接列表。

37
00:02:16,349 --> 00:02:17,879
所以我们的块更大。

38
00:02:17,879 --> 00:02:20,139
让我们考虑一下这个堆设置。

39
00:02:20,140 --> 00:02:24,530
我们有一块我们想要释放的，那就是
然后是一个已经空闲的块。

40
00:02:24,530 --> 00:02:29,240
自由块有两个指针，向前
向后指另一个自由

41
00:02:29,239 --> 00:02:30,239
块。

42
00:02:30,239 --> 00:02:32,139
所以它们在这个双链表中。

43
00:02:32,140 --> 00:02:37,130
现在会发生的是，自由算法
将这两个块合并在一起。

44
00:02:37,129 --> 00:02:42,059
它会先解除自由链接
使用"取消链接"从链接列表中阻止

45
00:02:42,060 --> 00:02:43,080
宏。

46
00:02:43,080 --> 00:02:47,780
我们学会了它的作用，它需要
转发地址并将其写入

47
00:02:47,780 --> 00:02:50,350
前一块的前向指针。

48
00:02:50,349 --> 00:02:55,109
它将采用反向地址
把它写在

49
00:02:55,109 --> 00:02:56,109
下一个块。

50
00:02:56,109 --> 00:03:00,739
当我们明显控制了指针
在一个将被取消链接的自由块中，我们

51
00:03:00,739 --> 00:03:06,549
可以指向全局偏移表和
在那里写下转发地址。

52
00:03:06,549 --> 00:03:10,339
在上一段视频中，我们停在这里，没有
看看接下来会发生什么。

53
00:03:10,340 --> 00:03:11,740
但我现在告诉你。

54
00:03:11,739 --> 00:03:17,019
接下来我们将增加块的大小
我们已经有了

55
00:03:17,019 --> 00:03:18,209
自由块。

56
00:03:18,209 --> 00:03:21,719
然后我们将这个块插入
双链接列表。

57
00:03:21,719 --> 00:03:24,469
也就是说，我们拿了一大块，然后向上看
它是正向块。

58
00:03:24,469 --> 00:03:28,789
然后我们相应地更新指针
现在包括我们的块。

59
00:03:28,790 --> 00:03:30,480
这就是堆的全部魔力。

60
00:03:30,480 --> 00:03:36,350
现在让我们回到著名的短语文章
"一次自由"和"Vudo Malloc"

61
00:03:36,349 --> 00:03:40,059
看他们告诉我们的关于
取消链接开发。

62
00:03:40,060 --> 00:03:45,270
这两篇文章都包含一个很酷的小技巧
以克服空字节的限制。

63
00:03:45,269 --> 00:03:49,829
所以当我们想构造一个假块时
我们可以取消链接，我们要确保

64
00:03:49,829 --> 00:03:52,569
任何字段都不必包含空字节。

65
00:03:52,569 --> 00:03:56,799
这意味着我们必须使用非常大的
大小的值。

66
00:03:56,799 --> 00:04:00,219
但这似乎没用，因为
堆没那么大。

67
00:04:00,219 --> 00:04:01,239
马来酸酐

68
00:04:01,239 --> 00:04:06,879
但这一聪明的想法在文章中有所体现
利用计算机处理负面信息的方式

69
00:04:06,879 --> 00:04:08,039
价值观。

70
00:04:08,040 --> 00:04:12,950
所以让我们快速探索一下
一个32位整数值，当我们加上

71
00:04:12,950 --> 00:04:14,390
数量很大。

72
00:04:14,390 --> 00:04:17,260
例如fffffff c。

73
00:04:17,260 --> 00:04:19,320
那将超过40亿。

74
00:04:19,319 --> 00:04:25,739
现在，当添加0x64时会发生什么
小数是100到40亿吗？

75
00:04:25,740 --> 00:04:27,610
这不适合32位。

76
00:04:27,610 --> 00:04:29,950
加在一起的东西会丢失。

77
00:04:29,949 --> 00:04:33,039
现在你又有了一个非常小的值。

78
00:04:33,040 --> 00:04:35,270
事实上，它是0x60。

79
00:04:35,270 --> 00:04:38,150
4小于0x64。

80
00:04:38,150 --> 00:04:47,050
这意味着增加40亿，即ffffff c
到100，我们实际上减去了4。

81
00:04:47,050 --> 00:04:49,730
这是一个非常有用的行为
我们的案子。

82
00:04:49,729 --> 00:04:55,329
因为这个值不包含
任何空字节的行为都像一个非常小的减法。

83
00:04:55,330 --> 00:04:59,630
所以当我们再次浏览源代码时，
我们现在可以制定计划了。

84
00:04:59,629 --> 00:05:03,439
首先，我们必须再次溢出
块的大小，其值大于

85
00:05:03,440 --> 00:05:04,440
80.

86
00:05:04,440 --> 00:05:07,850
所以让我们来做最后一个视频。

87
00:05:07,850 --> 00:05:11,890
但是我们也不在乎
上一次合并尝试

88
00:05:11,889 --> 00:05:12,889
块。

89
00:05:12,889 --> 00:05:15,009
这样我们就不必设置另一个
假块。

90
00:05:15,009 --> 00:05:19,509
所以我们要确保最后一块
我们将自由设置为1。

91
00:05:19,509 --> 00:05:21,479
所以它还在使用中。

92
00:05:21,479 --> 00:05:24,839
但我们可以做巩固前进的部分。

93
00:05:24,840 --> 00:05:29,070
在那里，我们取下一块，从那里检查
它是前一个正在使用的位的下一个块，并且

94
00:05:29,070 --> 00:05:32,370
如果没有设置，我们尝试取消链接，
巩固那个街区。

95
00:05:32,370 --> 00:05:37,470
这意味着我们需要两个假街区，一个
包含向前和向后指针

96
00:05:37,470 --> 00:05:41,570
我们想用一个
堆中的地址。

97
00:05:41,569 --> 00:05:46,829
第二个块的大小必须与
最低位设置为0。

98
00:05:46,830 --> 00:05:50,050
但我们不能使用小尺寸的值。

99
00:05:50,050 --> 00:05:54,720
但是如果你在代码中看到大小是如何使用的，
它只是作为一个附加的偏移量

100
00:05:54,720 --> 00:05:55,910
到一个地址。

101
00:05:55,910 --> 00:05:59,360
代码没有检查这是一个荒谬的
大块。

102
00:05:59,360 --> 00:06:01,310
它只是增加了这个价值。

103
00:06:01,310 --> 00:06:03,130
这就是技巧发挥的地方。

104
00:06:03,130 --> 00:06:09,500
我们可以使用fffff c作为块的大小，
结果是A-4。

105
00:06:09,500 --> 00:06:11,220
现在想想会发生什么。

106
00:06:11,219 --> 00:06:15,429
他补充说："这将占用该块的大小。"
到当前地址查找下一个

107
00:06:15,430 --> 00:06:20,290
一块一块的，哪个傻瓜可以自由地思考
下一块在这里的-4处。

108
00:06:20,289 --> 00:06:26,309
现在它将读取该块的大小，
我们也可以设置为fffffff c，而不是

109
00:06:26,310 --> 00:06:31,580
做最后一点准备并总结，是的，
以前的块没有使用，我们取消链接

110
00:06:31,580 --> 00:06:32,580
它。

111
00:06:32,580 --> 00:06:33,580
嘘声！

112
00:06:33,580 --> 00:06:35,330
它很漂亮很聪明。

113
00:06:35,330 --> 00:06:37,200
并且不包含任何空字节。

114
00:06:37,199 --> 00:06:43,029
那么让我们看看我们能不能把那堆填进去
我们可以用strcpys实现这一点。

115
00:06:43,030 --> 00:06:45,540
所以strcpy在一个空字节处停止。

116
00:06:45,539 --> 00:06:49,849
这意味着我们必须使用其中一个来溢出
我们要释放的块的大小

117
00:06:49,850 --> 00:06:51,710
100，0x64。

118
00:06:51,710 --> 00:06:58,020
嗯…很明显，我们想防止使用位
设置，所以我们需要用0x65溢出它。

119
00:06:58,020 --> 00:07:03,160
这是因为我们不想写
除此之外，它以一个空字节结束，并且

120
00:07:03,159 --> 00:07:05,039
保持尺寸清洁。

121
00:07:05,039 --> 00:07:09,239
另一个strcpy可以用来填充
100字节，直到奇怪的假连接

122
00:07:09,240 --> 00:07:14,270
用ffffc分块，然后两块
我们要写的地址。

123
00:07:14,270 --> 00:07:19,330
现在就像在上一个视频中一样，我们将设置
全局偏移表的一个地址，

124
00:07:19,330 --> 00:07:24,530
所以我们重写了Puts，而另一个
将指向第一个堆。

125
00:07:24,530 --> 00:07:28,630
这意味着我们将重定向代码执行
到这个堆地址，我们可以使用第一个

126
00:07:28,629 --> 00:07:31,609
strcpy在这里放置一些shellcode。

127
00:07:31,610 --> 00:07:35,760
请记住，链接也会写入
从全局偏移表到

128
00:07:35,759 --> 00:07:40,989
这个堆区，所以我们要么
壳码短了，或者跳过了碎的

129
00:07:40,990 --> 00:07:43,710
然后继续shellcode。

130
00:07:43,710 --> 00:07:45,460
但我们只想打电话给赢家。

131
00:07:45,460 --> 00:07:48,960
那么让我们来构建这个漏洞。

132
00:07:48,960 --> 00:07:53,360
你可以排成一行，但让我休息一下
这样做是为了更容易跟随。

133
00:07:53,360 --> 00:07:59,070
我们将在每一个窗口中
一个参数，每个strcpy一个字符串。

134
00:07:59,069 --> 00:08:04,459
所以也许我们先来照顾史崔比吧
因为这应该是

135
00:08:04,460 --> 00:08:09,510
用101覆盖块大小
第三块。

136
00:08:09,509 --> 00:08:14,239
我用echo计算了一下
字符的大小

137
00:08:14,240 --> 00:08:17,730
块，然后我们在这里写1010x65。

138
00:08:17,729 --> 00:08:22,949
我将输出重定向到文件B，然后
我们可以把它和背景和猫一起用

139
00:08:22,949 --> 00:08:25,179
gdb中的参数。

140
00:08:25,180 --> 00:08:28,580
然后我们可以运行它并调查堆。

141
00:08:28,580 --> 00:08:32,700
看起来很完美，第三块的大小
现在是0x65。

142
00:08:32,700 --> 00:08:38,170
接下来我们来处理第三块，
在溢出之后，所以是100

143
00:08:38,170 --> 00:08:39,390
字节大。

144
00:08:39,390 --> 00:08:44,090
所以我们想写100个字符
填满大块，然后我们最终到达

145
00:08:44,090 --> 00:08:50,250
在下一块，我们要写的地方
FFFFF C是为了之前的技巧，

146
00:08:50,250 --> 00:08:54,380
后跟全局偏移表地址
和堆地址。

147
00:08:54,380 --> 00:08:58,090
在这里我得到了Puts和
减去-12。

148
00:08:58,090 --> 00:09:01,540
因为堆地址将写入
+12.

149
00:09:01,540 --> 00:09:06,760
然后是最后一个Strcpy，第一个
chunk，我们要在其中包含shellcode

150
00:09:06,760 --> 00:09:07,920
打电话给胜利者。

151
00:09:07,920 --> 00:09:11,450
我很快在谷歌上搜索了一个在线组装程序。
创建外壳代码。

152
00:09:11,450 --> 00:09:16,200
我们要呼叫一个绝对地址
我们必须通过一个登记簿。

153
00:09:16,200 --> 00:09:22,140
所以我们可以把获胜者的地址移到
EAX，然后呼叫EAX。

154
00:09:22,140 --> 00:09:27,380
我们可以简单地复制字符串表示
把这个外壳代码写进

155
00:09:27,380 --> 00:09:28,850
文件。

156
00:09:28,850 --> 00:09:30,330
酷。

157
00:09:30,330 --> 00:09:33,450
既然我们有了三个参数，我们就可以
重新运行程序。

158
00:09:33,450 --> 00:09:34,590
让我们来看看堆。

159
00:09:34,590 --> 00:09:35,590
看起来不错。

160
00:09:35,590 --> 00:09:37,920
让我们执行自由和单步进入
看门电话。

161
00:09:37,920 --> 00:09:39,090
哦。

162
00:09:39,090 --> 00:09:42,810
太好了，我们跟着走，但不知何故
我们的代码不对。

163
00:09:42,810 --> 00:09:45,580
你可以看到它完全是垃圾。

164
00:09:45,580 --> 00:09:48,710
不是我们的外壳代码，我们有一些地址
在这里。

165
00:09:48,710 --> 00:09:49,710
哎哟！

166
00:09:49,710 --> 00:09:53,300
当然，我们执行多个释放，而不是
就是那个。

167
00:09:53,300 --> 00:09:56,790
所以我们显然是在上面写元数据的
价值观。

168
00:09:56,790 --> 00:10:00,560
但是我们可以简单地通过指向
堆的不同区域。

169
00:10:00,560 --> 00:10:02,600
14点在这儿怎么样？

170
00:10:02,600 --> 00:10:07,080
现在我们改变地址并预先准备一些
字符到我们的外壳代码。然后再试一次。

171
00:10:07,080 --> 00:10:12,480
我们一步一步地跑过去
胜利者。

172
00:10:12,480 --> 00:10:13,480
呵呵。

173
00:10:13,480 --> 00:10:17,530
让我们在没有gdb的情况下试试吧！

174
00:10:17,530 --> 00:10:18,530
它奏效了。

175
00:10:18,530 --> 00:10:19,950
天哪，我喜欢这个！

