1
00:00:00,149 --> 00:00:04,749
上一个视频我们看了free() 的dlmalloc实现。

2
00:00:04,750 --> 00:00:10,030
我们发现了unlink() 宏，它可以用来将几乎任意的数据写入

3
00:00:10,030 --> 00:00:11,420
另一个地址。

4
00:00:11,419 --> 00:00:16,779
我们用gdb构造了一个概念证明堆，并观察到对

5
00:00:16,779 --> 00:00:18,399
全局偏移表。

6
00:00:18,400 --> 00:00:24,300
但最终我们意识到，我们的计划行不通，因为它包含了太多

7
00:00:24,300 --> 00:00:30,510
空字节，我们不能用strcpy编写这些字节。

8
00:00:30,510 --> 00:00:38,880
让我们快速回顾和总结一下我们对堆和自由算法的了解

9
00:00:38,880 --> 00:00:41,040
完善我们的开发计划。

10
00:00:41,040 --> 00:00:47,090
最后一段视频更具探索性，带您了解如何发现漏洞

11
00:00:47,090 --> 00:00:50,520
你自己，但这段视频更像是一个演示。

12
00:00:50,520 --> 00:00:55,570
这样我们就有了不同风格的关于同一主题的视频，我希望增加

13
00:00:55,570 --> 00:00:58,580
了解它如何工作的人数。

14
00:00:58,580 --> 00:01:01,620
我们再来看看堆块的外观。

15
00:01:01,620 --> 00:01:05,780
当您分配某个大小的块时，该块的大小将写入

16
00:01:05,780 --> 00:01:09,560
第二个字和malloc将在这里返回地址。

17
00:01:09,560 --> 00:01:13,190
这意味着您有这个用户数据区域。

18
00:01:13,190 --> 00:01:17,000
块大小的最后一位具有特殊意义。

19
00:01:17,000 --> 00:01:21,270
最重要的是，最后一位是前一个正在使用的位。

20
00:01:21,270 --> 00:01:24,160
这是关于当前块之前的块的信息。

21
00:01:24,159 --> 00:01:27,139
所以在开始的时候把头包起来有点奇怪。

22
00:01:27,140 --> 00:01:31,660
这意味着如果在这里分配了这个块，那么后面的块将具有最后一个

23
00:01:31,659 --> 00:01:33,039
位集。

24
00:01:33,040 --> 00:01:35,640
因为它前面的块正在使用中。

25
00:01:35,640 --> 00:01:38,790
现在，一个自由块可以包含更多信息。

26
00:01:38,790 --> 00:01:44,310
所以一旦我们释放了这个块，很明显我们可以将块的最后一位设置为

27
00:01:44,310 --> 00:01:45,310
0。

28
00:01:45,310 --> 00:01:47,760
以指示上一块不再使用。

29
00:01:47,760 --> 00:01:50,430
现在假设有第三块。

30
00:01:50,430 --> 00:01:55,120
第二个块之后的块，它的前一个使用位未设置。

31
00:01:55,120 --> 00:01:57,380
这意味着第二个块是空闲的。

32
00:01:57,380 --> 00:02:01,480
现在，算法要合并，合并这两个块。

33
00:02:01,479 --> 00:02:04,799
这就是大小后的两个词开始变得重要的地方。

34
00:02:04,800 --> 00:02:07,730
它们是向前和向后的指针。

35
00:02:07,730 --> 00:02:12,990
正如旁注，这只适用于大于fastbin大小的块。

36
00:02:12,989 --> 00:02:16,349
因为FastBins是非常小的块，它们不使用双链接列表。

37
00:02:16,349 --> 00:02:17,879
所以我们的块更大。

38
00:02:17,879 --> 00:02:20,139
让我们考虑一下这个堆设置。

39
00:02:20,140 --> 00:02:24,530
我们有一个要释放的块，后面跟着一个已经释放的块。

40
00:02:24,530 --> 00:02:29,240
这个自由块有两个指针，向前和向后指向另一个自由块

41
00:02:29,239 --> 00:02:30,239
块。

42
00:02:30,239 --> 00:02:32,139
所以它们在这个双链表中。

43
00:02:32,140 --> 00:02:37,130
现在会发生的是，自由算法将这两个块合并在一起。

44
00:02:37,129 --> 00:02:42,059
它将首先通过使用“取消链接”从链接列表中取消自由块的链接来实现这一点。

45
00:02:42,060 --> 00:02:43,080
宏。

46
00:02:43,080 --> 00:02:47,780
我们知道了它的作用，它把前向地址写在

47
00:02:47,780 --> 00:02:50,350
前一块的前向指针。

48
00:02:50,349 --> 00:02:55,109
它将获取反向地址并将其写入

49
00:02:55,109 --> 00:02:56,109
下一个块。

50
00:02:56,109 --> 00:03:00,739
当我们明显地控制了一个自由块的指针，它将被取消链接，我们

51
00:03:00,739 --> 00:03:06,549
可以指向全局偏移量表并在其中写入转发地址。

52
00:03:06,549 --> 00:03:10,339
在上一段视频中，我们停在这里，没有查看接下来会发生什么。

53
00:03:10,340 --> 00:03:11,740
但我现在告诉你。

54
00:03:11,739 --> 00:03:17,019
接下来，我们将增加释放的块的大小

55
00:03:17,019 --> 00:03:18,209
自由块。

56
00:03:18,209 --> 00:03:21,719
然后我们将这个块插入到双链接列表中。

57
00:03:21,719 --> 00:03:24,469
这意味着我们取了一块，并查找它的前块。

58
00:03:24,469 --> 00:03:28,789
然后我们相应地更新指针，以包含块。

59
00:03:28,790 --> 00:03:30,480
这就是堆的全部魔力。

60
00:03:30,480 --> 00:03:36,350
现在让我们回到著名的短语文章“Once on a free”和“Vudo malloc”

61
00:03:36,349 --> 00:03:40,059
诡计“看看他们告诉我们什么关于不链接的利用。

62
00:03:40,060 --> 00:03:45,270
这两篇文章都包含一个很酷的小技巧来克服空字节的限制。

63
00:03:45,269 --> 00:03:49,829
因此，当我们想要构造一个可以取消链接的假块时，我们要确保

64
00:03:49,829 --> 00:03:52,569
任何字段都不必包含空字节。

65
00:03:52,569 --> 00:03:56,799
这意味着我们必须对大小使用非常大的值。

66
00:03:56,799 --> 00:04:00,219
但这似乎没用，因为堆没那么大。

67
00:04:00,219 --> 00:04:01,239
马来酸酐

68
00:04:01,239 --> 00:04:06,879
但是在文章中展示的聪明的想法是利用计算机处理负面信息的方式。

69
00:04:06,879 --> 00:04:08,039
价值观。

70
00:04:08,040 --> 00:04:12,950
因此，让我们快速探索32位整数值会发生什么，当我们添加一个

71
00:04:12,950 --> 00:04:14,390
数量很大。

72
00:04:14,390 --> 00:04:17,260
例如fffffff c。

73
00:04:17,260 --> 00:04:19,320
那将超过40亿。

74
00:04:19,319 --> 00:04:25,739
现在，当你加上0x64时会发生什么，它是十进制100到40亿？

75
00:04:25,740 --> 00:04:27,610
这不适合32位。

76
00:04:27,610 --> 00:04:29,950
加在一起的东西会丢失。

77
00:04:29,949 --> 00:04:33,039
现在你又有了一个非常小的值。

78
00:04:33,040 --> 00:04:35,270
事实上，它是0x60。

79
00:04:35,270 --> 00:04:38,150
4小于0x64。

80
00:04:38,150 --> 00:04:47,050
这意味着加上40亿，ffffff c到100，我们实际上减去了4。

81
00:04:47,050 --> 00:04:49,730
这对我们来说是非常有用的行为。

82
00:04:49,729 --> 00:04:55,329
因为这个不包含任何空字节的值的行为就像一个非常小的减法。

83
00:04:55,330 --> 00:04:59,630
所以当我们再次浏览源代码时，我们现在可以制定一个计划。

84
00:04:59,629 --> 00:05:03,439
首先，我们必须用一个大于

85
00:05:03,440 --> 00:05:04,440
80。

86
00:05:04,440 --> 00:05:07,850
所以让我们来做最后一个视频。

87
00:05:07,850 --> 00:05:11,890
但是我们也不关心前一次的合并尝试

88
00:05:11,889 --> 00:05:12,889
块。

89
00:05:12,889 --> 00:05:15,009
这样我们就不必设置另一个假块。

90
00:05:15,009 --> 00:05:19,509
所以我们要确保我们要释放的块的最后一个位设置为1。

91
00:05:19,509 --> 00:05:21,479
所以它还在使用中。

92
00:05:21,479 --> 00:05:24,839
但我们可以做巩固前进的部分。

93
00:05:24,840 --> 00:05:29,070
在这里，我们取下一个块，从它的下一个块中检查上一个正在使用的块，以及

94
00:05:29,070 --> 00:05:32,370
如果没有设置，我们将尝试取消链接，合并该块。

95
00:05:32,370 --> 00:05:37,470
这意味着我们需要两个假块，一个包含向前和向后指针

96
00:05:37,470 --> 00:05:41,570
我们想用堆中的地址覆盖got。

97
00:05:41,569 --> 00:05:46,829
第二个块必须有一个最小位设置为0的大小。

98
00:05:46,830 --> 00:05:50,050
但我们不能使用小尺寸的值。

99
00:05:50,050 --> 00:05:54,720
但是，如果您在代码中查看大小是如何使用的，它只是用作一个添加的偏移量。

100
00:05:54,720 --> 00:05:55,910
到一个地址。

101
00:05:55,910 --> 00:05:59,360
代码并没有检查它是否是一个荒谬的大块。

102
00:05:59,360 --> 00:06:01,310
它只是增加了这个价值。

103
00:06:01,310 --> 00:06:03,130
这就是技巧发挥的地方。

104
00:06:03,130 --> 00:06:09,500
我们可以使用fffff c作为块的大小，结果是-4。

105
00:06:09,500 --> 00:06:11,220
现在想想会发生什么。

106
00:06:11,219 --> 00:06:15,429
它将占用该块的大小，并将其添加到当前地址以查找下一个

107
00:06:15,430 --> 00:06:20,290
大块头，傻瓜们认为下一个大块头在这里-4。

108
00:06:20,289 --> 00:06:26,309
现在它将读取该块的大小，我们也可以将其设置为fffffff c，而不是

109
00:06:26,310 --> 00:06:31,580
设置最后一个位并结束，是的，之前的块没有使用，让我们取消链接。

110
00:06:31,580 --> 00:06:32,580
它。

111
00:06:32,580 --> 00:06:33,580
嘘声！

112
00:06:33,580 --> 00:06:35,330
它很漂亮很聪明。

113
00:06:35,330 --> 00:06:37,200
并且不包含任何空字节。

114
00:06:37,199 --> 00:06:43,029
那么让我们看看我们是否可以用strcpy来填充这个堆。

115
00:06:43,030 --> 00:06:45,540
所以strcpy在一个空字节处停止。

116
00:06:45,539 --> 00:06:49,849
这意味着我们必须使用其中一个来溢出我们想要释放的块的大小。

117
00:06:49,850 --> 00:06:51,710
100，0x64。

118
00:06:51,710 --> 00:06:58,020
嗯…显然，我们想要防止使用位集，所以我们需要用0x65溢出它。

119
00:06:58,020 --> 00:07:03,160
这是因为我们不想写更多，它以一个空字节结束，并且

120
00:07:03,159 --> 00:07:05,039
保持尺寸清洁。

121
00:07:05,039 --> 00:07:09,239
另一个strcpy可以用来填充100字节，直到奇怪的连体假的

122
00:07:09,240 --> 00:07:14,270
用ffffc分块，然后我们要写的两个地址。

123
00:07:14,270 --> 00:07:19,330
现在，就像在上一个视频中一样，我们将把一个地址设置为全局偏移表，

124
00:07:19,330 --> 00:07:24,530
这样我们就覆盖了puts，而另一个将指向第一个堆。

125
00:07:24,530 --> 00:07:28,630
这意味着我们将把代码执行重定向到这个堆地址，并且可以使用第一个

126
00:07:28,629 --> 00:07:31,609
strcpy在这里放置一些shellcode。

127
00:07:31,610 --> 00:07:35,760
请记住，取消链接也会将一些数据从全局偏移表写入

128
00:07:35,759 --> 00:07:40,989
这堆区域，所以我们要么保持代码简短，要么跳过粉碎的

129
00:07:40,990 --> 00:07:43,710
然后继续shellcode。

130
00:07:43,710 --> 00:07:45,460
但我们只想打电话给赢家。

131
00:07:45,460 --> 00:07:48,960
那么让我们来构建这个漏洞。

132
00:07:48,960 --> 00:07:53,360
你可以排成一行，但让我把它拆开，让它更容易跟随。

133
00:07:53,360 --> 00:07:59,070
在这些窗口中，我们将为每个strcpy构造一个参数和一个字符串。

134
00:07:59,069 --> 00:08:04,459
所以也许我们先来处理中间块的strcpy，因为它应该是

135
00:08:04,460 --> 00:08:09,510
用第三个块的101覆盖块大小。

136
00:08:09,509 --> 00:08:14,239
我用echo来表示，我计算了达到

137
00:08:14,240 --> 00:08:17,730
块，然后我们在这里写1010x65。

138
00:08:17,729 --> 00:08:22,949
我将输出重定向到一个文件B中，然后我们可以将它与backticks和cat一起用作

139
00:08:22,949 --> 00:08:25,179
gdb中的参数。

140
00:08:25,180 --> 00:08:28,580
然后我们可以运行它并调查堆。

141
00:08:28,580 --> 00:08:32,700
看起来很完美，第三个块的大小现在是0x65。

142
00:08:32,700 --> 00:08:38,170
接下来我们来处理第三个块，它在溢出之后，所以是100

143
00:08:38,170 --> 00:08:39,390
字节大。

144
00:08:39,390 --> 00:08:44,090
所以我们想写100个字符来填充数据块，然后最终到达

145
00:08:44,090 --> 00:08:50,250
在下一块，我们要为前面的技巧编写fffff c，

146
00:08:50,250 --> 00:08:54,380
后面是全局偏移表地址和堆地址。

147
00:08:54,380 --> 00:08:58,090
这里我得到了看跌期权的表地址，并从中减去-12。

148
00:08:58,090 --> 00:09:01,540
因为堆地址将写入
+ 12。

149
00:09:01,540 --> 00:09:06,760
然后是最后一个strcpy，第一个块，我们想在其中包含shellcode

150
00:09:06,760 --> 00:09:07,920
打电话给胜利者。

151
00:09:07,920 --> 00:09:11,450
我很快在谷歌上搜索了一个在线汇编程序来创建shellcode。

152
00:09:11,450 --> 00:09:16,200
我们要调用一个绝对地址，要做到这一点，我们必须通过一个寄存器。

153
00:09:16,200 --> 00:09:22,140
所以我们可以把获胜者的地址移到eax中，然后调用eax。

154
00:09:22,140 --> 00:09:27,380
我们可以简单地复制这个shell代码的字符串表示形式并将其写入

155
00:09:27,380 --> 00:09:28,850
文件。

156
00:09:28,850 --> 00:09:30,330
酷。

157
00:09:30,330 --> 00:09:33,450
既然我们有了三个参数，就可以重新运行程序了。

158
00:09:33,450 --> 00:09:34,590
让我们来看看堆。

159
00:09:34,590 --> 00:09:35,590
看起来不错。

160
00:09:35,590 --> 00:09:37,920
让我们在看跌期权调用中执行自由和单步操作。

161
00:09:37,920 --> 00:09:39,090
哦。

162
00:09:39,090 --> 00:09:42,810
太好了，我们继续往下看，但不知何故，我们的shell代码是错误的。

163
00:09:42,810 --> 00:09:45,580
你可以看到它完全是垃圾。

164
00:09:45,580 --> 00:09:48,710
这里没有我们的外壳代码，而是有一些地址。

165
00:09:48,710 --> 00:09:49,710
哎哟！

166
00:09:49,710 --> 00:09:53,300
当然，我们执行多个释放，而不仅仅是一个。

167
00:09:53,300 --> 00:09:56,790
所以我们显然是在这些值上写元数据的。

168
00:09:56,790 --> 00:10:00,560
但我们可以简单地通过指向堆的不同区域来解决这个问题。

169
00:10:00,560 --> 00:10:02,600
14点在这儿怎么样？

170
00:10:02,600 --> 00:10:07,080
现在我们更改地址，并在shell代码前面加上一些字符。然后再试一次。

171
00:10:07,080 --> 00:10:12,480
我们跑过去，一步一步的投入，最终获得冠军。

172
00:10:12,480 --> 00:10:13,480
呵呵。

173
00:10:13,480 --> 00:10:17,530
让我们在没有gdb的情况下试试吧！

174
00:10:17,530 --> 00:10:18,530
它奏效了。

175
00:10:18,530 --> 00:10:19,950
天哪，我喜欢这个！

