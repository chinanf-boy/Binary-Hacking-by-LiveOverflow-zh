1
00:00:00,149 --> 00:00:04,749
Last video we had a look at the dlmalloc implementation of free().

2
00:00:04,750 --> 00:00:10,030
我们发现了unlink（）宏，它可以用来将几乎任意的数据写入

3
00:00:10,030 --> 00:00:11,420
another address.

4
00:00:11,419 --> 00:00:16,779
我们用gdb构造了一个概念证明堆，并观察到对

5
00:00:16,779 --> 00:00:18,399
global offset table.

6
00:00:18,400 --> 00:00:24,300
但最终我们意识到，我们的计划行不通，因为它包含了太多

7
00:00:24,300 --> 00:00:30,510
null-bytes and we can’t write those with strcpy.

8
00:00:30,510 --> 00:00:38,880
让我们快速回顾和总结一下我们对堆和自由算法的了解

9
00:00:38,880 --> 00:00:41,040
to refine our exploitation plan.

10
00:00:41,040 --> 00:00:47,090
最后一段视频更具探索性，带您了解如何发现漏洞

11
00:00:47,090 --> 00:00:50,520
yourself, but this video will be more of a presentation.

12
00:00:50,520 --> 00:00:55,570
这样我们就有了不同风格的关于同一主题的视频，我希望增加

13
00:00:55,570 --> 00:00:58,580
the amount of people who understand how it works.

14
00:00:58,580 --> 00:01:01,620
So let’s look again at how a heap chunk looks like.

15
00:01:01,620 --> 00:01:05,780
当您分配某个大小的块时，该块的大小将写入

16
00:01:05,780 --> 00:01:09,560
2nd word and malloc will return the address here.

17
00:01:09,560 --> 00:01:13,190
This means you have this area for user data.

18
00:01:13,190 --> 00:01:17,000
The last bits of the chunk size have special meaning.

19
00:01:17,000 --> 00:01:21,270
Most importantly the last bit is the previous in use bit.

20
00:01:21,270 --> 00:01:24,160
So that is information about the chunk BEFORE the current chunk.

21
00:01:24,159 --> 00:01:27,139
So that’s a little bit weird to wrap your head around at the beginning.

22
00:01:27,140 --> 00:01:31,660
这意味着如果在这里分配了这个块，那么后面的块将具有最后一个

23
00:01:31,659 --> 00:01:33,039
bit set.

24
00:01:33,040 --> 00:01:35,640
Because the chunk in front of it is in use.

25
00:01:35,640 --> 00:01:38,790
Now a free chunk could contain more information.

26
00:01:38,790 --> 00:01:44,310
所以一旦我们释放了这个块，很明显我们可以将块的最后一位设置为

27
00:01:44,310 --> 00:01:45,310
0.

28
00:01:45,310 --> 00:01:47,760
To indicate that the previous chunk is not in use anymore.

29
00:01:47,760 --> 00:01:50,430
Now imagine there is a third chunk.

30
00:01:50,430 --> 00:01:55,120
A chunk after the 2nd one, which has it’s previous in use bit NOT set.

31
00:01:55,120 --> 00:01:57,380
This means the 2nd chunk is free.

32
00:01:57,380 --> 00:02:01,480
Now the algorithm would like to merge, consolidate those two blocks.

33
00:02:01,479 --> 00:02:04,799
This is where the two words after the size start being important.

34
00:02:04,800 --> 00:02:07,730
They are the forward and backward pointer.

35
00:02:07,730 --> 00:02:12,990
Just as a sidenote, this only applies to chunks that are bigger than the fastbin size.

36
00:02:12,989 --> 00:02:16,349
Because fastbins are very small chunks and they don’t use a double linked list.

37
00:02:16,349 --> 00:02:17,879
So our chunks are bigger.

38
00:02:17,879 --> 00:02:20,139
Let’s consider this heap setup.

39
00:02:20,140 --> 00:02:24,530
We have a chunk we want to free, which is followed by an already free chunk.

40
00:02:24,530 --> 00:02:29,240
这个自由块有两个指针，向前和向后指向另一个自由块

41
00:02:29,239 --> 00:02:30,239
chunks.

42
00:02:30,239 --> 00:02:32,139
So they are in this double linked list.

43
00:02:32,140 --> 00:02:37,130
Now what will happen is, the free algorithm will merge these two blocks together.

44
00:02:37,129 --> 00:02:42,059
它将首先通过使用“取消链接”从链接列表中取消自由块的链接来实现这一点。

45
00:02:42,060 --> 00:02:43,080
macro.

46
00:02:43,080 --> 00:02:47,780
我们知道了它的作用，它把前向地址写在

47
00:02:47,780 --> 00:02:50,350
the forward pointer of the previous chunk.

48
00:02:50,349 --> 00:02:55,109
它将获取反向地址并将其写入

49
00:02:55,109 --> 00:02:56,109
next chunk.

50
00:02:56,109 --> 00:03:00,739
当我们明显地控制了一个自由块的指针，它将被取消链接，我们

51
00:03:00,739 --> 00:03:06,549
can point into the global offset table and write there the forward address.

52
00:03:06,549 --> 00:03:10,339
In the last video we stopped here and didn’t check out what happens next.

53
00:03:10,340 --> 00:03:11,740
But let me tell you now.

54
00:03:11,739 --> 00:03:17,019
接下来，我们将增加释放的块的大小

55
00:03:17,019 --> 00:03:18,209
free block.

56
00:03:18,209 --> 00:03:21,719
And then we will insert this block into the double linked list.

57
00:03:21,719 --> 00:03:24,469
Which means we take one chunk, and look up it’s forward chunk.

58
00:03:24,469 --> 00:03:28,789
And then we update the pointers accordingly to now include our chunk.

59
00:03:28,790 --> 00:03:30,480
This is the whole magic of the heap.

60
00:03:30,480 --> 00:03:36,350
现在让我们回到著名的短语文章“Once on a free”和“Vudo malloc”

61
00:03:36,349 --> 00:03:40,059
tricks” to see what they tell us about the unlink exploit.

62
00:03:40,060 --> 00:03:45,270
Both articles contain a cool little trick to overcome the limitations of the null-byte.

63
00:03:45,269 --> 00:03:49,829
因此，当我们想要构造一个可以取消链接的假块时，我们要确保

64
00:03:49,829 --> 00:03:52,569
no field has to contain a null-byte.

65
00:03:52,569 --> 00:03:56,799
This means we have to use very very large values for the size.

66
00:03:56,799 --> 00:04:00,219
But that doesn’t seem useful, because the heap is not that big.

67
00:04:00,219 --> 00:04:01,239
Mh.

68
00:04:01,239 --> 00:04:06,879
但是在文章中展示的聪明的想法是利用计算机处理负面信息的方式。

69
00:04:06,879 --> 00:04:08,039
values.

70
00:04:08,040 --> 00:04:12,950
因此，让我们快速探索32位整数值会发生什么，当我们添加一个

71
00:04:12,950 --> 00:04:14,390
very large number.

72
00:04:14,390 --> 00:04:17,260
For example fffffffC.

73
00:04:17,260 --> 00:04:19,320
That would be over 4 billion.

74
00:04:19,319 --> 00:04:25,739
现在，当你加上0x64时会发生什么，它是十进制100到40亿？

75
00:04:25,740 --> 00:04:27,610
That doesn’t fit in 32bit.

76
00:04:27,610 --> 00:04:29,950
And the carry of the addition will be lost.

77
00:04:29,949 --> 00:04:33,039
And now you have a very small value again.

78
00:04:33,040 --> 00:04:35,270
In fact it’s 0x60.

79
00:04:35,270 --> 00:04:38,150
Which is 4 less than 0x64.

80
00:04:38,150 --> 00:04:47,050
This means by adding 4 billion, the ffffffc to 100, we actually subtracted 4.

81
00:04:47,050 --> 00:04:49,730
And that’s a really useful behaviour for our case.

82
00:04:49,729 --> 00:04:55,329
Because this value that doesn’t contain any null-bytes behaves like a very small subtraction.

83
00:04:55,330 --> 00:04:59,630
So when we skim over the sourcecode again, we can now make a plan.

84
00:04:59,629 --> 00:05:03,439
首先，我们必须用一个大于

85
00:05:03,440 --> 00:05:04,440
80.

86
00:05:04,440 --> 00:05:07,850
So let’s do the 100 like last video.

87
00:05:07,850 --> 00:05:11,890
但是我们也不关心前一次的合并尝试

88
00:05:11,889 --> 00:05:12,889
block.

89
00:05:12,889 --> 00:05:15,009
This ways we don’t have to setup another fake chunk.

90
00:05:15,009 --> 00:05:19,509
So we make sure that the last bit of the block we are going to free is set to 1.

91
00:05:19,509 --> 00:05:21,479
So it’s still in use.

92
00:05:21,479 --> 00:05:24,839
But we could do the consolidate forward part.

93
00:05:24,840 --> 00:05:29,070
在这里，我们取下一个块，从它的下一个块中检查上一个正在使用的块，以及

94
00:05:29,070 --> 00:05:32,370
if that is not set, we attempt to unlink, consolidate that block.

95
00:05:32,370 --> 00:05:37,470
这意味着我们需要两个假块，一个包含向前和向后指针

96
00:05:37,470 --> 00:05:41,570
we want to use to overwrite the GoT with an address from the heap.

97
00:05:41,569 --> 00:05:46,829
And the second chunk has to have a size with the lowest bit set to 0.

98
00:05:46,830 --> 00:05:50,050
BUT we can’t use small size values.

99
00:05:50,050 --> 00:05:54,720
但是，如果您在代码中查看大小是如何使用的，它只是用作一个添加的偏移量。

100
00:05:54,720 --> 00:05:55,910
to an address.

101
00:05:55,910 --> 00:05:59,360
The code doesn’t check that it’s a ridiculous huge chunk.

102
00:05:59,360 --> 00:06:01,310
It just adds that value.

103
00:06:01,310 --> 00:06:03,130
And here is where the trick comes into play.

104
00:06:03,130 --> 00:06:09,500
We could use fffffffc as the size of the chunk, which results in a -4.

105
00:06:09,500 --> 00:06:11,220
Now think what will happen.

106
00:06:11,219 --> 00:06:15,429
它将占用该块的大小，并将其添加到当前地址以查找下一个

107
00:06:15,430 --> 00:06:20,290
chunk, which fools free into thinking the next chunk is at -4 from here.

108
00:06:20,289 --> 00:06:26,309
现在它将读取该块的大小，我们也可以将其设置为fffffff c，而不是

109
00:06:26,310 --> 00:06:31,580
设置最后一个位并结束，是的，之前的块没有使用，让我们取消链接。

110
00:06:31,580 --> 00:06:32,580
it.

111
00:06:32,580 --> 00:06:33,580
嘘声！

112
00:06:33,580 --> 00:06:35,330
It’s very beautiful and clever.

113
00:06:35,330 --> 00:06:37,200
And doesn’t contain any null bytes.

114
00:06:37,199 --> 00:06:43,029
So let’s see if we can fill that heap in a way that we can do that with strcpys.

115
00:06:43,030 --> 00:06:45,540
So strcpy stops at a null-byte.

116
00:06:45,539 --> 00:06:49,849
这意味着我们必须使用其中一个来溢出我们想要释放的块的大小。

117
00:06:49,850 --> 00:06:51,710
100, 0x64.

118
00:06:51,710 --> 00:06:58,020
Ehh.. obviously we want to prev in use bit set, so we need to overflow it with 0x65.

119
00:06:58,020 --> 00:07:03,160
这是因为我们不想写更多，它以一个空字节结束，并且

120
00:07:03,159 --> 00:07:05,039
keeps the size clean.

121
00:07:05,039 --> 00:07:09,239
另一个strcpy可以用来填充100字节，直到奇怪的连体假的

122
00:07:09,240 --> 00:07:14,270
chunks with ffffc, and afterwards the two addresses we want to write.

123
00:07:14,270 --> 00:07:19,330
现在，就像前面的视频一样，我们将把一个地址设置为全局偏移表，

124
00:07:19,330 --> 00:07:24,530
so that we overwrite puts, and the other one will be pointing into the first heap.

125
00:07:24,530 --> 00:07:28,630
这意味着我们将把代码执行重定向到这个堆地址，并且可以使用第一个

126
00:07:28,629 --> 00:07:31,609
strcpy to place some shellcode here.

127
00:07:31,610 --> 00:07:35,760
请记住，取消链接也会将一些数据从全局偏移表写入

128
00:07:35,759 --> 00:07:40,989
这堆区域，所以我们要么保持代码简短，要么跳过粉碎的

129
00:07:40,990 --> 00:07:43,710
data and continue shellcode afterwards.

130
00:07:43,710 --> 00:07:45,460
But we just want to call winner.

131
00:07:45,460 --> 00:07:48,960
So let’s construct the exploit.

132
00:07:48,960 --> 00:07:53,360
You could do it in one line, but let me break it up to makeit easier to follow.

133
00:07:53,360 --> 00:07:59,070
In each of these windows we will construct one parameter, one string for each strcpy.

134
00:07:59,069 --> 00:08:04,459
所以也许我们先来处理中间块的strcpy，因为它应该是

135
00:08:04,460 --> 00:08:09,510
the one to overwrite the chunk size with 101 of the 3rd chunk.

136
00:08:09,509 --> 00:08:14,239
我用echo来表示，我计算了达到

137
00:08:14,240 --> 00:08:17,730
the chunk, where we then write 101, 0x65.

138
00:08:17,729 --> 00:08:22,949
我将输出重定向到一个文件B中，然后我们可以将它与backticks和cat一起用作

139
00:08:22,949 --> 00:08:25,179
parameter in gdb.

140
00:08:25,180 --> 00:08:28,580
We can then run it and investigate the heap.

141
00:08:28,580 --> 00:08:32,700
Looks perfect, the size of the third chunk is now 0x65.

142
00:08:32,700 --> 00:08:38,170
接下来我们来处理第三个块，它在溢出之后，所以是100

143
00:08:38,170 --> 00:08:39,390
byte big.

144
00:08:39,390 --> 00:08:44,090
所以我们想写100个字符来填充数据块，然后最终到达

145
00:08:44,090 --> 00:08:50,250
在下一块，我们要为前面的技巧编写fffff c，

146
00:08:50,250 --> 00:08:54,380
followed by the global offset table address and the heap address.

147
00:08:54,380 --> 00:08:58,090
Here I get the table address for puts and subtract -12 from it.

148
00:08:58,090 --> 00:09:01,540
因为堆地址将写入
+12.

149
00:09:01,540 --> 00:09:06,760
然后是最后一个strcpy，第一个块，我们想在其中包含shellcode

150
00:09:06,760 --> 00:09:07,920
to call winner.

151
00:09:07,920 --> 00:09:11,450
I quickly googled for an online assembler to create the shellcode.

152
00:09:11,450 --> 00:09:16,200
We want to call an absolute address, to do this we have to go via a register.

153
00:09:16,200 --> 00:09:22,140
So we could move the address of winner into eax and then call eax.

154
00:09:22,140 --> 00:09:27,380
我们可以简单地复制这个shell代码的字符串表示形式并将其写入

155
00:09:27,380 --> 00:09:28,850
file.

156
00:09:28,850 --> 00:09:30,330
Cool.

157
00:09:30,330 --> 00:09:33,450
Now that we have all thre parameters we can rerun the program.

158
00:09:33,450 --> 00:09:34,590
So Let’s have a look at the heap.

159
00:09:34,590 --> 00:09:35,590
It looks nice.

160
00:09:35,590 --> 00:09:37,920
Let’s execute the free and single step into the puts call.

161
00:09:37,920 --> 00:09:39,090
Oh.

162
00:09:39,090 --> 00:09:42,810
great we follow into the heap, but somehow our shellcode is wrong.

163
00:09:42,810 --> 00:09:45,580
You can see that it’s complete garbage.

164
00:09:45,580 --> 00:09:48,710
Instead of our shellcode we have some addresses here.

165
00:09:48,710 --> 00:09:49,710
哎哟！

166
00:09:49,710 --> 00:09:53,300
Of course, we perform multiple frees, not just the one.

167
00:09:53,300 --> 00:09:56,790
So we obviously write metadata over these values.

168
00:09:56,790 --> 00:10:00,560
But we can simply fix that by pointing to a different area of the heap.

169
00:10:00,560 --> 00:10:02,600
How about here at 14.

170
00:10:02,600 --> 00:10:07,080
Now we change the address and prepend some characters to our shellcode. and try it again.

171
00:10:07,080 --> 00:10:12,480
We run it, single step into puts and arrive at winner.

172
00:10:12,480 --> 00:10:13,480
hehe.

173
00:10:13,480 --> 00:10:17,530
让我们在没有gdb的情况下试试吧！

174
00:10:17,530 --> 00:10:18,530
It worked.

175
00:10:18,530 --> 00:10:19,950
天哪，我喜欢这个！

