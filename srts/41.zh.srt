1
00:00:00,280 --> 00:00:04,640
In this video we will cover heap level 0 from exploit-exercises.com/protostar.

2
00:00:04,640 --> 00:00:10,470
It’s the heap exploitation introductory challenge and is very easy.

3
00:00:10,469 --> 00:00:17,129
我们再次在Ubuntu16.04LTS版本上编译它，所以基本上是一个现代系统，

4
00:00:17,130 --> 00:00:20,120
see if or how it’s still exploitable.

5
00:00:20,120 --> 00:00:24,630
And spoiler alert, nothing changed for this challenge, it’s super straight forward.

6
00:00:24,630 --> 00:00:29,230
但我对这个视频有一个特别的想法，即使对你来说有点简单，你也可以

7
00:00:29,230 --> 00:00:38,520
want to checkout what else we learn at the end.

8
00:00:38,520 --> 00:00:43,410
在本系列之前的视频中，我通常会创建漏洞，然后思考一种方法

9
00:00:43,409 --> 00:00:45,909
how to explain and show it to you.

10
00:00:45,910 --> 00:00:50,980
但这太简单了，我想如果我把自己的解决方法记录下来会很酷的。

11
00:00:50,980 --> 00:00:54,070
it, kind of like a blind solve or a speedrun.

12
00:00:54,070 --> 00:00:58,540
但我没有试着超快，但它是相当直接的，我包括所有

13
00:00:58,539 --> 00:01:01,109
the mistakes and pauses I made.

14
00:01:01,109 --> 00:01:04,969
现在我们来看看视频，我向你解释一下我的想法

15
00:01:04,970 --> 00:01:08,380
in different moments and point out some other things.

16
00:01:08,380 --> 00:01:12,520
在右上角，您还可以看到一个计时器，它将跟踪多长时间

17
00:01:12,520 --> 00:01:14,400
took me in real time.

18
00:01:14,399 --> 00:01:17,789
But before we start doing the exploit let’s have a look at the code again.

19
00:01:17,789 --> 00:01:21,259
There are two functions winner() and nowinner().

20
00:01:21,259 --> 00:01:23,789
And obviously we have to somehow call winner().

21
00:01:23,789 --> 00:01:29,989
We can also see there are two structs that get space allocated for them on the heap.

22
00:01:29,990 --> 00:01:34,860
这里的fp构造看起来很复杂，但是你可以忽略这种奇怪，因为

23
00:01:34,859 --> 00:01:38,059
when you look in the code it’s clear what it does.

24
00:01:38,060 --> 00:01:40,500
We set fp to nowinner.

25
00:01:40,500 --> 00:01:45,380
Notice how nowinner has no parantheses, this means it’s not being called.

26
00:01:45,380 --> 00:01:50,830
This is literally the function pointer and adding paraentheses would cause a call.

27
00:01:50,829 --> 00:01:54,579
And then later we have those paraentheses for fp.

28
00:01:54,579 --> 00:02:00,229
And fp has been set to point to nowinner, so nowinner is executed().

29
00:02:00,229 --> 00:02:05,179
我们的目标是以某种方式使用strcpy，它将溢出名称缓冲区

30
00:02:05,179 --> 00:02:09,699
is only 64byte large and overwrite the function pointer.

31
00:02:09,700 --> 00:02:12,310
So sounds easy.

32
00:02:12,310 --> 00:02:15,010
I start by opening up the binary in gdb.

33
00:02:15,010 --> 00:02:21,310
做第一次测试，但是我遇到了一个segfault，它让我吃惊了几秒钟，

34
00:02:21,310 --> 00:02:25,010
but then I realized I forgot the argument parameter again.

35
00:02:25,010 --> 00:02:29,010
The strcpy uses the first argument to copy into name.

36
00:02:29,010 --> 00:02:32,080
Ok now we had a clean execution.

37
00:02:32,080 --> 00:02:35,720
Now I want to set a good breakpoint so I disassemble main.

38
00:02:35,720 --> 00:02:39,910
我在这里快速扫描汇编程序代码，主要是查看不同的函数

39
00:02:39,910 --> 00:02:43,890
calls to figure out what corresponds to what in the C code.

40
00:02:43,890 --> 00:02:49,490
起初我想在strcpy之前或之后设置一个断点，

41
00:02:49,490 --> 00:02:55,030
抓住溢出的前后，但在最后一刻，我发现

42
00:02:55,030 --> 00:03:00,370
可能不需要仔细观察，我可以直接进入魔法状态

43
00:03:00,370 --> 00:03:01,370
right away.

44
00:03:01,370 --> 00:03:03,370
The call rdx.

45
00:03:03,370 --> 00:03:07,050
This is calling the function pointer that contains nowinner().

46
00:03:07,050 --> 00:03:11,490
Ok, so I execute it again and we hit the breakpoint.

47
00:03:11,489 --> 00:03:15,879
现在这个挑战是关于堆溢出的，所以我首先检查

48
00:03:15,879 --> 00:03:18,149
the process with vmmap.

49
00:03:18,150 --> 00:03:22,520
在这里，您可以看到哪些内存区域中有二进制代码和数据

50
00:03:22,520 --> 00:03:27,150
段，我们还可以看到堆栈在哪里，以及像libc这样的共享库在哪里。

51
00:03:27,150 --> 00:03:30,580
loaded too, and we also have the heap here.

52
00:03:30,580 --> 00:03:34,370
So obviously I want to check out how the heap looks like.

53
00:03:34,370 --> 00:03:38,050
Examine 32 64bit hex values from the start of the heap.

54
00:03:38,050 --> 00:03:43,900
我立即查找我们作为参数输入的名称，它是“aaaa”，所以这里

55
00:03:43,900 --> 00:03:44,900
they are.

56
00:03:44,900 --> 00:03:47,910
And I also immediately look for the function pointer.

57
00:03:47,909 --> 00:03:50,039
This looks like an address.

58
00:03:50,040 --> 00:03:53,180
Quick sanity check with the disassemble command.

59
00:03:53,180 --> 00:03:58,100
Here is a puts call using this address as a paremter, and so that is our nowinner string.

60
00:03:58,099 --> 00:04:00,439
So yep, that’s nowinner.

61
00:04:00,439 --> 00:04:04,639
So now we want to overwrite that with winner, so we need that address.

62
00:04:04,640 --> 00:04:06,220
Here it is.

63
00:04:06,219 --> 00:04:10,839
接下来，我需要弄清楚我们需要溢出多少，为了实现这一点，我只需看看

64
00:04:10,840 --> 00:04:13,280
addresses to the left.

65
00:04:13,280 --> 00:04:20,680
Address of the start of the name ends in 0x10, and the function pointer is ath 0x60.

66
00:04:20,680 --> 00:04:23,710
So we have an offset of 0x50.

67
00:04:23,710 --> 00:04:28,220
所以现在我很自信，实际上退出了gdb，希望能有个工作。

68
00:04:28,220 --> 00:04:30,080
exploit right away.

69
00:04:30,080 --> 00:04:34,550
So I start by writing a short python inline script to print the exploit string.

70
00:04:34,550 --> 00:04:39,520
实际上，我们需要几个字符作为填充来到达函数指针和

71
00:04:39,520 --> 00:04:41,520
so I print a few As.

72
00:04:41,520 --> 00:04:47,690
Quick check again how many that was, 0x60-0x10 so we need 0x50.

73
00:04:47,690 --> 00:04:50,240
After that we need the address of winner.

74
00:04:50,240 --> 00:04:52,610
所以0x40，哎呀！

75
00:04:52,610 --> 00:04:56,620
几乎犯了一个错误-这个问题有时会发生在我身上，显然我们必须开始

76
00:04:56,620 --> 00:05:00,290
with 0xf6, 0x05 and then 0x40.

77
00:05:00,290 --> 00:05:01,980
Because of the endianess.

78
00:05:01,979 --> 00:05:06,789
现在，对于一个健全的和调试步骤，我将输出管道导入hexdump，看看它是否是

79
00:05:06,790 --> 00:05:07,890
I expect.

80
00:05:07,889 --> 00:05:13,039
But then I notice a 0x0a at the end, and that’s a newline.

81
00:05:13,040 --> 00:05:16,950
Python print will add a newline at the end which we don’t want.

82
00:05:16,949 --> 00:05:22,069
因此，现在我将脚本改为使用sys模块来直接写入

83
00:05:22,069 --> 00:05:25,429
a string to stdout, so we don’t have a newline.

84
00:05:25,430 --> 00:05:29,570
And I verify that again with hexdump.

85
00:05:29,569 --> 00:05:35,809
And then I’m basically done and try it on the target binary.

86
00:05:35,810 --> 00:05:43,730
所以输入作为参数传递，所以我使用反勾号来执行内部python命令，

87
00:05:43,729 --> 00:05:49,479
and the output is then basically replaced by it and placed here as the arguments.

88
00:05:49,479 --> 00:05:50,659
平地通过！

89
00:05:50,660 --> 00:05:51,660
令人惊叹的！

90
00:05:51,660 --> 00:05:54,480
I executed the winner function().

91
00:05:54,479 --> 00:05:57,049
You see this was super simple.

92
00:05:57,050 --> 00:06:01,550
所以当我用录音带上的解说词写这个剧本时，我注意到

93
00:06:01,550 --> 00:06:03,890
detail that I didn’t think about.

94
00:06:03,889 --> 00:06:06,239
And I actually never thought about before.

95
00:06:06,240 --> 00:06:08,510
So here is the heap output again.

96
00:06:08,509 --> 00:06:10,449
你看到下面的数据了吗？

97
00:06:10,449 --> 00:06:12,079
That is clearly ascii.

98
00:06:12,080 --> 00:06:17,520
And that’s weird, in our program we did not allocate any string like this on the heap.

99
00:06:17,520 --> 00:06:19,260
这是怎么发生的？

100
00:06:19,259 --> 00:06:24,629
When you look at this ascii text, then you will realize it’s in fact the printf output.

101
00:06:24,630 --> 00:06:26,270
但为什么会这样？

102
00:06:26,270 --> 00:06:28,090
Let’s investigate.

103
00:06:28,090 --> 00:06:31,300
First I thought we could checkout valgrind.

104
00:06:31,300 --> 00:06:35,120
Valgrind is an instrumentation framework for building dynamic analysis tools.

105
00:06:35,120 --> 00:06:39,540
Valgrind工具可以自动检测许多内存管理和线程

106
00:06:39,540 --> 00:06:41,770
bugs, and profile your programs in detail.

107
00:06:41,770 --> 00:06:45,750
I really should use valgrind more often, I use it wayy to little.

108
00:06:45,750 --> 00:06:50,470
But here is for example the valgrind output with tracing mallocs enabled.

109
00:06:50,470 --> 00:06:52,660
And then we run our heap0 level.

110
00:06:52,660 --> 00:06:58,160
我们在这里可以看到我们所做的结构的两个malloc，也可以看到malloc

111
00:06:58,160 --> 00:07:00,440
didn’t do of 1024.

112
00:07:00,440 --> 00:07:04,140
That’s also the only memory that is freed again.

113
00:07:04,139 --> 00:07:06,659
The mallocs we do have no free.

114
00:07:06,660 --> 00:07:08,780
为什么会这样？

115
00:07:08,780 --> 00:07:11,400
Another interesting output is strace.

116
00:07:11,400 --> 00:07:13,280
Strace traces syscalls.

117
00:07:13,280 --> 00:07:18,340
虽然我们在这里看不到malloc，因为malloc只是一些算法和内存管理。

118
00:07:18,340 --> 00:07:24,740
在libc中实现，我们可以看到brk syscall，它从操作系统获取内存。

119
00:07:24,740 --> 00:07:26,190
in the first place.

120
00:07:26,190 --> 00:07:30,750
So this is where we get memory that will then be used by libc for the heap.

121
00:07:30,750 --> 00:07:36,590
所以如果malloc是libc函数，我们也可以检查ltrace，它跟踪链接的动态

122
00:07:36,590 --> 00:07:38,430
library function calls.

123
00:07:38,430 --> 00:07:42,740
But oddly enough we only see two mallocs for the two structs.

124
00:07:42,740 --> 00:07:45,610
Nothing about the mysterious third malloc.

125
00:07:45,610 --> 00:07:50,100
这可能不是很明显，但实际上已经是一个很好的提示

126
00:07:50,099 --> 00:07:55,399
the mysterious malloc did not happen from a dynamically linked library call.

127
00:07:55,400 --> 00:08:00,520
Which means, this malloc must have been executed for example by libc itself.

128
00:08:00,520 --> 00:08:05,910
And valgrind is a bit smarter and also traces these internal mallocs.

129
00:08:05,909 --> 00:08:11,759
For the third test I create a simple program that calls puts, so it prints a string.

130
00:08:11,760 --> 00:08:16,490
因为我们知道堆确实包含printf输出，所以它必须对

131
00:08:16,490 --> 00:08:17,540
that.

132
00:08:17,539 --> 00:08:22,199
And then we can debug that program and set a breakpoint on brk.

133
00:08:22,199 --> 00:08:26,389
记住，brk是当程序请求其他虚拟机时调用的系统调用

134
00:08:26,389 --> 00:08:30,049
memory, and so this is called when the heap is set up.

135
00:08:30,050 --> 00:08:33,640
And the heap is not always setup, only if it is required.

136
00:08:33,640 --> 00:08:40,250
So if we assume printf or puts calls malloc, it would have to setup the heap first.

137
00:08:40,250 --> 00:08:44,630
这也是我创建这个小测试程序的原因，因为原来的heap0

138
00:08:44,630 --> 00:08:49,380
显然，打印前有规则的malloc，这让它有点烦人，所以这是

139
00:08:49,380 --> 00:08:51,280
a clean example.

140
00:08:51,280 --> 00:08:56,760
第二个注意事项是，当您使用BRK这样的符号名设置断点时，必须

141
00:08:56,760 --> 00:08:58,300
be a symbol name for it.

142
00:08:58,300 --> 00:09:01,070
And a syscall doesn’t have a symbol name.

143
00:09:01,070 --> 00:09:05,900
系统调用是一个以数字作为参数来指示

144
00:09:05,900 --> 00:09:08,460
syscall you want.

145
00:09:08,460 --> 00:09:12,310
But there is a brk symbol, but it’s not initially found.

146
00:09:12,310 --> 00:09:17,560
首先必须执行该程序才能加载动态库libc，这是

147
00:09:17,560 --> 00:09:19,840
contain a brk symbol.

148
00:09:19,840 --> 00:09:25,400
And infact that is a regular function as a wrapper around the brk syscall.

149
00:09:25,400 --> 00:09:30,580
所以libc中的任何内容都不会直接执行syscall中断，它会调用

150
00:09:30,580 --> 00:09:32,780
internal brk function.

151
00:09:32,780 --> 00:09:37,070
So that;s why we can easily set a breakpoint like this.

152
00:09:37,070 --> 00:09:41,460
长话短说，我们现在可以继续并点击该断点，然后检查函数

153
00:09:41,460 --> 00:09:47,420
backtrace which tells us which functions have been called that lead to this brk call.

154
00:09:47,420 --> 00:09:49,480
I clean that up a bit.

155
00:09:49,480 --> 00:09:50,480
So here we go.

156
00:09:50,480 --> 00:09:53,500
And as you can see it starts with IO_puts.

157
00:09:53,500 --> 00:09:58,210
你也可以看看这些东西的libc代码，我刚刚打开了libc的镜子

158
00:09:58,210 --> 00:10:01,410
on github, and you can read the code there.

159
00:10:01,410 --> 00:10:06,290
为什么函数不被称为puts，但io_puts，eventhough we only use

160
00:10:06,290 --> 00:10:10,990
puts when we call it, has to do with a lot of C macros in libc.

161
00:10:10,990 --> 00:10:13,860
I find it really difficult to read that code.

162
00:10:13,860 --> 00:10:20,520
例如，我们知道下一个函数的符号名为“IO”new“file”xsputn，但是

163
00:10:20,520 --> 00:10:22,770
that doesn’t show up in the C code.

164
00:10:22,770 --> 00:10:29,060
但是有一个类似的叫做io_sputn，当你往上看的时候，它会导致一个宏

165
00:10:29,060 --> 00:10:32,530
that says that it’s actually IO_Xsputn.

166
00:10:32,530 --> 00:10:39,660
它本身是另一个以xputn作为第一个参数的jump2宏，并且

167
00:10:39,660 --> 00:10:41,530
JUMP2 is obviously another macro.

168
00:10:41,530 --> 00:10:43,750
And it just keeps going like that.

169
00:10:43,750 --> 00:10:45,510
Feel free to do that on your own.

170
00:10:45,510 --> 00:10:50,610
But if we trust our trace we can see that at some point it calls doallocbuffer.

171
00:10:50,610 --> 00:10:54,780
And there is also a comment saying: “Allocate a buffer if needed”.

172
00:10:54,780 --> 00:11:00,690
So this 1024 byte malloc has to do with the standard output buffer.

173
00:11:00,690 --> 00:11:06,460
printf不会立即导致syscall写入，但libc实现了很多

174
00:11:06,460 --> 00:11:11,750
像这样的东西，为了获得更高的性能，通过缓冲输出而不是

175
00:11:11,750 --> 00:11:16,950
waiting for files, or writing a few bigger chunks instead of a lot of small pieces.

176
00:11:16,950 --> 00:11:17,950
Yeah.

177
00:11:17,950 --> 00:11:20,750
I would consider this a solved mystery.

178
00:11:20,750 --> 00:11:23,750
Just a little excursion into the inner workings of programs.

179
00:11:23,750 --> 00:11:25,230
I hope you liked that.

180
00:11:25,230 --> 00:11:25,730
See you next week.

