1
00:00:00,130 --> 00:00:04,670
你现在应该熟悉这个堆栈了
来自原恒星的0级，尤其是我们的

2
00:00:04,670 --> 00:00:08,900
快速查看编译时发生的情况
这是现代系统的代码。

3
00:00:08,900 --> 00:00:11,450
特别是与栈cookies。

4
00:00:11,450 --> 00:00:14,890
在这段视频中，我想开发一个工作漏洞
为了它。

5
00:00:14,889 --> 00:00:21,479
相信我，我们有几座山
必须克服。

6
00:00:21,480 --> 00:00:27,330
让我们让每个人都尽快赶上进度。

7
00:00:27,329 --> 00:00:29,899
我们有一个简单的缓冲区溢出漏洞。

8
00:00:29,899 --> 00:00:36,999
最初的目标是溢出到另一个
变量来更改if案例的结果。

9
00:00:37,000 --> 00:00:42,010
但这是不可能的，因为
缓冲区现在放在变量-not之后

10
00:00:42,010 --> 00:00:43,010
以前。

11
00:00:43,010 --> 00:00:48,330
为了执行我们想要的案件，我们可以
可能溢出堆栈上的返回指针

12
00:00:48,330 --> 00:00:51,390
然后简单地将代码执行重定向到那里。

13
00:00:51,390 --> 00:00:57,400
但我们面临的一个问题是堆栈cookie
其中包含三个随机字节

14
00:00:57,400 --> 00:00:59,690
函数返回前检查。

15
00:00:59,690 --> 00:01:03,600
所以为了溢出返回指针
我们得猜一下饼干。

16
00:01:03,600 --> 00:01:09,040
这意味着我们必须写一个漏洞
一次又一次地执行目标，百万

17
00:01:09,039 --> 00:01:14,299
有时总是猜测一堆饼干，
最终我们应该走运。

18
00:01:14,299 --> 00:01:19,359
但在我们写代码之前，我们先
开发利用，就好像我们知道cookie一样

19
00:01:19,360 --> 00:01:20,360
价值。

20
00:01:20,360 --> 00:01:25,670
这个输入必须是正确的
一旦我们猜到正确的cookie值，就开始工作。

21
00:01:25,670 --> 00:01:28,450
所以我们必须大量调试它。

22
00:01:28,450 --> 00:01:33,420
让我们从打开gdb中的二进制文件开始。
用peda扩展，使它看起来

23
00:01:33,420 --> 00:01:38,120
再好一点，让我们输入一堆角色
为了观察发生了什么。

24
00:01:38,119 --> 00:01:39,959
检测到OOPS堆栈粉碎。

25
00:01:39,960 --> 00:01:42,660
我们显然想忽略这一点。

26
00:01:42,659 --> 00:01:47,149
所以让我们在它前面设置一个断点
会继续堆叠失败。

27
00:01:47,149 --> 00:01:53,049
然后把EIP设置到它会跳的地方
如果曲奇是正确的。

28
00:01:53,049 --> 00:01:58,349
通过简单的命令指令，我们可以自动化
每次命中此断点时都是这样。

29
00:01:58,350 --> 00:02:00,810
然后继续。

30
00:02:00,810 --> 00:02:04,090
分割错误，这就是我们要做的
期待。

31
00:02:04,090 --> 00:02:05,090
令人惊叹的。

32
00:02:05,090 --> 00:02:06,090
哦…

33
00:02:06,090 --> 00:02:07,860
返回时出现分段错误？

34
00:02:07,859 --> 00:02:15,039
不是SegFault，因为我们重定向了代码执行
去错误的记忆？

35
00:02:15,040 --> 00:02:16,790
查看堆栈寄存器。

36
00:02:16,790 --> 00:02:22,080
esp指向无效内存，因此当
退货是构造想要查找退货

37
00:02:22,080 --> 00:02:27,480
它试图跟踪的堆栈上的指针
esp指向，这显然是访问

38
00:02:27,480 --> 00:02:29,250
内存无效。

39
00:02:29,250 --> 00:02:33,660
该死的…我们是怎么改写和修改的
堆栈指针？

40
00:02:33,660 --> 00:02:36,680
让我们再看一次拆解。

41
00:02:36,680 --> 00:02:39,390
就在回来之前。

42
00:02:39,390 --> 00:02:46,550
所以一个基指针引用的值，
所以栈上的一个值被移动到ecx中。

43
00:02:46,550 --> 00:02:52,020
然后计算ECX-4，它变成
新的堆栈指针。

44
00:02:52,020 --> 00:02:55,780
当我们看到这个开始的时候
函数，我们可以看到堆栈指针

45
00:02:55,780 --> 00:03:00,520
-4存储在ECX中并被推到堆栈中。

46
00:03:00,520 --> 00:03:05,230
因此堆栈指针也保存在
栈。

47
00:03:05,230 --> 00:03:09,730
我认为这是另一种缓解措施，
因为在我们能够控制

48
00:03:09,730 --> 00:03:13,710
返回指针，我们首先要控制
堆栈指针。

49
00:03:13,710 --> 00:03:17,210
起初这似乎不是问题，
因为这意味着我们必须写一个

50
00:03:17,210 --> 00:03:21,960
有效的堆栈指针并将其指向
我们控制的缓冲区，然后返回

51
00:03:21,960 --> 00:03:26,100
拿着我们控制的返回指针
缓冲静电除尘器指向和我们赢。

52
00:03:26,100 --> 00:03:31,960
但问题是，这个现代体系也有
现在ASLR。

53
00:03:31,960 --> 00:03:38,260
我们可以看到，如果我们在
调试程序并运行几次。

54
00:03:38,260 --> 00:03:39,530
观察ESP值。

55
00:03:39,530 --> 00:03:41,170
总是不一样的。

56
00:03:41,170 --> 00:03:45,850
我承认这不是完全随机的，但是
我们还需要猜测更多的字节。

57
00:03:45,850 --> 00:03:51,470
并点击cookie和有效的堆栈地址
开始看起来不好了。

58
00:03:51,470 --> 00:03:57,630
假设我们知道基本记忆
那对我们有帮助吗？

59
00:03:57,630 --> 00:03:59,650
这里还有更多。

60
00:03:59,650 --> 00:04:04,800
让我们重新运行程序，然后
时间让我们看看ESP指向何处并进行比较

61
00:04:04,800 --> 00:04:07,350
到堆栈在内存中实际开始的位置。

62
00:04:07,350 --> 00:04:13,910
当你这样做几次，你可以很快
你看，这个esp和

63
00:04:13,910 --> 00:04:15,250
堆栈真的开始了。

64
00:04:15,250 --> 00:04:20,630
事实上，有一个巨大的差距与随机
在

65
00:04:20,630 --> 00:04:25,920
在esp指向的代码中使用的堆栈
以及环境变量

66
00:04:25,920 --> 00:04:29,250
在堆栈内存的实际开始处
面积。

67
00:04:29,250 --> 00:04:35,430
我认为这是另一种随机化值的方法，
因为aslr只会随机化

68
00:04:35,430 --> 00:04:41,320
地址的一部分，这样也可以
较低的字节会变得不可预测。

69
00:04:41,320 --> 00:04:44,310
剥削的游戏已经明显改变了。

70
00:04:44,310 --> 00:04:46,870
还有更多的障碍。

71
00:04:46,870 --> 00:04:48,910
这是否意味着现在游戏结束了？

72
00:04:48,910 --> 00:04:51,000
它不再是可利用的了？

73
00:04:51,000 --> 00:04:53,260
我们不能用一个输入溢出来完成它？

74
00:04:53,260 --> 00:04:54,260
好。

75
00:04:54,260 --> 00:04:55,540
有一条路。

76
00:04:55,540 --> 00:04:56,810
但我们必须有创造力。

77
00:04:56,810 --> 00:04:59,290
现在不那么容易了。

78
00:04:59,290 --> 00:05:04,600
好吧，我们就知道这堆饼干
我们相信这是无法改变的。

79
00:05:04,600 --> 00:05:09,160
假设我们找到了正确的cookie，
我们从那里怎么走？

80
00:05:09,160 --> 00:05:13,090
我们知道存储了一个有效的堆栈指针
在饼干之后，对吗？

81
00:05:13,090 --> 00:05:18,340
开始时保存了esp的值
最后又恢复了。

82
00:05:18,340 --> 00:05:20,570
这意味着我们可以滥用它。

83
00:05:20,570 --> 00:05:23,720
我们不需要覆盖整个指针。

84
00:05:23,720 --> 00:05:28,400
如果我们只是破坏了第一个字节，那么
地址的最低部分。

85
00:05:28,400 --> 00:05:33,500
这意味着堆栈指针保持有效
但突然指向一个稍有不同的

86
00:05:33,500 --> 00:05:35,230
堆栈内存。

87
00:05:35,230 --> 00:05:40,820
也许我们可以稍微指出
我们控制的缓冲区，只是一点点

88
00:05:40,820 --> 00:05:43,940
低于此处存储的esp值。

89
00:05:43,940 --> 00:05:50,300
然后我们恢复这个稍微偏离的值，
现在可以按地址返回

90
00:05:50,300 --> 00:05:54,400
进入有效的堆栈内存并获取地址
回到那里。

91
00:05:54,400 --> 00:05:59,240
如果它现在指向我们的缓冲区，我们可以
控制我们想要返回的地方，我们可以

92
00:05:59,240 --> 00:06:03,190
回到印出我们目标的国际单项体育联合会案例中。

93
00:06:03,190 --> 00:06:08,170
我们可以通过编写足够的数据来实现这一点
到缓冲区，这样我们就可以填满

94
00:06:08,169 --> 00:06:13,809
离开存储的堆栈指针，因为
字符串以C中的零字节结尾，为空

95
00:06:13,810 --> 00:06:19,300
将写入
存储了esp值，因此使其更小，

96
00:06:19,300 --> 00:06:21,280
当我们幸运的时候，它指向我们的缓冲区。

97
00:06:21,280 --> 00:06:23,390
我们来计算一下长度。

98
00:06:23,390 --> 00:06:29,040
所以当我们使用长输入运行它时，我们
看到esp被ssss覆盖了。

99
00:06:29,040 --> 00:06:35,150
一个字节比其他字节低4，因此
变成了一个被ECX-4烧灼的O。

100
00:06:35,150 --> 00:06:39,080
所以这意味着我们要在
那。

101
00:06:39,080 --> 00:06:43,930
当我们现在运行它时，我们看到esp结束了
现在在FC。

102
00:06:43,930 --> 00:06:48,890
所以它起作用了，因为我们预测
堆栈上的部分被0覆盖，并且

103
00:06:48,890 --> 00:06:54,790
因为ECX-4，所以0-4我们最终
FC。

104
00:06:54,790 --> 00:06:59,500
但正如你所看到的，我们没有幸运，
esp指向的不是我们的缓冲区。

105
00:06:59,500 --> 00:07:06,160
但是让我们重新运行几次然后
同样，在某个时候，我们会很幸运，

106
00:07:06,160 --> 00:07:08,440
现在，esp指向我们的缓冲区。

107
00:07:08,440 --> 00:07:14,340
当我们现在返回时，我们实际上返回了
进入4d4d4d4d，即mmmm。

108
00:07:14,340 --> 00:07:16,700
它奏效了。

109
00:07:16,700 --> 00:07:21,090
实际上零填充的随机化
在堆栈上可以实现这一点，因为在某些情况下

110
00:07:21,090 --> 00:07:26,260
指向地址的最低随机值
将是正确的，因此0是正确的

111
00:07:26,260 --> 00:07:30,200
使esp指向我们的缓冲区的变化量。

112
00:07:30,199 --> 00:07:33,169
但你也看到它不是100%可靠。

113
00:07:33,169 --> 00:07:38,689
我们必须猜对饼干然后
希望电除尘器随机化也不错

114
00:07:38,690 --> 00:07:39,690
对我们来说。

115
00:07:39,690 --> 00:07:44,020
但这很常见，所以我希望
这已经足够普遍了，仍然使其可行。

116
00:07:44,020 --> 00:07:47,300
所以现在我们要做的就是把它组合起来。

117
00:07:47,300 --> 00:07:49,650
让我们编写一个快速的python脚本。

118
00:07:49,650 --> 00:07:53,140
我们导入结构以将地址转换为
4字节字符串。

119
00:07:53,139 --> 00:07:55,459
小lambda助手函数。

120
00:07:55,460 --> 00:07:59,730
然后我们简单地利用字符串
用我们的地址填充缓冲区

121
00:07:59,729 --> 00:08:01,609
希望返回。

122
00:08:01,610 --> 00:08:05,990
我们希望能让esp指向这个领域。

123
00:08:05,990 --> 00:08:09,760
然后是cookie值，我们
后来不得不写一些残忍的逻辑

124
00:08:09,759 --> 00:08:10,759
为了。

125
00:08:10,759 --> 00:08:15,169
之后又有4个字节，这就是
它。

126
00:08:15,169 --> 00:08:16,389
然后我们打印出来。

127
00:08:16,389 --> 00:08:17,389
看起来不错。

128
00:08:17,389 --> 00:08:20,519
您可以看到原始字节是用hexdump输出的。

129
00:08:20,520 --> 00:08:21,650
把它写进一个文件。

130
00:08:21,650 --> 00:08:26,460
让我们在cookie检查时设置一个断点
确保曲奇在正确的位置。

131
00:08:26,460 --> 00:08:30,630
然后我们可以在gdb中使用该文件作为输入。

132
00:08:30,630 --> 00:08:32,520
第一个断点是cookie检查。

133
00:08:32,520 --> 00:08:36,820
我们可以看到我们用
厨师。

134
00:08:36,820 --> 00:08:41,150
现在，当我按下"继续"时，另一个断点
从早到晚都会撞到并跳过饼干

135
00:08:41,151 --> 00:08:42,711
检查一下，我们到达返回点。

136
00:08:42,710 --> 00:08:44,510
哦，看看那个。

137
00:08:44,510 --> 00:08:49,080
我们很幸运有了ESP和ESP的分数
进入我们的缓冲区。

138
00:08:49,080 --> 00:08:55,350
当我们现在继续的时候，我们回到国际单项体育联合会的案例中
打印修改后的字符串。

139
00:08:55,350 --> 00:08:56,950
就在那里。

140
00:08:56,950 --> 00:08:57,950
太神了！

141
00:08:57,950 --> 00:09:00,630
所以这项研究在理论上是可行的。

142
00:09:00,630 --> 00:09:03,700
剩下的就是饼干的野蛮变形。

143
00:09:03,700 --> 00:09:06,570
不幸的是，这应该是它自己的一集。
再一次。

144
00:09:06,570 --> 00:09:10,830
这只是编程，但你要做
我可以学到很多关于Linux的知识

145
00:09:10,830 --> 00:09:12,350
想挤进去吗？

146
00:09:12,350 --> 00:09:13,980
同样，试着自己做那个部分。

147
00:09:13,980 --> 00:09:15,250
你真的可以学到很多。

