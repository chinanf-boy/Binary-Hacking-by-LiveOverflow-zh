1
00:00:00,130 --> 00:00:04,670
您现在应该熟悉原恒星的0级堆栈，尤其是我们的

2
00:00:04,670 --> 00:00:08,900
quick look at what happens when you compile this code on a modern system.

3
00:00:08,900 --> 00:00:11,450
Specifically with the stack cookies.

4
00:00:11,450 --> 00:00:14,890
In this video I wanna develop a working exploit for it.

5
00:00:14,889 --> 00:00:21,479
And believe me there are a few mountains we have to overcome.

6
00:00:21,480 --> 00:00:27,330
Let’s get everybody quickly on track.

7
00:00:27,329 --> 00:00:29,899
We have a simple buffer overflow vulnerability.

8
00:00:29,899 --> 00:00:36,999
Originally the goal was to overflow into another variable to change the outcome of an if case.

9
00:00:37,000 --> 00:00:42,010
但这已经不可能了，因为缓冲区现在放在变量之后-不是

10
00:00:42,010 --> 00:00:43,010
before.

11
00:00:43,010 --> 00:00:48,330
所以为了执行我们想要的if case，我们可能会溢出堆栈上的返回指针。

12
00:00:48,330 --> 00:00:51,390
and simply redirect the code execution there.

13
00:00:51,390 --> 00:00:57,400
但我们面临的一个问题是栈cookie，它包含三个随机字节，

14
00:00:57,400 --> 00:00:59,690
checked before the function returns.

15
00:00:59,690 --> 00:01:03,600
So in order to overflow the return pointer we would have to guess the cookie.

16
00:01:03,600 --> 00:01:09,040
这意味着我们必须编写一个漏洞来一遍又一遍地执行目标，数以百万计

17
00:01:09,039 --> 00:01:14,299
of times always guessing a stack cookie, and eventually we should get lucky.

18
00:01:14,299 --> 00:01:19,359
但是在我们编写代码之前，让我们先开发利用，就像我们知道cookie一样

19
00:01:19,360 --> 00:01:20,360
value.

20
00:01:20,360 --> 00:01:25,670
This input really must be correct in order to work once we guess the correct cookie value.

21
00:01:25,670 --> 00:01:28,450
So we have to debug this heavily.

22
00:01:28,450 --> 00:01:33,420
让我们从用peda扩展打开gdb中的二进制文件开始，这使得它看起来

23
00:01:33,420 --> 00:01:38,120
nicer and let’s just enter a loooot of characters in order to observe what happens.

24
00:01:38,119 --> 00:01:39,959
Oops stack smashing detected.

25
00:01:39,960 --> 00:01:42,660
We obviously want to ignore that.

26
00:01:42,659 --> 00:01:47,149
So let’s set a breakpoint just before it would continue to __stack_chk_fail.

27
00:01:47,149 --> 00:01:53,049
And then set eip to where it would have jumped to if the cookie was correct.

28
00:01:53,049 --> 00:01:58,349
With a simple commands directive we can automate this everytime this breakpoint is hit.

29
00:01:58,350 --> 00:02:00,810
Then continue.

30
00:02:00,810 --> 00:02:04,090
Segmentation fault, that’s what we would expect.

31
00:02:04,090 --> 00:02:05,090
Awesome.

32
00:02:05,090 --> 00:02:06,090
哦…

33
00:02:06,090 --> 00:02:07,860
返回时出现分段错误？

34
00:02:07,859 --> 00:02:15,039
不是SegFault，因为我们将代码执行重定向到故障内存？

35
00:02:15,040 --> 00:02:16,790
Look at the stack register.

36
00:02:16,790 --> 00:02:22,080
esp指向无效的内存，因此当返回是构造时要查找返回

37
00:02:22,080 --> 00:02:27,480
它试图跟踪esp指向的堆栈上的指针，这显然是在访问

38
00:02:27,480 --> 00:02:29,250
invalid memory.

39
00:02:29,250 --> 00:02:33,660
该死的…我们是怎么覆盖和修改堆栈指针的？

40
00:02:33,660 --> 00:02:36,680
Let’s look again in the disassembly.

41
00:02:36,680 --> 00:02:39,390
Down here just before the return.

42
00:02:39,390 --> 00:02:46,550
So a value referenced by the base pointer, so a value on the stack is moved into ecx.

43
00:02:46,550 --> 00:02:52,020
And then ecx -4 is calculated and that becomes the new stack pointer.

44
00:02:52,020 --> 00:02:55,780
当我们看到这个函数的开头时，我们可以看到堆栈指针

45
00:02:55,780 --> 00:03:00,520
-4 is stored in ecx and pushed on to the stack.

46
00:03:00,520 --> 00:03:05,230
So the stack pointer is also saved on the stack.

47
00:03:05,230 --> 00:03:09,730
我认为这是另一种缓解措施，因为在我们能够控制

48
00:03:09,730 --> 00:03:13,710
return pointer, we first have to control the stack pointer.

49
00:03:13,710 --> 00:03:17,210
起初这似乎不是问题，因为这意味着我们必须写一个

50
00:03:17,210 --> 00:03:21,960
有效的堆栈指针并将其指向我们控制的缓冲区，然后返回将

51
00:03:21,960 --> 00:03:26,100
take the return pointer we control in the buffer esp points to and we win.

52
00:03:26,100 --> 00:03:31,960
But the issue is this modern system also has now ASLR.

53
00:03:31,960 --> 00:03:38,260
We can see that if we re-enable aslr in the debugger and run it a few times.

54
00:03:38,260 --> 00:03:39,530
Observe the esp value.

55
00:03:39,530 --> 00:03:41,170
It’s always different.

56
00:03:41,170 --> 00:03:45,850
I admit it’s not fully random, but it’s more bytes we would have to guess.

57
00:03:45,850 --> 00:03:51,470
And to hit the cookie AND a valid stack address is starting to look bad.

58
00:03:51,470 --> 00:03:57,630
假设我们知道堆栈的基本内存，这对我们有帮助吗？

59
00:03:57,630 --> 00:03:59,650
There is even more here.

60
00:03:59,650 --> 00:04:04,800
让我们重新运行程序，这次让我们看看esp指向何处并进行比较。

61
00:04:04,800 --> 00:04:07,350
it to where the stack actually starts in memory.

62
00:04:07,350 --> 00:04:13,910
当你这样做几次，你可以很快看到，特别是在不同的地方。

63
00:04:13,910 --> 00:04:15,250
the stack really starts.

64
00:04:15,250 --> 00:04:20,630
事实上，在

65
00:04:20,630 --> 00:04:25,920
我们在esp指向的代码中使用的堆栈，以及

66
00:04:25,920 --> 00:04:29,250
at the actual beginning of the stack memory area.

67
00:04:29,250 --> 00:04:35,430
我认为这是另一种随机化值的方法，因为aslr只会随机化上面的值

68
00:04:35,430 --> 00:04:41,320
parts of an address and this way also the lower bytes become unpredictable.

69
00:04:41,320 --> 00:04:44,310
The game of exploitation has clearly changed.

70
00:04:44,310 --> 00:04:46,870
There are more hurdles.

71
00:04:46,870 --> 00:04:48,910
这是否意味着现在游戏结束了？

72
00:04:48,910 --> 00:04:51,000
它不再是可利用的了？

73
00:04:51,000 --> 00:04:53,260
我们不能用一个输入溢出来完成它？

74
00:04:53,260 --> 00:04:54,260
Well.

75
00:04:54,260 --> 00:04:55,540
there is a way.

76
00:04:55,540 --> 00:04:56,810
But we have to get creative.

77
00:04:56,810 --> 00:04:59,290
It’s not that easy anymore.

78
00:04:59,290 --> 00:05:04,600
Ok so we know there is a cookie on the stack and we believe it’s bruteforceable.

79
00:05:04,600 --> 00:05:09,160
So let’s assume we found the correct cookie, how do we go from there.

80
00:05:09,160 --> 00:05:13,090
我们知道有效的堆栈指针存储在cookie之后，对吗？

81
00:05:13,090 --> 00:05:18,340
The value of esp was saved at the beginning and restored here at the end again.

82
00:05:18,340 --> 00:05:20,570
which means we can abuse that.

83
00:05:20,570 --> 00:05:23,720
we don’t have to overwrite the whole pointer.

84
00:05:23,720 --> 00:05:28,400
What if we just corrupt the first byte, so the lowest part of the address.

85
00:05:28,400 --> 00:05:33,500
这意味着堆栈指针保持有效，但突然指向稍微不同的

86
00:05:33,500 --> 00:05:35,230
stack memory.

87
00:05:35,230 --> 00:05:40,820
也许我们可以让它稍微指向我们控制的缓冲区，这只是一点

88
00:05:40,820 --> 00:05:43,940
lower than the stored esp value here.

89
00:05:43,940 --> 00:05:50,300
然后我们恢复这个稍微偏离的值，返回值现在可以跟随地址指向

90
00:05:50,300 --> 00:05:54,400
into valid stack memory and take the address there to return into.

91
00:05:54,400 --> 00:05:59,240
如果它现在指向我们的缓冲区，我们可以控制我们想要返回的位置，我们可以

92
00:05:59,240 --> 00:06:03,190
return into the if-case that prints our goal.

93
00:06:03,190 --> 00:06:08,170
我们可以通过向缓冲区写入足够的数据来实现这一点，这样我们就可以在短时间内填满

94
00:06:08,169 --> 00:06:13,809
从存储的堆栈指针，由于字符串以C中的零字节结尾，因此

95
00:06:13,810 --> 00:06:19,300
将写入存储的esp值的最低部分，从而使其更小，

96
00:06:19,300 --> 00:06:21,280
and when we are lucky it points into our buffer.

97
00:06:21,280 --> 00:06:23,390
Let’s figure out the length.

98
00:06:23,390 --> 00:06:29,040
So when we run it with the long input, we see that esp got overwritten with SSSS.

99
00:06:29,040 --> 00:06:35,150
One byte is 4 lower than the others, thus became an O, which was cauysed by the ecx-4.

100
00:06:35,150 --> 00:06:39,080
So this means we want to stop right before that.

101
00:06:39,080 --> 00:06:43,930
And when we run it now, we see that esp ends now in fc.

102
00:06:43,930 --> 00:06:48,890
所以它起作用了，因为我们预测堆栈中的最低部分将被0覆盖，

103
00:06:48,890 --> 00:06:54,790
because of ecx-4, so 0 - 4 we end up with fc.

104
00:06:54,790 --> 00:06:59,500
But as you can see, we didn’t get lucky, esp points to not our buffer.

105
00:06:59,500 --> 00:07:06,160
但是，让我们重新运行它几次，并做同样的事情，在某个时刻，我们会很幸运，并且

106
00:07:06,160 --> 00:07:08,440
now esp points to our buffer.

107
00:07:08,440 --> 00:07:14,340
And when we now return we actually return into 4d4d4d4d, which is MMMM.

108
00:07:14,340 --> 00:07:16,700
It worked.

109
00:07:16,700 --> 00:07:21,090
实际上，堆栈上零填充的随机化使这项工作得以实现，因为在某些情况下

110
00:07:21,090 --> 00:07:26,260
点地址的最低随机值将是正确的，因此0是正确的

111
00:07:26,260 --> 00:07:30,200
amount of change so esp points into our buffer.

112
00:07:30,199 --> 00:07:33,169
But you also see it’s not 100% reliable.

113
00:07:33,169 --> 00:07:38,689
我们必须猜测cookie是正确的，然后希望esp随机化也很好。

114
00:07:38,690 --> 00:07:39,690
to us.

115
00:07:39,690 --> 00:07:44,020
But that’s fairly common so I hope that it’s common enough to still make it feasible.

116
00:07:44,020 --> 00:07:47,300
So now all that we have to do is, put it together.

117
00:07:47,300 --> 00:07:49,650
Let’s write a quick python script.

118
00:07:49,650 --> 00:07:53,140
We import struct to convert the address to 4 byte strings.

119
00:07:53,139 --> 00:07:55,459
Little lambda helper function for that.

120
00:07:55,460 --> 00:07:59,730
然后我们简单地让我们的漏洞字符串用我们的地址填充缓冲区

121
00:07:59,729 --> 00:08:01,609
want to return to.

122
00:08:01,610 --> 00:08:05,990
We hope we can make esp point into this area.

123
00:08:05,990 --> 00:08:09,760
然后是cookie值，稍后我们必须编写一些野蛮的逻辑

124
00:08:09,759 --> 00:08:10,759
for.

125
00:08:10,759 --> 00:08:15,169
Afterwards then comes 4 more bytes, and that’s it.

126
00:08:15,169 --> 00:08:16,389
Then we print it.

127
00:08:16,389 --> 00:08:17,389
Looks good.

128
00:08:17,389 --> 00:08:20,519
You see the raw bytes are output with hexdump.

129
00:08:20,520 --> 00:08:21,650
Write it to a file.

130
00:08:21,650 --> 00:08:26,460
Let’s set a breakpoint at the cookie check to make sure the cookie is in the right place.

131
00:08:26,460 --> 00:08:30,630
And then we can use the file as input in gdb.

132
00:08:30,630 --> 00:08:32,520
First breakpoint was the cookie check.

133
00:08:32,520 --> 00:08:36,820
And we can see we overwrite the cookie with COOK.

134
00:08:36,820 --> 00:08:41,150
现在，当我按下Continue时，前面的另一个断点将命中并跳过tghe cookie

135
00:08:41,151 --> 00:08:42,711
check and we reach the return.

136
00:08:42,710 --> 00:08:44,510
Oh and look at that.

137
00:08:44,510 --> 00:08:49,080
We got lucky with esp and esp actually points into our buffer.

138
00:08:49,080 --> 00:08:55,350
When we now continue we return into the if-case that prints the modified string.

139
00:08:55,350 --> 00:08:56,950
And there it is.

140
00:08:56,950 --> 00:08:57,950
太神了！

141
00:08:57,950 --> 00:09:00,630
So the exploit theoretically works.

142
00:09:00,630 --> 00:09:03,700
All that is left, is the cookie bruteforcing.

143
00:09:03,700 --> 00:09:06,570
Unfortunately that deserves it’s own episode again.

144
00:09:06,570 --> 00:09:10,830
这只是编程，但做了它，你可以学到很多关于Linux的知识，而我不知道

145
00:09:10,830 --> 00:09:12,350
wanna squeeze it in here.

146
00:09:12,350 --> 00:09:13,980
Again, try to do that part yourself.

147
00:09:13,980 --> 00:09:15,250
You could really learn alot.

