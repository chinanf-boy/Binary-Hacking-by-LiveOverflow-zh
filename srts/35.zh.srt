1
00:00:00,130 --> 00:00:04,670
您现在应该熟悉原恒星的0级堆栈，尤其是我们的

2
00:00:04,670 --> 00:00:08,900
快速查看在现代系统上编译此代码时会发生什么。

3
00:00:08,900 --> 00:00:11,450
特别是与栈cookies。

4
00:00:11,450 --> 00:00:14,890
在这段视频中，我想为它开发一个工作漏洞。

5
00:00:14,889 --> 00:00:21,479
相信我，还有几座山我们必须克服。

6
00:00:21,480 --> 00:00:27,330
让我们让每个人都尽快赶上进度。

7
00:00:27,329 --> 00:00:29,899
我们有一个简单的缓冲区溢出漏洞。

8
00:00:29,899 --> 00:00:36,999
最初的目标是溢出到另一个变量中，以更改if案例的结果。

9
00:00:37,000 --> 00:00:42,010
但这已经不可能了，因为缓冲区现在放在变量之后-不是

10
00:00:42,010 --> 00:00:43,010
以前。

11
00:00:43,010 --> 00:00:48,330
所以为了执行我们想要的if case，我们可能会溢出堆栈上的返回指针。

12
00:00:48,330 --> 00:00:51,390
然后简单地将代码执行重定向到那里。

13
00:00:51,390 --> 00:00:57,400
但我们面临的一个问题是栈cookie，它包含三个随机字节，

14
00:00:57,400 --> 00:00:59,690
函数返回前检查。

15
00:00:59,690 --> 00:01:03,600
所以为了溢出返回指针，我们必须猜测cookie。

16
00:01:03,600 --> 00:01:09,040
这意味着我们必须编写一个漏洞来一遍又一遍地执行目标，数以百万计

17
00:01:09,039 --> 00:01:14,299
有时我们总是猜测一堆饼干，最终我们应该走运。

18
00:01:14,299 --> 00:01:19,359
但是在我们编写代码之前，让我们先开发利用，就像我们知道cookie一样

19
00:01:19,360 --> 00:01:20,360
价值。

20
00:01:20,360 --> 00:01:25,670
一旦我们猜测到正确的cookie值，这个输入必须是正确的才能工作。

21
00:01:25,670 --> 00:01:28,450
所以我们必须大量调试它。

22
00:01:28,450 --> 00:01:33,420
让我们从用peda扩展打开gdb中的二进制文件开始，这使得它看起来

23
00:01:33,420 --> 00:01:38,120
好的，让我们输入一堆字符来观察发生了什么。

24
00:01:38,119 --> 00:01:39,959
检测到OOPS堆栈粉碎。

25
00:01:39,960 --> 00:01:42,660
我们显然想忽略这一点。

26
00:01:42,659 --> 00:01:47,149
所以让我们设置一个断点，在它继续堆栈失败之前。

27
00:01:47,149 --> 00:01:53,049
然后将EIP设置为如果cookie是正确的，它会跳到的位置。

28
00:01:53,049 --> 00:01:58,349
通过一个简单的命令指令，我们可以在每次点击这个断点时自动执行这个操作。

29
00:01:58,350 --> 00:02:00,810
然后继续。

30
00:02:00,810 --> 00:02:04,090
分段错误，这是我们所期望的。

31
00:02:04,090 --> 00:02:05,090
令人惊叹的。

32
00:02:05,090 --> 00:02:06,090
哦…

33
00:02:06,090 --> 00:02:07,860
返回时出现分段错误？

34
00:02:07,859 --> 00:02:15,039
不是SegFault，因为我们将代码执行重定向到故障内存？

35
00:02:15,040 --> 00:02:16,790
查看堆栈寄存器。

36
00:02:16,790 --> 00:02:22,080
esp指向无效的内存，因此当返回是构造时要查找返回

37
00:02:22,080 --> 00:02:27,480
它试图跟踪esp指向的堆栈上的指针，这显然是在访问

38
00:02:27,480 --> 00:02:29,250
内存无效。

39
00:02:29,250 --> 00:02:33,660
该死的…我们是怎么覆盖和修改堆栈指针的？

40
00:02:33,660 --> 00:02:36,680
让我们再看一次拆解。

41
00:02:36,680 --> 00:02:39,390
就在回来之前。

42
00:02:39,390 --> 00:02:46,550
所以一个被基指针引用的值，所以堆栈上的一个值被移动到ECX中。

43
00:02:46,550 --> 00:02:52,020
然后计算ECX-4，它就成为新的堆栈指针。

44
00:02:52,020 --> 00:02:55,780
当我们看到这个函数的开头时，我们可以看到堆栈指针

45
00:02:55,780 --> 00:03:00,520
-4存储在ECX中并被推到堆栈中。

46
00:03:00,520 --> 00:03:05,230
所以堆栈指针也保存在堆栈上。

47
00:03:05,230 --> 00:03:09,730
我认为这是另一种缓解措施，因为在我们能够控制

48
00:03:09,730 --> 00:03:13,710
返回指针，我们首先必须控制堆栈指针。

49
00:03:13,710 --> 00:03:17,210
起初这似乎不是问题，因为这意味着我们必须写一个

50
00:03:17,210 --> 00:03:21,960
有效的堆栈指针并将其指向我们控制的缓冲区，然后返回将

51
00:03:21,960 --> 00:03:26,100
拿着我们在缓冲区控制的返回指针esp指向，我们就赢了。

52
00:03:26,100 --> 00:03:31,960
但问题是，这个现代系统现在也有了ASLR。

53
00:03:31,960 --> 00:03:38,260
我们可以看到，如果我们在调试器中重新启用ASLR并运行它几次。

54
00:03:38,260 --> 00:03:39,530
观察ESP值。

55
00:03:39,530 --> 00:03:41,170
总是不一样的。

56
00:03:41,170 --> 00:03:45,850
我承认这不是完全随机的，但我们要猜的是更多的字节。

57
00:03:45,850 --> 00:03:51,470
如果命中cookie，那么有效的堆栈地址就开始变得糟糕了。

58
00:03:51,470 --> 00:03:57,630
假设我们知道堆栈的基本内存，这对我们有帮助吗？

59
00:03:57,630 --> 00:03:59,650
这里还有更多。

60
00:03:59,650 --> 00:04:04,800
让我们重新运行程序，这次让我们看看esp指向何处并进行比较。

61
00:04:04,800 --> 00:04:07,350
到堆栈在内存中实际开始的位置。

62
00:04:07,350 --> 00:04:13,910
当你这样做几次，你可以很快看到，特别是在不同的地方。

63
00:04:13,910 --> 00:04:15,250
堆栈真的开始了。

64
00:04:15,250 --> 00:04:20,630
事实上，在

65
00:04:20,630 --> 00:04:25,920
我们在esp指向的代码中使用的堆栈，以及

66
00:04:25,920 --> 00:04:29,250
在堆栈内存区的实际开始处。

67
00:04:29,250 --> 00:04:35,430
我认为这是另一种随机化值的方法，因为aslr只会随机化上面的值

68
00:04:35,430 --> 00:04:41,320
地址的一部分，这样，较低的字节也会变得不可预测。

69
00:04:41,320 --> 00:04:44,310
剥削的游戏已经明显改变了。

70
00:04:44,310 --> 00:04:46,870
还有更多的障碍。

71
00:04:46,870 --> 00:04:48,910
这是否意味着现在游戏结束了？

72
00:04:48,910 --> 00:04:51,000
它不再是可利用的了？

73
00:04:51,000 --> 00:04:53,260
我们不能用一个输入溢出来完成它？

74
00:04:53,260 --> 00:04:54,260
好。

75
00:04:54,260 --> 00:04:55,540
有一条路。

76
00:04:55,540 --> 00:04:56,810
但我们必须有创造力。

77
00:04:56,810 --> 00:04:59,290
现在不那么容易了。

78
00:04:59,290 --> 00:05:04,600
好吧，所以我们知道在堆栈上有一个cookie，我们相信它是无法处理的。

79
00:05:04,600 --> 00:05:09,160
所以假设我们找到了正确的cookie，我们该怎么做呢？

80
00:05:09,160 --> 00:05:13,090
我们知道有效的堆栈指针存储在cookie之后，对吗？

81
00:05:13,090 --> 00:05:18,340
esp的值在开始时保存，在结束时再次恢复到这里。

82
00:05:18,340 --> 00:05:20,570
这意味着我们可以滥用它。

83
00:05:20,570 --> 00:05:23,720
我们不需要覆盖整个指针。

84
00:05:23,720 --> 00:05:28,400
如果我们只是破坏了地址的第一个字节，那么地址的最低部分。

85
00:05:28,400 --> 00:05:33,500
这意味着堆栈指针保持有效，但突然指向稍微不同的

86
00:05:33,500 --> 00:05:35,230
堆栈内存。

87
00:05:35,230 --> 00:05:40,820
也许我们可以让它稍微指向我们控制的缓冲区，这只是一点

88
00:05:40,820 --> 00:05:43,940
低于此处存储的esp值。

89
00:05:43,940 --> 00:05:50,300
然后我们恢复这个稍微偏离的值，返回值现在可以跟随地址指向

90
00:05:50,300 --> 00:05:54,400
到有效的堆栈内存中，并获取要返回的地址。

91
00:05:54,400 --> 00:05:59,240
如果它现在指向我们的缓冲区，我们可以控制我们想要返回的位置，我们可以

92
00:05:59,240 --> 00:06:03,190
回到印出我们目标的国际单项体育联合会案例中。

93
00:06:03,190 --> 00:06:08,170
我们可以通过向缓冲区写入足够的数据来实现这一点，这样我们就可以在短时间内填满

94
00:06:08,169 --> 00:06:13,809
从存储的堆栈指针，由于字符串以C中的零字节结尾，因此

95
00:06:13,810 --> 00:06:19,300
将写入存储的esp值的最低部分，从而使其更小，

96
00:06:19,300 --> 00:06:21,280
当我们幸运的时候，它指向我们的缓冲区。

97
00:06:21,280 --> 00:06:23,390
我们来计算一下长度。

98
00:06:23,390 --> 00:06:29,040
所以当我们使用长输入运行它时，我们看到esp被sss覆盖了。

99
00:06:29,040 --> 00:06:35,150
一个字节比其他字节低4，因此成为一个O，被ECX-4烧灼。

100
00:06:35,150 --> 00:06:39,080
所以这意味着我们要在那之前就停下来。

101
00:06:39,080 --> 00:06:43,930
当我们现在运行它时，我们看到esp现在在fc中结束。

102
00:06:43,930 --> 00:06:48,890
所以它起作用了，因为我们预测堆栈中的最低部分将被0覆盖，

103
00:06:48,890 --> 00:06:54,790
因为ECX-4，所以0-4我们以FC结束。

104
00:06:54,790 --> 00:06:59,500
但正如你所看到的，我们并没有幸运，特别是指我们的缓冲区。

105
00:06:59,500 --> 00:07:06,160
但是，让我们重新运行它几次，并做同样的事情，在某个时刻，我们会很幸运，并且

106
00:07:06,160 --> 00:07:08,440
现在，esp指向我们的缓冲区。

107
00:07:08,440 --> 00:07:14,340
当我们现在返回时，我们实际上返回到4d4d4d4d，也就是mmmm。

108
00:07:14,340 --> 00:07:16,700
它奏效了。

109
00:07:16,700 --> 00:07:21,090
实际上，堆栈上零填充的随机化使这项工作得以实现，因为在某些情况下

110
00:07:21,090 --> 00:07:26,260
点地址的最低随机值将是正确的，因此0是正确的

111
00:07:26,260 --> 00:07:30,200
使esp指向我们的缓冲区的变化量。

112
00:07:30,199 --> 00:07:33,169
但你也看到它不是100%可靠。

113
00:07:33,169 --> 00:07:38,689
我们必须猜测cookie是正确的，然后希望esp随机化也很好。

114
00:07:38,690 --> 00:07:39,690
对我们来说。

115
00:07:39,690 --> 00:07:44,020
但这是相当普遍的，所以我希望它足够普遍，仍然使其可行。

116
00:07:44,020 --> 00:07:47,300
所以现在我们要做的就是把它组合起来。

117
00:07:47,300 --> 00:07:49,650
让我们编写一个快速的python脚本。

118
00:07:49,650 --> 00:07:53,140
我们导入结构以将地址转换为4个字节的字符串。

119
00:07:53,139 --> 00:07:55,459
小lambda助手函数。

120
00:07:55,460 --> 00:07:59,730
然后我们简单地让我们的漏洞字符串用我们的地址填充缓冲区

121
00:07:59,729 --> 00:08:01,609
希望返回。

122
00:08:01,610 --> 00:08:05,990
我们希望能让esp指向这个领域。

123
00:08:05,990 --> 00:08:09,760
然后是cookie值，稍后我们必须编写一些野蛮的逻辑

124
00:08:09,759 --> 00:08:10,759
为了。

125
00:08:10,759 --> 00:08:15,169
然后又有4个字节，就是这样。

126
00:08:15,169 --> 00:08:16,389
然后我们打印出来。

127
00:08:16,389 --> 00:08:17,389
看起来不错。

128
00:08:17,389 --> 00:08:20,519
您可以看到原始字节是用hexdump输出的。

129
00:08:20,520 --> 00:08:21,650
把它写进一个文件。

130
00:08:21,650 --> 00:08:26,460
让我们在cookie检查处设置一个断点，以确保cookie在正确的位置。

131
00:08:26,460 --> 00:08:30,630
然后我们可以在gdb中使用该文件作为输入。

132
00:08:30,630 --> 00:08:32,520
第一个断点是cookie检查。

133
00:08:32,520 --> 00:08:36,820
我们可以看到我们用库克覆盖了饼干。

134
00:08:36,820 --> 00:08:41,150
现在，当我按下Continue时，前面的另一个断点将命中并跳过tghe cookie

135
00:08:41,151 --> 00:08:42,711
检查一下，我们到达返回点。

136
00:08:42,710 --> 00:08:44,510
哦，看看那个。

137
00:08:44,510 --> 00:08:49,080
我们很幸运有了电除尘器，电除尘器实际上指向了我们的缓冲区。

138
00:08:49,080 --> 00:08:55,350
当我们现在继续时，我们返回到打印修改后字符串的if案例中。

139
00:08:55,350 --> 00:08:56,950
就在那里。

140
00:08:56,950 --> 00:08:57,950
太神了！

141
00:08:57,950 --> 00:09:00,630
所以这项研究在理论上是可行的。

142
00:09:00,630 --> 00:09:03,700
剩下的就是饼干的野蛮变形。

143
00:09:03,700 --> 00:09:06,570
不幸的是，这又应该成为自己的一集。

144
00:09:06,570 --> 00:09:10,830
这只是编程，但做了它，你可以学到很多关于Linux的知识，而我不知道

145
00:09:10,830 --> 00:09:12,350
想挤进去吗？

146
00:09:12,350 --> 00:09:13,980
同样，试着自己做那个部分。

147
00:09:13,980 --> 00:09:15,250
你真的可以学到很多。

