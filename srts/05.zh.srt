1
00:00:06,279 --> 00:00:08,919
现在我想介绍一下CPU的工作原理。

2
00:00:08,920 --> 00:00:13,430
我希望我能消除对装配工的恐惧
你可能有，因为它实际上很漂亮

3
00:00:13,430 --> 00:00:14,430
简单。

4
00:00:14,430 --> 00:00:20,590
在下一个视频中，您将能够
用这个破解你的第一个小程序。

5
00:00:20,590 --> 00:00:25,190
首先我有一个很长的剧本
尝试开发CPU步骤的概念

6
00:00:25,190 --> 00:00:26,190
循序渐进。

7
00:00:26,190 --> 00:00:29,700
但我意识到时间太长了
我想我没有明白这一点。

8
00:00:29,701 --> 00:00:34,641
但后来我偶然发现了这个黑客游戏
由星际战斗机制造。

9
00:00:34,640 --> 00:00:37,050
这段视频，starfighters.io不可用
然而。

10
00:00:37,050 --> 00:00:39,710
但是当你在这里看到这个的时候，它应该会上升
然后跑步。

11
00:00:39,710 --> 00:00:41,130
所以去看看。

12
00:00:41,130 --> 00:00:47,480
那个网站的创建者已经上传了
作为游戏预览的文章。

13
00:00:47,480 --> 00:00:53,590
那篇预告是一篇关于倒车的虚构报道
一种用于金融交易的手持设备。

14
00:00:53,589 --> 00:00:58,299
即使是虚构的，也不是
与现实中的情况相去甚远。

15
00:00:58,300 --> 00:01:01,170
所以我强烈建议你阅读
它。

16
00:01:01,170 --> 00:01:05,560
但我现在就要参加他们
介绍程序集并讨论

17
00:01:05,561 --> 00:01:07,301
它周围多一点。

18
00:01:07,300 --> 00:01:10,680
然后我希望你能开始理解
CPU的工作原理。

19
00:01:10,680 --> 00:01:16,560
一个CPU有惊人的简单概念，可以
用于解决非常复杂的任务。

20
00:01:16,560 --> 00:01:18,060
太疯狂了。

21
00:01:18,060 --> 00:01:21,840
我希望你能意识到，到最后
视频。

22
00:01:21,840 --> 00:01:26,700
想象一下，只要一张纸，
从上到下写指令。

23
00:01:26,700 --> 00:01:29,800
这是您的内存，就像您计算机中的RAM。

24
00:01:29,799 --> 00:01:36,259
纸上的每一行都有一个编号，
就像记忆中的位置有地址一样。

25
00:01:36,259 --> 00:01:41,179
所以在记忆中，不是纸上的第5行
它有点像十六进制地址

26
00:01:41,180 --> 00:01:42,730
0x400 5dB。

27
00:01:42,730 --> 00:01:48,720
所以那张纸，或者你知道，你的记忆里
程序集代码。

28
00:01:48,719 --> 00:01:52,249
但是汇编代码能做什么呢？

29
00:01:52,250 --> 00:01:56,950
首先，我们给你8-32个全局
要使用的固定大小变量，以及

30
00:01:56,950 --> 00:01:59,560
它们被称为"寄存器"。

31
00:01:59,560 --> 00:02:03,120
所以你的CPU，取决于你的架构
有很多这样的寄存器。

32
00:02:03,121 --> 00:02:04,121
例如，64位Intel CPU
16，17，也许更多？

33
00:02:04,121 --> 00:02:05,121
有点取决于你的计算方式。

34
00:02:05,121 --> 00:02:06,121
但一般来说，这就是登记册的数量
你经常看到或使用的。

35
00:02:06,121 --> 00:02:07,121
不管怎样。

36
00:02:07,121 --> 00:02:08,551
他们称这些寄存器为"全局变量"，
他们就是这样。

37
00:02:08,550 --> 00:02:13,370
就像在C或Python编程中一样
你可以像变量一样使用它们。

38
00:02:13,370 --> 00:02:19,430
在其中存储一个值并执行一些算术运算
在它们上面加或乘。

39
00:02:19,430 --> 00:02:21,790
这里的下一个关键字是固定大小。

40
00:02:21,790 --> 00:02:24,750
在32位机器中，它们是32位宽。

41
00:02:24,750 --> 00:02:28,350
在64位机器中，它们有64位。

42
00:02:28,349 --> 00:02:32,759
所以这是你能储存的最大的数字
在其中一个寄存器中。

43
00:02:32,760 --> 00:02:36,930
当你想要更大的数字时，
显然你必须写代码来拆分

44
00:02:36,930 --> 00:02:40,780
在多个寄存器上增加数字。

45
00:02:40,780 --> 00:02:43,600
其中一些寄存器是特殊寄存器。

46
00:02:43,599 --> 00:02:48,259
最重要的是"程序
计数器"，它告诉CPU哪个指令

47
00:02:48,260 --> 00:02:50,480
我们下一步要执行。

48
00:02:50,480 --> 00:02:54,840
每次执行一条指令，我们都会前进
程序计数器。

49
00:02:54,840 --> 00:03:00,740
这个寄存器通常被称为PC，意思是
程序计数器，但在我们的Intel x86体系结构上

50
00:03:00,739 --> 00:03:03,599
它被称为指令指针。

51
00:03:03,599 --> 00:03:04,599
IP。

52
00:03:04,599 --> 00:03:10,499
或EIP，或RIP-取决于16位、32位
或64位模式。

53
00:03:10,500 --> 00:03:15,130
所以当你看你的论文的时候
在每一行中，指令指针寄存器

54
00:03:15,129 --> 00:03:18,829
将具有将要
下一步执行。

55
00:03:18,830 --> 00:03:21,670
我们也经常提到这一点。

56
00:03:21,670 --> 00:03:26,310
所以指令指针指向行
5.

57
00:03:26,310 --> 00:03:30,510
当它执行了那个指令
它将增加一个，移动到

58
00:03:30,510 --> 00:03:32,190
下一行。

59
00:03:32,190 --> 00:03:37,050
几乎所有的计算都用
寄存器上简单操作的术语。

60
00:03:37,049 --> 00:03:39,219
让我们做个例子。

61
00:03:39,220 --> 00:03:42,820
在x86汇编程序中，可以将数字移入
语域

62
00:03:42,819 --> 00:03:45,229
就像"mov eax，5"。

63
00:03:45,230 --> 00:03:48,180
这意味着EAX现在将具有
5.

64
00:03:48,180 --> 00:03:51,770
然后你可以在上面加一个3这样的数字。

65
00:03:51,770 --> 00:03:54,500
'添加EAX，3'。

66
00:03:54,500 --> 00:03:57,260
现在让我们将另一个寄存器设置为value
8.

67
00:03:57,260 --> 00:04:00,680
所以"mov ebx，8"。

68
00:04:00,680 --> 00:04:05,780
然后你可以用"sub"减去那些
Eax，EBX’。

69
00:04:05,780 --> 00:04:12,130
这意味着从EAX中减去EBX
结果存储在EAX中。

70
00:04:12,129 --> 00:04:16,069
但真正的程序需要32个以上的1字节
要使用的变量。

71
00:04:16,070 --> 00:04:17,070
登记册上不适合的东西就住在
记忆。

72
00:04:17,070 --> 00:04:22,270
在我们的x86架构中，
超过16个64位寄存器，其中

73
00:04:22,271 --> 00:04:23,771
是8字节。

74
00:04:23,770 --> 00:04:26,710
想象一下在里面写一个超级马里奥这样的游戏
装配。

75
00:04:26,710 --> 00:04:31,850
你得把马里奥的X/Y位置储存起来，
生命，敌人，硬币。

76
00:04:31,850 --> 00:04:34,730
你只需要16个以上的变量。

77
00:04:34,729 --> 00:04:39,739
当你想收集超过32位
硬币的价值，你需要更多的空间。

78
00:04:39,740 --> 00:04:43,470
下一点是，什么不适合寄存器
生活在记忆中。

79
00:04:43,470 --> 00:04:47,530
你可以用报纸的其他部分
如果没有可存储更多程序集代码

80
00:04:47,530 --> 00:04:48,530
价值观。

81
00:04:48,530 --> 00:04:50,090
有道理，对吧？

82
00:04:50,090 --> 00:04:54,770
通过加载和存储访问内存
地址，就好像它是一个大数组，或者

83
00:04:54,770 --> 00:04:57,690
通过堆栈上的推和弹出操作。

84
00:04:57,690 --> 00:05:02,090
因此加载和存储指令被调用
移入x86汇编程序。

85
00:05:02,090 --> 00:05:06,900
所以我们可以从内存地址中移动值
在寄存器中，我们可以将值从

86
00:05:06,900 --> 00:05:08,210
存储器中的寄存器。

87
00:05:08,210 --> 00:05:09,210
例如"mov eax，[0x4005db]"。

88
00:05:09,210 --> 00:05:10,260
有不同的语法你可以写
汇编程序。

89
00:05:10,259 --> 00:05:12,769
我最喜欢英特尔汇编程序语法。

90
00:05:12,770 --> 00:05:16,490
所以在这种情况下，括号就像括号一样
从数组或列表中。

91
00:05:16,490 --> 00:05:22,640
例如在python中访问
在一个列表中，你可以写"我的清单"[5]

92
00:05:22,639 --> 00:05:25,339
获取索引5处的元素。

93
00:05:25,340 --> 00:05:30,000
所以我们基本上是一样的，只是
一个非常大的数字0x4005db，因为我们的RAM

94
00:05:30,000 --> 00:05:31,920
非常大。

95
00:05:31,919 --> 00:05:35,479
他们还谈论推送和弹出操作
在堆栈上。

96
00:05:35,479 --> 00:05:39,379
堆栈只是一个区域
在记忆的底部。

97
00:05:39,380 --> 00:05:41,670
就像在报纸的底部。

98
00:05:41,669 --> 00:05:47,519
然后你有一个特别的登记册
总是指向堆栈的顶部。

99
00:05:47,520 --> 00:05:49,640
堆栈指针sp。

100
00:05:49,639 --> 00:05:50,639
或ESP。

101
00:05:50,639 --> 00:05:51,639
或RSP。

102
00:05:51,639 --> 00:05:53,159
它和指令指针很特别。

103
00:05:53,160 --> 00:05:58,910
当你把一个新的价值推到
堆栈，例如"push 5"，堆栈指针

104
00:05:58,910 --> 00:06:04,580
将递增，指向下一个
地址和值将放在那里。

105
00:06:04,580 --> 00:06:09,940
当您执行"pop eax"时，
将保存堆栈指针的地址

106
00:06:09,940 --> 00:06:14,260
在EAX寄存器和堆栈指针中
将递减。

107
00:06:14,259 --> 00:06:16,589
它一直在程序中使用。

108
00:06:16,590 --> 00:06:17,590
嗯…

109
00:06:17,590 --> 00:06:19,040
我必须纠正自己。

110
00:06:19,040 --> 00:06:20,800
这堆东西通常是颠倒的。

111
00:06:20,800 --> 00:06:23,460
所以堆栈向下增长。

112
00:06:23,460 --> 00:06:27,210
意味着它从最高的地址开始
当我们推一个值时，我们不会增加

113
00:06:27,210 --> 00:06:31,420
堆栈指针，我们递减它。与
POP反之亦然。

114
00:06:31,419 --> 00:06:32,439
但并不重要。

115
00:06:32,440 --> 00:06:38,860
想象一下一堆东西，你在哪里
把东西放在上面，或者拿走。

116
00:06:38,860 --> 00:06:43,980
内存是一个汇编程序的什么
磁盘指向Ruby或Python程序：您将

117
00:06:43,979 --> 00:06:48,199
把记忆中的事情变为变量，做事情
和他们在一起，最后把他们放回

118
00:06:48,199 --> 00:06:49,799
记忆。

119
00:06:49,800 --> 00:06:51,930
现在，当我们谈论效率和速度时。

120
00:06:51,930 --> 00:06:55,070
那么寄存器上的计算是超级的
快。

121
00:06:55,069 --> 00:06:58,579
理想情况下，你的整个计划应该只
使用寄存器。

122
00:06:58,580 --> 00:07:02,830
但因为你不太可能
有时将值存入内存，因为

123
00:07:02,830 --> 00:07:05,610
更复杂的东西需要登记册。

124
00:07:05,610 --> 00:07:09,330
但是如果你要优化你的代码，你会
总是要确保访问内存

125
00:07:09,330 --> 00:07:10,810
尽可能少。

126
00:07:10,810 --> 00:07:11,810
好。

127
00:07:11,810 --> 00:07:15,950
这也是半真半假，因为你
类似于CPU附近的缓存。

128
00:07:15,949 --> 00:07:17,449
实际上是多级缓存。

129
00:07:17,449 --> 00:07:22,229
所以如果你重复使用某个记忆
地址，它将缓存在一个特殊的超级

130
00:07:22,229 --> 00:07:24,679
CPU附近的超高速内存，不在
猛撞。

131
00:07:24,680 --> 00:07:26,630
这还不错。

132
00:07:26,630 --> 00:07:28,540
但你明白了。

133
00:07:28,539 --> 00:07:33,199
控制流程是通过gotos完成的---跳转，
分支或调用。

134
00:07:33,199 --> 00:07:35,579
这个
这些指令的作用是改变

135
00:07:35,580 --> 00:07:37,910
直接编程计数器。

136
00:07:37,910 --> 00:07:42,790
控制流意味着CPU将更少
如果它只是执行您的程序，那么很有用

137
00:07:42,789 --> 00:07:45,979
一行接一行，不能跳到
在别的地方。

138
00:07:45,979 --> 00:07:49,359
例如，要重复一个任务，您需要
不断地向后跳。

139
00:07:49,360 --> 00:07:52,890
在汇编程序中，您有不同的指令
这样做。

140
00:07:52,889 --> 00:07:56,069
它们被称为跳跃、分支或
电话。

141
00:07:56,069 --> 00:07:59,819
它们基本上都改变了指令
指向其他值的指针。

142
00:07:59,819 --> 00:08:05,449
所以当你读到"跳跃2"时，你会
只需将指令指针设置为2，然后

143
00:08:05,449 --> 00:08:07,049
继续这一行。

144
00:08:07,050 --> 00:08:08,980
有点像"mov eip，2"

145
00:08:08,979 --> 00:08:12,669
跳跃只是一种无条件的Goto。

146
00:08:12,669 --> 00:08:17,489
所以当你遇到跳跃时，你会
跟着它走。

147
00:08:17,490 --> 00:08:23,750
但对于复杂的任务更有趣
就是做决定下一步要计算什么。

148
00:08:23,750 --> 00:08:27,320
寄存器上的大多数操作，比如加法
和减法，有

149
00:08:27,319 --> 00:08:31,799
改变状态标志的副作用，如
"最后计算的值

150
00:08:31,800 --> 00:08:32,820
结果是零"。

151
00:08:32,820 --> 00:08:37,810
只有几个状态标志，它们
通常住在一个特别的登记册里。

152
00:08:37,810 --> 00:08:43,980
例如，当我们之前在
带有"添加EAX，3"结果的5

153
00:08:43,980 --> 00:08:47,980
大于零，所以零标志
尚未设置。

154
00:08:47,980 --> 00:08:49,220
或者仅仅是0。

155
00:08:49,220 --> 00:08:56,250
但是当我们用'sub'减去8
EAX，8’，结果将为0，因此启用

156
00:08:56,250 --> 00:08:59,260
零标志，设置为1。

157
00:08:59,260 --> 00:09:04,620
分支只是被预测的goto
在状态标志上，比如"转到这个地址"

158
00:09:04,620 --> 00:09:08,290
仅当最后一个算术运算结果
"零"。

159
00:09:08,290 --> 00:09:13,630
在x86组件中，这将是"je"
指令。

160
00:09:13,630 --> 00:09:17,890
听起来很奇怪，但是如果两个
值相等？

161
00:09:17,890 --> 00:09:22,430
你可以简单地减去它们，当它们
结果为0，它们相等，因此设置

162
00:09:22,430 --> 00:09:23,430
零标志。

163
00:09:23,430 --> 00:09:29,560
因此，如果
零标志设置为"简单"Jump if Equal。

164
00:09:29,560 --> 00:09:34,500
打电话就是无条件的
按堆栈上的下一个地址，因此

165
00:09:34,500 --> 00:09:40,170
RET指令可以稍后弹出并保持
去电话中断的地方。

166
00:09:40,170 --> 00:09:44,220
所以早些时候我解释了如何推和弹出
指导工作。

167
00:09:44,220 --> 00:09:48,360
所以这个堆栈的一个非常巧妙的用法是
调用指令。

168
00:09:48,360 --> 00:09:50,860
假设在C语言中，你想调用一个函数。

169
00:09:50,860 --> 00:09:52,750
在汇编程序中你会怎么做？

170
00:09:52,750 --> 00:09:57,600
尤其是因为函数可能被使用
在多个地方，所以你总是想

171
00:09:57,600 --> 00:09:59,840
从你来的地方跳回来。

172
00:09:59,840 --> 00:10:05,550
如果只使用"jmp"指令，
您必须指定确切的地址。

173
00:10:05,550 --> 00:10:09,330
所以你能做的就是使用"调用"指令
相反。

174
00:10:09,330 --> 00:10:14,220
这将推动指令指针
堆栈上的下一条指令。

175
00:10:14,220 --> 00:10:19,190
当你跳到最后的时候，
它将执行"ret"指令。

176
00:10:19,190 --> 00:10:23,710
RET将当前值弹出顶部
将堆栈放入指令指针

177
00:10:23,710 --> 00:10:24,710
再一次。

178
00:10:24,710 --> 00:10:26,330
就像"流行EIP"。

179
00:10:26,330 --> 00:10:30,790
所以我们可以继续执行最初的
来自。

180
00:10:30,790 --> 00:10:34,580
在我们完成这段视频之前，我只想
为了说明，汇编程序指令

181
00:10:34,580 --> 00:10:36,080
实际上只是数字。

182
00:10:36,080 --> 00:10:42,270
如你所知，计算机只能存储0和
1s，我们通常把它们表示为数字。

183
00:10:42,270 --> 00:10:45,730
所以汇编程序代码并没有说"mov"
EAX，5’。

184
00:10:45,730 --> 00:10:51,170
它实际上是"B8 05 00 00 00"。

185
00:10:51,170 --> 00:10:58,420
十六进制B8表示"mov eax"，其余的
号码可用于您想要的号码

186
00:10:58,420 --> 00:11:00,790
进入EAX。

187
00:11:00,790 --> 00:11:05,340
所以当硬件读取这个数字时，
知道它必须移动以下号码

188
00:11:05,340 --> 00:11:07,120
在它的EAX寄存器中。

189
00:11:07,120 --> 00:11:12,750
而反汇编程序是一个需要
这个数字B8和使可读文本输出

190
00:11:12,750 --> 00:11:16,310
对我们来说更容易阅读汇编程序。

191
00:11:16,310 --> 00:11:19,800
如果你想在实践中尝试这个，你
可以转到microcorrution.com。

192
00:11:19,800 --> 00:11:20,800
这是给你的黑客游戏
虚构的架构和CPU。

193
00:11:20,800 --> 00:11:22,800
然后必须使用调试器来解决
不同的挑战。

194
00:11:22,800 --> 00:11:26,630
他们还有一个很好的教程介绍
到那个调试器。

195
00:11:26,630 --> 00:11:31,000
尽管它不是真正的x86 GDB，
它有完全相同的概念。

196
00:11:31,000 --> 00:11:35,800
理解概念是更有价值的
而不是掌握技术。

197
00:11:35,800 --> 00:11:36,800
在我看来。

198
00:11:36,800 --> 00:11:41,680
在下一个视频中，我们将使用这些知识
做一个实际的例子

199
00:11:41,680 --> 00:11:43,060
一个小型的许可证检查程序。

