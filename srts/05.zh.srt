1
00:00:06,279 --> 00:00:08,919
现在，我想介绍一下 CPU 的工作原理。

2
00:00:08,920 --> 00:00:13,430
我希望，我能消除你可能对 assembler(汇编语言) 的恐惧，因为它实际上相当

3
00:00:13,430 --> 00:00:14,430
简单。

4
00:00:14,430 --> 00:00:20,590
在下一个视频中，您将能够运用它，破解你的第一个小程序。

5
00:00:20,590 --> 00:00:25,190
首先，我有一个很长的剧本，尝试循序渐进地告诉你，

6
00:00:25,190 --> 00:00:26,190
CPU 的概念。

7
00:00:26,190 --> 00:00:29,700
但我意识到这太长了，还有我想我没有把重点讲清楚。

8
00:00:29,701 --> 00:00:34,641
但后来，我偶然发现了这个由 'starfighters.io' 制造的 hacking 游戏。

9
00:00:34,640 --> 00:00:37,050
虽说在录制这段视频时，starfighters.io 尚未可用。

10
00:00:37,050 --> 00:00:39,710
但，当看到这个视频的时候，它应该发布运行了。

11
00:00:39,710 --> 00:00:41,130
所以去看看吧。

12
00:00:41,130 --> 00:00:47,480
还有那个网站的创建者，已经上传了游戏预告的文章。

13
00:00:47,480 --> 00:00:53,590
那篇预告是，一篇关于反工程的虚构报道，一种用于金融交易的便携设备。

14
00:00:53,589 --> 00:00:58,299
即便是虚构的，却没有与现实情况相去甚远。

15
00:00:58,300 --> 00:01:01,170
所以，我强烈建议你阅读它。

16
00:01:01,170 --> 00:01:05,560
但我现在，就根据他们介绍编写汇编的部分，

17
00:01:05,561 --> 00:01:07,301
进行扩展讨论。

18
00:01:07,300 --> 00:01:10,680
之后，我希望你能开始理解 CPU的工作原理。

19
00:01:10,680 --> 00:01:16,560
CPU，有惊人的简单概念，可以用于解决非常复杂的任务。

20
00:01:16,560 --> 00:01:18,060
NB。

21
00:01:18,060 --> 00:01:21,840
到视频最后，我希望你能意识到这一点。

22
00:01:21,840 --> 00:01:26,700
想象一下，只要一张纸，从上到下写指令。

23
00:01:26,700 --> 00:01:29,800
而这是您的内存，就像您计算机中的RAM。

24
00:01:29,799 --> 00:01:36,259
纸上的每一行，都有一个编号，就好比，内存中的那些位置，都是有地址一样。

25
00:01:36,259 --> 00:01:41,179
所以纸上的第5行，对应在内存中，它会像 '0x4005db'

26
00:01:41,180 --> 00:01:42,730
这样的十六进制地址。

27
00:01:42,730 --> 00:01:48,720
所以，这纸啊，或者说你的内存，包含着汇编代码。

28
00:01:48,719 --> 00:01:52,249
但是，汇编代码能做什么呢？

29
00:01:52,250 --> 00:01:56,950
首先，我们给你 8-32 个全局变量，都使用固定大小，

30
00:01:56,950 --> 00:01:59,560
并称它们为"寄存器(registers)"。

31
00:01:59,560 --> 00:02:03,120
以此，你的 CPU，具体取决于你的架构，其实是有很多这样的寄存器。

32
00:02:03,121 --> 00:02:04,121
例如 64位 Intel CPU，会有 16，17个，也许更多？

33
00:02:04,121 --> 00:02:05,121
部分原因取决于，你的计算方式。

34
00:02:05,121 --> 00:02:06,121
但一般来说，这就是你经常看到或使用的寄存器数量。

35
00:02:06,121 --> 00:02:07,121
继续。

36
00:02:07,121 --> 00:02:08,551
他们把这些寄存器叫做"全局变量"，而其作用也正是(全局+变量)。

37
00:02:08,550 --> 00:02:13,370
就像在 C 或 Python 编程中的一样，你可以像变量一样使用它们。

38
00:02:13,370 --> 00:02:19,430
在其中存储一个值，并在它们上面执行一些算术运算，如，加或乘。

39
00:02:19,430 --> 00:02:21,790
这里的下一个关键字，是固定大小。

40
00:02:21,790 --> 00:02:24,750
在32位机器中，它们是32位的宽度。

41
00:02:24,750 --> 00:02:28,350
在64位机器中，它们有64位。

42
00:02:28,349 --> 00:02:32,759
所以，这就是一个寄存器，你能储存的最大数字。

43
00:02:32,760 --> 00:02:36,930
当你想要更大的数字时，显然你必须写代码来拆分

44
00:02:36,930 --> 00:02:40,780
也就是，在多个寄存器上，增加数字。

45
00:02:40,780 --> 00:02:43,600
其中一些寄存器，是特殊寄存器。

46
00:02:43,599 --> 00:02:48,259
最重要的是"程序计数器(Program Counter)"，它告诉 CPU 下一步

47
00:02:48,260 --> 00:02:50,480
要执行哪个指令。

48
00:02:50,480 --> 00:02:54,840
每次执行一条指令，我们都会前进程序计数器。

49
00:02:54,840 --> 00:03:00,740
这个寄存器通常被称为 PC，意思是程序计数器，但在我们的Intel x86体系结构上

50
00:03:00,739 --> 00:03:03,599
它被称为，指令指针(Instruction Pointer)。

51
00:03:03,599 --> 00:03:04,599
IP (缩写)。

52
00:03:04,599 --> 00:03:10,499
或 EIP，或 RIP - 取决于 16位、32位或64位 模式。

53
00:03:10,500 --> 00:03:15,130
所以，当你盯着纸上每一行指令时，指令指针寄存器

54
00:03:15,129 --> 00:03:18,829
会有下一步执行的行数。

55
00:03:18,830 --> 00:03:21,670
我们经常也将此称为，指向(pointing to)。

56
00:03:21,670 --> 00:03:26,310
所以指令指针，指向第 5 行。

57
00:03:26,310 --> 00:03:30,510
且当它执行了那个指令，它会加'1'，然移动到

58
00:03:30,510 --> 00:03:32,190
下一行(要执行的)。

59
00:03:32,190 --> 00:03:37,050
实际上，所有计算都是根据，寄存器上的简单操作来表达的。

60
00:03:37,049 --> 00:03:39,219
让我们做个例子。

61
00:03:39,220 --> 00:03:42,820
在x86汇编程序中，可以将数字移入一个寄存器

62
00:03:42,819 --> 00:03:45,229
就像"mov eax，5"。

63
00:03:45,230 --> 00:03:48,180
这意味着 "eax"，现在具有'5'这个值。

64
00:03:48,180 --> 00:03:51,770
然后你可以在上面，加一个 '3' 这样的数字。

65
00:03:51,770 --> 00:03:54,500
"add eax, 3"。

66
00:03:54,500 --> 00:03:57,260
现在让我们将，另一个寄存器设为'8'，

67
00:03:57,260 --> 00:04:00,680
所以为，"mov ebx，8"。

68
00:04:00,680 --> 00:04:05,780
然后，你可以减去值，‘sub eax, ebx’。

69
00:04:05,780 --> 00:04:12,130
这意味着，eax 减 ebx，结果存储在 eax 中。

70
00:04:12,129 --> 00:04:16,069
但真正的程序，需要使用，32个以上，1字节的变量。

71
00:04:16,070 --> 00:04:17,070
而这些大变量，不适合内存中的寄存器。

72
00:04:17,070 --> 00:04:22,270
而在我们的 x86 架构中，会有超过16个，64位寄存器，

73
00:04:22,271 --> 00:04:23,771
这种是8字节。

74
00:04:23,770 --> 00:04:26,710
想象一下，用汇编，写一个超级马里奥这样的游戏。

75
00:04:26,710 --> 00:04:31,850
你得把马里奥的 x/y 位置，生命，敌人，金币储存起来。

76
00:04:31,850 --> 00:04:34,730
仅是数得来的，你就需要，16个以上的变量。

77
00:04:34,729 --> 00:04:39,739
当你想收集超过32位硬币的值，你就需要更多的空间。

78
00:04:39,740 --> 00:04:43,470
所以下一个重点知识：什么东西是，不适合存储在内存中的寄存器。
《》HERE


79
00:04:43,470 --> 00:04:47,530
你可以用纸上，其他没有存储太多值的



80
00:04:47,530 --> 00:04:48,530
汇编代码部分。

81
00:04:48,530 --> 00:04:50,090
有道理，对吧？

82
00:04:50,090 --> 00:04:54,770
通过加载和存储，访问内存地址，好比一个大数组，或者

83
00:04:54,770 --> 00:04:57,690
是，栈上的推进(Push)和弹出(Pop)操作。

84
00:04:57,690 --> 00:05:02,090
因此加载和存储指令，在x86汇编程序中，叫做 "move"。

85
00:05:02,090 --> 00:05:06,900
所以我们可以从内存地址中，移动(move)值到寄存器，或是

86
00:05:06,900 --> 00:05:08,210
值从寄存器移动到内存。

87
00:05:08,210 --> 00:05:09,210
例如："mov eax, [0x4005db]"。

88
00:05:09,210 --> 00:05:10,260
写汇编程序，你可以有不同的语法。

89
00:05:10,259 --> 00:05:12,769
我最喜欢英特尔，汇编程序语法。

90
00:05:12,770 --> 00:05:16,490
所以在这种情况下，这个括号，就像数组或列表中的括号(索引)一样。

91
00:05:16,490 --> 00:05:22,640
例如在 python 中，访问在一个列表中的确切值，你可以写"my_list[5]"

92
00:05:22,639 --> 00:05:25,339
获取 索引 5 元素。

93
00:05:25,340 --> 00:05:30,000
所以，概念基本上是一样的，'0x4005db'只是一个非常大的数字，因为，

94
00:05:30,000 --> 00:05:31,920
我们的 RAM 非常大。

95
00:05:31,919 --> 00:05:35,479
文章还讨论了，在栈上的推进(push)和弹出(pop)操作。

96
00:05:35,479 --> 00:05:39,379
栈只是在内存底部的一个区域。

97
00:05:39,380 --> 00:05:41,670
就像纸的底部。

98
00:05:41,669 --> 00:05:47,519
然后，你有一个特别的寄存器，总是指向栈的顶部。

99
00:05:47,520 --> 00:05:49,640
栈指针(stack pointer) SP。

100
00:05:49,639 --> 00:05:50,639
或 ESP。

101
00:05:50,639 --> 00:05:51,639
或 RSP。

102
00:05:51,639 --> 00:05:53,159
它与指令指针一样特别。

103
00:05:53,160 --> 00:05:58,910
当你把一个新的值推入栈，例如"push 5"，

104
00:05:58,910 --> 00:06:04,580
栈指针将递增，指向下一个地址，和值将放在那里。

105
00:06:04,580 --> 00:06:09,940
当您执行"pop eax"时，栈指针的地址值，会保存在 eax 寄存器

106
00:06:09,940 --> 00:06:14,260
和栈指针将递减。

107
00:06:14,259 --> 00:06:16,589
程序全程都在使用。

108
00:06:16,590 --> 00:06:17,590
嗯…

109
00:06:17,590 --> 00:06:19,040
我必须纠正自己。

110
00:06:19,040 --> 00:06:20,800
这栈，通常是颠倒的。

111
00:06:20,800 --> 00:06:23,460
所以栈，向下增长。

112
00:06:23,460 --> 00:06:27,210
意味着，当我们推一个值时，它是从最高位置开始的，我们栈指针

113
00:06:27,210 --> 00:06:31,420
不会加，而是减。pop则相反。

114
00:06:31,419 --> 00:06:32,439
但这并不重要。

115
00:06:32,440 --> 00:06:38,860
想象一下，要叠罗汉(stack)，罗汉总是叠放在上面的，或者(从顶部)拿走。

HERE

116
00:06:38,860 --> 00:06:43,980
内存是一个汇编程序的磁盘，也是 Ruby或Python 程序的：

117
00:06:43,979 --> 00:06:48,199
您会把内存中的东西，放进变量里，修葺修葺，最后

118
00:06:48,199 --> 00:06:49,799
把他们放回内存。

119
00:06:49,800 --> 00:06:51,930
现在，当我们讨论下，效率和速度。

120
00:06:51,930 --> 00:06:55,070
寄存器上的计算，是超级快的。

121
00:06:55,069 --> 00:06:58,579
理想情况下，你的整个程序，应该只使用寄存器。

122
00:06:58,580 --> 00:07:02,830
但不太可能，因为你有时会将值存入内存，

123
00:07:02,830 --> 00:07:05,610
需要寄存器存点更复杂的东西。

124
00:07:05,610 --> 00:07:09,330
但是，如果你要优化你的代码，你要确保尽可能少地

125
00:07:09,330 --> 00:07:10,810
访问内存。

126
00:07:10,810 --> 00:07:11,810
Well。

127
00:07:11,810 --> 00:07:15,950
这也是半真半假，因为你有类似缓存的东西，就在 CPU(隔壁)。

128
00:07:15,949 --> 00:07:17,449
实际上叫，多级缓存。

129
00:07:17,449 --> 00:07:22,229
所以，如果你重复使用某个内存地址，它将缓存在一个特殊的，

130
00:07:22,229 --> 00:07:24,679
CPU附近的，超高速内存内，而不在 RAM.。

131
00:07:24,680 --> 00:07:26,630
这还不错吧。

132
00:07:26,630 --> 00:07:28,540
但你明白了。

133
00:07:28,539 --> 00:07:33,199
控制流程是通过 "goto" --- jumps, branches, 或 calls 完成的

134
00:07:33,199 --> 00:07:35,579
这些个指令的作用是，直接改变

135
00:07:35,580 --> 00:07:37,910
编程计数器。

136
00:07:37,910 --> 00:07:42,790
控制流，意味着：如果 CPU 只是一行接一行执行您的程序，

137
00:07:42,789 --> 00:07:45,979
而不能跳到别的地方，那么它的用处会变得很单一。

138
00:07:45,979 --> 00:07:49,359
例如，要重复一个任务，您需要不断地跳返回(起点)。

139
00:07:49,360 --> 00:07:52,890
在汇编程序中，您有不同的指令，做到这一点。

140
00:07:52,889 --> 00:07:56,069
它们被称为 "jumps, branches 或 calls"(跳，分支或调用)。

141
00:07:56,069 --> 00:07:59,819
它们基本上，都改变了'指令指针'，指向其他值。

142
00:07:59,819 --> 00:08:05,449
所以，当你读到"jump 2"时，你会只需将指令指针设置为 2，然后在这(2)行

143
00:08:05,449 --> 00:08:07,049
继续执行下去。

144
00:08:07,050 --> 00:08:08,980
有点像"mov eip，2" (eip == 指令指针)

145
00:08:08,979 --> 00:08:12,669
跳(jump)只是一种无条件的转行(goto)。

146
00:08:12,669 --> 00:08:17,489
所以，当你遇到跳时，你会跟着它走。

147
00:08:17,490 --> 00:08:23,750
但对于复杂任务，更有趣的就是，决定下一步要计算什么。

148
00:08:23,750 --> 00:08:27,320
寄存器上的大多数操作，比如加法和减法，

149
00:08:27,319 --> 00:08:31,799
有改变状态标志的副作用，如"最后计算结果值为

150
00:08:31,800 --> 00:08:32,820
零"。

151
00:08:32,820 --> 00:08:37,810
只有几个状态标志，它们通常住在一个特别的寄存器里。

152
00:08:37,810 --> 00:08:43,980
例如，我们之前，所让 5 加 3，"add eax, 3"，

153
00:08:43,980 --> 00:08:47,980
结果大于零，所以零标志不会设置。

154
00:08:47,980 --> 00:08:49,220
或者仅仅是 0。

155
00:08:49,220 --> 00:08:56,250
但是当我们用'sub eax, 8'减去8，结果将为 0，因此启用

156
00:08:56,250 --> 00:08:59,260
零标志，设为1。

157
00:08:59,260 --> 00:09:04,620
分支只是在预测状态标志上的转向，比如

158
00:09:04,620 --> 00:09:08,290
"转到这个地址，仅当最后一个算术运算结果为零的情况下"。

159
00:09:08,290 --> 00:09:13,630
在 x86 汇编中，就会是"je"指令。

160
00:09:13,630 --> 00:09:17,890
听起来很奇怪，但是如何测试两个值是相等的呢？

161
00:09:17,890 --> 00:09:22,430
你可以简单地，一个减一个，若结果为0，它们就相等，然设置

162
00:09:22,430 --> 00:09:23,430
零标志。

163
00:09:23,430 --> 00:09:29,560
因此，分支'branch if zero flag is set'相等条件成立，就简单跳'jump'的调用。

164
00:09:29,560 --> 00:09:34,500
一个调用(call)是无条件的goto，会把下一个地址推入栈，因此

165
00:09:34,500 --> 00:09:40,170
(可用)一个RET指令，稍后弹出，并让调用保持在中断的地方。

166
00:09:40,170 --> 00:09:44,220
早些时候，我解释了推入和弹出是如何指导工作。

167
00:09:44,220 --> 00:09:48,360
所以，栈的一个非常巧妙的用法，就是这个调用指令。

168
00:09:48,360 --> 00:09:50,860
假设在C语言中，你想调用一个函数。

169
00:09:50,860 --> 00:09:52,750
而在汇编程序中，你要怎么做？

170
00:09:52,750 --> 00:09:57,600
尤其是，函数可能被使用在多个地方，所以你总是

171
00:09:57,600 --> 00:09:59,840
要跳回你来的地方。

172
00:09:59,840 --> 00:10:05,550
如果只使用"jmp"指令，您必须指定确切的地址。

173
00:10:05,550 --> 00:10:09,330
所以，你能做的就是使用"call"指令代替。

174
00:10:09,330 --> 00:10:14,220
这将，指令指针的下一条指令推，到栈。

175
00:10:14,220 --> 00:10:19,190
当，你'jump'到最后的时候，它将执行"ret"指令。

176
00:10:19,190 --> 00:10:23,710
RET将栈的顶部当前值，弹出，再一次放入

177
00:10:23,710 --> 00:10:24,710
指令指针。

178
00:10:24,710 --> 00:10:26,330
就像一个"pop eip"。

179
00:10:26,330 --> 00:10:30,790
所以，我们可以继续执行最初(行)的位置。

180
00:10:30,790 --> 00:10:34,580
在这段视频结束之前，我只想说明白，汇编程序指令

181
00:10:34,580 --> 00:10:36,080
实际上，只是数字。

182
00:10:36,080 --> 00:10:42,270
如你所知，计算机只能存储(许多) 0 和 1 ，我们通常，把它们表示为数字。

183
00:10:42,270 --> 00:10:45,730
所以汇编程序代码，并没有说"mov eax, 5"。

184
00:10:45,730 --> 00:10:51,170
它实际上，是"B8 05 00 00 00"。

185
00:10:51,170 --> 00:10:58,420
十六进制 B8 表示"mov eax"，其余的则是

186
00:10:58,420 --> 00:11:00,790
您想要移到 eax 的数字。

187
00:11:00,790 --> 00:11:05,340
所以当硬件读取这个数字时，知道它必须移动该数字

188
00:11:05,340 --> 00:11:07,120
到它的 'eax' 寄存器中。

189
00:11:07,120 --> 00:11:12,750
而反汇编程序是一个需要这个数字 B8和，把它的(人类)可读文本输出

190
00:11:12,750 --> 00:11:16,310
给我们，让我们更容易阅读汇编程序。

191
00:11:16,310 --> 00:11:19,800
如果你想在实践中尝试这个，你可以转到 'microcorrution.com'。

192
00:11:19,800 --> 00:11:20,800
这是给你的黑客游戏，有关虚构的架构和CPU。

193
00:11:20,800 --> 00:11:22,800
这是，不得不使用调试器，来解决不同问题的挑战。

194
00:11:22,800 --> 00:11:26,630
他们还有一个很好的教程，介绍这个调试器。

195
00:11:26,630 --> 00:11:31,000
尽管它不是真正的x86 gdb，但它具有完全相同的概念。

196
00:11:31,000 --> 00:11:35,800
在我看来，理解概念是。

197
00:11:35,800 --> 00:11:36,800
比掌握技术更有价值的

198
00:11:36,800 --> 00:11:41,680
在下一个视频中，我们将使用这些知识，做一个实际的例子

199
00:11:41,680 --> 00:11:43,060
一个小型的，许可证检查(license-check)程序。

