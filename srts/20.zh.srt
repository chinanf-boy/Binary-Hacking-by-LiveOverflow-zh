1
00:00:06,759 --> 00:00:12,189
两集前，我们第一次利用格式字符串，在最后一段视频中，我们看了一下

2
00:00:12,190 --> 00:00:18,280
关于如何动态地将库链接到二进制文件-基本上，程序如何

3
00:00:18,279 --> 00:00:20,759
call functions from libc.

4
00:00:20,760 --> 00:00:25,610
And we also had an idea how to abuse this, when we want to redirect code execution.

5
00:00:25,610 --> 00:00:31,720
在本视频中，我们将使用此技术从漏洞攻击练习中利用格式级别4

6
00:00:31,720 --> 00:00:33,620
protostar.

7
00:00:33,620 --> 00:00:35,770
First let’s have a look at the code.

8
00:00:35,770 --> 00:00:38,570
The main function calls vuln.

9
00:00:38,570 --> 00:00:43,370
Vuln reads up to 512 characters from standard input into the buffer.

10
00:00:43,370 --> 00:00:46,990
And then uses printf to print the buffer.

11
00:00:46,989 --> 00:00:52,739
我们还立即看到缓冲区是printf-的第一个参数。

12
00:00:52,739 --> 00:00:54,959
that is the format parameter.

13
00:00:54,960 --> 00:00:58,420
After the printf there is a call to exit().

14
00:00:58,420 --> 00:01:02,300
This means that this function vuln will never return.

15
00:01:02,299 --> 00:01:08,759
It will perform the syscall exit to the kernel, which will quit this process.

16
00:01:08,760 --> 00:01:13,710
所以如果我们覆盖这个函数的返回指针，我们将永远不会返回

17
00:01:13,710 --> 00:01:16,400
we could not exploit it.

18
00:01:16,400 --> 00:01:23,620
因此，我们使用上一个视频中的技术覆盖get entry for exit，使用

19
00:01:23,620 --> 00:01:26,820
the address for hello.

20
00:01:26,820 --> 00:01:30,430
That instead of exit we execute hello at the end.

21
00:01:30,430 --> 00:01:32,020
Let’s get everything ready.

22
00:01:32,020 --> 00:01:37,630
I use again vmware to run the protostar image and connect to it via ssh with putty.

23
00:01:37,630 --> 00:01:40,230
Open one window for the binary.

24
00:01:40,230 --> 00:01:43,530
And another window where we can write the exploit.

25
00:01:43,530 --> 00:01:48,120
我们也可能希望立即导入结构模块，因为我们需要它来转换

26
00:01:48,120 --> 00:01:50,310
integers to binary strings.

27
00:01:50,310 --> 00:01:56,050
Let’s start by first verifying that we have a format string vulnerability.

28
00:01:56,050 --> 00:02:01,180
We can just specify some format characters and see if they are turned into numbers.

29
00:02:01,180 --> 00:02:02,180
是的！

30
00:02:02,180 --> 00:02:03,460
That works.

31
00:02:03,460 --> 00:02:07,750
So to make this exploit work we have to figure out a few addresses.

32
00:02:07,750 --> 00:02:12,810
Let’s get the address of the hello function with “x” examine hello.

33
00:02:12,810 --> 00:02:13,810
Here it is.

34
00:02:13,810 --> 00:02:16,150
Let’s copy that into our exploit script.

35
00:02:16,150 --> 00:02:20,400
只需突出显示要复制的区域，然后执行

36
00:02:20,400 --> 00:02:24,020
a mouse right click in the other window.

37
00:02:24,020 --> 00:02:28,840
接下来，让我们试着找到全局偏移量表，我们要在其中写入这个hello地址。

38
00:02:28,840 --> 00:02:30,300
to.

39
00:02:30,300 --> 00:02:31,300
Disassemble main.

40
00:02:31,300 --> 00:02:32,300
Ok.

41
00:02:32,300 --> 00:02:33,300
Right.

42
00:02:33,300 --> 00:02:34,300
I forgot.

43
00:02:34,300 --> 00:02:35,300
We call vuln.

44
00:02:35,300 --> 00:02:36,300
So disassemble vuln.

45
00:02:36,300 --> 00:02:42,380
And at the bottom you can see the call to exit at the procedure linkage table ptl.

46
00:02:42,379 --> 00:02:46,789
拆下那个地址，我们现在可以看到第一个引用的地址

47
00:02:46,790 --> 00:02:49,300
instruction with the jump.

48
00:02:49,300 --> 00:02:55,130
That tries to reference the address of exit from glibc from there.

49
00:02:55,129 --> 00:02:56,239
So examine that address.

50
00:02:56,240 --> 00:02:57,240
And yup.

51
00:02:57,240 --> 00:02:59,370
That’s the global offset table.

52
00:02:59,370 --> 00:03:02,250
Now we also store that table address in our script.

53
00:03:02,249 --> 00:03:05,649
Now let’s set two breakpoints in vuln.

54
00:03:05,650 --> 00:03:06,650
One before the printf.

55
00:03:06,650 --> 00:03:09,330
And one after the printf.

56
00:03:09,330 --> 00:03:13,110
Next let’s simulate by hand overwriting the got entry.

57
00:03:13,110 --> 00:03:14,490
So we run the code.

58
00:03:14,489 --> 00:03:15,489
在printf中，我们将global offset表中的exit条目更改为hello和

59
00:03:15,489 --> 00:03:16,489
continue to execute the exit at the end of vuln.

60
00:03:16,489 --> 00:03:17,489
Run. we enter some random input.

61
00:03:17,489 --> 00:03:18,489
First breakpoint.

62
00:03:18,489 --> 00:03:20,169
Now we are befoire the printf.

63
00:03:20,170 --> 00:03:23,280
Now let’s overwrite the GOT entry.

64
00:03:23,279 --> 00:03:25,859
Let’s check GOTagain.

65
00:03:25,859 --> 00:03:31,739
现在，用大括号int编写一个地址集，然后写入

66
00:03:31,739 --> 00:03:32,889
want to write.

67
00:03:32,889 --> 00:03:37,909
And now the entry for exit in the got has changed.

68
00:03:37,909 --> 00:03:38,909
Continue once.

69
00:03:38,909 --> 00:03:41,339
Now we are after the porintf.

70
00:03:41,340 --> 00:03:43,430
Just one instruction away from the call to exit.

71
00:03:43,430 --> 00:03:44,430
Next instruction.

72
00:03:44,430 --> 00:03:45,430
And disassemble and info registers.

73
00:03:45,430 --> 00:03:46,430
Yup, we are at the exit.

74
00:03:46,430 --> 00:03:48,550
So let’s continue and see if we execute exit, or hello.

75
00:03:48,549 --> 00:03:49,649
Whoop.

76
00:03:49,650 --> 00:03:51,950
Ok. we executed hello.

77
00:03:51,950 --> 00:03:52,950
That worked.

78
00:03:52,950 --> 00:03:57,010
Now we just have to achieve this write with a format string and percentage n.

79
00:03:57,010 --> 00:03:58,010
Ok.

80
00:03:58,010 --> 00:03:59,010
Step one.

81
00:03:59,010 --> 00:04:03,020
让我们退出调试器，通过播放找到堆栈中输入的字符串

82
00:04:03,019 --> 00:04:04,819
around with the format specifiers.

83
00:04:04,819 --> 00:04:07,509
We use our script to do those tests.

84
00:04:07,510 --> 00:04:10,910
So first we know the buffer is 512 bytes long.

85
00:04:10,909 --> 00:04:15,749
So let’s write a function that pads our string to that length.

86
00:04:15,749 --> 00:04:21,429
所以我们只需在字符串中附加一定数量的字符，其中该数字为512减去

87
00:04:21,430 --> 00:04:23,670
the length of the current string.

88
00:04:23,670 --> 00:04:28,250
Then we create a variable exploit and print that variable padded.

89
00:04:28,250 --> 00:04:33,980
当我们执行它时，我们可以看到我们的漏洞字符串，它被填充到512

90
00:04:33,980 --> 00:04:34,980
characters.

91
00:04:34,980 --> 00:04:41,680
So this will print the first 4 values from the stack.

92
00:04:41,680 --> 00:04:44,060
Yup seems to work.

93
00:04:44,060 --> 00:04:48,840
现在，让我们在字符串前面加上一些可识别的字符，然后尝试看看有多远

94
00:04:48,840 --> 00:04:51,010
away our string is on the stack.

95
00:04:51,010 --> 00:04:52,010
哈！

96
00:04:52,010 --> 00:04:53,010
Cool.

97
00:04:53,010 --> 00:04:54,010
Ok.

98
00:04:54,010 --> 00:04:56,820
Our string already starts with the 4th value.

99
00:04:56,820 --> 00:05:02,510
现在我们可以使用格式字符串中的数字美元符号来具体引用

100
00:05:02,510 --> 00:05:03,750
that offset.

101
00:05:03,750 --> 00:05:06,750
So 4 dollar after the percentage sign.

102
00:05:06,750 --> 00:05:11,730
这将尝试引用printf的第4个参数，而不是遍历这些参数

103
00:05:11,730 --> 00:05:13,160
one after another.

104
00:05:13,160 --> 00:05:17,410
See, now all values are 41414141.

105
00:05:17,410 --> 00:05:24,240
我希望你记得百分比n可以用来写印刷字符数

106
00:05:24,240 --> 00:05:26,480
to an address on the stack.

107
00:05:26,480 --> 00:05:31,290
所以我们可以用全局偏移表地址替换a字符

108
00:05:31,290 --> 00:05:33,100
to write to that value.

109
00:05:33,100 --> 00:05:34,720
Let’s try it.

110
00:05:34,720 --> 00:05:38,260
We use struct to convert the integer address to a binary string.

111
00:05:38,260 --> 00:05:39,260
Struct.

112
00:05:39,260 --> 00:05:40,260
Pack.

113
00:05:40,260 --> 00:05:41,260
I. exit_plt.

114
00:05:41,260 --> 00:05:42,260
Yup, we seem to hit that address.

115
00:05:42,260 --> 00:05:48,650
Let’s replace the percentage x with percentage n and see what that does in gdb.

116
00:05:48,650 --> 00:05:54,240
But first write the output of this script to a file so we can use it in gdb as input.

117
00:05:54,240 --> 00:05:58,520
Don’t forget to set the breakpoints again.

118
00:05:58,520 --> 00:06:01,030
Run and pipe in the exploit string.

119
00:06:01,030 --> 00:06:03,550
And we hit the breakpoint.

120
00:06:03,550 --> 00:06:06,040
So now we are about to execute the printf.

121
00:06:06,040 --> 00:06:08,380
Let’s check the GOT entry.

122
00:06:08,380 --> 00:06:11,970
Now let’s execute the printf and let’s check again.

123
00:06:11,970 --> 00:06:12,970
哈！

124
00:06:12,970 --> 00:06:15,970
We have overwritten GOT. with a fairly small number.

125
00:06:15,970 --> 00:06:22,310
If we now continue we will segfault in exit, because at this address is no function.

126
00:06:22,310 --> 00:06:27,740
因此，百分比n成功地将打印到GOT中的字符数写入

127
00:06:27,740 --> 00:06:28,740
table.

128
00:06:28,740 --> 00:06:35,380
现在我们所要做的就是把字符打印出来，这样我们就能找到地址

129
00:06:35,380 --> 00:06:37,050
of hello.

130
00:06:37,050 --> 00:06:39,220
Mhmh… hex 0x80484b4.

131
00:06:39,220 --> 00:06:45,570
Damn… that’s a big number.

132
00:06:45,570 --> 00:06:51,440
We have to print like over 134 MILLIOPn characters.

133
00:06:51,440 --> 00:06:56,410
每个字符都是一个字节，所以我们必须像128兆字节一样打印文本？

134
00:06:56,410 --> 00:06:57,560
这样行吗？

135
00:06:57,560 --> 00:07:02,570
Well, first of all we only have space for 512 characters in the buffer.

136
00:07:02,570 --> 00:07:04,490
So we can’t simply write them all.

137
00:07:04,490 --> 00:07:10,670
But we can abuse printf format strings again to pad an output string to any size.

138
00:07:10,670 --> 00:07:13,840
Which allows us to write way more characters.

139
00:07:13,840 --> 00:07:15,240
Let’s try that.

140
00:07:15,240 --> 00:07:19,190
Let’s also change the number of ns down to only one.

141
00:07:19,190 --> 00:07:23,030
啊。事实上，我们把它改回x，这样我们就不会一直砸桌子了。

142
00:07:23,030 --> 00:07:25,960
we can make sure we always hit the address.

143
00:07:25,960 --> 00:07:29,430
So let’s pad this to to like 30 characters, to see if that works.

144
00:07:29,430 --> 00:07:30,430
哦，我们不能忘了在后面再加一个%x，稍后我们将用它替换

145
00:07:30,430 --> 00:07:31,430
percentage n.

146
00:07:31,430 --> 00:07:35,000
Run it against the format4 binary.

147
00:07:35,000 --> 00:07:36,020
And yes.

148
00:07:36,020 --> 00:07:37,080
See all those spaces.

149
00:07:37,080 --> 00:07:39,740
Text got padded to 30 characters.

150
00:07:39,740 --> 00:07:48,370
Now le’ts try that with 134 million.

151
00:07:48,370 --> 00:07:52,670
Okay. seems to work.

152
00:07:52,670 --> 00:07:54,830
It’s printing and printing and printing.

153
00:07:54,830 --> 00:07:56,990
All those millions of spaces.

154
00:07:56,990 --> 00:07:57,990
This taks aaaages.

155
00:07:57,990 --> 00:07:58,990
And we arrived at the end.

156
00:07:58,990 --> 00:07:59,990
Let’s try that in gdb again with percentage n.

157
00:07:59,990 --> 00:08:00,990
Urgh man.

158
00:08:00,990 --> 00:08:01,990
这需要很长时间…

159
00:08:01,990 --> 00:08:06,020
:( Printing those hundret megabytes is just crazy.

160
00:08:06,020 --> 00:08:09,210
But it did change the global offset table pretty close to hello.

161
00:08:09,210 --> 00:08:14,870
We just would have to fiddle around a bit and adjust it exactly.

162
00:08:14,870 --> 00:08:16,020
但你知道吗？

163
00:08:16,020 --> 00:08:17,920
This sucks to print so many characters.

164
00:08:17,920 --> 00:08:19,400
Let’s use a little trick.

165
00:08:19,400 --> 00:08:24,110
Let’s use TWO shorter writes to achieve the same.

166
00:08:24,110 --> 00:08:29,560
我们可以先用一个小得多的值写下下面的两个字节，

167
00:08:29,560 --> 00:08:35,400
然后在地址+2处执行另一个写入操作，将另一个较小的值写入较高的值。

168
00:08:35,400 --> 00:08:36,450
bytes.

169
00:08:36,450 --> 00:08:39,870
Thus constructing the whole 4 byte through two writes.

170
00:08:39,870 --> 00:08:44,140
So let’s try to write the lower two bytes first.

171
00:08:44,140 --> 00:08:47,310
Let’s start with a padding like 30.

172
00:08:47,310 --> 00:08:49,120
Write the output again into the file.

173
00:08:49,120 --> 00:08:51,470
And run gdb with it as input.

174
00:08:51,470 --> 00:08:58,010
Ok, so with the padding of 30 we were able to write hex 2e, which is 46.

175
00:08:58,010 --> 00:09:08,560
Our goal is to write the two lower bytes so we want 84b4, which is 33972.

176
00:09:08,560 --> 00:09:14,180
因为我们有30个填充物，但最终我们只有46个，我们必须补偿16个填充物。

177
00:09:14,180 --> 00:09:15,180
characters.

178
00:09:15,180 --> 00:09:22,530
So we substract 16 from it, so we want to put 33960 as a padding.

179
00:09:22,529 --> 00:09:28,789
当我们运行它并查看got条目时，我们可以确认下面两个字节是

180
00:09:28,790 --> 00:09:31,600
now 84b4.

181
00:09:31,600 --> 00:09:37,030
Now to address the two higher bytes we move our address by two forward.

182
00:09:37,030 --> 00:09:38,960
And perform another write.

183
00:09:38,960 --> 00:09:40,960
So let’s add this address as well.

184
00:09:40,960 --> 00:09:43,620
So EXIT_PLT plus 2.

185
00:09:43,620 --> 00:09:48,780
This means that for the second write we want to address the fith element on the stack.

186
00:09:48,780 --> 00:09:52,930
And now we just have to figure out how many we need to write here.

187
00:09:52,930 --> 00:09:55,720
Let’s try with 30 again.

188
00:09:55,720 --> 00:09:56,720
Ok.

189
00:09:56,720 --> 00:10:01,650
The lower two bytes now stay 84b4.

190
00:10:01,650 --> 00:10:02,730
Perfect.

191
00:10:02,730 --> 00:10:06,550
And the higher bytes are 84d2.

192
00:10:06,550 --> 00:10:10,240
But we want to get 0804.

193
00:10:10,240 --> 00:10:15,020
那么，如果我们只能增加字符的数量，我们如何才能得到一个更低的数字呢？

194
00:10:15,020 --> 00:10:21,210
实际上，我们不只是写两个字节，我们总是写四个字节，这意味着

195
00:10:21,210 --> 00:10:26,070
that also currently we screw up data that is stored behind our exit GOT entry.

196
00:10:26,070 --> 00:10:31,500
现在猜猜，如果我们写的足够多以至于第3个字节

197
00:10:31,500 --> 00:10:32,590
is 1 and the rest becomes 0 again.

198
00:10:32,589 --> 00:10:36,769
It doesn’t matter for the GOT, because it will only see the other 4 bytes.

199
00:10:36,770 --> 00:10:42,620
So basically we overflow those two upper bytes so we can get there a lower value in.

200
00:10:42,620 --> 00:10:44,760
Now currently we have 84d2.

201
00:10:44,760 --> 00:10:46,430
And we want 0804.

202
00:10:46,430 --> 00:10:47,820
I mean.

203
00:10:47,820 --> 00:10:49,360
We actually want 10804.

204
00:10:49,360 --> 00:10:59,020
如果我们现在把84d2从这里减去，我们知道我们应该写多少得到

205
00:10:59,020 --> 00:11:00,190
10804.

206
00:11:00,190 --> 00:11:02,730
So 8332.

207
00:11:02,730 --> 00:11:05,400
But that’s hex, so that is 33586.

208
00:11:05,400 --> 00:11:10,000
And it already included the 30 padding.

209
00:11:10,000 --> 00:11:12,790
So we must not forget that.

210
00:11:12,790 --> 00:11:15,190
Now we might be done.

211
00:11:15,190 --> 00:11:18,230
Let’s check.

212
00:11:18,230 --> 00:11:21,140
We write the output file.

213
00:11:21,140 --> 00:11:23,230
We run gdb.

214
00:11:23,230 --> 00:11:25,210
We break before the printf.

215
00:11:25,210 --> 00:11:27,740
This is how the table entry looks before.

216
00:11:27,740 --> 00:11:30,990
Now continue and examine the address again.

217
00:11:30,990 --> 00:11:32,440
Wh00p.

218
00:11:32,440 --> 00:11:33,540
We changed it.

219
00:11:33,540 --> 00:11:35,470
And that’s the address of hello.

220
00:11:35,470 --> 00:11:37,950
So now continue and let the program run.

221
00:11:37,950 --> 00:11:40,480
BOOM. code execution redirected.

222
00:11:40,480 --> 00:11:41,480
我们赢了！

223
00:11:41,480 --> 00:11:46,860
像printf这样看起来无害的函数如何被用来控制指令真是太疯狂了

224
00:11:46,860 --> 00:11:47,140
指针X

