1
00:00:06,759 --> 00:00:12,189
两集前，我们第一次利用格式字符串，在最后一段视频中，我们看了一下

2
00:00:12,190 --> 00:00:18,280
关于如何动态地将库链接到二进制文件-基本上，程序如何

3
00:00:18,279 --> 00:00:20,759
从libc调用函数。

4
00:00:20,760 --> 00:00:25,610
当我们想要重定向代码执行时，我们还知道了如何滥用它。

5
00:00:25,610 --> 00:00:31,720
在本视频中，我们将使用此技术从漏洞攻击练习中利用格式级别4

6
00:00:31,720 --> 00:00:33,620
原恒星

7
00:00:33,620 --> 00:00:35,770
首先，让我们看看代码。

8
00:00:35,770 --> 00:00:38,570
主函数调用Vuln。

9
00:00:38,570 --> 00:00:43,370
Vuln从标准输入读取最多512个字符到缓冲区。

10
00:00:43,370 --> 00:00:46,990
然后使用printf打印缓冲区。

11
00:00:46,989 --> 00:00:52,739
我们还立即看到缓冲区是printf-的第一个参数。

12
00:00:52,739 --> 00:00:54,959
这是格式参数。

13
00:00:54,960 --> 00:00:58,420
在printf之后，将调用exit（）。

14
00:00:58,420 --> 00:01:02,300
这意味着这个函数Vuln永远不会返回。

15
00:01:02,299 --> 00:01:08,759
它将执行内核的系统调用退出，这将退出此进程。

16
00:01:08,760 --> 00:01:13,710
所以如果我们覆盖这个函数的返回指针，我们将永远不会返回

17
00:01:13,710 --> 00:01:16,400
我们不能利用它。

18
00:01:16,400 --> 00:01:23,620
因此，我们使用上一个视频中的技术覆盖get entry for exit，使用

19
00:01:23,620 --> 00:01:26,820
你好的地址。

20
00:01:26,820 --> 00:01:30,430
我们不是退出而是在最后执行hello。

21
00:01:30,430 --> 00:01:32,020
让我们把一切准备好。

22
00:01:32,020 --> 00:01:37,630
我再次使用vmware运行ProtoStar映像，并使用putty通过ssh连接到它。

23
00:01:37,630 --> 00:01:40,230
打开一个二进制窗口。

24
00:01:40,230 --> 00:01:43,530
以及另一个我们可以编写漏洞的窗口。

25
00:01:43,530 --> 00:01:48,120
我们也可能希望立即导入结构模块，因为我们需要它来转换

26
00:01:48,120 --> 00:01:50,310
整数到二进制字符串。

27
00:01:50,310 --> 00:01:56,050
让我们首先验证一下我们是否存在格式字符串漏洞。

28
00:01:56,050 --> 00:02:01,180
我们可以指定一些格式字符，看看它们是否转换成数字。

29
00:02:01,180 --> 00:02:02,180
是的！

30
00:02:02,180 --> 00:02:03,460
那是有效的。

31
00:02:03,460 --> 00:02:07,750
所以要想利用这个漏洞，我们必须找出一些地址。

32
00:02:07,750 --> 00:02:12,810
让我们用“x”来获取hello函数的地址，检查hello。

33
00:02:12,810 --> 00:02:13,810
在这里。

34
00:02:13,810 --> 00:02:16,150
让我们把它复制到我们的漏洞脚本中。

35
00:02:16,150 --> 00:02:20,400
只需突出显示要复制的区域，然后执行

36
00:02:20,400 --> 00:02:24,020
在另一个窗口中单击鼠标右键。

37
00:02:24,020 --> 00:02:28,840
接下来，让我们试着找到全局偏移量表，我们要在其中写入这个hello地址。

38
00:02:28,840 --> 00:02:30,300
去。

39
00:02:30,300 --> 00:02:31,300
拆卸主泵。

40
00:02:31,300 --> 00:02:32,300
好啊。

41
00:02:32,300 --> 00:02:33,300
正确的。

42
00:02:33,300 --> 00:02:34,300
我忘了。

43
00:02:34,300 --> 00:02:35,300
我们叫弗林。

44
00:02:35,300 --> 00:02:36,300
所以拆卸Vuln。

45
00:02:36,300 --> 00:02:42,380
在底部，您可以看到在过程链接表ptl处的退出调用。

46
00:02:42,379 --> 00:02:46,789
拆下那个地址，我们现在可以看到第一个引用的地址

47
00:02:46,790 --> 00:02:49,300
带跳转的指令。

48
00:02:49,300 --> 00:02:55,130
它试图引用从glibc退出的地址。

49
00:02:55,129 --> 00:02:56,239
所以检查一下那个地址。

50
00:02:56,240 --> 00:02:57,240
和YUP。

51
00:02:57,240 --> 00:02:59,370
这是全局偏移表。

52
00:02:59,370 --> 00:03:02,250
现在，我们还将该表地址存储在脚本中。

53
00:03:02,249 --> 00:03:05,649
现在让我们在vuln中设置两个断点。

54
00:03:05,650 --> 00:03:06,650
打印前一个。

55
00:03:06,650 --> 00:03:09,330
一张在印刷品后面。

56
00:03:09,330 --> 00:03:13,110
接下来，让我们用手覆盖got条目来模拟。

57
00:03:13,110 --> 00:03:14,490
所以我们运行代码。

58
00:03:14,489 --> 00:03:15,489
在printf中，我们将global offset表中的exit条目更改为hello和

59
00:03:15,489 --> 00:03:16,489
继续执行Vuln末尾的出口。

60
00:03:16,489 --> 00:03:17,489
跑。我们输入一些随机输入。

61
00:03:17,489 --> 00:03:18,489
第一个断点。

62
00:03:18,489 --> 00:03:20,169
现在我们开始印刷了。

63
00:03:20,170 --> 00:03:23,280
现在让我们覆盖got条目。

64
00:03:23,279 --> 00:03:25,859
我们再检查一下Got。

65
00:03:25,859 --> 00:03:31,739
现在，用大括号int编写一个地址集，然后写入

66
00:03:31,739 --> 00:03:32,889
想写。

67
00:03:32,889 --> 00:03:37,909
现在got的出口入口已经改变了。

68
00:03:37,909 --> 00:03:38,909
继续一次。

69
00:03:38,909 --> 00:03:41,339
现在我们在找色情电影。

70
00:03:41,340 --> 00:03:43,430
只有一条指令可以从调用中退出。

71
00:03:43,430 --> 00:03:44,430
下一条指令。

72
00:03:44,430 --> 00:03:45,430
以及拆卸和信息寄存器。

73
00:03:45,430 --> 00:03:46,430
是的，我们在出口处。

74
00:03:46,430 --> 00:03:48,550
那么让我们继续看看是执行exit，还是hello。

75
00:03:48,549 --> 00:03:49,649
呐喊。

76
00:03:49,650 --> 00:03:51,950
好啊。我们执行了你好。

77
00:03:51,950 --> 00:03:52,950
效果不错。

78
00:03:52,950 --> 00:03:57,010
现在，我们只需要用一个格式字符串和百分比n来实现这一写操作。

79
00:03:57,010 --> 00:03:58,010
好啊。

80
00:03:58,010 --> 00:03:59,010
第一步。

81
00:03:59,010 --> 00:04:03,020
让我们退出调试器，通过播放找到堆栈中输入的字符串

82
00:04:03,019 --> 00:04:04,819
在格式说明符周围。

83
00:04:04,819 --> 00:04:07,509
我们使用脚本进行这些测试。

84
00:04:07,510 --> 00:04:10,910
所以首先我们知道缓冲区是512字节长。

85
00:04:10,909 --> 00:04:15,749
所以让我们编写一个函数，将字符串填充到这个长度。

86
00:04:15,749 --> 00:04:21,429
所以我们只需在字符串中附加一定数量的字符，其中该数字为512减去

87
00:04:21,430 --> 00:04:23,670
当前字符串的长度。

88
00:04:23,670 --> 00:04:28,250
然后我们创建一个变量漏洞并打印这个变量。

89
00:04:28,250 --> 00:04:33,980
当我们执行它时，我们可以看到我们的漏洞字符串，它被填充到512

90
00:04:33,980 --> 00:04:34,980
字符。

91
00:04:34,980 --> 00:04:41,680
所以这将打印堆栈中的前4个值。

92
00:04:41,680 --> 00:04:44,060
是的，似乎有用。

93
00:04:44,060 --> 00:04:48,840
现在，让我们在字符串前面加上一些可识别的字符，然后尝试看看有多远

94
00:04:48,840 --> 00:04:51,010
我们的绳子在那堆上。

95
00:04:51,010 --> 00:04:52,010
哈！

96
00:04:52,010 --> 00:04:53,010
酷。

97
00:04:53,010 --> 00:04:54,010
好啊。

98
00:04:54,010 --> 00:04:56,820
我们的字符串已经以第4个值开始。

99
00:04:56,820 --> 00:05:02,510
现在我们可以使用格式字符串中的数字美元符号来具体引用

100
00:05:02,510 --> 00:05:03,750
抵消。

101
00:05:03,750 --> 00:05:06,750
所以在百分比符号之后是4美元。

102
00:05:06,750 --> 00:05:11,730
这将尝试引用printf的第4个参数，而不是遍历这些参数

103
00:05:11,730 --> 00:05:13,160
一个接一个。

104
00:05:13,160 --> 00:05:17,410
现在所有值都是41414141。

105
00:05:17,410 --> 00:05:24,240
我希望你记得百分比n可以用来写印刷字符数

106
00:05:24,240 --> 00:05:26,480
到堆栈上的地址。

107
00:05:26,480 --> 00:05:31,290
所以我们可以用全局偏移表地址替换a字符

108
00:05:31,290 --> 00:05:33,100
写入该值。

109
00:05:33,100 --> 00:05:34,720
让我们试试看。

110
00:05:34,720 --> 00:05:38,260
我们使用struct将整数地址转换为二进制字符串。

111
00:05:38,260 --> 00:05:39,260
结构。

112
00:05:39,260 --> 00:05:40,260
打包。

113
00:05:40,260 --> 00:05:41,260
一、退出。

114
00:05:41,260 --> 00:05:42,260
是的，我们好像找到了那个地址。

115
00:05:42,260 --> 00:05:48,650
让我们将百分比x替换为百分比n，看看在gdb中它有什么作用。

116
00:05:48,650 --> 00:05:54,240
但首先将这个脚本的输出写入一个文件，这样我们就可以在gdb中使用它作为输入。

117
00:05:54,240 --> 00:05:58,520
不要忘记再次设置断点。

118
00:05:58,520 --> 00:06:01,030
在利用字符串中运行和管道。

119
00:06:01,030 --> 00:06:03,550
我们到达了断点。

120
00:06:03,550 --> 00:06:06,040
所以现在我们要执行printf。

121
00:06:06,040 --> 00:06:08,380
让我们检查一下got条目。

122
00:06:08,380 --> 00:06:11,970
现在让我们执行printf并再次检查。

123
00:06:11,970 --> 00:06:12,970
哈！

124
00:06:12,970 --> 00:06:15,970
我们已经覆盖了got。数量很少。

125
00:06:15,970 --> 00:06:22,310
如果我们现在继续，我们将在退出中分段故障，因为在这个地址是没有功能的。

126
00:06:22,310 --> 00:06:27,740
因此，百分比n成功地将打印到GOT中的字符数写入

127
00:06:27,740 --> 00:06:28,740
表。

128
00:06:28,740 --> 00:06:35,380
现在我们所要做的就是把字符打印出来，这样我们就能找到地址

129
00:06:35,380 --> 00:06:37,050
你好。

130
00:06:37,050 --> 00:06:39,220
MHMH…六角0x80484B4。

131
00:06:39,220 --> 00:06:45,570
该死的…这是个大数字。

132
00:06:45,570 --> 00:06:51,440
我们必须打印超过134百万个字符。

133
00:06:51,440 --> 00:06:56,410
每个字符都是一个字节，所以我们必须像128兆字节一样打印文本？

134
00:06:56,410 --> 00:06:57,560
这样行吗？

135
00:06:57,560 --> 00:07:02,570
首先，缓冲区中只有512个字符的空间。

136
00:07:02,570 --> 00:07:04,490
所以我们不能简单地把它们都写下来。

137
00:07:04,490 --> 00:07:10,670
但我们可以再次滥用printf格式字符串，将输出字符串填充到任何大小。

138
00:07:10,670 --> 00:07:13,840
这样我们可以写更多的字符。

139
00:07:13,840 --> 00:07:15,240
我们试试看。

140
00:07:15,240 --> 00:07:19,190
我们也将ns的数目改为只有一个。

141
00:07:19,190 --> 00:07:23,030
啊。事实上，我们把它改回X，这样我们就不会一直砸桌子了。

142
00:07:23,030 --> 00:07:25,960
我们可以确保始终按地址。

143
00:07:25,960 --> 00:07:29,430
所以，让我们把这个字符垫成30个字符，看看是否有效。

144
00:07:29,430 --> 00:07:30,430
哦，我们不能忘了在后面再加一个%x，稍后我们将用它替换

145
00:07:30,430 --> 00:07:31,430
百分比n

146
00:07:31,430 --> 00:07:35,000
对format4二进制文件运行它。

147
00:07:35,000 --> 00:07:36,020
是的。

148
00:07:36,020 --> 00:07:37,080
查看所有这些空间。

149
00:07:37,080 --> 00:07:39,740
文本被填充到30个字符。

150
00:07:39,740 --> 00:07:48,370
现在我们要用1.34亿美元来试试。

151
00:07:48,370 --> 00:07:52,670
可以。似乎起作用了。

152
00:07:52,670 --> 00:07:54,830
它是印刷，印刷和印刷。

153
00:07:54,830 --> 00:07:56,990
千百万空间。

154
00:07:56,990 --> 00:07:57,990
这是一个星期。

155
00:07:57,990 --> 00:07:58,990
我们到达了终点。

156
00:07:58,990 --> 00:07:59,990
让我们用百分比n在gdb中再试一次。

157
00:07:59,990 --> 00:08:00,990
呃，伙计。

158
00:08:00,990 --> 00:08:01,990
这需要很长时间…

159
00:08:01,990 --> 00:08:06,020
：（打印那些百兆字节简直是疯了。

160
00:08:06,020 --> 00:08:09,210
但它确实改变了全球偏移表非常接近hello。

161
00:08:09,210 --> 00:08:14,870
我们只需要稍作调整就行了。

162
00:08:14,870 --> 00:08:16,020
但你知道吗？

163
00:08:16,020 --> 00:08:17,920
印这么多字真是太糟了。

164
00:08:17,920 --> 00:08:19,400
让我们用点小技巧。

165
00:08:19,400 --> 00:08:24,110
让我们使用两个较短的写入来实现相同的结果。

166
00:08:24,110 --> 00:08:29,560
我们可以先用一个小得多的值写下下面的两个字节，

167
00:08:29,560 --> 00:08:35,400
然后在地址+2处执行另一个写入操作，将另一个较小的值写入较高的值。

168
00:08:35,400 --> 00:08:36,450
字节。

169
00:08:36,450 --> 00:08:39,870
因此，通过两次写入构造整个4字节。

170
00:08:39,870 --> 00:08:44,140
所以让我们先写下下面的两个字节。

171
00:08:44,140 --> 00:08:47,310
让我们从30这样的填充开始。

172
00:08:47,310 --> 00:08:49,120
再次将输出写入文件。

173
00:08:49,120 --> 00:08:51,470
并以它作为输入运行gdb。

174
00:08:51,470 --> 00:08:58,010
好的，填充30，我们就可以写十六进制2e，也就是46。

175
00:08:58,010 --> 00:09:08,560
我们的目标是写下两个较低的字节，所以我们需要84B4，即33972。

176
00:09:08,560 --> 00:09:14,180
因为我们有30个填充物，但最终我们只有46个，我们必须补偿16个填充物。

177
00:09:14,180 --> 00:09:15,180
字符。

178
00:09:15,180 --> 00:09:22,530
所以我们从中减去16，所以我们想把33960作为填充。

179
00:09:22,529 --> 00:09:28,789
当我们运行它并查看got条目时，我们可以确认下面两个字节是

180
00:09:28,790 --> 00:09:31,600
现在是84B4。

181
00:09:31,600 --> 00:09:37,030
现在要处理两个更高的字节，我们将地址向前移动两个字节。

182
00:09:37,030 --> 00:09:38,960
再写一次。

183
00:09:38,960 --> 00:09:40,960
所以我们也添加这个地址。

184
00:09:40,960 --> 00:09:43,620
所以退出PLT加2。

185
00:09:43,620 --> 00:09:48,780
这意味着对于第二次写入，我们要处理堆栈上的fith元素。

186
00:09:48,780 --> 00:09:52,930
现在我们只需要弄清楚我们需要在这里写多少。

187
00:09:52,930 --> 00:09:55,720
我们再试试30。

188
00:09:55,720 --> 00:09:56,720
好啊。

189
00:09:56,720 --> 00:10:01,650
下面两个字节现在保持84b4。

190
00:10:01,650 --> 00:10:02,730
很完美。

191
00:10:02,730 --> 00:10:06,550
更高的字节是84d2。

192
00:10:06,550 --> 00:10:10,240
但我们想得到0804。

193
00:10:10,240 --> 00:10:15,020
那么，如果我们只能增加字符的数量，我们如何才能得到一个更低的数字呢？

194
00:10:15,020 --> 00:10:21,210
实际上，我们不只是写两个字节，我们总是写四个字节，这意味着

195
00:10:21,210 --> 00:10:26,070
目前，我们也会破坏存储在出口入口后面的数据。

196
00:10:26,070 --> 00:10:31,500
现在猜猜，如果我们写的足够多以至于第3个字节

197
00:10:31,500 --> 00:10:32,590
为1，其余值再次变为0。

198
00:10:32,589 --> 00:10:36,769
对于got来说并不重要，因为它只会看到其他4个字节。

199
00:10:36,770 --> 00:10:42,620
所以基本上，我们溢出这两个高位字节，这样我们可以得到一个较低的值。

200
00:10:42,620 --> 00:10:44,760
现在我们有84d2。

201
00:10:44,760 --> 00:10:46,430
我们要0804。

202
00:10:46,430 --> 00:10:47,820
我是说。

203
00:10:47,820 --> 00:10:49,360
我们实际上想要10804。

204
00:10:49,360 --> 00:10:59,020
如果我们现在把84d2从这里减去，我们知道我们应该写多少得到

205
00:10:59,020 --> 00:11:00,190
10804。

206
00:11:00,190 --> 00:11:02,730
所以8332。

207
00:11:02,730 --> 00:11:05,400
但那是十六进制的，所以是33586。

208
00:11:05,400 --> 00:11:10,000
它已经包括了30个填充物。

209
00:11:10,000 --> 00:11:12,790
所以我们不能忘记这一点。

210
00:11:12,790 --> 00:11:15,190
现在我们可以结束了。

211
00:11:15,190 --> 00:11:18,230
让我们检查一下。

212
00:11:18,230 --> 00:11:21,140
我们编写输出文件。

213
00:11:21,140 --> 00:11:23,230
我们运行GDB。

214
00:11:23,230 --> 00:11:25,210
我们在印刷品之前就坏了。

215
00:11:25,210 --> 00:11:27,740
这就是表条目以前的样子。

216
00:11:27,740 --> 00:11:30,990
现在继续检查地址。

217
00:11:30,990 --> 00:11:32,440
WHP。

218
00:11:32,440 --> 00:11:33,540
我们改变了它。

219
00:11:33,540 --> 00:11:35,470
这是你好的地址。

220
00:11:35,470 --> 00:11:37,950
现在继续运行程序。

221
00:11:37,950 --> 00:11:40,480
繁荣。代码执行已重定向。

222
00:11:40,480 --> 00:11:41,480
我们赢了！

223
00:11:41,480 --> 00:11:46,860
像printf这样看起来无害的函数如何被用来控制指令真是太疯狂了

224
00:11:46,860 --> 00:11:47,140
指针X

