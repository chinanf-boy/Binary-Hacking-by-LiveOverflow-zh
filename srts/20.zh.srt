1
00:00:06,759 --> 00:00:12,189
两集前，我们第一次使用了格式字符串漏洞，而在上集视频中，

2
00:00:12,190 --> 00:00:18,280
我们看了一下，关于如何将库动态链接到二进制文件，

3
00:00:18,279 --> 00:00:20,759
基本上来说就是，程序是如何从 libc 调用函数的。

4
00:00:20,760 --> 00:00:25,610
当我们想要重定向代码执行时，我们还要有利用它的想法。

5
00:00:25,610 --> 00:00:31,720
在本视频中，我们将使用此技术，利用格式级别4，

6
00:00:31,720 --> 00:00:33,620
还是来自 exploit exercises protostar 的练习。

7
00:00:33,620 --> 00:00:35,770
首先，让我们看看代码。

8
00:00:35,770 --> 00:00:38,570
main 函数调用 vuln。

9
00:00:38,570 --> 00:00:43,370
 vuln 从标准输入，读取最多512个字符到缓冲区。

10
00:00:43,370 --> 00:00:46,990
然后，使用 printf 打印缓冲区。

11
00:00:46,989 --> 00:00:52,739
我们还立即看到缓冲区，是 printf 的第一个参数。

12
00:00:52,739 --> 00:00:54,959
而这个是格式参数。

13
00:00:54,960 --> 00:00:58,420
在 printf 之后，将调用exit() 。

14
00:00:58,420 --> 00:01:02,300
这意味着这个函数，vuln 永远不会返回。

15
00:01:02,299 --> 00:01:08,759
它将执行内核的 syscall 退出函数，退出此进程。

16
00:01:08,760 --> 00:01:13,710
所以，即便我们覆盖这个函数的返回指针，我们还是永远不会返回

17
00:01:13,710 --> 00:01:16,400
，也就不能利用它。

18
00:01:16,400 --> 00:01:23,620
因此，我们使用上一个视频中的技术，覆盖 GOT 的 exit 条目，

19
00:01:23,620 --> 00:01:26,820
换成 hello 的地址。

20
00:01:26,820 --> 00:01:30,430
这样就不是退出，而是在最后执行 hello。

21
00:01:30,430 --> 00:01:32,020
让我们把一切准备好。

22
00:01:32,020 --> 00:01:37,630
我再次使用vmware，运行ProtoStar映像，并使用 putty ，通过 ssh连接到它。

23
00:01:37,630 --> 00:01:40,230
打开一个窗口，给予二进制文件。

24
00:01:40,230 --> 00:01:43,530
以及另一个我们可以编写漏洞的窗口。

25
00:01:43,530 --> 00:01:48,120
我们也可能希望立即导入 struct 模块，

26
00:01:48,120 --> 00:01:50,310
因为我们需要它，把整数转换成二进制字符串。

27
00:01:50,310 --> 00:01:56,050
让我们首先验证一下，是否存在格式字符串漏洞。

28
00:01:56,050 --> 00:02:01,180
我们可以指定一些格式字符，看看它们是否转换成数字。

29
00:02:01,180 --> 00:02:02,180
是的！

30
00:02:02,180 --> 00:02:03,460
有效。

31
00:02:03,460 --> 00:02:07,750
所以要想利用这个漏洞，我们必须找出一些地址。

32
00:02:07,750 --> 00:02:12,810
让我们用“x”检查 hello，来获取 hello 函数的地址。

33
00:02:12,810 --> 00:02:13,810
就是它。

34
00:02:13,810 --> 00:02:16,150
让我们把它，复制到我们的漏洞脚本中。

35
00:02:16,150 --> 00:02:20,400
只需高亮要复制的区域，

36
00:02:20,400 --> 00:02:24,020
然后执行在另一个窗口中，单击鼠标右键就好。

37
00:02:24,020 --> 00:02:28,840
接下来，让我们试着找到全局偏移量表，我们要在其中，写入这个 hello 地址。

38
00:02:28,840 --> 00:02:30,300
去。

39
00:02:30,300 --> 00:02:31,300
反汇编 main。

40
00:02:31,300 --> 00:02:32,300
好啊。

41
00:02:32,300 --> 00:02:33,300
对了。

42
00:02:33,300 --> 00:02:34,300
我忘了。

43
00:02:34,300 --> 00:02:35,300
我们，调用了 vule。

44
00:02:35,300 --> 00:02:36,300
所以反汇编 vuln。

45
00:02:36,300 --> 00:02:42,380
在底部，您可以看到在过程链接表 ptl 的退出调用。

46
00:02:42,379 --> 00:02:46,789
反汇编那个地址，我们现在可以看到，

47
00:02:46,790 --> 00:02:49,300
第一个带跳转的指令，所引用的地址。

48
00:02:49,300 --> 00:02:55,130
它试图引用来自 glibc ，退出的地址。

49
00:02:55,129 --> 00:02:56,239
所以，检查一下那个地址。

50
00:02:56,240 --> 00:02:57,240
和 yup 瞧。

51
00:02:57,240 --> 00:02:59,370
这是全局偏移表。

52
00:02:59,370 --> 00:03:02,250
现在，我们还将该表地址，存储在脚本中。

53
00:03:02,249 --> 00:03:05,649
现在，让我们在 vuln 中，设置两个断点。

54
00:03:05,650 --> 00:03:06,650
一个在 printf 前面。

55
00:03:06,650 --> 00:03:09,330
一个在 printf 后面。

56
00:03:09,330 --> 00:03:13,110
接下来，让我们手动模拟，覆盖 GOT 条目 。

57
00:03:13,110 --> 00:03:14,490
让，我们运行代码。

58
00:03:14,489 --> 00:03:15,489
在 printf 中，我们将 GOT 中的exit条目，更改为 hello ，

59
00:03:15,489 --> 00:03:16,489
并继续执行到 vuln 末尾 的 exit。

60
00:03:16,489 --> 00:03:17,489
run。我们键入，一些随机输入。

61
00:03:17,489 --> 00:03:18,489
第一个断点。

62
00:03:18,489 --> 00:03:20,169
现在，我们在 printf 之前。

63
00:03:20,170 --> 00:03:23,280
现在，让我们覆盖GOT条目。

64
00:03:23,279 --> 00:03:25,859
我们，再检查一下Got。

65
00:03:25,859 --> 00:03:31,739
现在写入设定，大括号 int ，写入想写的地址，然后

66
00:03:31,739 --> 00:03:32,889
写入想写的值。

67
00:03:32,889 --> 00:03:37,909
现在GOT的 exit 条目已经改变了。

68
00:03:37,909 --> 00:03:38,909
继续来一次。

69
00:03:38,909 --> 00:03:41,339
现在，我们在找 printf。

70
00:03:41,340 --> 00:03:43,430
只有一条指令，可以从 该 call，到 eixt。

71
00:03:43,430 --> 00:03:44,430
下一条指令。

72
00:03:44,430 --> 00:03:45,430
以及反汇编和 info 寄存器。

73
00:03:45,430 --> 00:03:46,430
是的，我们在 exit 处。

74
00:03:46,430 --> 00:03:48,550
那么让，我们看看，继续执行的是 exit，还是hello。

75
00:03:48,549 --> 00:03:49,649
呼呼。

76
00:03:49,650 --> 00:03:51,950
好呀。我们执行了 hello 。

77
00:03:51,950 --> 00:03:52,950
效果不错。

78
00:03:52,950 --> 00:03:57,010
现在，我们只需要用一个格式字符串和 "%n" ，来实现这一写操作。

79
00:03:57,010 --> 00:03:58,010
好啊。

80
00:03:58,010 --> 00:03:59,010
第一步。

81
00:03:59,010 --> 00:04:03,020
让我们退出调试器，通过在格式说明符周围找到，

82
00:04:03,019 --> 00:04:04,819
我输入到栈中的字符串。

83
00:04:04,819 --> 00:04:07,509
我们使用脚本进行，这些测试。

84
00:04:07,510 --> 00:04:10,910
但是首先，我们要知道缓冲区是512字节长。

85
00:04:10,909 --> 00:04:15,749
所以，让我们编写一个函数，将字符串填充到这个长度。

86
00:04:15,749 --> 00:04:21,429
基本来说，我们只需在字符串中，附加一定数量的字符，其中该数目为 

87
00:04:21,430 --> 00:04:23,670
512 减去 当前字符串的长度。

88
00:04:23,670 --> 00:04:28,250
然后，我们创建一个变量漏洞，并打印该填充的变量。

89
00:04:28,250 --> 00:04:33,980
当我们执行它时，我们可以看到我们的漏洞字符串，

90
00:04:33,980 --> 00:04:34,980
它被填充到512字符。

91
00:04:34,980 --> 00:04:41,680
所以，这将打印栈中的前4个值。

92
00:04:41,680 --> 00:04:44,060
是的，似乎有用。

93
00:04:44,060 --> 00:04:48,840
现在，让我们在字符串前面，加上一些可识别的字符，然后试着看看，

94
00:04:48,840 --> 00:04:51,010
我们的字符串在那栈上有多远。

95
00:04:51,010 --> 00:04:52,010
哈！

96
00:04:52,010 --> 00:04:53,010
酷。

97
00:04:53,010 --> 00:04:54,010
好啊。

98
00:04:54,010 --> 00:04:56,820
我们的字符串，已经以第4个值开始。

99
00:04:56,820 --> 00:05:02,510
现在，我们可以使用格式字符串中的数字美元符号，

100
00:05:02,510 --> 00:05:03,750
来具体指定便宜。

101
00:05:03,750 --> 00:05:06,750
所以，在百分比符号之后是 4 美元。

102
00:05:06,750 --> 00:05:11,730
这将尝试引用 printf 的第4个参数，

103
00:05:11,730 --> 00:05:13,160
而不是一个接一个地遍历这些参数。

104
00:05:13,160 --> 00:05:17,410
现在，所有值都是 41414141。

105
00:05:17,410 --> 00:05:24,240
我希望你记得 "%n" ，

106
00:05:24,240 --> 00:05:26,480
能写出打印字符的栈地址。

107
00:05:26,480 --> 00:05:31,290
所以，我们可以用我们的一个字符，替换全局偏移表地址，

108
00:05:31,290 --> 00:05:33,100
用来写入该值。

109
00:05:33,100 --> 00:05:34,720
让我们试试看。

110
00:05:34,720 --> 00:05:38,260
我们使用 struct 将整数地址，转换为二进制字符串。

111
00:05:38,260 --> 00:05:39,260
Struct。

112
00:05:39,260 --> 00:05:40,260
Pack。

113
00:05:40,260 --> 00:05:41,260
一、exit_plt。

114
00:05:41,260 --> 00:05:42,260
是的，我们好像找到了那个地址。

115
00:05:42,260 --> 00:05:48,650
让我们将 "%x"替换为 "%n" ，看看在gdb中，它有什么作用。

116
00:05:48,650 --> 00:05:54,240
但首先将这个脚本的输出，写入一个文件，这样我们就可以在gdb中，使用它作为输入。

117
00:05:54,240 --> 00:05:58,520
不要忘记，再次设置断点。

118
00:05:58,520 --> 00:06:01,030
在漏洞字符串中，运行和管道。

119
00:06:01,030 --> 00:06:03,550
我们到达了断点。

120
00:06:03,550 --> 00:06:06,040
所以，现在我们要执行 printf。

121
00:06:06,040 --> 00:06:08,380
让我们检查一下GOT条目。

122
00:06:08,380 --> 00:06:11,970
现在让我们执行 printf，并再次检查。

123
00:06:11,970 --> 00:06:12,970
哈！

124
00:06:12,970 --> 00:06:15,970
我们已经覆盖了GOT。是一个很少的数。

125
00:06:15,970 --> 00:06:22,310
如果我们现在继续，我们将在 exit 会有分段错误，因为在这个地址是没有函数的。

126
00:06:22,310 --> 00:06:27,740
因此， "%n" 把打印字符数，成功写入

127
00:06:27,740 --> 00:06:28,740
GOT表。

128
00:06:28,740 --> 00:06:35,380
现在我们所要做的就是，把足够数量的字符打印出来，

129
00:06:35,380 --> 00:06:37,050
这样我们就能到达 hello 地址。

130
00:06:37,050 --> 00:06:39,220
MHMH… hex 0x80484B4。

131
00:06:39,220 --> 00:06:45,570
该死的… 这是个大数字。

132
00:06:45,570 --> 00:06:51,440
我们必须打印超过134百万个字符。

133
00:06:51,440 --> 00:06:56,410
每个字符都是一个字节，所以我们必须像128兆字节，一样打印文本？

134
00:06:56,410 --> 00:06:57,560
这样行吗？

135
00:06:57,560 --> 00:07:02,570
首先，缓冲区中，只有512个字符的空间。

136
00:07:02,570 --> 00:07:04,490
所以，我们不能简单地把它们都写下来。

137
00:07:04,490 --> 00:07:10,670
但我们可以再次滥用printf格式字符串，将输出字符串，填充到任何大小。

138
00:07:10,670 --> 00:07:13,840
这样，我们可以写更多的字符。

139
00:07:13,840 --> 00:07:15,240
我们试试看。

140
00:07:15,240 --> 00:07:19,190
我们也将 n 的数目,改为只有一个。

141
00:07:19,190 --> 00:07:23,030
啊。事实上，我们把它改回 x，这样我们就不会，一直轰炸表格了。

142
00:07:23,030 --> 00:07:25,960
我们可以确保，始终触碰到地址。

143
00:07:25,960 --> 00:07:29,430
所以，让我们把这个字符垫高，比如说30个字符，看看是否有效。

144
00:07:29,430 --> 00:07:30,430
哦，我们不能忘了，在后面再加一个 %x，

145
00:07:30,430 --> 00:07:31,430
稍后我们会替换成"%n" 

146
00:07:31,430 --> 00:07:35,000
对 format4 二进制文件运行它。

147
00:07:35,000 --> 00:07:36,020
当然还有。

148
00:07:36,020 --> 00:07:37,080
查看所有这些空间。

149
00:07:37,080 --> 00:07:39,740
文本被填充到30个字符。

150
00:07:39,740 --> 00:07:48,370
现在，我们要用1.34亿，来试试。

151
00:07:48,370 --> 00:07:52,670
可以。似乎起作用了。

152
00:07:52,670 --> 00:07:54,830
它是在一直打印，打印，打印。

153
00:07:54,830 --> 00:07:56,990
这可是，以亿计的所有空间。

154
00:07:56,990 --> 00:07:57,990
花上一个世纪的时间的感觉。

155
00:07:57,990 --> 00:07:58,990
我们到达了终点。

156
00:07:58,990 --> 00:07:59,990
让我们用 "%n" 在gdb中，再试一次。

157
00:07:59,990 --> 00:08:00,990
呃，伙计。

158
00:08:00,990 --> 00:08:01,990
这需要很长时间…

159
00:08:01,990 --> 00:08:06,020
:( 打印那些百兆字节，简直是疯了。

160
00:08:06,020 --> 00:08:09,210
但它确实改变了全球偏移表，非常接近hello。

161
00:08:09,210 --> 00:08:14,870
我们只需要，稍作调整就行了。

162
00:08:14,870 --> 00:08:16,020
但你知道吗？

163
00:08:16,020 --> 00:08:17,920
印这么多字，真是太糟了。

164
00:08:17,920 --> 00:08:19,400
让我们用点小技巧。

165
00:08:19,400 --> 00:08:24,110
让我们使用两个较短的写入，来实现相同的结果。

166
00:08:24,110 --> 00:08:29,560
这个想法是，我们可以先用一个小得多的值，写下低位的两个字节，

167
00:08:29,560 --> 00:08:35,400
然后在 地址+2 处执行另一个写入操作，将另一个较小的值，写入高位字节

168
00:08:35,400 --> 00:08:36,450
字节。

169
00:08:36,450 --> 00:08:39,870
因此，通过两次写入，构造整个4字节。

170
00:08:39,870 --> 00:08:44,140
所以，让我们先写下低位的两个字节。

171
00:08:44,140 --> 00:08:47,310
让我们从30这样的填充数开始。

172
00:08:47,310 --> 00:08:49,120
再次将输出写入文件。

173
00:08:49,120 --> 00:08:51,470
并以它作为输入，运行gdb。

174
00:08:51,470 --> 00:08:58,010
好的，填充30，我们就可以写 hex 2e，也就是 46。

175
00:08:58,010 --> 00:09:08,560
我们的目标是写下，两个低位的字节，所以，我们需要 84B4，即33972。

176
00:09:08,560 --> 00:09:14,180
因为，我们有30个填充物，但最终我们是 46 结尾的，我们必须推掉，

177
00:09:14,180 --> 00:09:15,180
16个字符填充物。

178
00:09:15,180 --> 00:09:22,530
所以，我们从中减去16，我们想把 33960 作为填充。

179
00:09:22,529 --> 00:09:28,789
当我们运行它，并查看GOT条目时，我们可以确认，

180
00:09:28,790 --> 00:09:31,600
低位两字节现在是84B4。

181
00:09:31,600 --> 00:09:37,030
现在，要处理两个高位的字节，我们将地址向前移动两个字节。

182
00:09:37,030 --> 00:09:38,960
再写一次。

183
00:09:38,960 --> 00:09:40,960
所以，我们也添加这个地址。

184
00:09:40,960 --> 00:09:43,620
所以 EXIT_PLT 加2。

185
00:09:43,620 --> 00:09:48,780
这意味着，对于第二次写入，我们要处理栈上的第三元素。

186
00:09:48,780 --> 00:09:52,930
现在，我们只需要弄清楚我们需要在这里写多少。

187
00:09:52,930 --> 00:09:55,720
我们再试试 30。

188
00:09:55,720 --> 00:09:56,720
好啊。

189
00:09:56,720 --> 00:10:01,650
低位两字节，现在保持84b4。

190
00:10:01,650 --> 00:10:02,730
很完美。

191
00:10:02,730 --> 00:10:06,550
更高的字节是 84d2。

192
00:10:06,550 --> 00:10:10,240
但我们想得到 0804。

193
00:10:10,240 --> 00:10:15,020
那么，如果我们只能增加字符的数量，我们如何才能得到一个更低的数字呢？

194
00:10:15,020 --> 00:10:21,210
实际上，我们不只是写两个字节，我们总写四个字节，

195
00:10:21,210 --> 00:10:26,070
这意味着目前，我们也会把存储在 eixt 条目后面的数据刮下来。

196
00:10:26,070 --> 00:10:31,500
现在猜猜，如果我们写的足够多让值递增，

197
00:10:31,500 --> 00:10:32,590
以至于第3个字节为1，其余值再次变为0。

198
00:10:32,589 --> 00:10:36,769
对于GOT来说，这并不重要，因为它只会看到其他4个字节。

199
00:10:36,770 --> 00:10:42,620
所以基本上，我们溢出这两个高位字节，这样较低的值就上来了。

200
00:10:42,620 --> 00:10:44,760
现在，我们有84d2。

201
00:10:44,760 --> 00:10:46,430
我们要0804。

202
00:10:46,430 --> 00:10:47,820
我意思。

203
00:10:47,820 --> 00:10:49,360
实际上，想要的是 10804。

204
00:10:49,360 --> 00:10:59,020
如果，我们现在把84d2从这里减去，

205
00:10:59,020 --> 00:11:00,190
我们知道我们应该写多少，才能得到 10804。

206
00:11:00,190 --> 00:11:02,730
就是 8332。

207
00:11:02,730 --> 00:11:05,400
但这个十六进制的，换算下就是33586。

208
00:11:05,400 --> 00:11:10,000
它已经包括了，30个填充物。

209
00:11:10,000 --> 00:11:12,790
所以，我们不能忘记这一点。

210
00:11:12,790 --> 00:11:15,190
现在，我们可能完成了。

211
00:11:15,190 --> 00:11:18,230
让我们检查一下。

212
00:11:18,230 --> 00:11:21,140
我们编写输出文件。

213
00:11:21,140 --> 00:11:23,230
我们运行GDB。

214
00:11:23,230 --> 00:11:25,210
我们在 printf 之前，就断点下了。

215
00:11:25,210 --> 00:11:27,740
这就是表格条目，以前的样子。

216
00:11:27,740 --> 00:11:30,990
现在继续，并再次检查地址。

217
00:11:30,990 --> 00:11:32,440
哇。

218
00:11:32,440 --> 00:11:33,540
我们改变了它。

219
00:11:33,540 --> 00:11:35,470
这是 hello 的地址。

220
00:11:35,470 --> 00:11:37,950
现在，继续运行程序。

221
00:11:37,950 --> 00:11:40,480
掌声。代码执行已重定向。

222
00:11:40,480 --> 00:11:41,480
我们赢了！

223
00:11:41,480 --> 00:11:46,860
像 printf 这样看起来无害的函数，

224
00:11:46,860 --> 00:11:47,140
如何被用来控制指令 pointer.x ，真是太雕了

