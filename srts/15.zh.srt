1
00:00:06,230 --> 00:00:09,050
让我们继续探索漏斗 - 练习堆栈
5级。

2
00:00:09,050 --> 00:00:13,430
你应该看过以前的视频
了解我们如何到达这里。

3
00:00:13,430 --> 00:00:14,530
挑战描述说

4
00:00:14,530 --> 00:00:20,240
Stack5是标准的缓冲区溢出，这个
时间介绍shellcode。

5
00:00:20,240 --> 00:00:21,260
提示是：

6
00:00:21,260 --> 00:00:25,200
那个，使用别人可能更容易
的shellcode。

7
00:00:25,199 --> 00:00:27,179
这也是我们将要做的。

8
00:00:27,180 --> 00:00:28,180
和

9
00:00:28,180 --> 00:00:33,580
如果调试shellcode，请使用“int3”
使用操作码十六进制CC的指令，停止

10
00:00:33,579 --> 00:00:37,049
程序执行并返回调试器。

11
00:00:37,050 --> 00:00:38,360
这非常有帮助。

12
00:00:38,360 --> 00:00:41,760
好的，我们来看看这段代码。

13
00:00:41,760 --> 00:00:42,950
它非常小。

14
00:00:42,949 --> 00:00:48,309
只有一个函数调用gets（），
我们知道允许我们覆盖数据

15
00:00:48,309 --> 00:00:49,839
在堆栈上。

16
00:00:49,840 --> 00:00:54,680
那么我们如何从没有功能获得
程序，到root shell？

17
00:00:54,680 --> 00:01:01,920
所以戴上你的巫师的帽子，因为我们会
做一些魔术。

18
00:01:01,920 --> 00:01:07,360
让我们在gdb中打开这个程序吧
只是扔一个长串反对它。

19
00:01:07,360 --> 00:01:10,820
要做到这一点，我们已经准备好了我们的漏洞
脚本。

20
00:01:10,820 --> 00:01:14,900
所以首先我们要找到允许的偏移量
我们来控制指令指针。

21
00:01:14,900 --> 00:01:17,800
我想用一个像
字母表。

22
00:01:17,800 --> 00:01:21,770
所以我创建这个漏洞变量并分配
把长长的字符串放到上面，然后打印出来。

23
00:01:21,770 --> 00:01:26,840
现在将此脚本的输出重定向到
一个文件，然后我们可以将其用作

24
00:01:26,840 --> 00:01:28,350
GDB。

25
00:01:28,350 --> 00:01:32,150
在执行程序之前，我们先创建
在主程序返回时的一个断点。

26
00:01:32,150 --> 00:01:36,970
让我们定义一个钩子，就像我们所做的那样
在以前的视频中。

27
00:01:36,970 --> 00:01:41,610
定义钩子停止，我们希望显示
将要执行的当前指令

28
00:01:41,610 --> 00:01:47,190
接下来，在该位置检查一条指令
EIP。

29
00:01:47,190 --> 00:01:51,390
然后从堆栈中检查8个十六进制单词。

30
00:01:51,390 --> 00:01:52,890
结束。

31
00:01:52,890 --> 00:01:56,450
然后执行它，我们就到达了断点
在返回。

32
00:01:56,450 --> 00:01:59,790
下一行显示堆栈的外观
就像现在一样。

33
00:01:59,790 --> 00:02:05,270
当我们执行RET时，我们会跳
到堆栈上以前的地址。

34
00:02:05,270 --> 00:02:08,390
所以不可以用字母表再执行一次。

35
00:02:08,390 --> 00:02:12,890
我们又回来了，我们可以看到
我们已经覆盖了堆栈上的内容。

36
00:02:12,890 --> 00:02:18,470
现在我们试着返回地址hex 545454。

37
00:02:18,469 --> 00:02:21,719
这显然是无效的，所以我们得到一个分段
Fault。

38
00:02:21,719 --> 00:02:26,459
使用examine作为字符串，我们可以看到
我们已经用覆盖返回指针

39
00:02:26,459 --> 00:02:31,419
T的

40
00:02:31,420 --> 00:02:34,270
所以让我们更新我们的漏洞脚本。

41
00:02:34,269 --> 00:02:35,819
这将是我们的填充物。

42
00:02:35,819 --> 00:02:40,119
我们创建变量eip，我们可以
用于控制指令指针和

43
00:02:40,120 --> 00:02:42,280
想跳到哪里就跳。

44
00:02:42,280 --> 00:02:46,400
我使用struct创建一个二进制字符串
再次从地址。

45
00:02:46,400 --> 00:02:48,750
所以结构。

46
00:02:48,749 --> 00:02:50,269
但是我们想跳到哪里呢？

47
00:02:50,269 --> 00:02:55,089
我们没有类似的win（）函数
以前的级别。

48
00:02:55,090 --> 00:02:57,220
你知道我们可以跳到哪里吗？

49
00:02:57,219 --> 00:03:04,589
我想我会让你思考一下
关于这个。

50
00:03:04,590 --> 00:03:13,040
好吧，我们可以跳到那堆
我们控制数据。

51
00:03:13,040 --> 00:03:16,290
所以很明显我们可以安排一些装配工
代码在那里。

52
00:03:16,290 --> 00:03:18,320
现在我们找个好地址。

53
00:03:18,319 --> 00:03:22,089
我们可以在接到指令后马上跳下去
我们控制的指针。

54
00:03:22,090 --> 00:03:27,020
要做到这一点，只需再次运行，执行ret
看看栈指针。

55
00:03:27,019 --> 00:03:29,999
所以这就是我们要跳转到的地址。

56
00:03:30,000 --> 00:03:35,820
现在我们必须附加我们想要的代码
在返回指针之后执行，所以为什么

57
00:03:35,819 --> 00:03:41,809
不使用操作码cc，int3，它们是
在挑战描述中提出建议。

58
00:03:41,810 --> 00:03:45,340
让我们也快速了解一下Intel
说明参考。

59
00:03:45,340 --> 00:03:47,800
让我们搜索“int 3”。

60
00:03:47,799 --> 00:03:50,469
好的，嗯…叫它中断程序。

61
00:03:50,469 --> 00:03:52,159
我们还能找到什么。

62
00:03:52,160 --> 00:03:56,570
在本表中，关于一般例外情况
调用此指令断点？

63
00:03:56,569 --> 00:03:59,109
胡，真有趣。

64
00:03:59,110 --> 00:04:02,160
好的，这是对它的描述。

65
00:04:02,159 --> 00:04:04,399
中断3，陷阱到调试器。

66
00:04:04,400 --> 00:04:06,390
下面是：

67
00:04:06,389 --> 00:04:11,819
int 3指令是一个特殊的单字节
用于调用

68
00:04:11,819 --> 00:04:13,579
调试异常处理程序。

69
00:04:13,579 --> 00:04:18,399
（这个单字节形式很有价值，因为它
可用于替换

70
00:04:18,400 --> 00:04:23,000
具有断点的指令，包括其他
单字节指令，无过度写入

71
00:04:23,000 --> 00:04:24,050
其他代码）。

72
00:04:24,050 --> 00:04:25,050
哇哦。

73
00:04:25,050 --> 00:04:26,510
那是什么意思？

74
00:04:26,510 --> 00:04:29,020
嗯，你认为gdb是如何工作的？

75
00:04:29,020 --> 00:04:31,500
或者其他的调试器？

76
00:04:31,500 --> 00:04:34,220
怎样才能阻止CPU执行
某物。

77
00:04:34,220 --> 00:04:36,200
或者只是一个指令？

78
00:04:36,200 --> 00:04:40,630
实际上，调试程序只能使用int 3
指令。

79
00:04:40,630 --> 00:04:42,570
让我们举个例子。

80
00:04:42,570 --> 00:04:45,810
我们刚刚在这个ret上创建了一个断点。

81
00:04:45,810 --> 00:04:51,080
我们实际做的是，我们换了这个
用int 3返回内存中的指令。

82
00:04:51,080 --> 00:04:54,110
当CPU达到这个指令时，
引发了异常。

83
00:04:54,110 --> 00:05:00,010
或者在硬件方面，一个中断被触发，
它阻止了CPU继续执行

84
00:05:00,010 --> 00:05:07,140
并调用一个中断处理程序（类似
系统调用如何导致中断和执行

85
00:05:07,140 --> 00:05:08,140
继续其他地方）。

86
00:05:08,140 --> 00:05:12,180
现在我们可以决定如何处理
这个例外。

87
00:05:12,180 --> 00:05:16,990
如果我们是一个调试器，我们现在将替换
这个int 3指令与原来的

88
00:05:16,990 --> 00:05:18,920
值，返回指令。

89
00:05:18,920 --> 00:05:22,920
也可以用来做倒车
技术。

90
00:05:22,920 --> 00:05:26,780
因为常规应用程序不会使用
CC指令。

91
00:05:26,780 --> 00:05:31,890
所以恶意软件可能会不断扫描自己
对于CC操作码，如果找到它，它

92
00:05:31,890 --> 00:05:36,590
知道有人附加了一个调试器
试图设置断点。

93
00:05:36,590 --> 00:05:38,220
现在我们将在有效载荷中使用CC。

94
00:05:38,220 --> 00:05:39,220
所以我们在
覆盖返回指针。

95
00:05:39,220 --> 00:05:41,890
别忘了写
在漏洞文件中编写脚本。

96
00:05:41,890 --> 00:05:44,040
然后在gdb中测试这个。

97
00:05:44,040 --> 00:05:45,740
好的，再跑。

98
00:05:45,740 --> 00:05:49,800
我们可以看到我们在退房处停了下来，
我们看到了我们将返回的地址。

99
00:05:49,800 --> 00:05:56,200
当我们继续时，我们弹出指令
堆栈中的指针值，因此继续

100
00:05:56,200 --> 00:06:02,500
在堆栈上执行，我们的
Int 3 Instructions，如您所见，GDB

101
00:06:02,500 --> 00:06:07,560
停止，因为它接收到信号信号陷阱，
跟踪/断点陷阱。

102
00:06:07,560 --> 00:06:08,560
酷。

103
00:06:08,560 --> 00:06:13,220
这样我们就知道我们有代码执行，
因为我们成功地注入了一个汇编程序

104
00:06:13,220 --> 00:06:14,930
指令。

105
00:06:14,930 --> 00:06:17,360
现在，没有gdb这也行吗？

106
00:06:17,360 --> 00:06:19,480
让我们试试……

107
00:06:19,480 --> 00:06:22,430
但是我们得到了非法指令？

108
00:06:22,430 --> 00:06:24,630
这不是我们应该看到的。

109
00:06:24,630 --> 00:06:26,240
我们应该得到断点消息。

110
00:06:26,240 --> 00:06:31,060
让我们在gdb中打开它，然后再试一次。

111
00:06:31,060 --> 00:06:32,460
仍然是非法指令。

112
00:06:32,460 --> 00:06:39,880
让我们设置钩子和断点
就像在其他GDB会话中一样。

113
00:06:39,880 --> 00:06:41,370
好吧，跑吧。

114
00:06:41,370 --> 00:06:42,660
嗯…

115
00:06:42,660 --> 00:06:45,060
堆栈上的地址不相同。

116
00:06:45,060 --> 00:06:47,220
为什么它们不同？

117
00:06:47,220 --> 00:06:49,550
让我们做些疯狂的事情吧。

118
00:06:49,550 --> 00:06:50,710
打印整个堆栈。

119
00:06:50,710 --> 00:06:53,060
我只印了一千串或其他东西。

120
00:06:53,060 --> 00:06:55,250
让我们看看我们得到了什么。

121
00:06:55,250 --> 00:06:57,130
好的，首先我们有一些基代数。

122
00:06:57,130 --> 00:06:58,270
我们走得更远。

123
00:06:58,270 --> 00:06:59,270
嗯……看。

124
00:06:59,270 --> 00:07:00,980
现在我们得到一些有趣的东西。

125
00:07:00,980 --> 00:07:04,160
让我们在另一个gdb会话中做同样的事情。

126
00:07:04,160 --> 00:07:06,380
这看起来像环境变量。

127
00:07:06,380 --> 00:07:11,150
例如，这里是用户环境变量
我们在以前的程序中使用的

128
00:07:11,150 --> 00:07:12,150
视频。

129
00:07:12,150 --> 00:07:16,400
当你看到地址时，他们
仍然是不同的。

130
00:07:16,400 --> 00:07:17,400
让我们再往下看。

131
00:07:17,400 --> 00:07:21,630
嗯！在这里他们是一样的。

132
00:07:21,630 --> 00:07:26,540
所以在这里和环境变量之间
上面应该有一些不同的东西。

133
00:07:26,540 --> 00:07:31,710
当你仔细观察的时候，你会发现
pwd环境变量，当前

134
00:07:31,710 --> 00:07:33,610
工作目录不同。

135
00:07:33,610 --> 00:07:35,960
它们的长度不同。

136
00:07:35,960 --> 00:07:41,010
很明显，只有一个执行环境
堆栈上需要更多空间来存储此

137
00:07:41,010 --> 00:07:42,010
路径。

138
00:07:42,010 --> 00:07:44,060
从而进一步推高堆栈。

139
00:07:44,060 --> 00:07:48,170
难怪堆栈地址不是
再也一样了。

140
00:07:48,170 --> 00:07:50,340
那么我们如何应对呢？

141
00:07:50,340 --> 00:07:54,290
有一些技巧
可以用来对

142
00:07:54,290 --> 00:07:55,290
栈。

143
00:07:55,290 --> 00:07:59,140
例如，通过删除所有环境变量
在执行二进制文件之前。

144
00:07:59,140 --> 00:08:03,550
但是还有另一个很容易但很有效的方法
诡计。

145
00:08:03,550 --> 00:08:04,690
这里有一个提示：

146
00:08:04,690 --> 00:08:08,260
不，不，不，不，不，不

147
00:08:08,260 --> 00:08:10,280
好的……没有幻灯片……

148
00:08:10,280 --> 00:08:13,300
让我们添加一个loooot的nop指令。

149
00:08:13,300 --> 00:08:16,050
nop指令不执行任何操作。

150
00:08:16,050 --> 00:08:17,980
它有操作码hex 90。

151
00:08:17,980 --> 00:08:22,310
而不是选择一个非常具体的堆栈
地址，让我们选一个我们希望的

152
00:08:22,310 --> 00:08:24,150
击中我们的NoP。

153
00:08:24,150 --> 00:08:25,580
所以再次运行。

154
00:08:25,580 --> 00:08:28,710
现在我们可以看到我们在
栈。

155
00:08:28,710 --> 00:08:32,700
我们将跳转到某个地点的地址
再往下走。

156
00:08:32,700 --> 00:08:36,930
如果我们看更多的堆栈，我们可以看到
它几乎就在中间

157
00:08:36,930 --> 00:08:39,990
NOPS的。

158
00:08:39,990 --> 00:08:42,740
让我们向前迈出一步。

159
00:08:42,740 --> 00:08:48,030
现在我们高兴地滑下了nop滑道
直到我们用陷阱到达底部！

160
00:08:48,029 --> 00:08:49,219
繁荣。

161
00:08:49,220 --> 00:08:50,410
酷。

162
00:08:50,410 --> 00:08:53,780
这也在GDB之外起作用。

163
00:08:53,779 --> 00:08:56,959
现在，我们要执行一些操作，而不是CC
有用的。

164
00:08:56,960 --> 00:08:59,390
所以我们来找一些外壳代码。

165
00:08:59,389 --> 00:09:04,259
正如挑战描述所说，这是
最好是重用别人的shell代码。

166
00:09:04,259 --> 00:09:08,639
我真的很喜欢贝壳代码的收集
来自暴风雪。

167
00:09:08,640 --> 00:09:12,660
暴风雪有很多不同的种类
Shellcode，用于许多不同的系统。

168
00:09:12,660 --> 00:09:16,280
所以我们要找的是LinuxIntel32bit
贝壳代码。

169
00:09:16,279 --> 00:09:21,809
Freebsd，ARM上的Linux，64位，这里我们
有32位。

170
00:09:21,810 --> 00:09:24,360
他们都有一个简短的描述和做不同的
东西。

171
00:09:24,360 --> 00:09:28,540
但我们正在寻找一个简单的执行
将执行shell。

172
00:09:28,540 --> 00:09:31,160
所以，为什么不买这个呢？

173
00:09:31,160 --> 00:09:35,310
如果你看汇编程序代码，它是什么？
是基本上只是推一些价值观

174
00:09:35,310 --> 00:09:40,730
在堆栈上，它只是一个字符串
这是路径/bin/sh。

175
00:09:40,730 --> 00:09:42,960
然后呼叫Execve。

176
00:09:42,959 --> 00:09:46,699
将字节复制到python漏洞脚本中
作为有效载荷，我们可以把它扔到

177
00:09:46,699 --> 00:09:52,559
程序。

178
00:09:52,560 --> 00:09:59,600
嗯……什么都没发生。

179
00:09:59,600 --> 00:10:00,600
它不工作吗？

180
00:10:00,600 --> 00:10:03,930
让我们在有效载荷开始处添加CC
如果我们仍然击中它。

181
00:10:03,931 --> 00:10:07,711
它应该起作用。

182
00:10:07,709 --> 00:10:12,029
移除CC againa并在gdb中尝试。让我们
单步执行。

183
00:10:12,029 --> 00:10:13,549
我们正在滑下NOP滑道。

184
00:10:13,550 --> 00:10:14,550
一切似乎都很好。

185
00:10:14,550 --> 00:10:15,960
现在是Shellcode。

186
00:10:15,959 --> 00:10:20,059
它说：“执行新程序，/bin/dash”。

187
00:10:20,060 --> 00:10:23,010
这听起来很奇怪，但是正确的。

188
00:10:23,010 --> 00:10:25,180
/bin/sh只指向/bin/dash。

189
00:10:25,180 --> 00:10:27,970
为什么它不起作用？

190
00:10:27,970 --> 00:10:28,970
也在旁注上。

191
00:10:28,970 --> 00:10:30,520
这个gdb会话没有中断。

192
00:10:30,520 --> 00:10:34,090
因为execve替换了当前程序
和另一个。

193
00:10:34,089 --> 00:10:35,909
所以stack5被/bin/dash替换。

194
00:10:35,910 --> 00:10:39,490
当你试图执行
再说一遍。

195
00:10:39,490 --> 00:10:41,950
所以你必须再次加载stack5
文件。

196
00:10:41,949 --> 00:10:42,949
好啊。

197
00:10:42,949 --> 00:10:45,339
那么问题是什么呢？

198
00:10:45,339 --> 00:10:46,979
这是我发疯的原因之一。

199
00:10:46,980 --> 00:10:52,070
当我第一次像这样被困的时候，我会花上几个小时
试图弄清楚发生了什么。

200
00:10:52,069 --> 00:10:57,579
就像我想看到别人受苦一样
像我一样，我告诉你问题是什么。

201
00:10:57,579 --> 00:11:01,459
你执行的shell需要一些输入，对吗？

202
00:11:01,459 --> 00:11:02,759
来自标准输入。

203
00:11:02,759 --> 00:11:03,759
但是！.

204
00:11:03,759 --> 00:11:09,309
我们使用了一个程序并重定向了它的stdOutput
输入到这个程序的stdinput中。

205
00:11:09,309 --> 00:11:12,389
当程序完成后，它关闭了
管子。

206
00:11:12,389 --> 00:11:16,299
所以现在shell被执行了，但是没有
有任何输入。

207
00:11:16,300 --> 00:11:17,310
因为它已经关闭了。

208
00:11:17,310 --> 00:11:19,490
所以它就会退出。

209
00:11:19,490 --> 00:11:22,960
还有一个简单的技巧
在这附近。

210
00:11:22,959 --> 00:11:28,989
当您使用没有参数的cat时，它只是
将它的stdinput重定向到标准输出。

211
00:11:28,990 --> 00:11:30,130
请看这里。

212
00:11:30,130 --> 00:11:34,280
你输入一些东西，它就会被反映出来
出来。

213
00:11:34,279 --> 00:11:38,859
现在你可以把程序连在一起
行，例如分号。

214
00:11:38,860 --> 00:11:43,930
所以我们可以先打印出漏洞的输出，
然后猫被处决了，所以我们可以

215
00:11:43,930 --> 00:11:45,730
输入新输入。

216
00:11:45,730 --> 00:11:50,270
如果我们现在用括号来分组，
并将它们的组合输出重定向到

217
00:11:50,270 --> 00:11:55,560
堆栈级别，漏洞将首先运行并
执行一个shell，然后cat将接管

218
00:11:55,559 --> 00:11:59,459
我们可以简单地通过CAT将输入中继到
壳牌。

219
00:11:59,459 --> 00:12:01,709
巴姆！它起作用了。

220
00:12:01,709 --> 00:12:06,599
我们有一个丑陋的外壳，我们可以验证
与whoami或id的身份。

221
00:12:06,600 --> 00:12:09,260
所以现在我们把特权升级到根目录。

222
00:12:09,259 --> 00:12:11,239
该死。感觉很好。

223
00:12:11,240 --> 00:12:12,350
真是太美了。

