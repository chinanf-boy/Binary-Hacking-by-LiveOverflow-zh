1
00:00:06,230 --> 00:00:09,050
让我们继续，栈级别5的漏洞利用。

2
00:00:09,050 --> 00:00:13,430
你应该看之前的视频，了解我们是怎么到这一步的。

3
00:00:13,430 --> 00:00:14,530
挑战描述

4
00:00:14,530 --> 00:00:20,240
stack5是一个标准的缓冲区溢出，这次引入了shellcode。

5
00:00:20,240 --> 00:00:21,260
提示是：

6
00:00:21,260 --> 00:00:25,200
这样，可能更容易使用别人的shellcode。

7
00:00:25,199 --> 00:00:27,179
这也是我们将要做的。

8
00:00:27,180 --> 00:00:28,180
和

9
00:00:28,180 --> 00:00:33,580
如果调试shellcode，请使用操作码 hex cc 的 “int3”指令

10
00:00:33,579 --> 00:00:37,049
去停止程序的执行，并返回到调试器。

11
00:00:37,050 --> 00:00:38,360
这很有帮助。

12
00:00:38,360 --> 00:00:41,760
好的，让我们看一下这个代码。

13
00:00:41,760 --> 00:00:42,950
它非常小。

14
00:00:42,949 --> 00:00:48,309
只有一个函数调用gets()，我们知道它

15
00:00:48,309 --> 00:00:49,839
允许我们覆盖在栈上的数据。

16
00:00:49,840 --> 00:00:54,680
那么，我们如何从没有程序功能的地方，得到一个根 shell呢？

17
00:00:54,680 --> 00:01:01,920
让我们戴上巫师的帽子，因为我们要施展魔法啦。

18
00:01:01,920 --> 00:01:07,360
让我们在gdb中，打开这个程序，然后向它抛出一个 long 字符串。

19
00:01:07,360 --> 00:01:10,820
为了做到这一点，我们已经准备好了我们的漏洞脚本。

20
00:01:10,820 --> 00:01:14,900
所以，我们首先要找到，允许我们控制指令指针的偏移量。

21
00:01:14,900 --> 00:01:17,800
我想用一个简单的模式，像字母表。

22
00:01:17,800 --> 00:01:21,770
所以，我创建了这个 exploit 变量，并将 long 字符串赋给它，然后打印它。

23
00:01:21,770 --> 00:01:26,840
现在，将该脚本的输出，重定向到一个文件中，然后我们可以将该文件，

24
00:01:26,840 --> 00:01:28,350
用作 gdb的输入。

25
00:01:28,350 --> 00:01:32,150
在执行程序之前，让我们在main的返回处，创建一个断点。

26
00:01:32,150 --> 00:01:36,970
和定义一个钩子，就像我们在前一个视频中，所做的那样。

27
00:01:36,970 --> 00:01:41,610
定义 stop 钩子，我们希望显示，将执行的正确指令。

28
00:01:41,610 --> 00:01:47,190
接下来，检查EIP位置的一条指令。

29
00:01:47,190 --> 00:01:51,390
然后检查栈中，8个十六进制单词。

30
00:01:51,390 --> 00:01:52,890
结束。

31
00:01:52,890 --> 00:01:56,450
然后执行它，我们会在函数返回那里，碰到了断点。

32
00:01:56,450 --> 00:01:59,790
下一行显示了，栈现在的样子。

33
00:01:59,790 --> 00:02:05,270
当我们执行ret时，我们将跳到，栈以前的地址。

34
00:02:05,270 --> 00:02:08,390
所以，不可以用字母表，再次执行。

35
00:02:08,390 --> 00:02:12,890
我们再次返回，我们可以看到栈上，有覆盖的内容。

36
00:02:12,890 --> 00:02:18,470
现在，我们试着返回到地址 hex 545454。

37
00:02:18,469 --> 00:02:21,719
这显然是无效的，所以我们得到一个分段错误。

38
00:02:21,719 --> 00:02:26,459
使用 examine 作为字符串，我们可以看到

39
00:02:26,459 --> 00:02:31,419
我们已经用 T 覆盖了返回指针

40
00:02:31,420 --> 00:02:34,270
所以，让我们更新我们的漏洞脚本。

41
00:02:34,269 --> 00:02:35,819
这将是我们的填充物。

42
00:02:35,819 --> 00:02:40,119
然后我们创建，变量 eip，我们可以使用它，来控制指令指针和

43
00:02:40,120 --> 00:02:42,280
想跳到哪里，就跳那里。

44
00:02:42,280 --> 00:02:46,400
我再次使用 struct，从地址创建一个二进制字符串。

45
00:02:46,400 --> 00:02:48,750
所以使用 struct.pack 。

46
00:02:48,749 --> 00:02:50,269
但是，我们想跳到哪里呢？

47
00:02:50,269 --> 00:02:55,089
我们没有像以前的级别一样，任何有关 win() 的函数。

48
00:02:55,090 --> 00:02:57,220
你知道，我们可以跳到哪里吗？

49
00:02:57,219 --> 00:03:04,589
我想，我会先让你考虑一下(暂停想一想)。

50
00:03:04,590 --> 00:03:13,040
对，我们可以直接跳到，控制了数据的栈的地址。

51
00:03:13,040 --> 00:03:16,290
所以很明显，我们可以在那里，放置一些汇编代码。

52
00:03:16,290 --> 00:03:18,320
现在我们找个好地址。

53
00:03:18,319 --> 00:03:22,089
我们可以直接跳到，我们控制的指令指针之后。

54
00:03:22,090 --> 00:03:27,020
要做到这一点，只需再次 run，执行 ret 并查看栈指针。

55
00:03:27,019 --> 00:03:29,999
可以看到，这就是我们要跳转到的地址。

56
00:03:30,000 --> 00:03:35,820
现在我们必须在返回指针之后，加上要执行的代码，

57
00:03:35,819 --> 00:03:41,809
所以我们为什么不用用操作码 cc，即 int3 呢，它们在挑战描述中，也是建议使用的。

58
00:03:41,810 --> 00:03:45,340
我们还可以快速查看，英特尔指令参考。

59
00:03:45,340 --> 00:03:47,800
让我们搜索“int 3”。

60
00:03:47,799 --> 00:03:50,469
好的，嗯… 叫做 中断程序。

61
00:03:50,469 --> 00:03:52,159
我们还能找到什么。

62
00:03:52,160 --> 00:03:56,570
在这个关于一般异常情况的表格中，它调用这个指令断点？

63
00:03:56,569 --> 00:03:59,109
呼，真有趣。

64
00:03:59,110 --> 00:04:02,160
好的，这就是对它的描述了。

65
00:04:02,159 --> 00:04:04,399
中断数3，给调试器布置陷阱。

66
00:04:04,400 --> 00:04:06,390
下面是：

67
00:04:06,389 --> 00:04:11,819
Int3指令是一个特殊的单字节操作码（CC），

68
00:04:11,819 --> 00:04:13,579
用于调用调试异常处理程序。

69
00:04:13,579 --> 00:04:18,399
（此单字节格式很有价值，因为它可以用一个断点

70
00:04:18,400 --> 00:04:23,000
替换指令的首字节，包括其他单字节指令，而不需要

71
00:04:23,000 --> 00:04:24,050
过量编写其他代码）。

72
00:04:24,050 --> 00:04:25,050
哇哦。

73
00:04:25,050 --> 00:04:26,510
那究竟是什么意思？

74
00:04:26,510 --> 00:04:29,020
嗯，你认为 gdb 是如何工作的？

75
00:04:29,020 --> 00:04:31,500
或者其他相应的调试器？

76
00:04:31,500 --> 00:04:34,220
你怎么能阻止CPU，执行某件事情呢？

77
00:04:34,220 --> 00:04:36,200
或者只是前进一个指令？

78
00:04:36,200 --> 00:04:40,630
实际上，调试程序只能使用int 3指令。

79
00:04:40,630 --> 00:04:42,570
让我们举个例子。

80
00:04:42,570 --> 00:04:45,810
我们刚刚在这个ret上，创建了一个断点。

81
00:04:45,810 --> 00:04:51,080
实际上，我们是用int 3，替换了内存中的这个返回指令。

82
00:04:51,080 --> 00:04:54,110
当CPU达到这个指令时，引发了一个异常。

83
00:04:54,110 --> 00:05:00,010
或者在硬件方面，一个中断被触发，从而使CPU停止继续执行。

84
00:05:00,010 --> 00:05:07,140
并调用一个中断处理程序（类似于系统调用，导致中断和执行

85
00:05:07,140 --> 00:05:08,140
继续其他地方的方式）。

86
00:05:08,140 --> 00:05:12,180
现在，我们可以决定如何处理这个异常。

87
00:05:12,180 --> 00:05:16,990
如果我们是一个调试器，现在我们将把这个int 3指令，

88
00:05:16,990 --> 00:05:18,920
重新换回原来的指令值，再返回指令。

89
00:05:18,920 --> 00:05:22,920
这也可以作为一种反反转技术。

90
00:05:22,920 --> 00:05:26,780
因为常规应用程序，不会使用CC指令。

91
00:05:26,780 --> 00:05:31,890
因此，恶意软件可能会不断扫描自己的CC操作码，

92
00:05:31,890 --> 00:05:36,590
如果它找到了，它就知道有人附加了一个调试器，并试图设置断点。

93
00:05:36,590 --> 00:05:38,220
现在，我们将在 payload 中使用CC。

94
00:05:38,220 --> 00:05:39,220
所以，让我们在覆盖的返回指针后面，附加几个 CC。

95
00:05:39,220 --> 00:05:41,890
不要忘记，将脚本的输出写入漏洞文件。

96
00:05:41,890 --> 00:05:44,040
然后在gdb中，测试这个。

97
00:05:44,040 --> 00:05:45,740
好的，再 run。

98
00:05:45,740 --> 00:05:49,800
我们可以看到我们停在ret，还有看到我们将返回的地址。

99
00:05:49,800 --> 00:05:56,200
当我们现在继续，我们从栈中，弹出指令指针值，

100
00:05:56,200 --> 00:06:02,500
从而继续在栈的执行，我们有int 3指令，如您所见，gdb

101
00:06:02,500 --> 00:06:07,560
从而继续停止，因为它接收到一个信号SIGTRAP，一个跟踪/断点陷阱。

102
00:06:07,560 --> 00:06:08,560
酷。

103
00:06:08,560 --> 00:06:13,220
这样我们就知道，我们有代码执行，因为我们成功

104
00:06:13,220 --> 00:06:14,930
注入了一个汇编程序指令。

105
00:06:14,930 --> 00:06:17,360
现在可以想想，若没有了gdb，也行吗？

106
00:06:17,360 --> 00:06:19,480
让我们试试… 

107
00:06:19,480 --> 00:06:22,430
但是，我们得到了非法指令？

108
00:06:22,430 --> 00:06:24,630
这不是我们应该看到的。

109
00:06:24,630 --> 00:06:26,240
我们应该得到断点消息。

110
00:06:26,240 --> 00:06:31,060
让我们在gdb中，打开它，然后再试一次。

111
00:06:31,060 --> 00:06:32,460
仍然是非法指令。

112
00:06:32,460 --> 00:06:39,880
让我们像在其他gdb会话中，一样设置钩子和断点。

113
00:06:39,880 --> 00:06:41,370
好吧，run 吧。

114
00:06:41,370 --> 00:06:42,660
嗯…

115
00:06:42,660 --> 00:06:45,060
栈上的地址，不相同。

116
00:06:45,060 --> 00:06:47,220
为什么它们不同？

117
00:06:47,220 --> 00:06:49,550
让我们做些疯狂的事情吧。

118
00:06:49,550 --> 00:06:50,710
打印整个栈。

119
00:06:50,710 --> 00:06:53,060
我只印了一千个字符串，或其他东西。

120
00:06:53,060 --> 00:06:55,250
让我们看看，我们得到了什么。

121
00:06:55,250 --> 00:06:57,130
好的，首先我们有一些基代数 gibebrish。

122
00:06:57,130 --> 00:06:58,270
我们走远点。

123
00:06:58,270 --> 00:06:59,270
嗯… 看。

124
00:06:59,270 --> 00:07:00,980
现在，我们得到一些有趣的东西。

125
00:07:00,980 --> 00:07:04,160
让我们在另一个gdb会话中，做同样的事情。

126
00:07:04,160 --> 00:07:06,380
这看起来像环境变量。

127
00:07:06,380 --> 00:07:11,150
例如，这里是我们在以前的编程视频中，

128
00:07:11,150 --> 00:07:12,150
使用的用户环境变量

129
00:07:12,150 --> 00:07:16,400
呃，当你看到地址时，它们仍然是不同的。

130
00:07:16,400 --> 00:07:17,400
让我们再往下看。

131
00:07:17,400 --> 00:07:21,630
嗯！在这里，他们是一样的。

132
00:07:21,630 --> 00:07:26,540
所以，在这里和上面的环境变量之间，肯定出现了一些不同。

133
00:07:26,540 --> 00:07:31,710
当你仔细观察，你可以看到pwd环境变量，

134
00:07:31,710 --> 00:07:33,610
当前工作目录不同。

135
00:07:33,610 --> 00:07:35,960
它们的长度不同。

136
00:07:35,960 --> 00:07:41,010
所以很明显，一个执行环境需要在栈上，有更多的空间

137
00:07:41,010 --> 00:07:42,010
来存储这个路径。

138
00:07:42,010 --> 00:07:44,060
从而进一步，让栈地址变高了。

139
00:07:44,060 --> 00:07:48,170
难怪，栈地址不再相同了。

140
00:07:48,170 --> 00:07:50,340
那么我们如何应对呢？

141
00:07:50,340 --> 00:07:54,290
您可以使用一些技术，

142
00:07:54,290 --> 00:07:55,290
来更好地控制栈。

143
00:07:55,290 --> 00:07:59,140
例如，在执行二进制文件之前，删除所有环境变量。

144
00:07:59,140 --> 00:08:03,550
但还有另一个非常简单但有效的技巧。

145
00:08:03,550 --> 00:08:04,690
这里有一个提示：

146
00:08:04,690 --> 00:08:08,260
nop, nop, nop, nop, nop

147
00:08:08,260 --> 00:08:10,280
好吧… 没有幻灯片… 

148
00:08:10,280 --> 00:08:13,300
让我们添加一个许许多多 的 nop指令。

149
00:08:13,300 --> 00:08:16,050
nop指令是，不执行任何操作。

150
00:08:16,050 --> 00:08:17,980
它有操作码 hex 90。

151
00:08:17,980 --> 00:08:22,310
不选择一个非常具体的栈地址，

152
00:08:22,310 --> 00:08:24,150
让我们选择一个，希望击中我们的 nop 们的地址。

153
00:08:24,150 --> 00:08:25,580
所以，再次run。

154
00:08:25,580 --> 00:08:28,710
现在，我们可以看到栈上有很多nop。

155
00:08:28,710 --> 00:08:32,700
还有下一个跳转的地址，指向了某处。

156
00:08:32,700 --> 00:08:36,930
但如果我们看多些的栈信息，我们可以看到几乎指向，

157
00:08:36,930 --> 00:08:39,990
nop们的中间。

158
00:08:39,990 --> 00:08:42,740
让我们程序向前，迈出一步。

159
00:08:42,740 --> 00:08:48,030
现在，我们高兴啦，它滑下了 nop 滑道，直到陷阱底部！

160
00:08:48,029 --> 00:08:49,219
炸裂。

161
00:08:49,220 --> 00:08:50,410
酷。

162
00:08:50,410 --> 00:08:53,780
这(技巧)在 gdb 之外，也起作用。

163
00:08:53,779 --> 00:08:56,959
现在，我们要执行一些有用的操作，而不是CC。

164
00:08:56,960 --> 00:08:59,390
所以我们来找一些 shellcode。

165
00:08:59,389 --> 00:09:04,259
正如挑战描述所说，最好重用其他人的 shellcode。

166
00:09:04,259 --> 00:09:08,639
我真的很喜欢从ShellStorm，收集的 hellcode。

167
00:09:08,640 --> 00:09:12,660
ShellStorm 有许多不同类型的 Shellcode，用于许多不同的系统。

168
00:09:12,660 --> 00:09:16,280
因此，我们正在寻找一个Linux Intel 32bit 的 shellcode。

169
00:09:16,279 --> 00:09:21,809
freebsd，arm 上 的linux，64位，这里我们有32位。

170
00:09:21,810 --> 00:09:24,360
他们都有一个简短的描述，且用来做不同的事情。

171
00:09:24,360 --> 00:09:28,540
但是我们正在寻找一个简单的，执行 shell 的 execve。

172
00:09:28,540 --> 00:09:31,160
所以，为什么不选这个呢？

173
00:09:31,160 --> 00:09:35,310
如果你看一下汇编程序代码，它所做的基本上，

174
00:09:35,310 --> 00:09:40,730
就是推一些值进栈，实际上，它只是一个字符串，它是 路径 /bin/sh。

175
00:09:40,730 --> 00:09:42,960
然后，再调用 execve。

176
00:09:42,959 --> 00:09:46,699
将字节作为 playload ，复制到 python exploit 脚本中，

177
00:09:46,699 --> 00:09:52,559
我们可以放出去，对抗程序。

178
00:09:52,560 --> 00:09:59,600
嗯… 什么都没发生。

179
00:09:59,600 --> 00:10:00,600
它不工作吗？

180
00:10:00,600 --> 00:10:03,930
如果仍能用，让我们在 playload 开始时，添加CC，。

181
00:10:03,931 --> 00:10:07,711
它应该起作用。

182
00:10:07,709 --> 00:10:12,029
移除CC againa ，并在gdb中尝试。让我们步进程序。

183
00:10:12,029 --> 00:10:13,549
我们正在滑下nop滑道。

184
00:10:13,550 --> 00:10:14,550
一切似乎都很好。

185
00:10:14,550 --> 00:10:15,960
现在是Shellcode。

186
00:10:15,959 --> 00:10:20,059
它说：“执行新程序，/bin/dash”。

187
00:10:20,060 --> 00:10:23,010
这听起来很奇怪，但，正确。

188
00:10:23,010 --> 00:10:25,180
/bin/sh 只是指向 /bin/dash。

189
00:10:25,180 --> 00:10:27,970
为什么，它不起作用？

190
00:10:27,970 --> 00:10:28,970
还有，在旁注上。

191
00:10:28,970 --> 00:10:30,520
这个gdb会话，没有中断。

192
00:10:30,520 --> 00:10:34,090
因为 execve，所以用另一个程序，替换当前程序。

193
00:10:34,089 --> 00:10:35,909
所以，stack5 被 /bin/dash 替换。

194
00:10:35,910 --> 00:10:39,490
当你再次尝试执行它时，你可以看到这一点。

195
00:10:39,490 --> 00:10:41,950
所以您必须，再次加载stack5和文件。

196
00:10:41,949 --> 00:10:42,949
好啊。

197
00:10:42,949 --> 00:10:45,339
那么问题是什么呢？

198
00:10:45,339 --> 00:10:46,979
这是我神经兮兮的原因之一。

199
00:10:46,980 --> 00:10:52,070
当我第一次陷入这样的困境时，我花了好几个小时，试图弄清楚到底发生了什么。

200
00:10:52,069 --> 00:10:57,579
尽管我很想看到像我一样受苦，但我会告诉你问题出在哪里。

201
00:10:57,579 --> 00:11:01,459
你执行的 shell 需要一些输入，对吗？

202
00:11:01,459 --> 00:11:02,759
比如：来自标准输入。

203
00:11:02,759 --> 00:11:03,759
但是！

204
00:11:03,759 --> 00:11:09,309
我们使用了一个程序，并将它的stdOutput重定向，到这个程序的stdInput中。

205
00:11:09,309 --> 00:11:12,389
当程序完成后，它关闭了管道。

206
00:11:12,389 --> 00:11:16,299
所以，现在shell被执行，但没有任何输入。

207
00:11:16,300 --> 00:11:17,310
因为，它已经关闭了。

208
00:11:17,310 --> 00:11:19,490
所以，它就会退出。

209
00:11:19,490 --> 00:11:22,960
有一个很好的技巧，基本可以解决这个问题。

210
00:11:22,959 --> 00:11:28,989
当您在没有用参数的情况下，使用cat时，它只是将stdinput，重定向到标准输出。

211
00:11:28,990 --> 00:11:30,130
请看这里。

212
00:11:30,130 --> 00:11:34,280
你输入一些东西，它就会反射出来。

213
00:11:34,279 --> 00:11:38,859
现在，您可以在一行代码上，将程序链接在一起，例如，使用分号。

214
00:11:38,860 --> 00:11:43,930
所以我们可以，先打印漏洞脚本的输出，然后执行cat，

215
00:11:43,930 --> 00:11:45,730
这样我们就可以输入，新 input。

216
00:11:45,730 --> 00:11:50,270
如果我们现在用一些括号,将其分组，并将它们的组合输出重定向到

217
00:11:50,270 --> 00:11:55,560
栈级别，漏洞脚本，首先运行并执行 shell，然后cat将接管

218
00:11:55,559 --> 00:11:59,459
再之后，我们可以简单将输入，通过cat 中继到shell。

219
00:11:59,459 --> 00:12:01,709
巴姆！它起作用了。

220
00:12:01,709 --> 00:12:06,599
我们有一个丑陋的外壳，我们可以用whoami 或 id 来验证我们的身份。

221
00:12:06,600 --> 00:12:09,260
所以现在我们，把特权升级到 root。

222
00:12:09,259 --> 00:12:11,239
一库。感觉很好。

223
00:12:11,240 --> 00:12:12,350
真是太美了。

