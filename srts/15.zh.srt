1
00:00:06,230 --> 00:00:09,050
Let’s move on to exploit-exercises stack level 5.

2
00:00:09,050 --> 00:00:13,430
You should have watched the previous videos to understand how we got here.

3
00:00:13,430 --> 00:00:14,530
挑战描述说

4
00:00:14,530 --> 00:00:20,240
Stack5 is a standard buffer overflow, this time introducing shellcode.

5
00:00:20,240 --> 00:00:21,260
提示是：

6
00:00:21,260 --> 00:00:25,200
that, it might be easier to use someone elses shellcode.

7
00:00:25,199 --> 00:00:27,179
That is also what we will do.

8
00:00:27,180 --> 00:00:28,180
和

9
00:00:28,180 --> 00:00:33,580
如果调试shellcode，请使用操作码hex cc的“int3”指令停止

10
00:00:33,579 --> 00:00:37,049
the program executing and return to the debugger.

11
00:00:37,050 --> 00:00:38,360
And that is very helpful.

12
00:00:38,360 --> 00:00:41,760
Ok, let’s have a look at this code.

13
00:00:41,760 --> 00:00:42,950
It is surprisingly small.

14
00:00:42,949 --> 00:00:48,309
只有一个函数调用gets（），我们知道它允许我们覆盖数据

15
00:00:48,309 --> 00:00:49,839
on the stack.

16
00:00:49,840 --> 00:00:54,680
那么，我们如何从没有程序功能的地方得到一个根shell呢？

17
00:00:54,680 --> 00:01:01,920
So put on your wizard's hat, because we will do some magic.

18
00:01:01,920 --> 00:01:07,360
Let’s open this program in gdb, and let’s just throw a long string against it.

19
00:01:07,360 --> 00:01:10,820
To do that let’s already prepare our exploit script.

20
00:01:10,820 --> 00:01:14,900
So first we want to find the offset that allows us to control the instruction pointer.

21
00:01:14,900 --> 00:01:17,800
I’d like to use a simple pattern like the alphabet.

22
00:01:17,800 --> 00:01:21,770
So I create this exploit variable and assign the long string to it, and then print that.

23
00:01:21,770 --> 00:01:26,840
现在将该脚本的输出重定向到一个文件中，然后我们可以将该文件用作

24
00:01:26,840 --> 00:01:28,350
gdb.

25
00:01:28,350 --> 00:01:32,150
Before we execute the program, let’s create a breakpoint at the return of main.

26
00:01:32,150 --> 00:01:36,970
And let’s define a hook, like we have done in a previous video.

27
00:01:36,970 --> 00:01:41,610
定义钩子停止，我们希望显示将执行的当前指令

28
00:01:41,610 --> 00:01:47,190
next, so examine one instruction at the location of eip.

29
00:01:47,190 --> 00:01:51,390
And then examine 8 words as hex from the stack.

30
00:01:51,390 --> 00:01:52,890
And end.

31
00:01:52,890 --> 00:01:56,450
Then execute it, and we hit the breakpoint at the return.

32
00:01:56,450 --> 00:01:59,790
The next line shows us how the stack looks like right now.

33
00:01:59,790 --> 00:02:05,270
And when we execute the ret, we will jump to the address that was on the stack before.

34
00:02:05,270 --> 00:02:08,390
So no execute it again with the alphabet.

35
00:02:08,390 --> 00:02:12,890
We are at the return again, and we can see that we have overwritten stuff on the stack.

36
00:02:12,890 --> 00:02:18,470
So now we try to return to address hex 54545454.

37
00:02:18,469 --> 00:02:21,719
Which is obviously invalid, so we get a Segmentation Fault.

38
00:02:21,719 --> 00:02:26,459
使用examine作为字符串，我们可以看到我们已经用

39
00:02:26,459 --> 00:02:31,419
T’s.

40
00:02:31,420 --> 00:02:34,270
So let’s update our exploit script.

41
00:02:34,269 --> 00:02:35,819
This will be our padding.

42
00:02:35,819 --> 00:02:40,119
然后我们创建变量eip，我们可以使用它来控制指令指针和

43
00:02:40,120 --> 00:02:42,280
jump anywhere we want.

44
00:02:42,280 --> 00:02:46,400
And I use struct to create a binary string from the address again.

45
00:02:46,400 --> 00:02:48,750
So struct.pack.

46
00:02:48,749 --> 00:02:50,269
但是我们想跳到哪里呢？

47
00:02:50,269 --> 00:02:55,089
We don’t have any win() function like in previous levels.

48
00:02:55,090 --> 00:02:57,220
你知道我们可以跳到哪里吗？

49
00:02:57,219 --> 00:03:04,589
I think I will give you a second to think about this.

50
00:03:04,590 --> 00:03:13,040
Right, we can just jump to the stack where we control data.

51
00:03:13,040 --> 00:03:16,290
So obviously we could place some assembler code there.

52
00:03:16,290 --> 00:03:18,320
Now let’s find a good address.

53
00:03:18,319 --> 00:03:22,089
We could just jump right after the instruction pointer we control.

54
00:03:22,090 --> 00:03:27,020
To do that just run again, execute the ret and have a look at the stack pointer.

55
00:03:27,019 --> 00:03:29,999
So that is the address we want to jump to.

56
00:03:30,000 --> 00:03:35,820
现在我们必须在返回指针之后附加要执行的代码，所以为什么

57
00:03:35,819 --> 00:03:41,809
not use the opcode CC, the int3, they were suggesting in the challenge description.

58
00:03:41,810 --> 00:03:45,340
Let’s also quickly have a look at the intel instruction reference.

59
00:03:45,340 --> 00:03:47,800
Let’s search for “Int 3”.

60
00:03:47,799 --> 00:03:50,469
Ok mmhh… call itnerrupt procedure.

61
00:03:50,469 --> 00:03:52,159
what else do we find.

62
00:03:52,160 --> 00:03:56,570
在这个关于一般异常的表中，它调用这个指令断点？

63
00:03:56,569 --> 00:03:59,109
Huuu, that’s interesting.

64
00:03:59,110 --> 00:04:02,160
Ok and here is the description of it.

65
00:04:02,159 --> 00:04:04,399
Interrupt number 3, traps to debugger.

66
00:04:04,400 --> 00:04:06,390
下面是：

67
00:04:06,389 --> 00:04:11,819
Int3指令是一个特殊的单字节操作码（CC），用于调用

68
00:04:11,819 --> 00:04:13,579
debug exception handler.

69
00:04:13,579 --> 00:04:18,399
（此单字节格式很有价值，因为它可以用来替换

70
00:04:18,400 --> 00:04:23,000
具有断点的指令，包括其他单字节指令，但不过度写入

71
00:04:23,000 --> 00:04:24,050
other code).

72
00:04:24,050 --> 00:04:25,050
wooooh.

73
00:04:25,050 --> 00:04:26,510
那是什么意思？

74
00:04:26,510 --> 00:04:29,020
嗯，你认为gdb是如何工作的？

75
00:04:29,020 --> 00:04:31,500
或者其他的调试器？

76
00:04:31,500 --> 00:04:34,220
How can you just stop the CPU from executing something.

77
00:04:34,220 --> 00:04:36,200
或者只是一个指令？

78
00:04:36,200 --> 00:04:40,630
Actually a debugger can just use the INT 3 instruction.

79
00:04:40,630 --> 00:04:42,570
Let’s make an example.

80
00:04:42,570 --> 00:04:45,810
We just created a breakpoint at this ret.

81
00:04:45,810 --> 00:04:51,080
What we actually did was, we replaced this return instruction in memory with int 3.

82
00:04:51,080 --> 00:04:54,110
And when the CPU reached this instruction, an exception was raised.

83
00:04:54,110 --> 00:05:00,010
或者在硬件方面，一个中断被触发，从而使CPU停止继续执行。

84
00:05:00,010 --> 00:05:07,140
并调用一个中断处理程序（类似于系统调用如何导致中断和执行

85
00:05:07,140 --> 00:05:08,140
continued somewhere else).

86
00:05:08,140 --> 00:05:12,180
And we can now decide how we want to handle this exception.

87
00:05:12,180 --> 00:05:16,990
如果我们是一个调试器，现在我们将用原来的指令替换这个int 3指令。

88
00:05:16,990 --> 00:05:18,920
value, the return instruction.

89
00:05:18,920 --> 00:05:22,920
That can also be used as an anti reversing technique.

90
00:05:22,920 --> 00:05:26,780
Because a regular application will not use the CC instruction.

91
00:05:26,780 --> 00:05:31,890
因此，恶意软件可能会不断扫描自己的CC操作码，如果它找到了，它

92
00:05:31,890 --> 00:05:36,590
knows that somebody attached a debugger and tried to set a breakpoint.

93
00:05:36,590 --> 00:05:38,220
And now we will use the CC in our payload.

94
00:05:38,220 --> 00:05:39,220
So let’s append a couple of CCs after the overwritten return pointer.

95
00:05:39,220 --> 00:05:41,890
Don’t forget to write the output of the script into the exploit file.

96
00:05:41,890 --> 00:05:44,040
And then test this in gdb.

97
00:05:44,040 --> 00:05:45,740
Ok run again.

98
00:05:45,740 --> 00:05:49,800
We can see that we stopped at the ret and we see the address where we would return to.

99
00:05:49,800 --> 00:05:56,200
当我们现在继续时，我们从堆栈中弹出指令指针值，从而继续

100
00:05:56,200 --> 00:06:02,500
在堆栈上执行，我们有int 3指令，如您所见，gdb

101
00:06:02,500 --> 00:06:07,560
stopped because it received a signal SIGTRAP, a trace/breakpoint trap.

102
00:06:07,560 --> 00:06:08,560
Cool.

103
00:06:08,560 --> 00:06:13,220
这样我们就知道我们有代码执行，因为我们成功地注入了一个汇编程序

104
00:06:13,220 --> 00:06:14,930
instruction.

105
00:06:14,930 --> 00:06:17,360
现在，没有gdb这也行吗？

106
00:06:17,360 --> 00:06:19,480
让我们试试……

107
00:06:19,480 --> 00:06:22,430
但是我们得到了非法指令？

108
00:06:22,430 --> 00:06:24,630
That is not what we should see.

109
00:06:24,630 --> 00:06:26,240
We should get the breakpoint message.

110
00:06:26,240 --> 00:06:31,060
Let’s open it in gdb here and try it again.

111
00:06:31,060 --> 00:06:32,460
Still illegal instruction.

112
00:06:32,460 --> 00:06:39,880
Let’s set the hooks and the breakpoints like in the other gdb session.

113
00:06:39,880 --> 00:06:41,370
Ok run.

114
00:06:41,370 --> 00:06:42,660
嗯…

115
00:06:42,660 --> 00:06:45,060
The addresses on the stack are not the same.

116
00:06:45,060 --> 00:06:47,220
为什么它们不同？

117
00:06:47,220 --> 00:06:49,550
Let’s do something crazy.

118
00:06:49,550 --> 00:06:50,710
Print the whole stack.

119
00:06:50,710 --> 00:06:53,060
I just print a thousand strings or something.

120
00:06:53,060 --> 00:06:55,250
Let’s se what we get.

121
00:06:55,250 --> 00:06:57,130
Ok first we have some gibebrish.

122
00:06:57,130 --> 00:06:58,270
Let’s go further.

123
00:06:58,270 --> 00:06:59,270
UUUh… see.

124
00:06:59,270 --> 00:07:00,980
Now we get some interesting stuff.

125
00:07:00,980 --> 00:07:04,160
Let’s do the same in the other gdb session.

126
00:07:04,160 --> 00:07:06,380
This looks like the environment variables.

127
00:07:06,380 --> 00:07:11,150
例如，这里是我们在以前的编程中使用的用户环境变量

128
00:07:11,150 --> 00:07:12,150
video.

129
00:07:12,150 --> 00:07:16,400
Mh and when you look at the addresses, they are still diferent.

130
00:07:16,400 --> 00:07:17,400
So let’s look a bit further down.

131
00:07:17,400 --> 00:07:21,630
mh! down here they are the same.

132
00:07:21,630 --> 00:07:26,540
So between here and the environemnt variables above there mus be something different.

133
00:07:26,540 --> 00:07:31,710
当你仔细观察，你可以看到pwd环境变量，当前

134
00:07:31,710 --> 00:07:33,610
working directory is different.

135
00:07:33,610 --> 00:07:35,960
They have a different length.

136
00:07:35,960 --> 00:07:41,010
所以很明显，一个执行环境需要在堆栈上有更多的空间来存储这个

137
00:07:41,010 --> 00:07:42,010
path.

138
00:07:42,010 --> 00:07:44,060
And thus pushing the stack further up.

139
00:07:44,060 --> 00:07:48,170
No wonder that the stack addresses are not the same anymore.

140
00:07:48,170 --> 00:07:50,340
那么我们如何应对呢？

141
00:07:50,340 --> 00:07:54,290
您可以使用一些技术来更好地控制

142
00:07:54,290 --> 00:07:55,290
stack.

143
00:07:55,290 --> 00:07:59,140
For example by removing all environment variables before executing a binary.

144
00:07:59,140 --> 00:08:03,550
But there is another very easy but effective trick.

145
00:08:03,550 --> 00:08:04,690
这里有一个提示：

146
00:08:04,690 --> 00:08:08,260
不，不，不，不，不，不

147
00:08:08,260 --> 00:08:10,280
好的……没有幻灯片……

148
00:08:10,280 --> 00:08:13,300
Let’s just add a looooot of NOP instructions.

149
00:08:13,300 --> 00:08:16,050
A Nop instruction performs no operation.

150
00:08:16,050 --> 00:08:17,980
And it has the opcode hex 90.

151
00:08:17,980 --> 00:08:22,310
而不是选择一个非常具体的堆栈地址，让我们选择一个我们希望

152
00:08:22,310 --> 00:08:24,150
hits our nops.

153
00:08:24,150 --> 00:08:25,580
So run again.

154
00:08:25,580 --> 00:08:28,710
Now we can see we have a lot of NOPs on the stack.

155
00:08:28,710 --> 00:08:32,700
And the address we will jump to points somewhere else further down.

156
00:08:32,700 --> 00:08:36,930
如果我们看更多的堆栈，我们可以看到它几乎就在中间。

157
00:08:36,930 --> 00:08:39,990
of the nops.

158
00:08:39,990 --> 00:08:42,740
So let’s just single step forwards.

159
00:08:42,740 --> 00:08:48,030
现在我们高兴地滑下NOP滑道，直到我们用陷阱到达底部！

160
00:08:48,029 --> 00:08:49,219
Boom.

161
00:08:49,220 --> 00:08:50,410
Cool.

162
00:08:50,410 --> 00:08:53,780
And that also works now outside of gdb.

163
00:08:53,779 --> 00:08:56,959
Now instead of CC, we want to execute something useful.

164
00:08:56,960 --> 00:08:59,390
So let’s look for some shellcode.

165
00:08:59,389 --> 00:09:04,259
As the challenge description said, it’s best to reuse shellcode from other people.

166
00:09:04,259 --> 00:09:08,639
I really like the collection of shellcode from shellstorm.

167
00:09:08,640 --> 00:09:12,660
Shellstorm has a lot of different kind of shellcode, for a lot of different system.

168
00:09:12,660 --> 00:09:16,280
So we are looking for a Linux Intel 32bit shellcode.

169
00:09:16,279 --> 00:09:21,809
FreeBSD, Linux on ARM, 64bit, and here we have 32bit.

170
00:09:21,810 --> 00:09:24,360
They all have a short description and do different stuff.

171
00:09:24,360 --> 00:09:28,540
But we are looking for a simple execve that will execute a shell.

172
00:09:28,540 --> 00:09:31,160
So, why not take this one.

173
00:09:31,160 --> 00:09:35,310
如果你看一下汇编程序代码，它所做的基本上就是推送一些值

174
00:09:35,310 --> 00:09:40,730
on the stack, which are infact just a string that is the path /bin/sh.

175
00:09:40,730 --> 00:09:42,960
And then calls execve.

176
00:09:42,959 --> 00:09:46,699
将字节作为有效负载复制到python exploit脚本中，我们可以将其与

177
00:09:46,699 --> 00:09:52,559
program.

178
00:09:52,560 --> 00:09:59,600
mhmh… nothing happens.

179
00:09:59,600 --> 00:10:00,600
它不工作吗？

180
00:10:00,600 --> 00:10:03,930
Let’s add the CC at the start of the payload if we still hit it.

181
00:10:03,931 --> 00:10:07,711
It should work.

182
00:10:07,709 --> 00:10:12,029
Remove the CC againa and try it in gdb. let’s single step.

183
00:10:12,029 --> 00:10:13,549
We are sliding down the nop slide.

184
00:10:13,550 --> 00:10:14,550
All seems fine.

185
00:10:14,550 --> 00:10:15,960
And now comes the shellcode.

186
00:10:15,959 --> 00:10:20,059
And it says: “Executing new program, /bin/dash”.

187
00:10:20,060 --> 00:10:23,010
That first sounds weird, but is correct.

188
00:10:23,010 --> 00:10:25,180
/bin/sh just points to /bin/dash.

189
00:10:25,180 --> 00:10:27,970
为什么它不起作用？

190
00:10:27,970 --> 00:10:28,970
Also on a side note.

191
00:10:28,970 --> 00:10:30,520
This gdb session is no broken.

192
00:10:30,520 --> 00:10:34,090
Because execve, replaces the current program with another one.

193
00:10:34,089 --> 00:10:35,909
So stack5 got replaced by /bin/dash.

194
00:10:35,910 --> 00:10:39,490
And you can see that when you try to execute it again.

195
00:10:39,490 --> 00:10:41,950
So you would have to load stack5 again with file.

196
00:10:41,949 --> 00:10:42,949
Ok.

197
00:10:42,949 --> 00:10:45,339
那么问题是什么呢？

198
00:10:45,339 --> 00:10:46,979
This is one of the things I got nuts.

199
00:10:46,980 --> 00:10:52,070
When I first got stuck like this I spend houuurs trying to figure out what is happening.

200
00:10:52,069 --> 00:10:57,579
As much as I want to see anybody else suffer like me, I tell you what the problem is.

201
00:10:57,579 --> 00:11:01,459
你执行的shell需要一些输入，对吗？

202
00:11:01,459 --> 00:11:02,759
From standard input.

203
00:11:02,759 --> 00:11:03,759
But!.

204
00:11:03,759 --> 00:11:09,309
We used a program and redirected it’s stdoutput into the stdinput of this program.

205
00:11:09,309 --> 00:11:12,389
And when the program was done it closed that pipe.

206
00:11:12,389 --> 00:11:16,299
So now the shell is executed, but doesn’t have any input.

207
00:11:16,300 --> 00:11:17,310
Because it’s closed.

208
00:11:17,310 --> 00:11:19,490
So it will just exit.

209
00:11:19,490 --> 00:11:22,960
And there is a neat trick to get basically around that.

210
00:11:22,959 --> 00:11:28,989
When you use cat without parameters, it simply redirect it’s stdinput to the standard output.

211
00:11:28,990 --> 00:11:30,130
See like here.

212
00:11:30,130 --> 00:11:34,280
You type something in, and it get’s reflected out.

213
00:11:34,279 --> 00:11:38,859
Now you can chain programs together on one line, for example with semicolon.

214
00:11:38,860 --> 00:11:43,930
所以我们可以先打印漏洞的输出，然后执行cat，这样我们就可以

215
00:11:43,930 --> 00:11:45,730
enter new input.

216
00:11:45,730 --> 00:11:50,270
如果我们现在用一些括号将其分组，并将它们的组合输出重定向到

217
00:11:50,270 --> 00:11:55,560
堆栈级别，漏洞首先运行并执行shell，然后cat将接管

218
00:11:55,559 --> 00:11:59,459
and we can simply relay input via cat to the shell.

219
00:11:59,459 --> 00:12:01,709
BAM! it works.

220
00:12:01,709 --> 00:12:06,599
We have an ugly shell, and we can verify our identity with whoami, or id.

221
00:12:06,600 --> 00:12:09,260
So now we escalated privileges to root.

222
00:12:09,259 --> 00:12:11,239
Damn. feels so good.

223
00:12:11,240 --> 00:12:12,350
It’s just beautiful.

