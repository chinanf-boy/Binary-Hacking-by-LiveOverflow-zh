1
00:00:00,120 --> 00:00:03,120
可以，
上一个视频我给你看了这个节目

2
00:00:03,120 --> 00:00:05,779
language I made, ugly but works.

3
00:00:05,779 --> 00:00:09,120
我们把它编译成一个奇怪的二进制文件
format.

4
00:00:09,120 --> 00:00:14,339
然后把这个二进制文件传递给
程序名为invoice，它执行

5
00:00:14,339 --> 00:00:15,339
program.

6
00:00:15,339 --> 00:00:19,200
在上一段视频中，我也向你展示了
这个二进制格式的开头

7
00:00:19,200 --> 00:00:23,090
触发缓冲区溢出并覆盖
the return pointer on the stack.

8
00:00:23,090 --> 00:00:27,070
在那一点上，你可能认为
我们的程序只是shellcode，所以汇编程序

9
00:00:27,070 --> 00:00:31,300
我们注入然后跳转到的代码，
the buffer overflow.

10
00:00:31,300 --> 00:00:34,929
但这是不可能的，因为
stack is not executable.

11
00:00:34,929 --> 00:00:39,969
所以即使我们不能注入实际的汇编程序
执行指令，我们还是

12
00:00:39,969 --> 00:00:42,399
able to execute my programs.

13
00:00:42,399 --> 00:00:47,839
现在很明显，
this is possible thanks to return-oriented-programming.

14
00:00:47,839 --> 00:00:50,399
So let’s examine how this works.

15
00:00:50,399 --> 00:00:51,820
But I warn you.

16
00:00:51,820 --> 00:00:55,879
你真的需要把你的大脑
abstract philosophical thinking mode.

17
00:00:55,879 --> 00:00:57,440
This will get weird.

18
00:00:57,440 --> 00:01:02,109
也许你得再看一遍
在未来，也许可以结帐一些“正常的”

19
00:01:02,109 --> 00:01:05,120
面向返回的编程教程和
then come back to this.

20
00:01:05,120 --> 00:01:09,580
但是如果你收到这个视频，我想会的
更深入更深入的理解

21
00:01:09,580 --> 00:01:10,580
for you.

22
00:01:10,580 --> 00:01:12,870
So just try...

23
00:01:12,870 --> 00:01:14,520
Anyway.

24
00:01:14,520 --> 00:01:19,480
Let’s head in.

25
00:01:19,480 --> 00:01:24,490
所以在x86汇编程序中有一个指令
called “call”.

26
00:01:24,490 --> 00:01:27,090
And call actually does two things.

27
00:01:27,090 --> 00:01:30,491
首先，它推送返回地址
电话后的地址是马上吗

28
00:01:30,491 --> 00:01:32,630
instruction) on the stack.

29
00:01:32,630 --> 00:01:37,620
然后它改变EIP，即当前的指令
pointer, to the call destination.

30
00:01:37,620 --> 00:01:40,750
So the CPU continues execution there.

31
00:01:40,750 --> 00:01:46,690
现在，当我们在C中调用一个函数时，这将
be compiled to an assembler call instruction.

32
00:01:46,690 --> 00:01:51,020
但是要理解面向返回的编程，
you have to forget this.

33
00:01:51,020 --> 00:01:54,030
Ignore the concept of calling functions.

34
00:01:54,030 --> 00:01:59,140
只需记住，此指令推动
呼叫指令后的地址

35
00:01:59,140 --> 00:02:04,730
放到堆栈上，然后设置指令指针
to the target address.

36
00:02:04,730 --> 00:02:07,530
返回指令在
same way.

37
00:02:07,530 --> 00:02:12,480
是的，ret是根据c中的返回进行编译的。
forget this connection.

38
00:02:12,480 --> 00:02:17,560
一个ret只是弹出一个地址，我们称之为
返回地址，离开堆栈并设置

39
00:02:17,560 --> 00:02:19,900
instruction pointer back to that.

40
00:02:19,900 --> 00:02:25,069
从堆栈中“pooping a value”是
also already again an abstract interpretation.

41
00:02:25,069 --> 00:02:29,640
它的字面意思是
堆栈指针寄存器，在该地址之后，

42
00:02:29,640 --> 00:02:30,719
takes that value.

43
00:02:30,719 --> 00:02:33,370
And then it increments the stack pointer register.

44
00:02:33,370 --> 00:02:35,430
It increments because the stack grows downwards.

45
00:02:35,430 --> 00:02:38,560
所以如果我们缩小它，当我们弹出一个值时，我们
increase it.

46
00:02:38,560 --> 00:02:40,889
So it gets closer to the highest address again.

47
00:02:40,889 --> 00:02:41,889
Anyway.

48
00:02:41,889 --> 00:02:42,980
This is what ret does.

49
00:02:42,980 --> 00:02:47,069
在堆栈寄存器的位置取这个值
指向，增加堆栈指针地址，

50
00:02:47,069 --> 00:02:52,290
然后使用它得到的值来设置
指令指针。这就是我们“返回”的方式

51
00:02:52,290 --> 00:02:54,269
(in quotation marks).

52
00:02:54,269 --> 00:02:56,340
So this was lesson one.

53
00:02:56,340 --> 00:03:01,920
忽略指令的名称或
典型意义和典型用法，只要理解

54
00:03:01,920 --> 00:03:04,660
what the instruction itself does.

55
00:03:04,660 --> 00:03:08,530
所以，再次记住“ret”（the
return) instruction does.

56
00:03:08,530 --> 00:03:12,109
首先查看堆栈寄存器，然后
address and take that value.

57
00:03:12,109 --> 00:03:13,190
Increment the stack pointer.

58
00:03:13,190 --> 00:03:15,110
Set the instruction pointer to that value.

59
00:03:15,110 --> 00:03:16,110
Done.

60
00:03:16,110 --> 00:03:18,170
Now let’s think about something else.

61
00:03:18,170 --> 00:03:22,139
机器执行是什么意思
指令？

62
00:03:22,139 --> 00:03:26,340
CPU是执行
instructions.

63
00:03:26,340 --> 00:03:30,349
这些指令是机器代码或汇编程序
代码，对吧？

64
00:03:30,349 --> 00:03:33,099
从抽象的意义上讲，这是如何工作的？

65
00:03:33,099 --> 00:03:38,279
嗯，有记忆，指令在哪里
stored, and this memory has addresses.

66
00:03:38,279 --> 00:03:43,360
然后CPU有一个指令指针寄存器，
包含指向内存的地址

67
00:03:43,360 --> 00:03:45,950
with the next instruction to execute.

68
00:03:45,950 --> 00:03:48,139
So if it’s 0, it will execute this.

69
00:03:48,139 --> 00:03:51,049
然后它就可以执行这条指令
is defined to do.

70
00:03:51,049 --> 00:03:53,890
不太重要，这说明是什么
does.

71
00:03:53,890 --> 00:03:58,799
但是通过执行任何指令
指针简单地递增并向前移动

72
00:03:58,799 --> 00:04:00,950
to point to the next instruction.

73
00:04:00,950 --> 00:04:05,029
然后执行指令
指针将更新为指向下一个

74
00:04:05,029 --> 00:04:06,029
one.

75
00:04:06,029 --> 00:04:07,029
And so forth.

76
00:04:07,029 --> 00:04:10,540
当然，这会随着指令而改变，比如
跳转、调用或返回，其中

77
00:04:10,540 --> 00:04:12,059
pointer is directly updated.

78
00:04:12,059 --> 00:04:13,059
But you get it.

79
00:04:13,059 --> 00:04:17,199
一台计算机，实际上是抽象的，
发出指令的机器会计算

80
00:04:17,199 --> 00:04:19,430
or executes those instructions.

81
00:04:19,430 --> 00:04:21,889
So the CPU is a machine implemented in hardware.

82
00:04:21,889 --> 00:04:25,150
But of course there are also virtual machines.

83
00:04:25,150 --> 00:04:28,199
所以机器是在我们的CPU上实现的
machines.

84
00:04:28,199 --> 00:04:33,770
例如JVM，Java虚拟
Machine behaves in the same way.

85
00:04:33,770 --> 00:04:35,169
It is a machine.

86
00:04:35,169 --> 00:04:40,590
所以在记忆的某个地方有字节码，
在软件方面，JVM有一个指令

87
00:04:40,590 --> 00:04:46,020
指针，或者有一个叫做程序计数器
PC，指向下一个指令，或

88
00:04:46,020 --> 00:04:47,550
there called opcode.

89
00:04:47,550 --> 00:04:52,550
当JVM执行一个操作码时，
必须更新程序计数器并移动

90
00:04:52,550 --> 00:04:54,330
it to the next one.

91
00:04:54,330 --> 00:04:55,810
Here I looked up the source code for that.

92
00:04:55,810 --> 00:04:59,240
这里是OpenJDK源代码
在那里你会看到一个更新，继续

93
00:04:59,240 --> 00:05:04,610
宏，字面上加上大小（或
当前操作码到程序上的长度）

94
00:05:04,610 --> 00:05:07,430
counter, so this moves it forward.

95
00:05:07,430 --> 00:05:10,790
就像CPU会增加指令一样
pointer.

96
00:05:10,790 --> 00:05:12,199
So this is lesson two.

97
00:05:12,199 --> 00:05:14,340
A machine in an abstract sense is simple.

98
00:05:14,340 --> 00:05:17,340
There is memory that holds code or instructions.

99
00:05:17,340 --> 00:05:21,699
机器指向代码，
一条指令，执行它，然后更新

100
00:05:21,699 --> 00:05:25,409
the program counter to point to the next one.

101
00:05:25,409 --> 00:05:29,879
那么这和F'有什么关系呢？
面向返回编程？

102
00:05:29,879 --> 00:05:34,430
最后一段视频我也介绍了这个概念
of a weird machine.

103
00:05:34,430 --> 00:05:38,300
不知怎么的，这个发票程序实现了
weird machine.

104
00:05:38,300 --> 00:05:43,110
我知道，这个概念太令人困惑了
但请原谅我，这在

105
00:05:43,110 --> 00:05:44,110
moment.

106
00:05:44,110 --> 00:05:48,501
如果这个发票程序实现了一个奇怪的
机器，你给那个奇怪的机器编程

107
00:05:48,501 --> 00:05:53,199
使用一种称为面向返回编程的技术，
then you should ask yourself now.

108
00:05:53,199 --> 00:05:58,220
包含我们指令的存储器在哪里？
指向的指令指针在哪里

109
00:05:58,220 --> 00:06:03,290
对那些指令，逻辑在哪里
执行任何定义的指令

110
00:06:03,290 --> 00:06:04,290
做什么？

111
00:06:04,290 --> 00:06:08,919
好吧，幸运的是我们有一些示例程序，
and we can debug this weird machine with GDB.

112
00:06:08,919 --> 00:06:13,189
让我们把发票程序加载到gdb中
and let’s learn how it executes.

113
00:06:13,189 --> 00:06:17,090
我不想解释缓冲区溢出
再次，请检查我的二进制攻击

114
00:06:17,090 --> 00:06:18,470
playlist for that.

115
00:06:18,470 --> 00:06:22,820
但是当你熟悉它的时候，你知道
that we overwrote stuff on the stack.

116
00:06:22,820 --> 00:06:26,730
如果您查看“添加发票”功能，
可以找到危险函数gets（），其中

117
00:06:26,730 --> 00:06:28,400
cause the buffer overflow.

118
00:06:28,400 --> 00:06:31,979
所以我们可以在这里设置一个断点，
one at the return.

119
00:06:31,979 --> 00:06:36,490
然后让我们运行二进制文件并作为输入
we pass in the helloworld.binary.

120
00:06:36,490 --> 00:06:40,090
现在我们知道输入触发了缓冲区
overflow.

121
00:06:40,090 --> 00:06:42,480
So here we hit the breakpoint at the gets.

122
00:06:42,480 --> 00:06:46,971
如果我们执行get并检查th堆栈，
we can find all of our input here.

123
00:06:46,971 --> 00:06:50,120
Here are all the As that fill up the buffer.

124
00:06:50,120 --> 00:06:55,280
然后我们有这些随机的，但是
actually carefully chosen values after it.

125
00:06:55,280 --> 00:06:57,840
But let’s go forward to the return instruction.

126
00:06:57,840 --> 00:07:03,930
所以现在我们要执行返回，
and please remember what return means.

127
00:07:03,930 --> 00:07:08,759
它查看堆栈寄存器中的地址，
所以这个地址指向这个记忆，

128
00:07:08,759 --> 00:07:11,650
所以这是堆栈，那是顶部
element.

129
00:07:11,650 --> 00:07:16,750
返回指令现在接受了
值作为地址，并设置指令

130
00:07:16,750 --> 00:07:17,820
pointer to it.

131
00:07:17,820 --> 00:07:20,800
同时增加堆栈
pointer.

132
00:07:20,800 --> 00:07:22,039
So let’s do that.

133
00:07:22,039 --> 00:07:23,710
Single step forward.

134
00:07:23,710 --> 00:07:27,020
现在让我们比较一下
return.

135
00:07:27,020 --> 00:07:28,729
It did exactly what we expected.

136
00:07:28,729 --> 00:07:35,389
堆栈指针寄存器已递增
from 0x18 to 0x20, so move 8 bytes forward.

137
00:07:35,389 --> 00:07:40,229
指令指针被设置为
value previously on top of the stack.

138
00:07:40,229 --> 00:07:45,719
顺便说一句。。。当我们执行一个“ret”时，我们也
often use the phrase “we return into <something>”.

139
00:07:45,719 --> 00:07:51,849
不管我们说“我们回来了”
说“我们回到”或“我们

140
00:07:51,849 --> 00:07:53,020
continued execution here”.

141
00:07:53,020 --> 00:07:54,139
It’s all the same.

142
00:07:54,139 --> 00:07:57,449
Don’t get confused by the term “return”.

143
00:07:57,449 --> 00:07:59,729
You know what the ret instruction really does.

144
00:07:59,729 --> 00:08:03,430
它只是从堆栈中获取一个值，
sets the instruction pointer to it.

145
00:08:03,430 --> 00:08:04,430
Anyway.

146
00:08:04,430 --> 00:08:05,430
那么现在发生了什么？

147
00:08:05,430 --> 00:08:08,139
我们的指示指针指向哪里
去？

148
00:08:08,139 --> 00:08:09,139
It points here...

149
00:08:09,139 --> 00:08:10,210
To this assembler code.

150
00:08:10,210 --> 00:08:13,380
A pop rdx and a pop rbx.

151
00:08:13,380 --> 00:08:15,789
然后又回来了？

152
00:08:15,789 --> 00:08:20,449
这意味着它从
stack and puts it into rdx.

153
00:08:20,449 --> 00:08:21,710
Increments rsp again.

154
00:08:21,710 --> 00:08:25,670
然后获取堆栈上的下一个值，
moves it into rbx.

155
00:08:25,670 --> 00:08:28,130
增加RSP，然后返回
again.

156
00:08:28,130 --> 00:08:32,360
现在返回的值是
堆栈并将指令指针设置为

157
00:08:32,360 --> 00:08:33,360
it.

158
00:08:33,360 --> 00:08:35,810
那么它现在在哪里继续执行呢？

159
00:08:35,810 --> 00:08:36,810
Okay.

160
00:08:36,810 --> 00:08:37,820
现在我们到了？

161
00:08:37,820 --> 00:08:39,669
Here we have a pop rdi.

162
00:08:39,669 --> 00:08:43,050
所以它取栈中的下一个值，移动
it into rdi.

163
00:08:43,050 --> 00:08:47,660
然后是ret，它取下一个值
and sets the instruction pointer to it.

164
00:08:47,660 --> 00:08:49,209
我们现在在哪里？

165
00:08:49,209 --> 00:08:50,610
Now we execute a move.

166
00:08:50,610 --> 00:08:55,480
我们把edx移动到
rdi.

167
00:08:55,480 --> 00:08:57,970
还记得我们设置EDX的时候吗？

168
00:08:57,970 --> 00:09:03,470
在开始时弹出RDX，设置值
of EDX to a value we had on the stack.

169
00:09:03,470 --> 00:09:09,040
还有RDI，我们现在写信的地址，
我们还把它放进了RDI

170
00:09:09,040 --> 00:09:11,440
with a pop RDI.

171
00:09:11,440 --> 00:09:13,700
想想这段代码现在做了什么！

172
00:09:13,700 --> 00:09:18,470
我知道它看起来很奇怪，但它所做的只是
它把我们想要的值移到一个地址

173
00:09:18,470 --> 00:09:19,930
we specified.

174
00:09:19,930 --> 00:09:25,360
我们将一个值移入RDX，然后是一个地址
在RDI中，然后我们写下EDX值

175
00:09:25,360 --> 00:09:28,070
to the address RDI points to.

176
00:09:28,070 --> 00:09:31,110
现在看看hello世界的源代码
program.

177
00:09:31,110 --> 00:09:36,300
在这里，代码说我们移动字符串，“地狱”
当然是4个字节，输入变量

178
00:09:36,300 --> 00:09:37,300
4.

179
00:09:37,300 --> 00:09:40,130
然后将变量4存储在内存位置
1.

180
00:09:40,130 --> 00:09:44,420
这只是另一种说法，我们
移动字符串或4个字节，“地狱”

181
00:09:44,420 --> 00:09:45,570
into rdx.

182
00:09:45,570 --> 00:09:49,820
然后我们将RDX移动到内存位置
we specify in RDI.

183
00:09:49,820 --> 00:09:53,600
哪个内存位置，并转换
字符串“hell”到四个字节是什么

184
00:09:53,600 --> 00:09:55,260
my compiler program does.

185
00:09:55,260 --> 00:10:01,199
我知道，也许这太令人困惑了，
maybe better just ignore my compiler shenanigans.

186
00:10:01,199 --> 00:10:02,810
But if think about what we did.

187
00:10:02,810 --> 00:10:07,620
我们执行了这几条移动指令
a value into some memory location.

188
00:10:07,620 --> 00:10:14,990
我们通过使用超奇怪的指令做到了这一点，
which we usually refer to as “gadgets”.

189
00:10:14,990 --> 00:10:19,150
为了执行这个内存写入，我们使用了三个
gadgets.

190
00:10:19,150 --> 00:10:24,529
首先我们使用了一个“pop-rdx，pop-rbx”小工具，
然后是“pop rdi”小工具，然后是“mov”

191
00:10:24,529 --> 00:10:25,529
gadget”.

192
00:10:25,529 --> 00:10:28,060
看看这些小玩意有什么共同点？

193
00:10:28,060 --> 00:10:31,210
They all end with a return instruction.

194
00:10:31,210 --> 00:10:32,829
Now bend you mind.

195
00:10:32,829 --> 00:10:37,740
接受我们刚才看到的，并努力适应
它进入了机器执行的概念

196
00:10:37,740 --> 00:10:38,740
instructions.

197
00:10:38,740 --> 00:10:41,339
First, we have memory, that is our stack.

198
00:10:41,339 --> 00:10:44,040
On there we had all these addresses and values.

199
00:10:44,040 --> 00:10:50,480
用一种奇怪的该死的方式，堆栈指针
是我们的指示指针吗？

200
00:10:50,480 --> 00:10:55,699
我们的奇怪机器基本上是从
返回操作码，它取第一个地址

201
00:10:55,699 --> 00:10:59,140
on the stack and continued CPU execution there.

202
00:10:59,140 --> 00:11:03,160
然后堆栈指针指向下一个
value, we popped it and moved it to the next.

203
00:11:03,160 --> 00:11:04,880
Pooped another value moved it to the next.

204
00:11:04,880 --> 00:11:10,660
然后又回来了，带着
value and let the CPU execute code there.

205
00:11:10,660 --> 00:11:13,769
Moving the stack again to the next value.

206
00:11:13,769 --> 00:11:19,790
所以在某种程度上这些地址在堆栈上，
当我们有返回时，定义指令

207
00:11:19,790 --> 00:11:21,269
处理程序，对吗？

208
00:11:21,269 --> 00:11:25,830
你可以说这里的地址实际上是
操作码，执行POP的指令

209
00:11:25,830 --> 00:11:28,420
rdx and then a pop rbx.

210
00:11:28,420 --> 00:11:33,760
还有这个小器具，这个地址，
是将EDX移动到

211
00:11:33,760 --> 00:11:35,060
address of rdi.

212
00:11:35,060 --> 00:11:41,120
这基本上不是同一件事吗
实际上是一个x86汇编程序“调用”指令

213
00:11:41,120 --> 00:11:45,550
意味着我们在堆栈上推一个地址，
set the instruction pointer to the given destination.

214
00:11:45,550 --> 00:11:49,930
那“调用”x86指令有什么不同？
从我们奇怪的机器设备里？

215
00:11:49,930 --> 00:11:50,930
不是！

216
00:11:50,930 --> 00:11:54,760
两者都定义了一些动作，它做什么，以及
then the machine moves to the next instruction.

217
00:11:54,760 --> 00:11:59,800
CPU通过增加指令来实现这一点
指针，Java虚拟机这样做

218
00:11:59,800 --> 00:12:04,140
只需增加程序计数器，
我们的奇怪机器通过增加

219
00:12:04,140 --> 00:12:05,899
the stack pointer.

220
00:12:05,899 --> 00:12:08,899
I know, these gadgets are super weird instructions.

221
00:12:08,899 --> 00:12:13,199
每个程序，取决于代码的多少
它包含什么类型的函数

222
00:12:13,199 --> 00:12:17,519
写在那里，在记忆中
编译器放置代码，更改类型

223
00:12:17,519 --> 00:12:19,620
of gadgets are available.

224
00:12:19,620 --> 00:12:24,620
使用小工具，我们实际上可以
列出所有小工具，以便汇编程序片段

225
00:12:24,620 --> 00:12:28,459
遵循以下几个说明的模式
by a “ret”.

226
00:12:28,459 --> 00:12:32,840
基本上这些都是奇怪的指示
我们可以用它来实现我们想要的一切

227
00:12:32,840 --> 00:12:34,269
on this weird machine.

228
00:12:34,269 --> 00:12:35,590
I know it’s crappy.

229
00:12:35,590 --> 00:12:40,670
没人说这必须是个好主意
像CPU或Java虚拟机

230
00:12:40,670 --> 00:12:41,690
Machine.

231
00:12:41,690 --> 00:12:45,519
但基本上可以执行任何
kind of computation.

232
00:12:45,519 --> 00:12:50,380
对我来说，收集那些
似乎很有用，并构建了一个编译程序

233
00:12:50,380 --> 00:12:56,140
此文本表示实际地址
that point to those gadgets.

234
00:12:56,140 --> 00:13:01,529
这就是为什么每个程序都有这样一个
脆弱性，意外地制造了自己的

235
00:13:01,529 --> 00:13:03,040
weird machine.

236
00:13:03,040 --> 00:13:07,640
每个易受攻击的程序都有自己的
指令集，它是

237
00:13:07,640 --> 00:13:08,640
gadgets.

238
00:13:08,640 --> 00:13:11,800
它是自己的初始化代码
that weird machine.

239
00:13:11,800 --> 00:13:15,720
基本上是触发我们脆弱性的代码
in the first place.

240
00:13:15,720 --> 00:13:17,649
So writing such an exploit.

241
00:13:17,649 --> 00:13:23,290
本质上是设置和实例化
通过触发缓冲区

242
00:13:23,290 --> 00:13:24,290
overflow.

243
00:13:24,290 --> 00:13:28,730
然后我们用
一个ROP链，一组链接的小工具

244
00:13:28,730 --> 00:13:34,740
一起被我们的怪人处决
机器，这要归功于x86“ret”指令

245
00:13:34,740 --> 00:13:36,620
together with the stack works.

246
00:13:36,620 --> 00:13:43,529
我们所能规划的只是
creativity and availability of useful gadgets.

247
00:13:43,529 --> 00:13:47,639
但是如果你有大量的小工具
你可以理解你可以实现

248
00:13:47,639 --> 00:13:49,149
ANYTHING you want.

249
00:13:49,149 --> 00:13:53,579
你只要把这些小汇编代码串起来
together to build anything.

250
00:13:53,579 --> 00:13:58,209
在攻击中，你通常试图创建一个远程
贝壳之类的，但它可以

251
00:13:58,209 --> 00:13:59,940
be just a regular program.

252
00:13:59,940 --> 00:14:04,649
就像我创造了这些ROP链
例如，以两个数字作为输入，

253
00:14:04,649 --> 00:14:06,620
adds them together, and prints the result.

254
00:14:06,620 --> 00:14:07,620
And that’s it.

255
00:14:07,620 --> 00:14:11,639
这就是面向返回的编程
in a super confused way.

256
00:14:11,639 --> 00:14:14,850
I know, this is maybe not the best ROP tutorial.

257
00:14:14,850 --> 00:14:19,589
但是有很多“普通”的教程，
我只是想尝试一些不同的东西

258
00:14:19,589 --> 00:14:24,459
我希望你们中的一些人
在这个话题上有一种不同的角度就是头脑

259
00:14:24,459 --> 00:14:25,459
opening.

260
00:14:25,459 --> 00:14:30,839
至少对我来说，这太令人兴奋了
很漂亮，你知道，它变成了一个口号

261
00:14:30,839 --> 00:14:32,610
for my channel.

262
00:14:32,610 --> 00:14:37,009
我还想提醒你
papers and talks I have listed in the description.

263
00:14:37,009 --> 00:14:39,579
即使你不明白，也请阅读
this video.

264
00:14:39,579 --> 00:14:44,459
它们也许更好，但肯定更多
正确解释这一奇怪机器的概念

265
00:14:44,459 --> 00:14:46,130
and exploit development.

266
00:14:46,130 --> 00:14:50,250
不管怎样……谢谢你的收看，也许还可以结账
my Patreon and YouTube membership in the description.

