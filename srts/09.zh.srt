1
00:00:06,370 --> 00:00:11,600
我们可以使用静态分析和逆向工程许可证检查算法并写一个keygen

2
00:00:11,600 --> 00:00:18,840
生成有效的密钥。显然这个算法

3
00:00:18,840 --> 00:00:22,800
也可能变得非常复杂，但一般来说，如果你在其中投入大量的工作，你可以想象

4
00:00:22,800 --> 00:00:28,370
出来。现在你告诉你的经理，但他

5
00:00:28,369 --> 00:00:33,099
是一个自作聪明，告诉你："然后停下来人们无法进行逆向工程

6
00:00:33,100 --> 00:00:38,420
二进制"。然后你拖回来

7
00:00:38,420 --> 00:00:41,630
到桌子上，你想出了一个新的创意如何阻止某人调试或

8
00:00:41,630 --> 00:00:47,480
扭转它。因为你是职业选手，你明白这一点

9
00:00:47,480 --> 00:00:54,110
可执行文件是一种非常复杂的文件格式。使用objdump我们已经看到了这个可执行文件

10
00:00:54,109 --> 00:00:59,379
那里有很多信息，就是这样需要加载并执行它。

11
00:00:59,379 --> 00:01:05,499
但你也是意识到像gdb这样的程序必须解析

12
00:01:05,500 --> 00:01:11,430
可执行程序，以便能够反汇编和调试它。

13
00:01:11,430 --> 00:01:15,410
并且radare必须阅读和解析可执行文件向您展示的东西。

14
00:01:15,410 --> 00:01:22,750
所以你能以某种方式修改可执行文件吗？

15
00:01:22,750 --> 00:01:33,700
你仍然可以用linux执行它，但是gdb和radare告诉你那件事

16
00:01:33,700 --> 00:01:39,460
完全相同的方式。但每个工具都实现了

17
00:01:39,460 --> 00:01:44,790
解析算法有点不同。所以

18
00:01:44,790 --> 00:01:51,090
如果你搞砸输入，linux可能会查看有效文件并执行它，而a

19
00:01:51,090 --> 00:01:54,100
gdb说它坏了，不能拆卸。

20
00:01:54,100 --> 00:01:57,230
让我告诉你如何找到一个非常天真的方式类似的东西。

21
00:01:57,230 --> 00:02:01,670
模糊不清。所以让我们创建一个名为的新python脚本

22
00:02:01,670 --> 00:02:06,890
fuzz_elf.py。首先我们导入一些我们需要的模块。

23
00:02:06,891 --> 00:02:12,701
进口随机。

24
00:02:12,700 --> 00:02:19,260
并导入操作系统。我们将编写的第一个函数叫做flip_byte。

25
00:02:19,260 --> 00:02:26,150
作为参数，它需要一个大字符串。哪一个

26
00:02:26,150 --> 00:02:31,960
稍后将是整个可执行文件。然后

27
00:02:31,959 --> 00:02:37,069
我们选择一个0和0之间的随机索引i输入的最大长度。

28
00:02:37,069 --> 00:02:42,739
然后我们选择我们将用来覆盖的随机字符

29
00:02:42,739 --> 00:02:44,529
程序中的一个字节。

30
00:02:44,530 --> 00:02:49,690
所以字符字节来自0到FF之间的随机数，即

31
00:02:49,689 --> 00:02:54,199
然后我们返回原始字节索引我。

32
00:02:54,200 --> 00:03:00,510
现在你可以看到一个随机的角色换了别的东西。

33
00:03:00,510 --> 00:03:06,160
使用dd，您可以再次删除这些行。现在我们想要一个复制原件的功能

34
00:03:06,159 --> 00:03:16,979
二进制但翻转一个字节并将其保存在另一个字节中文件。

35
00:03:16,981 --> 00:03:24,991
我们称这个函数为二进制复制。所以

36
00:03:24,989 --> 00:03:31,929
我们打开正常的license_2和copy license_2_fuzz具有写访问权限。

37
00:03:31,930 --> 00:03:36,660
现在我们阅读整个原始文件，然后通过那些字节到flip_byte函数。

38
00:03:36,660 --> 00:03:38,000
现在这将返回license_2可执行文件的副本，

39
00:03:38,000 --> 00:03:39,000
只是随机字节翻转。然后

40
00:03:39,000 --> 00:03:42,780
我们把它写到副本上。如果我们现在就运行这个，那就是新的license_2_fuzz

41
00:03:42,779 --> 00:03:47,489
文件将不可执行，所以我已经创建此文件作为原始副本，

42
00:03:47,489 --> 00:03:54,059
它将是可执行的。现在显然我们翻了很多东西。

43
00:03:54,060 --> 00:03:59,030
而且文件可能不再可执行。

44
00:03:59,029 --> 00:04:04,299
所以我们应检查该程序是否仍然有效

45
00:04:04,299 --> 00:04:09,529
同样的方式。这意味着它应该打印

46
00:04:09,530 --> 00:04:15,530
访问权限授予有效密钥。所以这个输出

47
00:04:15,529 --> 00:04:20,279
像我刚才那样的命令，只需管道输出进入fuzz_output。

48
00:04:20,280 --> 00:04:25,690
现在我添加一个功能来比较原始输出与模糊输出。

49
00:04:25,690 --> 00:04:33,440
并且还让结果从检查输出函数返回。

50
00:04:33,440 --> 00:04:37,150
好的，这个函数检查二进制文件是否仍然存在正常执行。

51
00:04:37,150 --> 00:04:43,260
现在让我们考虑如何检查是否可以gdb仍然有效。

52
00:04:43,259 --> 00:04:52,139
基本上我们不想要人们要拆解主力。

53
00:04:52,139 --> 00:04:56,579
所以你可以使用echo并管道此命令并退出到gdb

54
00:04:56,580 --> 00:05:03,590
得到输出。所以回声 - 这就是这里

55
00:05:03,590 --> 00:05:08,200
只是基本上键入这两个命令和使用管道我们将其重定向到输入

56
00:05:08,199 --> 00:05:19,619
的gdb。这看起来不错。

57
00:05:19,620 --> 00:05:27,640
所以，简单地说吧将此输出重定向到文件，即

58
00:05:27,640 --> 00:05:33,520
我将调用original_gdb。现在让我们基本上创建相同的功能，

59
00:05:33,520 --> 00:05:37,790
只需检查gdb。然后比较这两个文件。

60
00:05:37,789 --> 00:05:43,959
现在让我们来吧对于radare2也一样。

61
00:05:43,960 --> 00:05:49,800
我们在这里使用命令aaa，s sym.main和pdf。

62
00:05:49,800 --> 00:05:57,440
作品。如果可行，我们需要radare和gdb

63
00:05:57,440 --> 00:06:02,550
失败。如果不是check_gdb和，那就让我们这样做吧

64
00:06:02,551 --> 00:06:07,111
不check_radare。如果我们到达这里，我们

65
00:06:07,110 --> 00:06:12,420
打印成功并退出。然后我们打印radare和gdb的尾部

66
00:06:12,419 --> 00:06:18,329
输出。只是为了进行目测检查

67
00:06:18,330 --> 00:06:25,180
反汇编在某种程度上失败了。使用raw_input

68
00:06:25,180 --> 00:06:31,940
我们可以暂停python程序，直到我们命中输入。

69
00:06:31,940 --> 00:06:40,320
现在让我们来运行吧。啊另一个小错误。

70
00:06:40,319 --> 00:06:49,069
这应该是f1而不是fn1。我刚刚发现了另一个错误。

71
00:06:49,069 --> 00:06:52,769
好吧，它找到了一些东西，但我们显然还是那里拆卸。

72
00:06:52,770 --> 00:06:58,200
所以，让我们继续吧直到我们找到没有拆卸的输出。

73
00:06:58,199 --> 00:07:02,019
呃。看起来很好。

74
00:07:02,020 --> 00:07:05,840
我们来调查吧。二进制仍然有效。

75
00:07:05,840 --> 00:07:11,240
Gdb找不到主要功能。而雷达也有问题。

76
00:07:11,240 --> 00:07:15,320
哈哈！那很酷：D

77
00:07:15,321 --> 00:07:19,741
来自IOActive的ELF文件格式。你可以更深入地阅读甚至更多

78
00:07:19,740 --> 00:07:28,440
疯狂的ELF文件格式欺骗神圣的"国际PoC杂志||

79
00:07:28,439 --> 00:07:32,609
GTFO  - 问题0x00"我的二进制文件可以在github存储库中找到

80
00:07:32,610 --> 00:07:39,180
你可以尝试不同的工具，如料斗或IDA，看看他们是否仍然自动分析它。

81
00:07:39,180 --> 00:07:42,910
但我怀疑他们这样做。所以这只是一个

82
00:07:42,909 --> 00:07:48,139
可以惹恼别人的小动作分析它。

83
00:07:48,139 --> 00:07:52,189
现在你可以回到你的经理那里告诉你了他，他应该聘请一些网络开发人员

