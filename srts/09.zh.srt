1
00:00:06,370 --> 00:00:11,600
我们可以对验证检查算法，进行静态分析并反工程，并编写一个生成有效密钥的keygen。

2
00:00:11,600 --> 00:00:18,840
显然，这种算法也会变得非常复杂，但一般来说，

3
00:00:18,840 --> 00:00:22,800
如果你花了心思，终会找到密钥。

4
00:00:22,800 --> 00:00:28,370
现在你告诉你的经理，但他是个聪明人，告诉你：

5
00:00:28,369 --> 00:00:33,099
那就阻止人们对二进制文件进行反向工程”。然后你把自己拖回去到了办公桌前，

6
00:00:33,100 --> 00:00:38,420
你想出了一个如何阻止某人调试或对其反工程的新创意。

7
00:00:38,420 --> 00:00:41,630
因为你是专业的，你明白可执行文件是一种非常复杂的文件格式。

8
00:00:41,630 --> 00:00:47,480
使用objdump，我们已经看到这个可执行文件，包含许多信息，

9
00:00:47,480 --> 00:00:54,110
其中，有加载和执行它，所必需的。

10
00:00:54,109 --> 00:00:59,379
但你也知道，像gdb这样的程序，必须要能解析可执行文件，才能反汇编和调试它。

11
00:00:59,379 --> 00:01:05,499
同样，radare2也必须读取和解析可执行文件，才能向您展示一些东西。

12
00:01:05,500 --> 00:01:11,430
所以，若你能以某种方式修改可执行文件，但仍可以用Linux来执行它，

13
00:01:11,430 --> 00:01:15,410
但是，gdb和radare2 告诉你，这程序是坏了的？

14
00:01:15,410 --> 00:01:22,750
我们要寻找的是，一个不同解析器。我们希望 execve 的解析器与gdb解析器有所不同。

15
00:01:22,750 --> 00:01:33,700
在一个理想的世界中，每一个程序的读取输入，都是相同的方式。

16
00:01:33,700 --> 00:01:39,460
但是，每个工具实现的解析算法，都有点不同。

17
00:01:39,460 --> 00:01:44,790
所以如果使用同个输入，Linux可能会看到一个有效的文件，并可以执行，

18
00:01:44,790 --> 00:01:51,090
但 gdb 会说它坏了，不能反汇编。让我用一种非常天真的方法：

19
00:01:51,090 --> 00:01:54,100
fuzzing（模糊方法），告诉你如何搞出这样的东西。

20
00:01:54,100 --> 00:01:57,230
让我们创建一个新的 python 脚本，叫做 "fuzz_elf.py"。

21
00:01:57,230 --> 00:02:01,670
首先，我们导入些需要的模块。 "import random"。 和 "import os".

22
00:02:01,670 --> 00:02:06,890
我们将要编写的第一个函数称为"flip_byte"。它需要一个长字符串参数。

23
00:02:06,891 --> 00:02:12,701
这个参数稍后，将是整个可执行文件。然后我们选择一个随机索引'i'，

24
00:02:12,700 --> 00:02:19,260
介于0和 输入的最大长度之间。然后我们选择一个随机字符来覆盖程序中的一个字节。

25
00:02:19,260 --> 00:02:26,150
可，从 0到ff 之间的随机数中，得到的字符字节，即 255。

26
00:02:26,150 --> 00:02:31,960
然后我们将原始字节，返回到索引'i'。下一个字符是随机创建的，

27
00:02:31,959 --> 00:02:37,069
而不是原来 索引 'i' 上的字符。我们附加了剩余原始字节。

28
00:02:37,069 --> 00:02:42,739
如果,您想了解 Python 中这个花哨的括号，冒号索引内容，

29
00:02:42,739 --> 00:02:44,529
就去谷歌下 "python lists"。

30
00:02:44,530 --> 00:02:49,690
所以，这只是一个简单的函数例子。用 "yy" print flip_bytes("ASD123")

31
00:02:49,689 --> 00:02:54,199
你可以复制这行，然后按 p 就可以粘贴到多个地方。

32
00:02:54,200 --> 00:03:00,510
现在你可以看到，随机字符改变的某些地方。

33
00:03:00,510 --> 00:03:06,160
使用 dd，您可以再次删除这些行。现在我们需要一个复制原始文件，

34
00:03:06,159 --> 00:03:16,979
但会翻转一个字节，并将结果保存到另一个文件的函数。我们调用这个函数来复制二进制文件。

35
00:03:16,981 --> 00:03:24,991
所以，我们用写(w)模式，打开正常的 license_2 和 副本 license_2_fuzz.

36
00:03:24,989 --> 00:03:31,929
现在，我们读取整个原始文件，并将这些字节传递给"flip_byte"函数。

37
00:03:31,930 --> 00:03:36,660
现在，这将返回license_2 的副本，但多了些随机字符，

38
00:03:36,660 --> 00:03:38,000
然后，我们把这个写在副本上。如果我们现在就运行这个，新 license_2_fuzz 文件将不会执行。

39
00:03:38,000 --> 00:03:39,000
因此，我已创建原始文件的副本，且它是可执行的。

40
00:03:39,000 --> 00:03:42,780
现在很明显我们可能会翻一些奇怪的东西，导致文件不再是可执行文件。

41
00:03:42,779 --> 00:03:47,489
所以，我们应该检查程序是否仍然有效工作。

42
00:03:47,489 --> 00:03:54,059
这意味着，它应该能让有效密钥，授予打印访问的权限。所以这个结果输出，对于原始程序和模糊(fuzzing)程序来说，应该是相同的。

43
00:03:54,060 --> 00:03:59,030
这就是我重定向输出到名为“原始输出(original_output)”文件的原因。

44
00:03:59,029 --> 00:04:04,299
现在让我们编写一个 python 函数，

45
00:04:04,299 --> 00:04:09,529
它可以运行一次模糊二进制，并检查其输出是否与原始的相同。

46
00:04:09,530 --> 00:04:15,530
注意，我现在是以一种非常丑陋的方式来做的，只因为它的代码很少，

47
00:04:15,529 --> 00:04:20,279
我只要执行，之前的相同命令就好，将结果输出，管道到 fuzz_output。

48
00:04:20,280 --> 00:04:25,690
现在我添加了一个函数，来比较原始输出和模糊输出。

49
00:04:25,690 --> 00:04:33,440
还要返回检查输出函数的结果。好的，这个函数检查，二进制文件是否仍正常执行。

50
00:04:33,440 --> 00:04:37,150
现在，让我们想想，如何检查 gdb 执行模糊文件是否还有效。

51
00:04:37,150 --> 00:04:43,260
基本上我，们不希望人们反汇编，main 函数。

52
00:04:43,259 --> 00:04:52,139
所以你可以使用 echo 并通过管道发送该命令，然后退出到gdb，以获取输出。

53
00:04:52,139 --> 00:04:56,579
所以 "echo -e" 和这里的，基本上只需键入这两个命令，然后通过管道，将其重定向到gdb的输入。

54
00:04:56,580 --> 00:05:03,590
这个看起来不错。所以让我们同样简单地，将这个输出重定向到一个文件，叫做 'original_gdb'。

55
00:05:03,590 --> 00:05:08,200
然后，现在让我们创建基本上相同，但只需检查gdb，然后，比较这两个文件的函数，

56
00:05:08,199 --> 00:05:19,619
现在，让我们为radare2，做同样的事情。

57
00:05:19,620 --> 00:05:27,640
这里我们只使用命令 aaa, s sym.main 和 pdf。

58
00:05:27,640 --> 00:05:33,520
还有，把结果输出存入一个文件中。 现在，再次编写一个检查radare2 的函数.

59
00:05:33,520 --> 00:05:37,790
可以使用 "shift v" ，来高亮显示多行，使用 y 可以复制并按 p 粘贴。

60
00:05:37,789 --> 00:05:43,959
好的… 快到了。现在让我们创建一个无止境的循环。

61
00:05:43,960 --> 00:05:49,800
这里我们首先，创建新副本。然后，我们检查可执行文件是否仍工作。

62
00:05:49,800 --> 00:05:57,440
如果一切符合预期，我们希望 radare2和gdb 会失败。所以，"if not check_gdb and not check_radare2"。

63
00:05:57,440 --> 00:06:02,550
如果我们能进到这里, 我们会打印成功并退出。

64
00:06:02,551 --> 00:06:07,111
然后，我们打印 radare2 和 gdb 结果输出的尾部。只需目测下，反汇编在某种程度上是失败了。

65
00:06:07,110 --> 00:06:12,420
通过 "raw_input" ，我们可以停止python程序，直到 按 Enter。

66
00:06:12,419 --> 00:06:18,329
好啦，运行吧. 啊，又一个小错误。

67
00:06:18,330 --> 00:06:25,180
用 f1 代替 fn1 应该能修复。 又又发现一个错误.

68
00:06:25,180 --> 00:06:31,940
好吧，它发现了一些东西，但我们显然还在那里反汇编。

69
00:06:31,940 --> 00:06:40,320
我们继续吧，直到找到一个不能反汇编的输出。噢 看起来不错。调查下。

70
00:06:40,319 --> 00:06:49,069
二进制文件还可以工作。 Gdb 且不能找到 main 函数啦。

71
00:06:49,069 --> 00:06:52,769
radare2的执行也有问题。哈哈！这很酷 :D

72
00:06:52,770 --> 00:06:58,200
我承认, 这很丑。 这并不是使用实践中，一个很好的技术方法。

73
00:06:58,199 --> 00:07:02,019
但，这基本上就是模糊的工作原理。

74
00:07:02,020 --> 00:07:05,840
以及延展思维，发现如何隐藏恶意代码的新妙招，和让人们更难分析它。

75
00:07:05,840 --> 00:07:11,240
如果，你想了解更多关于这方面的知识，你可以阅读这本书，它叫做“技术小说(novel technique)”。

76
00:07:11,240 --> 00:07:15,320
但，这并不都是新的。来自ioactive的elf文件格式，还有一些更深入的研究。

77
00:07:15,321 --> 00:07:19,741
你可以在神圣的“PoC || GTFO 国际杂志 - Issue 0x00”中，

78
00:07:19,740 --> 00:07:28,440
更深入地阅读，疯狂的ELF文件格式技巧

79
00:07:28,439 --> 00:07:32,609
我的二进制文件可以，在Github存储库中找到，你可以尝试不同的工具，比如 Hopper或者IDA，

80
00:07:32,610 --> 00:07:39,180
看看他们，是否会自动分析它。但我猜想还是能分析的。

81
00:07:39,180 --> 00:07:42,910
所以这只是一个让一部分人困惑，怎么分析它的小技巧。

82
00:07:42,909 --> 00:07:48,139
现在，你可以回到你的经理那里，告诉他，他应该雇用一些网络开发人员和把产品放到云端, 

83
00:07:48,139 --> 00:07:52,189
以此，代码只会在你控制的服务器中，运行。

