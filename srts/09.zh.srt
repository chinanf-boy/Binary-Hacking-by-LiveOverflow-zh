1
00:00:06,370 --> 00:00:11,600
我们可以使用静态分析和逆向工程的许可证检查算法，并编写一个keygen

2
00:00:11,600 --> 00:00:18,840
生成有效密钥。显然，这种算法也会变得非常复杂，但一般来说，

3
00:00:18,840 --> 00:00:22,800
if you put a lot of work in it, you can figure it out.

4
00:00:22,800 --> 00:00:28,370
现在你告诉你的经理，但他是个聪明人，告诉你：“那就停下来。”

5
00:00:28,369 --> 00:00:33,099
人们无法对二进制文件进行反向工程”。然后你把自己拖回去

6
00:00:33,100 --> 00:00:38,420
到了办公桌前，你想出了一个新的创意方法，如何阻止某人调试或

7
00:00:38,420 --> 00:00:41,630
倒车。因为你是职业选手，你明白

8
00:00:41,630 --> 00:00:47,480
可执行文件是一种非常复杂的文件格式。使用objdump，我们已经看到这个可执行文件

9
00:00:47,480 --> 00:00:54,110
其中包含许多信息，这是加载和执行它所必需的。但你也

10
00:00:54,109 --> 00:00:59,379
认识到像gdb这样的程序必须解析可执行文件才能反汇编和

11
00:00:59,379 --> 00:01:05,499
调试它。而且Radare必须读取和解析可执行文件来向您展示一些东西。所以

12
00:01:05,500 --> 00:01:11,430
你能以某种方式修改可执行文件吗，你仍然可以用Linux来执行它，

13
00:01:11,430 --> 00:01:15,410
但是GDB和Radare告诉你什么东西坏了？

14
00:01:15,410 --> 00:01:22,750
我们要寻找的是一个解析器微分。我们希望execve的解析器不同

15
00:01:22,750 --> 00:01:33,700
来自gdb解析器。在一个理想的世界中，每一个读取输入的程序都会在

16
00:01:33,700 --> 00:01:39,460
完全一样。但是每个工具实现的解析算法都有点不同。所以

17
00:01:39,460 --> 00:01:44,790
如果使用输入，Linux可能会看到一个有效的文件并执行它，而

18
00:01:44,790 --> 00:01:51,090
GDB说它坏了，不能拆卸。让我用一种非常天真的方式告诉你如何找到

19
00:01:51,090 --> 00:01:54,100
something like that. With fuzzing.

20
00:01:54,100 --> 00:01:57,230
So lets create a new python script called fuzz_elf.py.

21
00:01:57,230 --> 00:02:01,670
First we import some modules we need. Import random. And import os.

22
00:02:01,670 --> 00:02:06,890
我们将要编写的第一个函数称为flip_byte。作为一个参数，它需要一个大字符串。哪个

23
00:02:06,891 --> 00:02:12,701
稍后将是整个可执行文件。然后我们选择一个随机索引i，介于0和

24
00:02:12,700 --> 00:02:19,260
输入的最大长度。然后我们选择一个随机字符来覆盖

25
00:02:19,260 --> 00:02:26,150
程序中的一个字节。所以从0到ff之间的随机数中得到的字符字节，即

26
00:02:26,150 --> 00:02:31,960
255。然后我们将原始字节返回到索引I。下一个字符将是

27
00:02:31,959 --> 00:02:37,069
随机创建了一个，而不是原来的字符我在这一点上。我们附加了

28
00:02:37,069 --> 00:02:42,739
剩余原始字节。如果您想了解Python中这个花哨的括号冒号索引内容，

29
00:02:42,739 --> 00:02:44,529
just google ‘python lists’.

30
00:02:44,530 --> 00:02:49,690
所以只是这个函数的一个简单例子。打印翻转字节（“ASD123”）

31
00:02:49,689 --> 00:02:54,199
With yy you can copy this line and with p you can paste it multiple times.

32
00:02:54,200 --> 00:03:00,510
And now you can see that a random character got changed to something else.

33
00:03:00,510 --> 00:03:06,160
使用dd，您可以再次删除这些行。现在我们需要一个复制原始文件的函数

34
00:03:06,159 --> 00:03:16,979
但会翻转一个字节并将其保存到另一个文件中。我们称这个函数为copy binary。所以

35
00:03:16,981 --> 00:03:24,991
we open the normal license_2 and a copy license_2_fuzz with write access.

36
00:03:24,989 --> 00:03:31,929
现在我们读取整个原始文件，并将这些字节传递给flip-byte函数。现在

37
00:03:31,930 --> 00:03:36,660
这将返回许可证的一个可执行文件副本，只是翻转了一个随机字节。然后

38
00:03:36,660 --> 00:03:38,000
我们把这个写在副本上。如果我们现在就运行这个，新的许可证

39
00:03:38,000 --> 00:03:39,000
文件将不可执行，因此我已创建此文件作为原始文件的副本，

40
00:03:39,000 --> 00:03:42,780
它将是可执行的。现在很明显我们会翻一些奇怪的东西。以及

41
00:03:42,779 --> 00:03:47,489
文件可能不再是可执行文件。所以我们应该检查程序是否仍然有效

42
00:03:47,489 --> 00:03:54,059
同样的方法。这意味着，它应该使用有效密钥授予打印访问权限。所以这个输出

43
00:03:54,060 --> 00:03:59,030
对于原始程序和模糊程序应该是相同的。这就是我重新定向的原因

44
00:03:59,029 --> 00:04:04,299
输出到名为“原始输出”的文件。现在让我们编写一个运行

45
00:04:04,299 --> 00:04:09,529
the fuzz binary once a byte got flipped and let’s check if it outputs the same thing.

46
00:04:09,530 --> 00:04:15,530
一个非常丑陋的方式，我现在怎么做，只是因为它的代码更少，我执行相同的

47
00:04:15,529 --> 00:04:20,279
command like I just did, just pipe the output into fuzz_output.

48
00:04:20,280 --> 00:04:25,690
现在我添加了一个函数来比较原始输出和模糊输出。也让

49
00:04:25,690 --> 00:04:33,440
该结果从检查输出函数返回。好的，这个函数检查二进制文件是否仍然存在

50
00:04:33,440 --> 00:04:37,150
执行正常。现在让我们想想如何检查

51
00:04:37,150 --> 00:04:43,260
GDB仍然有效。基本上我们不希望人们拆卸主管道。所以你可以使用

52
00:04:43,259 --> 00:04:52,139
echo并通过管道发送该命令，然后退出到gdb以获取输出。所以echo-e和这个

53
00:04:52,139 --> 00:04:56,579
基本上只需键入这两个命令，然后通过管道将其重定向到输入

54
00:04:56,580 --> 00:05:03,590
GDB的。这个看起来不错。所以让我们简单地将这个输出重定向到一个文件，

55
00:05:03,590 --> 00:05:08,200
我会打电话给原版的。现在让我们基本上创建相同的函数，

56
00:05:08,199 --> 00:05:19,619
只需检查gdb。然后比较这两个文件。现在让我们

57
00:05:19,620 --> 00:05:27,640
Radare2也一样。这里我们只使用命令aaa、s sym.main和pdf。阿尔索

58
00:05:27,640 --> 00:05:33,520
store this output in a file. And now again we create a check radare function.

59
00:05:33,520 --> 00:05:37,790
可以使用shift v来突出显示多条线，使用y可以

60
00:05:37,789 --> 00:05:43,959
复制并贴上P。好的…快到了。现在让我们创建一个

61
00:05:43,960 --> 00:05:49,800
无止境的循环。我们首先创建新副本的位置。然后我们检查可执行文件是否仍然

62
00:05:49,800 --> 00:05:57,440
作品。如果这样的话，我们希望Radare和GDB失败。所以，如果不检查gdb和

63
00:05:57,440 --> 00:06:02,550
not check_radare. If we reach this here, we print success and exit.

64
00:06:02,551 --> 00:06:07,111
然后我们打印radare和gdb输出的尾部。只需目视检查

65
00:06:07,110 --> 00:06:12,420
反汇编在某种程度上失败了。通过原始输入，我们可以停止python程序，直到

66
00:06:12,419 --> 00:06:18,329
enter. Now let’s run it. Ah another small mistake.

67
00:06:18,330 --> 00:06:25,180
this should be f1 instead of fn1. And I just discovered another mistake.

68
00:06:25,180 --> 00:06:31,940
好吧，它发现了一些东西，但我们显然还在那里拆卸。我们继续吧

69
00:06:31,940 --> 00:06:40,320
until we find an output without disassembly. Uh. that looks good. Let’s investigate.

70
00:06:40,319 --> 00:06:49,069
Binary still works. Gdb can’t find a main function.

71
00:06:49,069 --> 00:06:52,769
Radare也有问题。哈哈！这很酷：D

72
00:06:52,770 --> 00:06:58,200
I admit, this is very ugly. This is not really a good technique that you can use in practice.

73
00:06:58,199 --> 00:07:02,019
但这基本上就是模糊的工作原理。以及如何发现新的妙招

74
00:07:02,020 --> 00:07:05,840
hide your malware and make it harder for people to analyse it.

75
00:07:05,840 --> 00:07:11,240
如果你想了解更多关于这方面的知识，你可以阅读这本书，它称之为“小说”。

76
00:07:11,240 --> 00:07:15,320
技术”，但这并不是什么新鲜事。还有一些更深入的研究

77
00:07:15,321 --> 00:07:19,741
来自ioactive的elf文件格式。你可以更深入地阅读

78
00:07:19,740 --> 00:07:28,440
疯狂的精灵文件格式技巧在神圣的“国际POC杂志gtfo-第0x00期”

79
00:07:28,439 --> 00:07:32,609
我的二进制文件可以在Github存储库中找到，你可以尝试不同的工具，比如Hopper

80
00:07:32,610 --> 00:07:39,180
或者IDA，看看他们是否仍然自动分析它。但我怀疑是的。所以这只是一个

81
00:07:39,180 --> 00:07:42,910
small trick which can annoy somebody trying to analyse it.

82
00:07:42,909 --> 00:07:48,139
现在你可以回到你的经理那里告诉他，他应该雇用一些网络开发人员。

83
00:07:48,139 --> 00:07:52,189
and move the product into the cloud, so that the code only runs on the servers you control.

