1
00:00:01,530 --> 00:00:05,050
最终级别1存在格式字符串漏洞
可以远程利用。

2
00:00:05,050 --> 00:00:09,990
在过去的几段视频中，我们学到了
通过TCP网络与这些程序对话

3
00:00:09,990 --> 00:00:20,120
连接以及如何调试它们，所以我们
一切都准备好了。

4
00:00:20,120 --> 00:00:24,310
就像所有以前的挑战一样，该计划
在这种情况下作为网络守护程序运行

5
00:00:24,310 --> 00:00:25,840
在2994号港口。

6
00:00:25,840 --> 00:00:32,220
所以我们可以使用netcat连接到这个服务
显示最后一个提示。

7
00:00:32,220 --> 00:00:35,710
但是当我们进入一些我们看不见的东西时
什么都行。

8
00:00:35,710 --> 00:00:36,710
马来酸酐

9
00:00:36,710 --> 00:00:41,100
因为我们已经知道
格式字符串漏洞，我们可以尝试

10
00:00:41,100 --> 00:00:45,970
插入一些字符，如%x，但是
同样，什么都没有发生。

11
00:00:45,969 --> 00:00:52,709
我们也可以尝试%s，因为如果您记得，
它将以堆栈上的值作为地址

12
00:00:52,710 --> 00:00:57,860
字符串的位置，因此如果
堆栈未指向有效内存，

13
00:00:57,860 --> 00:01:03,340
程序应该崩溃，这是另一个
指示格式字符串漏洞。

14
00:01:03,339 --> 00:01:04,439
但是没有。

15
00:01:04,440 --> 00:01:05,660
也不做任何事。

16
00:01:05,659 --> 00:01:09,699
我们也可以尝试发送一个很长的字符串，
只是看看是否有缓冲区溢出

17
00:01:09,700 --> 00:01:13,060
这会使程序崩溃，但也不会
工作。

18
00:01:13,060 --> 00:01:17,810
您可以看到提示现在已返回
多次，这表明

19
00:01:17,810 --> 00:01:22,960
程序总是读取有限的量
你一次发送了这么多的字符，

20
00:01:22,960 --> 00:01:25,900
读取循环能够读取多次。

21
00:01:25,899 --> 00:01:30,089
所以我想是时候看看
源代码。

22
00:01:30,090 --> 00:01:34,350
设置后主调用两个函数
所有的网络资料。

23
00:01:34,350 --> 00:01:39,370
第一个是getipport（），第二个是
一个是parser（）。

24
00:01:39,369 --> 00:01:44,979
getipport调用函数getpeername（），
让我们看看这是怎么回事。

25
00:01:44,979 --> 00:01:50,809
getpeername（）返回对等机的地址
接插座插座fd，缓冲器内

26
00:01:50,810 --> 00:01:52,870
由地址指向。

27
00:01:52,869 --> 00:01:58,919
我们可以看到它还定义了一个结构sockaddr_in
很明显它会包含源头

28
00:01:58,920 --> 00:02:02,710
客户端的IP地址和源端口
连接到插座。

29
00:02:02,710 --> 00:02:08,950
您还可以查看结构
在IP的手册页上。

30
00:02:08,950 --> 00:02:14,680
所以它基本上包含端口号，
和IP地址，并且IP地址是

31
00:02:14,680 --> 00:02:16,960
32字节的整数。

32
00:02:16,959 --> 00:02:22,899
sprintf将编写这个构造的字符串
到hostname，这是一个全局变量。

33
00:02:22,900 --> 00:02:28,230
好的，所以一旦这个函数完成，
代码将调用Parser（）。

34
00:02:28,230 --> 00:02:32,110
解析器将打印最后一个提示
已经知道了。

35
00:02:32,110 --> 00:02:37,390
然后它使用fgets将128个字节读取到
线路缓冲器。

36
00:02:37,390 --> 00:02:41,700
之后，它使用trim，它查找
换行符或换行符的第一次出现

37
00:02:41,700 --> 00:02:44,480
并将其替换为0。

38
00:02:44,480 --> 00:02:46,810
基本上就是在这些位置切割绳子。

39
00:02:46,810 --> 00:02:51,870
然后它将检查您输入的字符串
以"用户名"或"登录"开头。

40
00:02:51,870 --> 00:02:55,870
啊，好的，所以有一些特殊的命令
那个提示。

41
00:02:55,870 --> 00:03:01,550
如果您输入用户名，它可能需要额外的
后面的数据，因为它字符串复制任何

42
00:03:01,549 --> 00:03:05,679
在"用户名"部分进入全局后
变量用户名。

43
00:03:05,680 --> 00:03:09,480
如果您要使用命令"登录"，
它将检查您是否指定了用户名

44
00:03:09,480 --> 00:03:13,940
以前，如果不是，它会告诉你走错了
协议。

45
00:03:13,939 --> 00:03:19,929
但是如果您之前指定了一个用户名，
将使用指向字符串的指针调用logit

46
00:03:19,930 --> 00:03:23,360
登录后，因为它需要密码
那里。

47
00:03:23,360 --> 00:03:28,630
密码在logit中没有使用，它是
只是一个挑战的模型，但在那里

48
00:03:28,629 --> 00:03:33,119
它使用一个缓冲区并用snprintf写入。

49
00:03:33,120 --> 00:03:38,350
基本上是为一个日志条目创建一行，
这表示有一次登录尝试从

50
00:03:38,349 --> 00:03:42,449
特定用户的特定客户端
一个特定的密码。

51
00:03:42,450 --> 00:03:45,470
然后这个字符串记录在系统中
原木。

52
00:03:45,470 --> 00:03:49,120
然后这个函数返回并打印
"登录失败"。

53
00:03:49,120 --> 00:03:52,160
有了这些知识，我们可以尝试使用
再次提示。

54
00:03:52,160 --> 00:03:54,270
它做了我们所期望的。

55
00:03:54,270 --> 00:03:58,290
现在这个失败的登录尝试应该
已登录到系统日志。

56
00:03:58,290 --> 00:04:00,100
我们来看看。

57
00:04:00,099 --> 00:04:02,479
注意，您必须是根目录才能读取该文件。

58
00:04:02,480 --> 00:04:07,690
所以tail，只得到最后几行，of
/var／log／ylog

59
00:04:07,690 --> 00:04:12,570
在这里，最后一次登录尝试来自
此源IP和源端口，作为LiveOverflow

60
00:04:12,569 --> 00:04:14,099
使用密码。

61
00:04:14,099 --> 00:04:15,099
可以。

62
00:04:15,099 --> 00:04:17,779
但是格式字符串漏洞到底在哪里呢？

63
00:04:17,780 --> 00:04:22,350
没有我们控制的打印机
格式参数。

64
00:04:22,350 --> 00:04:23,740
为什么我这么匆忙？

65
00:04:23,740 --> 00:04:26,410
我们甚至不完全理解代码
然而，我们呢？

66
00:04:26,410 --> 00:04:31,630
我们以某些假设阅读此代码
毫无疑问，他们是否是真的。

67
00:04:31,630 --> 00:04:35,590
黑客的意义，如果有的话，是关于
更深入地理解计算机。

68
00:04:35,590 --> 00:04:40,750
但有一个功能我们变得懒惰
刷了一遍，因为我们认为是的

69
00:04:40,750 --> 00:04:41,960
这是工作。

70
00:04:41,960 --> 00:04:46,480
如果你拿走了我的东西
创造，那就应该是，不要满足

71
00:04:46,479 --> 00:04:49,749
用你认为你知道的，挑战你的
信仰。

72
00:04:49,750 --> 00:04:52,800
好吧，那个咆哮有点夸张了。

73
00:04:52,800 --> 00:04:56,160
但我们没有研究这个新功能
我们遇到了-syslog。

74
00:04:56,160 --> 00:05:01,310
我想我说的是，当你解决
这些简单的挑战，你达到了一个点

75
00:05:01,310 --> 00:05:05,070
你认为你知道每一个危险的功能，
但事实并非如此。

76
00:05:05,070 --> 00:05:08,610
所以不要变得懒惰，去阅读手册。

77
00:05:08,610 --> 00:05:12,770
如果我们查看Syslog的手册页，我们将
请注意，第二个参数是一个格式

78
00:05:12,770 --> 00:05:13,770
参数。

79
00:05:13,770 --> 00:05:19,810
syslog（）生成一条日志消息，该消息将
由系统日志D（8）分发。

80
00:05:19,810 --> 00:05:25,810
优先级参数是通过
设施和水平值（解释如下）。

81
00:05:25,810 --> 00:05:30,440
其余参数是一种格式，如
普林特夫（3）

82
00:05:30,440 --> 00:05:32,080
Syslog的工作方式与printf类似。

83
00:05:32,080 --> 00:05:35,410
在logit（）中，buf是格式参数。

84
00:05:35,410 --> 00:05:40,290
buf只包含用户名和
我们输入的密码，因此我们可以注入

85
00:05:40,289 --> 00:05:41,659
设置字符格式。

86
00:05:41,660 --> 00:05:43,300
让我们试试看。

87
00:05:43,300 --> 00:05:47,430
让我们用%x东西登录。

88
00:05:47,430 --> 00:05:49,680
登录失败，请检查系统日志。

89
00:05:49,680 --> 00:05:50,680
就在那里。

90
00:05:50,680 --> 00:05:54,010
在括号中可以看到泄漏的值
从堆栈。

91
00:05:54,009 --> 00:05:57,369
很好，现在我们已经识别出了这个错误。

92
00:05:57,370 --> 00:06:02,110
从早期的格式字符串，利用视频
我们知道一个好的策略是改写

93
00:06:02,110 --> 00:06:08,140
全局偏移量表中的地址
另一个功能，比如执行命令的系统。

94
00:06:08,139 --> 00:06:12,119
让我们考虑一下什么函数
便于覆盖。

95
00:06:12,120 --> 00:06:17,460
我认为，strncmp是一个很酷的功能，因为
我们控制第一个参数。

96
00:06:17,460 --> 00:06:18,460
这条线。

97
00:06:18,460 --> 00:06:21,910
系统使用第一个参数
用于执行内容的字符串。

98
00:06:21,910 --> 00:06:29,740
所以如果我们用系统替换strncmp，我们可以
只需输入一行并执行shell

99
00:06:29,740 --> 00:06:30,740
命令。

100
00:06:30,740 --> 00:06:33,800
好吧，让我们来构建我们的开发。

101
00:06:33,800 --> 00:06:38,160
我们导入可能重要的内容，并设置
我们使用的远程插座连接

102
00:06:38,160 --> 00:06:39,160
去。

103
00:06:39,160 --> 00:06:41,350
也许我们创建了一个新的函数，
读到。

104
00:06:41,349 --> 00:06:44,739
在这种遥控器上很有用
服务挑战。

105
00:06:44,740 --> 00:06:49,810
因此，读取直到将缓冲区填满
读取单个字符，直到缓冲区包含

106
00:06:49,810 --> 00:06:53,050
由read_-until指定的魔力字符串。

107
00:06:53,050 --> 00:06:55,990
然后我们可以简单地写，
阅读直到最后一个提示。

108
00:06:55,990 --> 00:06:58,200
然后我们可以做我们的事情。

109
00:06:58,199 --> 00:07:00,279
所以首先我们指定一个用户名。

110
00:07:00,280 --> 00:07:04,490
读取到下一个提示，然后指定
登录密码，下次再读取

111
00:07:04,490 --> 00:07:05,930
提示。

112
00:07:05,930 --> 00:07:10,510
我使用的另一个技巧是函数raw_input（），
实际上是从用户那里读取输入

113
00:07:10,509 --> 00:07:15,959
在python中，但是非常方便
暂停脚本，直到按Enter键。

114
00:07:15,960 --> 00:07:19,650
所以当我们现在执行这个时，我们连接到
服务，然后我们等待直到我们击中

115
00:07:19,650 --> 00:07:20,760
在脚本中输入。

116
00:07:20,760 --> 00:07:25,560
当我们现在检查正在运行的进程
最后，我们看到两个。

117
00:07:25,560 --> 00:07:30,630
如果您记得其中一个是父守护进程，
以及新的（具有更高的进程ID）

118
00:07:30,629 --> 00:07:34,409
是处理我们的
客户端连接。

119
00:07:34,410 --> 00:07:41,160
所以我们可以将gdb附加到该进程并开始
收集重要符号的地址。

120
00:07:41,160 --> 00:07:46,010
首先，让我们找出
全局偏移表中的strncmp。

121
00:07:46,009 --> 00:07:50,519
通过信息函数和搜索词，我们可以
快速找到PLT中的蹦床功能。

122
00:07:50,520 --> 00:07:54,730
我们可以把这些说明拆开
我们很快看到它跳到地址

123
00:07:54,729 --> 00:07:56,359
存放在这里。

124
00:07:56,360 --> 00:08:00,440
这指向全局偏移表，
很明显会包含真实地址

125
00:08:00,440 --> 00:08:02,310
到libc中的strncmp。

126
00:08:02,310 --> 00:08:06,140
所以这是我们想要覆盖的目标地址。

127
00:08:06,139 --> 00:08:08,539
接下来是系统地址。

128
00:08:08,539 --> 00:08:12,159
系统是libc的一部分，我们可以很快
在这里找到它的地址。

129
00:08:12,159 --> 00:08:17,849
注：由于ASLR，通常libc是随机的。
现在，但是在这个旧的Linux系统上，或者

130
00:08:17,850 --> 00:08:20,240
在嵌入式设备上，它仍然以这种方式工作。

131
00:08:20,240 --> 00:08:24,840
在一个真正的现代系统上，你首先会
从内存中泄漏地址以便

132
00:08:24,840 --> 00:08:27,000
计算偏移量并断开aslr。

133
00:08:27,000 --> 00:08:32,950
好的，我们有我们的目标，我们有
我们要写信给它的地址。

134
00:08:32,950 --> 00:08:37,640
此外，生成的日志消息还将包含
源IP和端口，可能会有所不同

135
00:08:37,640 --> 00:08:38,910
在长度上。

136
00:08:38,910 --> 00:08:42,840
来自本地主机将不同于
来自远程主机。

137
00:08:42,840 --> 00:08:47,110
所以我们应该把它加入到我们的开发中
要可靠。

138
00:08:47,110 --> 00:08:51,660
挑战使用getpeername获取
它的对等端的IP和端口。

139
00:08:51,660 --> 00:08:55,140
所以我们可以用等价物来得到你自己的
姓名。

140
00:08:55,140 --> 00:08:57,150
使用getsockname（）。

141
00:08:57,150 --> 00:09:02,110
现在我们也知道了源IP和端口以及
可以编写相应的代码来适应。

142
00:09:02,110 --> 00:09:05,930
另外，很抱歉，代码太糟糕了
以这种方式阅读。

143
00:09:05,930 --> 00:09:09,800
我不知道为什么我从不费心转弯
关于语法代码高度化。

144
00:09:09,800 --> 00:09:10,800
我们走吧。

145
00:09:10,800 --> 00:09:11,800
迟到总比不迟到好。

146
00:09:11,800 --> 00:09:12,800
语法。

147
00:09:12,800 --> 00:09:14,130
让我们再看一下记录的线路
从早起。

148
00:09:14,130 --> 00:09:19,590
最后这些人物看起来可疑
和ASCII一样，当我们转换它们时，我们会看到

149
00:09:19,590 --> 00:09:23,220
它们拼写为"从……登录等等"。

150
00:09:23,220 --> 00:09:27,730
让我们用一些可识别的
用于查找用户名的字符。

151
00:09:27,730 --> 00:09:30,420
就在这里。

152
00:09:30,420 --> 00:09:35,480
所以花了大约14次
使用aaaa访问用户名。

153
00:09:35,480 --> 00:09:41,060
你可以看到A不完美
对齐，它们甚至可能会移动，因为

154
00:09:41,060 --> 00:09:43,410
IP和端口的长度。

155
00:09:43,410 --> 00:09:48,970
因此，第一步是通过
调整后的数量

156
00:09:48,970 --> 00:09:51,900
它将是一个已知的对齐偏移量。

157
00:09:51,900 --> 00:09:54,890
所以在本例中，主机名是15个字符
长。

158
00:09:54,890 --> 00:09:58,630
再加一个A就可以填好并会签了
记忆。

159
00:09:58,630 --> 00:10:03,020
那么让我们想想最短的和
最长的主机名可能是。

160
00:10:03,020 --> 00:10:06,400
最短的是9，最长的是21。

161
00:10:06,400 --> 00:10:13,380
因为我们更喜欢四的倍数
32位对齐，我们决定填充到24个字符。

162
00:10:13,380 --> 00:10:18,600
因此，我们取主机名的长度，减去
从24开始，然后我们知道有多少A

163
00:10:18,600 --> 00:10:19,600
我们需要。

164
00:10:19,600 --> 00:10:22,740
让我们用一些%x在
用户名。

165
00:10:22,740 --> 00:10:27,040
哦，我们不能忘记在
测试输入结束。

166
00:10:27,040 --> 00:10:29,210
哦，不工作吗？

167
00:10:29,210 --> 00:10:30,920
我们做错了什么？

168
00:10:30,920 --> 00:10:33,740
啊…我们忘了用户名和登录命令。

169
00:10:33,740 --> 00:10:35,720
仍然不起作用…

170
00:10:35,720 --> 00:10:44,120
哦，行的长度只能是128字节，但是
我们寄了更多的信，其中28个是…

171
00:10:44,120 --> 00:10:48,050
看，这么多小的事情都会出错
让你慢下来。

172
00:10:48,050 --> 00:10:49,800
现在登录失败。

173
00:10:49,800 --> 00:10:54,000
查看系统日志并搜索
对英国人来说，我们看到了……天哪……我们

174
00:10:54,000 --> 00:10:56,380
忘记用as添加填充。

175
00:10:56,380 --> 00:11:02,750
好了，我们开始……
BS现在完全对齐。

176
00:11:02,750 --> 00:11:03,750
令人惊叹的。

177
00:11:03,750 --> 00:11:07,760
现在不管你的IP或端口是什么
有，它会一直在那里。

178
00:11:07,760 --> 00:11:13,070
我们可以数一数堆栈上的单词，
得到偏移量17。

179
00:11:13,070 --> 00:11:20,630
现在我们可以继续使用一个%x
用美元表示的是17

180
00:11:20,630 --> 00:11:24,150
参数，堆栈上的第17个值。

181
00:11:24,150 --> 00:11:30,020
例如，我们现在可以放置地址
strncmp的全局偏移量表条目的

182
00:11:30,020 --> 00:11:35,710
在这里输入字符串，然后使用%n写入
到那个地址。

183
00:11:35,710 --> 00:11:41,690
所以现在我们只需要知道有多大
对于填充，我们需要编写值，

184
00:11:41,690 --> 00:11:42,690
想要。

185
00:11:42,690 --> 00:11:46,930
如果这让您感到困惑，请重新调整旧格式
字符串的东西。

186
00:11:46,930 --> 00:11:51,020
所以在我们现在运行它之前，添加另一个原始输入
这样脚本就不会退出，然后

187
00:11:51,019 --> 00:11:57,929
我们运行它，用gdb连接它，并观察
strncmp的入口，我们在后面看到

188
00:11:57,930 --> 00:12:00,190
登录尝试被覆盖。

189
00:12:00,190 --> 00:12:05,170
我们的目标是系统地址的较低部分，
是0xffb0。

190
00:12:05,170 --> 00:12:09,650
所以现在我们可以计算出正确的数字
我们需要打印的字符数。

191
00:12:09,650 --> 00:12:12,200
这就是现在的过程
作品。

192
00:12:12,200 --> 00:12:18,060
我们用%n写信到地址，检查
数字，计算缺少多少或如何

193
00:12:18,060 --> 00:12:22,490
我们太过分了，更正一下数字
我们打印并重复直到

194
00:12:22,490 --> 00:12:25,620
已构建系统的完整地址。

195
00:12:25,620 --> 00:12:31,740
这太烦人了，而且
需要一些时间，但一旦你得到它，它

196
00:12:31,740 --> 00:12:34,390
太酷了。

197
00:12:34,390 --> 00:12:41,060
所以现在我得到了补偿和地址
被系统地址覆盖。

198
00:12:41,060 --> 00:12:45,780
现在我们可以用interact添加telnetlib技巧
从理论上讲

199
00:12:45,780 --> 00:12:49,810
将所有调用指向strncm将调用系统
相反。

200
00:12:49,811 --> 00:12:55,111
如果你研究代码并思考
简单地在提示下写一些东西

201
00:12:55,110 --> 00:12:57,640
应导致命令执行。

202
00:12:57,640 --> 00:12:58,820
所以我们试试看。

203
00:12:58,820 --> 00:13:03,310
我们得到一个提示，现在我们可以输入命令
就好像我们在一个真正的壳里。

204
00:13:03,310 --> 00:13:09,390
程序读取我们的线路，调用
strncmp，实际上它调用系统和

205
00:13:09,390 --> 00:13:11,230
执行我们的命令。

206
00:13:11,230 --> 00:13:15,020
再说一次，我们可以把这个漏洞复制到
Windows计算机，将IP地址更改为

207
00:13:15,020 --> 00:13:17,450
然后得到一个远程shell。

208
00:13:17,450 --> 00:13:18,350
令人惊叹的！

