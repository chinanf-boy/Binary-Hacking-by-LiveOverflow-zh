1
00:00:01,530 --> 00:00:05,050
最终级别1存在可远程利用的格式字符串漏洞。

2
00:00:05,050 --> 00:00:09,990
在过去的几段视频中，我们学习了如何通过TCP网络与这些程序通信。

3
00:00:09,990 --> 00:00:20,120
连接以及如何调试它们，所以我们都准备好了。

4
00:00:20,120 --> 00:00:24,310
与所有以前的挑战一样，在本例中，该程序作为网络守护程序运行

5
00:00:24,310 --> 00:00:25,840
在2994号港口。

6
00:00:25,840 --> 00:00:32,220
所以我们可以使用netcat连接到显示final1提示的服务。

7
00:00:32,220 --> 00:00:35,710
但当我们进入某个地方，却什么也看不见。

8
00:00:35,710 --> 00:00:36,710
马来酸酐

9
00:00:36,710 --> 00:00:41,100
另外，因为我们已经知道这将是一个格式字符串漏洞，我们可以尝试

10
00:00:41,100 --> 00:00:45,970
注入一些字符，如%x，但同样，什么也不会发生。

11
00:00:45,969 --> 00:00:52,709
我们也可以尝试使用%s，因为如果您记得，它将以堆栈上的值作为地址

12
00:00:52,710 --> 00:00:57,860
字符串的位置，因此，如果堆栈上的值未指向有效内存，则

13
00:00:57,860 --> 00:01:03,340
程序应该崩溃，这将是格式字符串漏洞的另一个指示。

14
00:01:03,339 --> 00:01:04,439
但是没有。

15
00:01:04,440 --> 00:01:05,660
也不做任何事。

16
00:01:05,659 --> 00:01:09,699
我们还可以尝试发送一个非常长的字符串，只是为了查看是否存在缓冲区溢出。

17
00:01:09,700 --> 00:01:13,060
这会使程序崩溃，但也不起作用。

18
00:01:13,060 --> 00:01:17,810
您可以看到现在多次返回提示，这表示

19
00:01:17,810 --> 00:01:22,960
程序总是读取有限数量的字符，而您一次发送了如此多的字符，

20
00:01:22,960 --> 00:01:25,900
读取循环能够读取多次。

21
00:01:25,899 --> 00:01:30,089
所以我想是时候看看源代码了。

22
00:01:30,090 --> 00:01:34,350
在设置完所有的网络设备后，MAIN调用两个函数。

23
00:01:34,350 --> 00:01:39,370
第一个是getipport() ，第二个是parser() 。

24
00:01:39,369 --> 00:01:44,979
getipport调用getpeername() 函数，让我们看看这是怎么回事。

25
00:01:44,979 --> 00:01:50,809
getpeername() 返回缓冲区中连接到socket sockfd的对等机的地址

26
00:01:50,810 --> 00:01:52,870
由地址指向。

27
00:01:52,869 --> 00:01:58,919
我们可以看到，它还定义了一个结构sockaddr_，其中显然将包含源代码

28
00:01:58,920 --> 00:02:02,710
连接到套接字的客户端的IP地址和源端口。

29
00:02:02,710 --> 00:02:08,950
您还可以在IP的手册页上查找结构的确切外观。

30
00:02:08,950 --> 00:02:14,680
所以它基本上包含端口号和IP地址，IP地址是

31
00:02:14,680 --> 00:02:16,960
32字节的整数。

32
00:02:16,959 --> 00:02:22,899
sprintf将把这个构造好的字符串写到hostname中，hostname是一个全局变量。

33
00:02:22,900 --> 00:02:28,230
好的，所以一旦函数完成，代码将调用parser() 。

34
00:02:28,230 --> 00:02:32,110
解析器将打印我们已经知道的最后一个提示。

35
00:02:32,110 --> 00:02:37,390
然后它使用fgets将128个字节读取到行缓冲区中。

36
00:02:37,390 --> 00:02:41,700
然后它使用trim，它查找换行符或换行符的第一个匹配项

37
00:02:41,700 --> 00:02:44,480
并将其替换为0。

38
00:02:44,480 --> 00:02:46,810
基本上就是在这些位置切割绳子。

39
00:02:46,810 --> 00:02:51,870
然后它将检查您输入的字符串是否以“用户名”或“登录”开头。

40
00:02:51,870 --> 00:02:55,870
啊，好的，所以这个提示有一些特殊的命令。

41
00:02:55,870 --> 00:03:01,550
如果您输入用户名，它在后面会有一些额外的数据，因为它字符串会复制任何内容。

42
00:03:01,549 --> 00:03:05,679
在“username”部分之后进入全局变量username。

43
00:03:05,680 --> 00:03:09,480
如果您要使用命令“login”，它将检查您是否指定了用户名

44
00:03:09,480 --> 00:03:13,940
之前，如果没有，它会告诉你遵循了一个错误的协议。

45
00:03:13,939 --> 00:03:19,929
但是如果您之前指定了一个用户名，它将调用logit，并在字符串中插入一个指针。

46
00:03:19,930 --> 00:03:23,360
在登录之后，因为它需要一个密码。

47
00:03:23,360 --> 00:03:28,630
密码不在logit中使用，它只是挑战的一个模型，但在那里

48
00:03:28,629 --> 00:03:33,119
它使用一个缓冲区并用snprintf写入。

49
00:03:33,120 --> 00:03:38,350
基本上是为一个日志条目创建一行，这表示有一个登录尝试来自

50
00:03:38,349 --> 00:03:42,449
具有特定密码的特定用户的特定客户端。

51
00:03:42,450 --> 00:03:45,470
然后这个字符串记录在系统日志中。

52
00:03:45,470 --> 00:03:49,120
然后此函数返回，并将打印“登录失败”。

53
00:03:49,120 --> 00:03:52,160
有了这些知识，我们可以再次尝试使用提示。

54
00:03:52,160 --> 00:03:54,270
它做了我们所期望的。

55
00:03:54,270 --> 00:03:58,290
现在，这个失败的登录尝试应该记录在系统日志中。

56
00:03:58,290 --> 00:04:00,100
我们来看看。

57
00:04:00,099 --> 00:04:02,479
注意，您必须是根目录才能读取该文件。

58
00:04:02,480 --> 00:04:07,690
所以tail，只获取/var/log/syslog的最后几行

59
00:04:07,690 --> 00:04:12,570
在这里，从这个源IP和源端口的final1登录尝试，作为liveoverflow

60
00:04:12,569 --> 00:04:14,099
使用密码。

61
00:04:14,099 --> 00:04:15,099
可以。

62
00:04:15,099 --> 00:04:17,779
但是格式字符串漏洞到底在哪里呢？

63
00:04:17,780 --> 00:04:22,350
我们控制格式参数的地方没有printf。

64
00:04:22,350 --> 00:04:23,740
为什么我这么匆忙？

65
00:04:23,740 --> 00:04:26,410
我们还没有完全理解代码，是吗？

66
00:04:26,410 --> 00:04:31,630
我们在阅读这段代码时，会有一些假设，如果它们是真的，我们会毫不怀疑。

67
00:04:31,630 --> 00:04:35,590
黑客的意义，如果有的话，是关于更深层次的理解计算机。

68
00:04:35,590 --> 00:04:40,750
但有一个功能让我们变得懒惰和被忽视，因为我们认为它确实如此

69
00:04:40,750 --> 00:04:41,960
这是工作。

70
00:04:41,960 --> 00:04:46,480
如果你从我创造的东西中拿走了任何东西，那就是，不要满足

71
00:04:46,479 --> 00:04:49,749
用你认为你知道的去挑战你的信仰。

72
00:04:49,750 --> 00:04:52,800
好吧，那咆哮有点夸张了。

73
00:04:52,800 --> 00:04:56,160
但是我们没有研究我们遇到的这个新函数-syslog。

74
00:04:56,160 --> 00:05:01,310
我想我要说的是，当你解决这些简单的挑战时，你达到了一个点

75
00:05:01,310 --> 00:05:05,070
你认为你知道所有危险的功能，但那不是真的。

76
00:05:05,070 --> 00:05:08,610
所以别偷懒了，读一下手册。

77
00:05:08,610 --> 00:05:12,770
如果我们查看syslog的手册页，我们将看到第二个参数是一种格式

78
00:05:12,770 --> 00:05:13,770
参数。

79
00:05:13,770 --> 00:05:19,810
syslog() 生成一条日志消息，由syslogd（8）分发。

80
00:05:19,810 --> 00:05:25,810
优先级参数是通过ORing设备和级别值形成的（如下所述）。

81
00:05:25,810 --> 00:05:30,440
其余参数是一种格式，如printf（3）中所示。

82
00:05:30,440 --> 00:05:32,080
Syslog的工作方式与printf类似。

83
00:05:32,080 --> 00:05:35,410
在logit() 中，buf是格式参数。

84
00:05:35,410 --> 00:05:40,290
buf只包含我们输入的用户名和密码，因此我们可以注入

85
00:05:40,289 --> 00:05:41,659
设置字符格式。

86
00:05:41,660 --> 00:05:43,300
让我们试试看。

87
00:05:43,300 --> 00:05:47,430
让我们用%x东西登录。

88
00:05:47,430 --> 00:05:49,680
登录失败，请检查系统日志。

89
00:05:49,680 --> 00:05:50,680
就在那里。

90
00:05:50,680 --> 00:05:54,010
在括号中，您可以看到堆栈中泄漏的值。

91
00:05:54,009 --> 00:05:57,369
很好，现在我们已经识别出了这个错误。

92
00:05:57,370 --> 00:06:02,110
从早期的格式字符串利用视频，我们了解到一个好的策略是覆盖

93
00:06:02,110 --> 00:06:08,140
全局偏移量表中的一个地址，具有另一个函数，如执行命令的系统。

94
00:06:08,139 --> 00:06:12,119
让我们考虑一下覆盖什么函数比较方便。

95
00:06:12,120 --> 00:06:17,460
我认为strncmp是一个很酷的函数，因为我们控制第一个参数。

96
00:06:17,460 --> 00:06:18,460
这条线。

97
00:06:18,460 --> 00:06:21,910
系统使用字符串的第一个参数来执行任务。

98
00:06:21,910 --> 00:06:29,740
因此，如果我们用系统替换strncmp，我们可以简单地键入一行并执行shell

99
00:06:29,740 --> 00:06:30,740
命令。

100
00:06:30,740 --> 00:06:33,800
好吧，让我们来构建我们的开发。

101
00:06:33,800 --> 00:06:38,160
我们导入可能重要的内容，并像使用一样设置远程套接字连接

102
00:06:38,160 --> 00:06:39,160
去。

103
00:06:39,160 --> 00:06:41,350
也许我们创建了一个新的函数，叫做，read-until。

104
00:06:41,349 --> 00:06:44,739
这在这些远程服务挑战中非常有用。

105
00:06:44,740 --> 00:06:49,810
所以read until应该用单个字符的读来填充缓冲区，直到缓冲区包含

106
00:06:49,810 --> 00:06:53,050
由read_-until指定的魔力字符串。

107
00:06:53,050 --> 00:06:55,990
然后我们可以简单地写、读直到最后一个提示。

108
00:06:55,990 --> 00:06:58,200
然后我们可以做我们的事情。

109
00:06:58,199 --> 00:07:00,279
所以首先我们指定一个用户名。

110
00:07:00,280 --> 00:07:04,490
读取到下一个提示，然后指定登录密码，然后再次读取直到下一个提示

111
00:07:04,490 --> 00:07:05,930
提示。

112
00:07:05,930 --> 00:07:10,510
我使用的另一个技巧是函数raw_input() ，它实际上是从用户那里读取输入。

113
00:07:10,509 --> 00:07:15,959
在python中，但是非常方便地暂停脚本，直到我们点击enter。

114
00:07:15,960 --> 00:07:19,650
所以当我们现在执行这个时，我们连接到服务，然后等待直到

115
00:07:19,650 --> 00:07:20,760
在脚本中输入。

116
00:07:20,760 --> 00:07:25,560
当我们现在检查运行过程的最终版本时，我们看到两个。

117
00:07:25,560 --> 00:07:30,630
如果您记得，其中一个是父守护进程，而新的守护进程（具有更高的进程ID）

118
00:07:30,629 --> 00:07:34,409
是处理客户端连接的派生子级。

119
00:07:34,410 --> 00:07:41,160
所以我们可以将gdb附加到这个过程中，并开始收集重要符号的地址。

120
00:07:41,160 --> 00:07:46,010
首先，让我们在全局偏移量表中计算strncmp的地址。

121
00:07:46,009 --> 00:07:50,519
通过信息函数和搜索项，我们可以快速地在PLT中找到函数蹦床。

122
00:07:50,520 --> 00:07:54,730
我们可以把这些指令拆开，很快就能看到它跳到地址上。

123
00:07:54,729 --> 00:07:56,359
存放在这里。

124
00:07:56,360 --> 00:08:00,440
这指向全局偏移量表，显然包含实际地址

125
00:08:00,440 --> 00:08:02,310
到libc中的strncmp。

126
00:08:02,310 --> 00:08:06,140
所以这是我们想要覆盖的目标地址。

127
00:08:06,139 --> 00:08:08,539
接下来是系统地址。

128
00:08:08,539 --> 00:08:12,159
系统是libc的一部分，我们可以在这里快速获取它的地址。

129
00:08:12,159 --> 00:08:17,849
注意，通常libc是由于aslr而随机化的，但是在这个旧的linux系统上，或者

130
00:08:17,850 --> 00:08:20,240
在嵌入式设备上，它仍然以这种方式工作。

131
00:08:20,240 --> 00:08:24,840
在一个真正的现代系统中，为了

132
00:08:24,840 --> 00:08:27,000
计算偏移量并断开aslr。

133
00:08:27,000 --> 00:08:32,950
好的，我们有我们的目标，我们有我们想写的地址。

134
00:08:32,950 --> 00:08:37,640
此外，生成的日志消息将包含源IP和端口，这可能会有所不同

135
00:08:37,640 --> 00:08:38,910
在长度上。

136
00:08:38,910 --> 00:08:42,840
来自本地主机将不同于来自远程主机。

137
00:08:42,840 --> 00:08:47,110
因此，我们应该将这一点加入到我们的开发中，以使其可靠。

138
00:08:47,110 --> 00:08:51,660
挑战使用getpeername获取其对等机的IP和端口。

139
00:08:51,660 --> 00:08:55,140
所以我们可以用等价物来得到你自己的名字。

140
00:08:55,140 --> 00:08:57,150
使用getsockname() 。

141
00:08:57,150 --> 00:09:02,110
现在我们也知道了源IP和端口，可以编写相应的代码来适应。

142
00:09:02,110 --> 00:09:05,930
另外，我很抱歉，用这种方式读代码真的很糟糕。

143
00:09:05,930 --> 00:09:09,800
我不知道为什么我从不费心打开语法代码高速转换。

144
00:09:09,800 --> 00:09:10,800
我们走吧。

145
00:09:10,800 --> 00:09:11,800
迟到总比不迟到好。

146
00:09:11,800 --> 00:09:12,800
语法。

147
00:09:12,800 --> 00:09:14,130
让我们再看看前面记录的行。

148
00:09:14,130 --> 00:09:19,590
结尾处的这些字符看起来可疑地像ASCII，当我们转换它们时，我们会看到

149
00:09:19,590 --> 00:09:23,220
它们拼写为“从……登录等等”。

150
00:09:23,220 --> 00:09:27,730
让我们用一些可识别的字符再做一次，以找到用户名。

151
00:09:27,730 --> 00:09:30,420
就在那里。

152
00:09:30,420 --> 00:09:35,480
所以用aaaa访问用户名大约需要14个pop。

153
00:09:35,480 --> 00:09:41,060
你可以看到A不完全对齐，它们甚至可能会移动，因为

154
00:09:41,060 --> 00:09:43,410
IP和端口的长度。

155
00:09:43,410 --> 00:09:48,970
因此，第一步是通过调整

156
00:09:48,970 --> 00:09:51,900
这将是一个已知的对齐偏移量。

157
00:09:51,900 --> 00:09:54,890
因此，在本例中，主机名的长度为15个字符。

158
00:09:54,890 --> 00:09:58,630
再加一个A就可以填满并重新标记记忆了。

159
00:09:58,630 --> 00:10:03,020
那么让我们考虑一下最短和最长的主机名是什么。

160
00:10:03,020 --> 00:10:06,400
最短的是9，最长的是21。

161
00:10:06,400 --> 00:10:13,380
因为我们更喜欢4的倍数是32位对齐的，所以我们决定填充到24个字符。

162
00:10:13,380 --> 00:10:18,600
因此，我们取主机名的长度，从24减去它，然后我们知道有多少个A

163
00:10:18,600 --> 00:10:19,600
我们需要。

164
00:10:19,600 --> 00:10:22,740
让我们用用户名中的一些%x再试一次。

165
00:10:22,740 --> 00:10:27,040
哦，我们不能忘记在测试输入结束时的换行符。

166
00:10:27,040 --> 00:10:29,210
哦，不工作吗？

167
00:10:29,210 --> 00:10:30,920
我们做错了什么？

168
00:10:30,920 --> 00:10:33,740
啊…我们忘了用户名和登录命令。

169
00:10:33,740 --> 00:10:35,720
仍然不起作用…

170
00:10:35,720 --> 00:10:44,120
哦，行的长度只能是128字节，但是我们用这些%x中的28个发送更多…

171
00:10:44,120 --> 00:10:48,050
你看，这么多小的事情会让你走错路，让你减速。

172
00:10:48,050 --> 00:10:49,800
现在登录失败。

173
00:10:49,800 --> 00:10:54,000
查看系统日志并搜索BS，我们看到……上帝啊，该死的……我们

174
00:10:54,000 --> 00:10:56,380
忘记用as添加填充。

175
00:10:56,380 --> 00:11:02,750
好了，我们开始……BS现在完全对齐。

176
00:11:02,750 --> 00:11:03,750
令人惊叹的。

177
00:11:03,750 --> 00:11:07,760
现在，无论您拥有什么IP或端口，它都将一直在那里。

178
00:11:07,760 --> 00:11:13,070
我们可以数一数堆栈上的单词，得到偏移量17。

179
00:11:13,070 --> 00:11:20,630
现在我们可以继续使用一个带有美元符号的%x来表示第17个

180
00:11:20,630 --> 00:11:24,150
参数，堆栈上的第17个值。

181
00:11:24,150 --> 00:11:30,020
例如，我们现在可以放置strncmp的全局偏移表条目的地址

182
00:11:30,020 --> 00:11:35,710
在这里输入字符串，然后使用%n写入该地址。

183
00:11:35,710 --> 00:11:41,690
所以现在我们只需要知道填充有多大，我们需要写下

184
00:11:41,690 --> 00:11:42,690
想要。

185
00:11:42,690 --> 00:11:46,930
如果这让您感到困惑，请重新包装旧格式的字符串资料。

186
00:11:46,930 --> 00:11:51,020
所以在我们现在运行它之前，添加另一个原始输入，这样脚本就不会退出，然后

187
00:11:51,019 --> 00:11:57,929
我们运行它，用gdb连接它，观察strncmp的got条目，然后看到

188
00:11:57,930 --> 00:12:00,190
登录尝试被覆盖。

189
00:12:00,190 --> 00:12:05,170
我们的目标是系统地址的较低部分，即0xffb0。

190
00:12:05,170 --> 00:12:09,650
现在我们可以计算出需要打印的正确字符数。

191
00:12:09,650 --> 00:12:12,200
这就是这个过程现在的工作原理。

192
00:12:12,200 --> 00:12:18,060
我们用%n写信到地址，核对号码，计算丢失了多少或如何

193
00:12:18,060 --> 00:12:22,490
太多了，我们超调，更正我们打印的字符数，重复直到我们

194
00:12:22,490 --> 00:12:25,620
已构建系统的完整地址。

195
00:12:25,620 --> 00:12:31,740
这太烦人了，很烦人，需要一些时间，但一旦你得到了它，它

196
00:12:31,740 --> 00:12:34,390
太酷了。

197
00:12:34,390 --> 00:12:41,060
所以现在我得到了正确的偏移量，地址被系统的地址覆盖。

198
00:12:41,060 --> 00:12:45,780
现在我们可以将telnetlib技巧和interaction添加到我们的程序中，理论上来说

199
00:12:45,780 --> 00:12:49,810
将所有对strncm的调用都指向系统。

200
00:12:49,811 --> 00:12:55,111
如果您研究代码并考虑一下，只需在提示符上写一些东西

201
00:12:55,110 --> 00:12:57,640
应导致命令执行。

202
00:12:57,640 --> 00:12:58,820
所以我们试试看。

203
00:12:58,820 --> 00:13:03,310
我们得到了一个提示，现在我们可以像在真正的shell中一样键入命令。

204
00:13:03,310 --> 00:13:09,390
程序读取我们的线路，调用strncmp，实际上它调用系统和

205
00:13:09,390 --> 00:13:11,230
执行我们的命令。

206
00:13:11,230 --> 00:13:15,020
同样，我们可以将漏洞复制到我们的Windows计算机上，将IP地址更改为

207
00:13:15,020 --> 00:13:17,450
然后得到一个远程shell。

208
00:13:17,450 --> 00:13:18,350
令人惊叹的！

