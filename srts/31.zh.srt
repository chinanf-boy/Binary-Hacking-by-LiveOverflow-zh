1
00:00:01,530 --> 00:00:05,050
Final level 1 has a format string vulnerability that can be exploited remotely.

2
00:00:05,050 --> 00:00:09,990
在过去的几段视频中，我们学习了如何通过TCP网络与这些程序通信。

3
00:00:09,990 --> 00:00:20,120
connection and how to debug them, so we are all set to go.

4
00:00:20,120 --> 00:00:24,310
与所有以前的挑战一样，在本例中，该程序作为网络守护程序运行

5
00:00:24,310 --> 00:00:25,840
on port 2994.

6
00:00:25,840 --> 00:00:32,220
So we can use netcat to connect to this service which displays a final1 prompt.

7
00:00:32,220 --> 00:00:35,710
But when we enter something we don’t see anything.

8
00:00:35,710 --> 00:00:36,710
Mh.

9
00:00:36,710 --> 00:00:41,100
另外，因为我们已经知道这将是一个格式字符串漏洞，我们可以尝试

10
00:00:41,100 --> 00:00:45,970
to inject some characters such as %x, but again, nothing happens.

11
00:00:45,969 --> 00:00:52,709
我们也可以尝试使用%s，因为如果您记得，它将以堆栈上的值作为地址

12
00:00:52,710 --> 00:00:57,860
字符串的位置，因此，如果堆栈上的值未指向有效内存，则

13
00:00:57,860 --> 00:01:03,340
program should crash, which would be another indication of a format string vulnerability.

14
00:01:03,339 --> 00:01:04,439
But nope.

15
00:01:04,440 --> 00:01:05,660
Also doesn’t do anything.

16
00:01:05,659 --> 00:01:09,699
我们还可以尝试发送一个非常长的字符串，只是为了查看是否存在缓冲区溢出。

17
00:01:09,700 --> 00:01:13,060
that would crash the program, but also doesn’t work.

18
00:01:13,060 --> 00:01:17,810
您可以看到现在多次返回提示，这表示

19
00:01:17,810 --> 00:01:22,960
程序总是读取有限数量的字符，而您一次发送了如此多的字符，

20
00:01:22,960 --> 00:01:25,900
that the read loop was able to read many times.

21
00:01:25,899 --> 00:01:30,089
So I guess it’s time to have a look at the source code.

22
00:01:30,090 --> 00:01:34,350
Main calls two functions after setting up all the networking stuff.

23
00:01:34,350 --> 00:01:39,370
The first one is getipport(), and the second one is parser().

24
00:01:39,369 --> 00:01:44,979
Getipport calls the function getpeername(), so let’s see what that is about.

25
00:01:44,979 --> 00:01:50,809
getpeername（）返回缓冲区中连接到socket sockfd的对等机的地址

26
00:01:50,810 --> 00:01:52,870
pointed to by addr.

27
00:01:52,869 --> 00:01:58,919
我们可以看到，它还定义了一个结构sockaddr_，其中显然将包含源代码

28
00:01:58,920 --> 00:02:02,710
ip address and source port by the client that connected to the socket.

29
00:02:02,710 --> 00:02:08,950
You can also look up how the struct exactly looks like on the man page for ip.

30
00:02:08,950 --> 00:02:14,680
所以它基本上包含端口号和IP地址，IP地址是

31
00:02:14,680 --> 00:02:16,960
a 32byte integer.

32
00:02:16,959 --> 00:02:22,899
And sprintf will write this constructed string into hostname, which is a global variable.

33
00:02:22,900 --> 00:02:28,230
Ok so once this function is complete, the code will call parser().

34
00:02:28,230 --> 00:02:32,110
And parser will print the final1 prompt we already know.

35
00:02:32,110 --> 00:02:37,390
Then it uses fgets to read 128 bytes into the line buffer.

36
00:02:37,390 --> 00:02:41,700
然后它使用trim，它查找换行符或换行符的第一个匹配项

37
00:02:41,700 --> 00:02:44,480
and replaces it with a 0.

38
00:02:44,480 --> 00:02:46,810
Basically cutting the string at these positions.

39
00:02:46,810 --> 00:02:51,870
Then it will check if the string you entered starts with “username”, or “login”.

40
00:02:51,870 --> 00:02:55,870
Ahh, ok, so there are special commands for that prompt.

41
00:02:55,870 --> 00:03:01,550
如果您输入用户名，它在后面会有一些额外的数据，因为它字符串会复制任何内容。

42
00:03:01,549 --> 00:03:05,679
after the “username” part into the global variable username.

43
00:03:05,680 --> 00:03:09,480
如果您要使用命令“login”，它将检查您是否指定了用户名

44
00:03:09,480 --> 00:03:13,940
before, if not it tells you you follow a wrong protocol.

45
00:03:13,939 --> 00:03:19,929
但是如果您之前指定了一个用户名，它将调用logit，并在字符串中插入一个指针。

46
00:03:19,930 --> 00:03:23,360
after login, because it expects a password there.

47
00:03:23,360 --> 00:03:28,630
密码不在logit中使用，它只是挑战的一个模型，但在那里

48
00:03:28,629 --> 00:03:33,119
it uses a buffer and writes to it with snprintf.

49
00:03:33,120 --> 00:03:38,350
基本上是为一个日志条目创建一行，这表示有一个登录尝试来自

50
00:03:38,349 --> 00:03:42,449
a certain client for a specific user with a certain password.

51
00:03:42,450 --> 00:03:45,470
And then this string logged in the system log.

52
00:03:45,470 --> 00:03:49,120
Then this function returns and it will print “login failed”.

53
00:03:49,120 --> 00:03:52,160
Armed with this knowledge we can try to use the prompt again.

54
00:03:52,160 --> 00:03:54,270
And it does what we expect.

55
00:03:54,270 --> 00:03:58,290
Now this failed login attempt should have been logged in the syslog.

56
00:03:58,290 --> 00:04:00,100
So let’s check it out.

57
00:04:00,099 --> 00:04:02,479
Note you have to be root to read that file.

58
00:04:02,480 --> 00:04:07,690
所以tail，只获取/var/log/syslog的最后几行

59
00:04:07,690 --> 00:04:12,570
在这里，从这个源IP和源端口的final1登录尝试，作为liveoverflow

60
00:04:12,569 --> 00:04:14,099
with the password.

61
00:04:14,099 --> 00:04:15,099
Okay.

62
00:04:15,099 --> 00:04:17,779
但是格式字符串漏洞到底在哪里呢？

63
00:04:17,780 --> 00:04:22,350
There is no printf where we controlled the format parameter.

64
00:04:22,350 --> 00:04:23,740
为什么我这么匆忙？

65
00:04:23,740 --> 00:04:26,410
我们还没有完全理解代码，是吗？

66
00:04:26,410 --> 00:04:31,630
We read this code with certain assumptions without questioning if they are true.

67
00:04:31,630 --> 00:04:35,590
The meaning of hacking, if anything, is about understanding computers on a deeper level.

68
00:04:35,590 --> 00:04:40,750
但有一个功能让我们变得懒惰和被忽视，因为我们认为它确实如此

69
00:04:40,750 --> 00:04:41,960
it’s job.

70
00:04:41,960 --> 00:04:46,480
如果你从我创造的东西中拿走了任何东西，那就是，不要满足

71
00:04:46,479 --> 00:04:49,749
with what you think you know, challenge your beliefs.

72
00:04:49,750 --> 00:04:52,800
Ok, well that rant was a bit overplaying it.

73
00:04:52,800 --> 00:04:56,160
But we did not look into this new function we encountered - syslog.

74
00:04:56,160 --> 00:05:01,310
我想我要说的是，当你解决这些简单的挑战时，你达到了一个点

75
00:05:01,310 --> 00:05:05,070
where you think you know every dangerous function, but that’s not true.

76
00:05:05,070 --> 00:05:08,610
So don’t get lazy, and read the man page.

77
00:05:08,610 --> 00:05:12,770
如果我们查看syslog的手册页，我们将看到第二个参数是一种格式

78
00:05:12,770 --> 00:05:13,770
parameter.

79
00:05:13,770 --> 00:05:19,810
syslog() generates a log message, which will be distributed by syslogd(8).

80
00:05:19,810 --> 00:05:25,810
The priority argument is formed by ORing the facility and the level values (explained below).

81
00:05:25,810 --> 00:05:30,440
其余参数是一种格式，如printf（3）中所示。

82
00:05:30,440 --> 00:05:32,080
Syslog works like printf.

83
00:05:32,080 --> 00:05:35,410
And buf in logit(), is the format parameter.

84
00:05:35,410 --> 00:05:40,290
buf只包含我们输入的用户名和密码，因此我们可以注入

85
00:05:40,289 --> 00:05:41,659
format characters.

86
00:05:41,660 --> 00:05:43,300
Let’s try it.

87
00:05:43,300 --> 00:05:47,430
Let’s login with %x stuff.

88
00:05:47,430 --> 00:05:49,680
Login failed, check the syslog.

89
00:05:49,680 --> 00:05:50,680
And there it is.

90
00:05:50,680 --> 00:05:54,010
In brackets you can see the leaked values from the stack.

91
00:05:54,009 --> 00:05:57,369
Perfect, now we have identified the bug.

92
00:05:57,370 --> 00:06:02,110
从早期的格式字符串利用视频，我们了解到一个好的策略是覆盖

93
00:06:02,110 --> 00:06:08,140
an address in the global offset table with another function, like system to execute commands.

94
00:06:08,139 --> 00:06:12,119
Let’s think about what function would be convenient to overwrite.

95
00:06:12,120 --> 00:06:17,460
I think, the strncmp is a cool function, because we control the first parameter.

96
00:06:17,460 --> 00:06:18,460
The line.

97
00:06:18,460 --> 00:06:21,910
And system uses the first parameter for the string to execute stuff.

98
00:06:21,910 --> 00:06:29,740
因此，如果我们用系统替换strncmp，我们可以简单地键入一行并执行shell

99
00:06:29,740 --> 00:06:30,740
command.

100
00:06:30,740 --> 00:06:33,800
Ok, so let’s construct our exploit.

101
00:06:33,800 --> 00:06:38,160
我们导入可能重要的内容，并像使用一样设置远程套接字连接

102
00:06:38,160 --> 00:06:39,160
to.

103
00:06:39,160 --> 00:06:41,350
And maybe we create a new function called, read_until.

104
00:06:41,349 --> 00:06:44,739
Which is very useful in these kind of remote service challenges.

105
00:06:44,740 --> 00:06:49,810
因此，read until应使用单个字符读取来填充缓冲区，直到缓冲区包含

106
00:06:49,810 --> 00:06:53,050
the magic string specified by read_until.

107
00:06:53,050 --> 00:06:55,990
And then we can simply write, read_until the final1 prompt.

108
00:06:55,990 --> 00:06:58,200
And then we can do our stuff.

109
00:06:58,199 --> 00:07:00,279
So first we specify a username.

110
00:07:00,280 --> 00:07:04,490
读取到下一个提示，然后指定登录密码，然后再次读取直到下一个提示

111
00:07:04,490 --> 00:07:05,930
prompt.

112
00:07:05,930 --> 00:07:10,510
我使用的另一个技巧是函数raw_input（），它实际上是从用户那里读取输入。

113
00:07:10,509 --> 00:07:15,959
in python, but is very convenient to kinda pause the script, until we hit enter.

114
00:07:15,960 --> 00:07:19,650
所以当我们现在执行这个时，我们连接到服务，然后等待直到

115
00:07:19,650 --> 00:07:20,760
enter in the script.

116
00:07:20,760 --> 00:07:25,560
When we now check the running processes for final, we see two.

117
00:07:25,560 --> 00:07:30,630
如果您记得，其中一个是父守护进程，而新的守护进程（具有更高的进程ID）

118
00:07:30,629 --> 00:07:34,409
is the spawned child that is handling our client connection.

119
00:07:34,410 --> 00:07:41,160
So we can attach gdb to that process and start collecting addresses of important symbols.

120
00:07:41,160 --> 00:07:46,010
So first let’s figure out the address of strncmp in the global offset table.

121
00:07:46,009 --> 00:07:50,519
With info functions and a search term we can find the function trampoline in the plt quickly.

122
00:07:50,520 --> 00:07:54,730
我们可以把这些指令拆开，很快就能看到它跳到地址上。

123
00:07:54,729 --> 00:07:56,359
stored here.

124
00:07:56,360 --> 00:08:00,440
这指向全局偏移量表，显然包含实际地址

125
00:08:00,440 --> 00:08:02,310
to strncmp in libc.

126
00:08:02,310 --> 00:08:06,140
So that is our target address we want to overwrite.

127
00:08:06,139 --> 00:08:08,539
Next is the address of system.

128
00:08:08,539 --> 00:08:12,159
System is part of libc and we can quickly get the address of it here.

129
00:08:12,159 --> 00:08:17,849
注意，通常libc是由于aslr而随机化的，但是在这个旧的linux系统上，或者

130
00:08:17,850 --> 00:08:20,240
on embedded devices, it still works this way.

131
00:08:20,240 --> 00:08:24,840
在一个真正的现代系统中，为了

132
00:08:24,840 --> 00:08:27,000
calculate offsets and break ASLR.

133
00:08:27,000 --> 00:08:32,950
Ok, so we have our target and we have the address that we want to write to it.

134
00:08:32,950 --> 00:08:37,640
此外，生成的日志消息将包含源IP和端口，这可能会有所不同

135
00:08:37,640 --> 00:08:38,910
in length.

136
00:08:38,910 --> 00:08:42,840
Coming from localhost will be different than coming from a remote host.

137
00:08:42,840 --> 00:08:47,110
So we should add this into our exploit to be reliable.

138
00:08:47,110 --> 00:08:51,660
The challenge used getpeername to get the ip and port of it’s peer.

139
00:08:51,660 --> 00:08:55,140
So we can use the equivalent to get your own name.

140
00:08:55,140 --> 00:08:57,150
With getsockname().

141
00:08:57,150 --> 00:09:02,110
Now we also know the source ip and port and can write code to adapt accordingly.

142
00:09:02,110 --> 00:09:05,930
Also, I’m sorry, the code is really awful to read this way.

143
00:09:05,930 --> 00:09:09,800
I don’t know why I never bothered to turn on syntax code highltighing.

144
00:09:09,800 --> 00:09:10,800
So here we go.

145
00:09:10,800 --> 00:09:11,800
Better late than never.

146
00:09:11,800 --> 00:09:12,800
Syntax on.

147
00:09:12,800 --> 00:09:14,130
Let’s have a look again at the logged line from earlier.

148
00:09:14,130 --> 00:09:19,590
结尾处的这些字符看起来可疑地像ASCII，当我们转换它们时，我们会看到

149
00:09:19,590 --> 00:09:23,220
that they spell “Login from… and so forth”.

150
00:09:23,220 --> 00:09:27,730
Let’s do this again with some recognizable characters to find the username.

151
00:09:27,730 --> 00:09:30,420
And there it is.

152
00:09:30,420 --> 00:09:35,480
So it took roughly 14 pops of the stack to reach the username with the AAAA.

153
00:09:35,480 --> 00:09:41,060
你可以看到A不完全对齐，它们甚至可能会移动，因为

154
00:09:41,060 --> 00:09:43,410
of the length of the IP and port.

155
00:09:43,410 --> 00:09:48,970
因此，第一步是通过调整

156
00:09:48,970 --> 00:09:51,900
it will be a known aligned offset.

157
00:09:51,900 --> 00:09:54,890
So in this case the hostname was 15 characters long.

158
00:09:54,890 --> 00:09:58,630
And one more A would have filled up and alligned the memory.

159
00:09:58,630 --> 00:10:03,020
So let’s think about what the shortest and longest hostname could be.

160
00:10:03,020 --> 00:10:06,400
Shortest would be 9, longest 21.

161
00:10:06,400 --> 00:10:13,380
Because we prefer multiples of four to be 32bit aligned, we decide to pad to 24 characters.

162
00:10:13,380 --> 00:10:18,600
因此，我们取主机名的长度，从24减去它，然后我们知道有多少个A

163
00:10:18,600 --> 00:10:19,600
we need.

164
00:10:19,600 --> 00:10:22,740
Let’s try this again with some %x in the username.

165
00:10:22,740 --> 00:10:27,040
Oh and we must not forget the newline at the end of our test inputs.

166
00:10:27,040 --> 00:10:29,210
哦，不工作吗？

167
00:10:29,210 --> 00:10:30,920
我们做错了什么？

168
00:10:30,920 --> 00:10:33,740
Ahh… we forgot the username and login command.

169
00:10:33,740 --> 00:10:35,720
仍然不起作用…

170
00:10:35,720 --> 00:10:44,120
哦，行的长度只能是128字节，但是我们用这些%x中的28个发送更多…

171
00:10:44,120 --> 00:10:48,050
See, so many small things that can go wrong and slow you down.

172
00:10:48,050 --> 00:10:49,800
Now we get the login failed.

173
00:10:49,800 --> 00:10:54,000
查看系统日志并搜索BS，我们看到……上帝啊，该死的……我们

174
00:10:54,000 --> 00:10:56,380
forgot to add the padding with the As.

175
00:10:56,380 --> 00:11:02,750
Ok, there we go... the Bs are now perfectly aligned.

176
00:11:02,750 --> 00:11:03,750
Awesome.

177
00:11:03,750 --> 00:11:07,760
Now it doesn’t matter what IP or port you have, it will always be exactly there.

178
00:11:07,760 --> 00:11:13,070
And we can count the words on the stack and get the offset 17.

179
00:11:13,070 --> 00:11:20,630
现在我们可以继续使用一个带有美元符号的%x来表示第17个

180
00:11:20,630 --> 00:11:24,150
parameter, the 17th value on the stack.

181
00:11:24,150 --> 00:11:30,020
例如，我们现在可以放置strncmp的全局偏移表条目的地址

182
00:11:30,020 --> 00:11:35,710
here into the string, and then use %n to write to that address.

183
00:11:35,710 --> 00:11:41,690
所以现在我们只需要知道填充有多大，我们需要写下

184
00:11:41,690 --> 00:11:42,690
want.

185
00:11:42,690 --> 00:11:46,930
If that confuses you, rewatch the old format string stuff.

186
00:11:46,930 --> 00:11:51,020
所以在我们现在运行它之前，添加另一个原始输入，这样脚本就不会退出，然后

187
00:11:51,019 --> 00:11:57,929
我们运行它，用gdb连接它，观察strncmp的got条目，然后看到

188
00:11:57,930 --> 00:12:00,190
the login attempt it got overwritten.

189
00:12:00,190 --> 00:12:05,170
Our goal is the lower part of the system address, which is 0xffb0.

190
00:12:05,170 --> 00:12:09,650
So now we can calculate the correct number of characters we need to print.

191
00:12:09,650 --> 00:12:12,200
And this is basically how the process now works.

192
00:12:12,200 --> 00:12:18,060
我们用%n写信到地址，核对号码，计算丢失了多少或如何

193
00:12:18,060 --> 00:12:22,490
太多了，我们超调，更正我们打印的字符数，重复直到我们

194
00:12:22,490 --> 00:12:25,620
have constructed the full address for system.

195
00:12:25,620 --> 00:12:31,740
这太烦人了，很烦人，需要一些时间，但一旦你得到了它，它

196
00:12:31,740 --> 00:12:34,390
so cool.

197
00:12:34,390 --> 00:12:41,060
So now I got the offsets right and the address is overwritten with the address of system.

198
00:12:41,060 --> 00:12:45,780
现在我们可以将telnetlib技巧和interaction添加到我们的程序中，理论上来说

199
00:12:45,780 --> 00:12:49,810
point all calls to strncm would call system instead.

200
00:12:49,811 --> 00:12:55,111
如果您研究代码并考虑一下，只需在提示符上写一些东西

201
00:12:55,110 --> 00:12:57,640
should result in command execution.

202
00:12:57,640 --> 00:12:58,820
So let’s try it.

203
00:12:58,820 --> 00:13:03,310
We get a prompt, and now we can type commands as if we were in a real shell.

204
00:13:03,310 --> 00:13:09,390
程序读取我们的线路，调用strncmp，实际上它调用系统和

205
00:13:09,390 --> 00:13:11,230
executes our commands.

206
00:13:11,230 --> 00:13:15,020
同样，我们可以将漏洞复制到我们的Windows计算机上，将IP地址更改为

207
00:13:15,020 --> 00:13:17,450
the VM and then get a remote shell.

208
00:13:17,450 --> 00:13:18,350
令人惊叹的！

