1
00:00:06,370 --> 00:00:12,420
在这一集中我们将看一下来自exploit-exercises.com的第一级protostar。

2
00:00:12,420 --> 00:00:16,150
如果您对设置有疑问，请与您联系可以观看上一个视频。

3
00:00:16,150 --> 00:00:21,590
一般来说，我建议你停止视频在这里，先自己动手做。

4
00:00:21,590 --> 00:00:24,090
也许给它一天，看看你能做多少弄清楚。

5
00:00:24,090 --> 00:00:26,540
然后，看看我的解释。

6
00:00:26,540 --> 00:00:29,910
但如果你感到完全迷失，那么就是跟着我。

7
00:00:29,910 --> 00:00:33,370
这里应该给你足够的信息自己解决下一个级别。

8
00:00:33,370 --> 00:00:37,050
让我们先来看看挑战描述。

9
00:00:37,050 --> 00:00:42,400
这个级别引入了内存的概念可以在其分配的区域之外访问，

10
00:00:42,399 --> 00:00:47,359
如何布局堆栈变量，以及在已分配的内存之外修改

11
00:00:47,359 --> 00:00:50,109
可以修改程序执行。

12
00:00:50,109 --> 00:00:53,239
此级别位于/ opt / protostar / bin / stack0

13
00:00:53,239 --> 00:00:54,809
好。

14
00:00:54,809 --> 00:00:58,259
接下来我们将看一下源代码这在下面提供。

15
00:00:58,260 --> 00:01:01,370
让我们从第一个快速概述开始。

16
00:01:01,370 --> 00:01:06,560
这显然是用C语言编写的程序用gets（）读取一些输入，然后检查

17
00:01:06,560 --> 00:01:10,900
修改后的变量并打印出一个成功或失败的消息。

18
00:01:10,900 --> 00:01:16,050
显然，这个级别的目标是使程序打印成功字符串。

19
00:01:16,050 --> 00:01:20,970
注意，这个级别不是关于执行任意的获取root权限的代码。

20
00:01:20,970 --> 00:01:23,060
首先，我们必须了解一些基础知识。

21
00:01:23,060 --> 00:01:26,780
一个真正的完全根漏洞将在稍后出现水平。

22
00:01:26,780 --> 00:01:30,170
所以现在，让我们关注这个更小的目标。

23
00:01:30,170 --> 00:01:32,740
我们也可以执行stack0程序。

24
00:01:32,740 --> 00:01:37,570
我们可以看到它似乎在等待一些输入，然后打印"再试一次？"。

25
00:01:37,570 --> 00:01:39,780
好的，让我们更详细一下代码。

26
00:01:39,780 --> 00:01:42,060
有两个局部变量。

27
00:01:42,060 --> 00:01:47,820
修改的整数和char数组缓冲区，空格为64个字符。

28
00:01:47,820 --> 00:01:51,310
C中的一系列字符基本上只是一个串。

29
00:01:51,310 --> 00:01:52,790
然后修改将设置为0。

30
00:01:52,790 --> 00:01:56,060
而且显然从未改变过。

31
00:01:56,060 --> 00:01:59,820
接下来是带有64个字符的gets函数长焦缓冲区。

32
00:01:59,820 --> 00:02:03,060
我们来看看获取手册页。

33
00:02:03,060 --> 00:02:06,520
所以gets用于从中读取字符串输入。

34
00:02:06,520 --> 00:02:12,170
当我们向下滚动时，我们也可以找到一个Bugs告诉我们，从不使用的部分

35
00:02:12,170 --> 00:02:13,500
得到（）！

36
00:02:13,500 --> 00:02:17,410
这是不可能更明确的该计划中的漏洞。

37
00:02:17,409 --> 00:02:22,679
作为解释，它说，这是不可能的告诉你将读取多少个字符。

38
00:02:22,680 --> 00:02:25,810
它已被用来打破计算机安全。

39
00:02:25,810 --> 00:02:28,970
在获得呼叫之后，比较修改后的内容到0。

40
00:02:28,970 --> 00:02:31,440
如果它不是0，我们就赢了。

41
00:02:31,440 --> 00:02:33,820
但是如何修改变得非零？

42
00:02:33,819 --> 00:02:36,179
它被设置为0并且从未改变过。

43
00:02:36,180 --> 00:02:42,020
顺便说一句。volatile是一种告诉编译器的方法，

44
00:02:42,019 --> 00:02:43,019
它不应该优化使用它

45
00:02:43,019 --> 00:02:47,189
变量。因为乍一看它看起来像修改过

46
00:02:47,189 --> 00:02:50,329
永远是0，因此它可能只是

47
00:02:50,329 --> 00:02:54,369
删除不必要的if-case。但是对于volatile，我们可以强制编译器

48
00:02:54,370 --> 00:02:59,190
保持原样。我想我们对此有很好的理解

49
00:02:59,189 --> 00:03:01,999
程序现在在C.让我们用gdb打开它

50
00:03:01,999 --> 00:03:06,009
并开始调试。首先让我们在main中设置一个断点

51
00:03:06,010 --> 00:03:09,600
打破*主要。然后键入run或short r以启动程序

52
00:03:09,599 --> 00:03:12,319
从最开始。

53
00:03:12,319 --> 00:03:15,889
现在它停在主要的开始。通过拆卸，您可以拆卸电流

54
00:03:15,890 --> 00:03:19,970
功能。但也将反汇编的味道设置为intel，

55
00:03:19,970 --> 00:03:22,750
因为我更喜欢它让我们试着充分了解正在发生的事情

56
00:03:22,750 --> 00:03:28,910
我在逆向工程中忽略了那些部分介绍，但在这里我们需要充分了解

57
00:03:28,910 --> 00:03:30,740
堆栈如何工作。

58
00:03:30,740 --> 00:03:34,680
所以让我们从第一条指令开始吧'推动ebp'。

59
00:03:34,680 --> 00:03:37,050
快速回放到我的CPU介绍视频。

60
00:03:37,049 --> 00:03:41,049
我提到堆栈只是一个内存底部的区域。

61
00:03:41,049 --> 00:03:46,649
当我们用'info'查看映射的内存时proc mappings'，我们可以看到堆栈

62
00:03:46,650 --> 00:03:51,610
从bffeb000到c0000。

63
00:03:51,609 --> 00:03:56,299
而且因为堆栈从底部开始增长，它从最高地址开始。

64
00:03:56,299 --> 00:04:04,649
c0000不再属于它了，所以基本上堆栈从c0000-8开始。

65
00:04:04,650 --> 00:04:06,020
这是bfffff8。

66
00:04:06,019 --> 00:04:10,259
所以推动EBP。EBP是一个用作基础的寄存器

67
00:04:10,260 --> 00:04:13,900
指针。它包含一个指向somwhere的地址

68
00:04:13,900 --> 00:04:14,900
进入堆栈。

69
00:04:14,900 --> 00:04:15,900
esp现在实际上是bffff7bc。

70
00:04:15,900 --> 00:04:19,930
在那个位置是这个b7something值。好的，不管这个地址的含义是什么

71
00:04:19,930 --> 00:04:20,930
是的，它似乎很重要，因为它得到了

72
00:04:20,930 --> 00:04:22,310
推到堆栈上。

73
00:04:22,310 --> 00:04:25,790
这就像保存价值一样。在您找到的main 函数结束时

74
00:04:25,789 --> 00:04:31,759
请假。并且intel指令参考告诉

75
00:04:31,759 --> 00:04:33,459
ebp和pop ebp。

76
00:04:33,460 --> 00:04:38,620
正如您可以看到函数的开始和结束是对称的。

77
00:04:38,620 --> 00:04:42,840
一开始我们将ebp和mov esp推入EBP。

78
00:04:42,840 --> 00:04:45,020
当功能完成后，我们会反过来。

79
00:04:45,020 --> 00:04:48,350
别担心，我会很好地说明这一点一会儿。

80
00:04:48,349 --> 00:04:50,279
还有一件小事。

81
00:04:50,280 --> 00:04:54,960
在这两个指令之后我们掩盖了esp，它基本上只设置了最后4位

82
00:04:54,960 --> 00:04:57,280
到0，保持良好对齐。

83
00:04:57,280 --> 00:04:58,280
没那么重要。

84
00:04:58,280 --> 00:05:00,860
然后我们从中减去hex 60。

85
00:05:00,860 --> 00:05:06,190
所以ESP，堆栈指针现在指向a比ebp低一点的地址。

86
00:05:06,190 --> 00:05:11,640
然后下一条指令移动0内存位置在偏移十六进制5c处

87
00:05:11,639 --> 00:05:12,639
堆栈指针。

88
00:05:12,639 --> 00:05:18,759
这似乎完全符合我们的修改变量设置为0。

89
00:05:18,759 --> 00:05:20,369
起初它需要很多东西。

90
00:05:20,370 --> 00:05:24,400
但是，让我们再次这样做，但这一次动画。

91
00:05:24,400 --> 00:05:26,910
所以在左边你可以看到汇编程序码。

92
00:05:26,910 --> 00:05:31,140
在右边，我将说明堆栈。与3个重要的寄存器，指令

93
00:05:31,140 --> 00:05:37,970
指针EIP，堆栈指针ESP和基指针EBP。

94
00:05:37,970 --> 00:05:41,290
所以首先它通过'呼叫从其他地方开始主要'。

95
00:05:41,289 --> 00:05:46,089
调用将推动理论上的下一条指令指针到堆栈上。

96
00:05:46,090 --> 00:05:47,910
然后跳转到我们的main 函数。

97
00:05:47,910 --> 00:05:52,980
如你所见，当下一个地址指令被推，堆栈指针

98
00:05:52,980 --> 00:05:57,030
得到增加，地址放在那里。

99
00:05:57,030 --> 00:05:59,780
所以现在我们推动EBP。

100
00:05:59,780 --> 00:06:04,450
我将用一些箭头说明这一点value是一个堆栈地址，指向

101
00:06:04,449 --> 00:06:06,669
堆栈上的另一个位置。

102
00:06:06,669 --> 00:06:12,999
现在我们用ESP中的值覆盖EBP。mov ebp，尤其是

103
00:06:13,000 --> 00:06:16,150
然后我们从esp中减去十六进制0x60。

104
00:06:16,150 --> 00:06:18,690
现在看看堆栈。

105
00:06:18,689 --> 00:06:23,719
esp和ebp之间的这个区域称为a堆栈框架。

106
00:06:23,720 --> 00:06:29,360
这是我们现在的一小部分记忆可以用于局部变量和计算

107
00:06:29,360 --> 00:06:31,390
在main 函数内。

108
00:06:31,389 --> 00:06:34,099
您是否注意到EBP指向的位置？

109
00:06:34,099 --> 00:06:36,929
它指向OLD ebp。

110
00:06:36,930 --> 00:06:45,760
所以这个区域基本上就是堆栈框架上一个函数，称为main。

111
00:06:45,759 --> 00:06:49,689
我们知道我们将0移到esp + 0x5c。

112
00:06:49,689 --> 00:06:53,409
我们认为是修改后的变量。

113
00:06:53,409 --> 00:06:54,579
这是真的。

114
00:06:54,580 --> 00:06:58,310
局部变量都有自己的空间这个堆栈框架。

115
00:06:58,310 --> 00:07:02,440
它太大了，因为它必须制造空格至少64个字符和修改后的

116
00:07:02,439 --> 00:07:04,509
整数。

117
00:07:04,509 --> 00:07:07,449
在这个功能结束时，我们现在将执行请假。

118
00:07:07,449 --> 00:07:10,389
这将EBP转变为ESP。

119
00:07:10,389 --> 00:07:13,669
有效地摧毁了之前的堆栈帧。

120
00:07:13,669 --> 00:07:16,719
然后我们弹出EBP，恢复前一个堆栈框架。

121
00:07:16,720 --> 00:07:17,890
这不是很棒吗？

122
00:07:17,890 --> 00:07:20,140
可是等等！

123
00:07:20,140 --> 00:07:23,420
它变凉了。我们现在怎么知道从哪里返回

124
00:07:23,419 --> 00:07:28,999
主要？好吧，如果你还记得，打电话推了一下地址

125
00:07:29,000 --> 00:07:32,540
通话后的指令。所以堆栈的下一个值就是我们所处的位置

126
00:07:32,539 --> 00:07:36,969
想回去。ret指令基本上就是

127
00:07:36,969 --> 00:07:37,969
将此地址弹出到指令中

128
00:07:37,969 --> 00:07:40,469
指针。

129
00:07:40,469 --> 00:07:41,469
从而跳回我们来自的地方。

130
00:07:41,469 --> 00:07:43,669
电脑。

131
00:07:43,670 --> 00:07:45,660
哈！

132
00:07:45,659 --> 00:07:48,419
他们不是在想。

133
00:07:48,419 --> 00:07:54,339
那里有那么多聪明的东西。现在让我们继续使用汇编代码。

134
00:07:54,340 --> 00:07:56,580
在堆栈上的值设置为0之后，我们

135
00:07:56,580 --> 00:08:03,230
准备带有地址的eax寄存器移动，而不是移动内容

136
00:08:03,229 --> 00:08:08,189
寄存器偏移到寄存器中，它将寄存器偏移的地址移入

137
00:08:08,189 --> 00:08:09,599
一个登记册。

138
00:08:09,599 --> 00:08:12,909
然后这个地址被放置在堆栈顶部。

139
00:08:12,909 --> 00:08:15,289
这称为调用约定。

140
00:08:15,289 --> 00:08:20,179
程序和功能必须达成一致在汇编程序中传递函数参数。

141
00:08:20,180 --> 00:08:23,350
在这种情况下，参数被放置堆栈。

142
00:08:23,349 --> 00:08:28,129
并且gets函数有一个参数，它指向一个字符缓冲区。

143
00:08:28,129 --> 00:08:32,599
和字符缓冲区在堆栈上，因此我们

144
00:08:32,599 --> 00:08:34,999
必须传递角色所在的地址

145
00:08:35,000 --> 00:08:40,020
缓冲开始。之后我们读取了之前的值

146
00:08:40,020 --> 00:08:41,040
设置为0，并通过测试我们可以检查它是否

147
00:08:41,039 --> 00:08:45,019
是0还是不。

148
00:08:45,020 --> 00:08:48,570
并分支打印其中一条消息。所以让我们删除断点形式main

149
00:08:48,570 --> 00:08:49,900
用'del'删除并设置断点

150
00:08:49,899 --> 00:08:52,429
得到之前和之后。在我们重新开始之前，我想向您展示一个很酷的

151
00:08:52,430 --> 00:08:58,000
特技。我们将定义一个钩子，它将执行一些

152
00:08:58,000 --> 00:09:01,260
当我们在断点处停止时gdb命令。要做这种类型

153
00:09:01,260 --> 00:09:08,360
定义钩子停止和x / 24wx $ esp。

154
00:09:08,360 --> 00:09:13,000
和x / 2i $ eip结束。

155
00:09:13,000 --> 00:09:19,260
现在将打印寄存器堆栈以及接下来的两条指令

156
00:09:19,260 --> 00:09:20,750
我们遇到了一个断点。

157
00:09:20,750 --> 00:09:21,750
现在重启程序。

158
00:09:21,750 --> 00:09:22,750
繁荣。

159
00:09:22,750 --> 00:09:23,750
第一个断点。现在继续并输入几个资本

160
00:09:23,750 --> 00:09:28,820
如。你看到那些十六进制41。

161
00:09:28,820 --> 00:09:33,050
这些都是正如你输入的那样。

162
00:09:33,050 --> 00:09:37,110
现在让我们看看地址的内容

163
00:09:37,110 --> 00:09:38,240
我们检查它是否为0。

164
00:09:38,240 --> 00:09:42,740
只需检查$ esp + hex 5c。仍为0。

165
00:09:42,740 --> 00:09:46,430
但它告诉我们它在哪里堆。

166
00:09:46,430 --> 00:09:48,110
当我们看到我们的堆栈时，我们看到了

167
00:09:48,110 --> 00:09:49,440
我们的As仍然有点太过分了

168
00:09:49,440 --> 00:09:52,790
远。

169
00:09:52,790 --> 00:09:54,140
所以我们算一下我们需要多少钱。

170
00:09:54,140 --> 00:09:57,880
这里有4个字符。然后4次4，这是16连续。

171
00:09:57,880 --> 00:09:59,460
我们有3个完整的行。

172
00:09:59,460 --> 00:10:00,930
我们可以明显地看到下一整行

173
00:10:00,930 --> 00:10:02,780
写入那些零。

174
00:10:02,780 --> 00:10:06,650
所以再跑一次。是。

175
00:10:06,649 --> 00:10:10,429
看起来很有希

176
00:10:10,430 --> 00:10:14,150
所以向前迈出一步，它就会加载修改后的变量从栈到

177
00:10:14,149 --> 00:10:15,599
EAX。

178
00:10:15,600 --> 00:10:16,600
确实如此。

179
00:10:16,600 --> 00:10:18,690
这些是我们输入的角色。

180
00:10:18,690 --> 00:10:23,960
让我们试试这个没有gdb。

181
00:10:23,959 --> 00:10:29,709
我们可以使用echo和我们之前的字符串和将它传递给stack0程序。

182
00:10:29,710 --> 00:10:32,820
凉！

183
00:10:32,820 --> 00:10:37,490
有效。在结束之前，让我告诉你我们怎么做

184
00:10:37,490 --> 00:10:38,820
感谢，使输入更方便

185
00:10:38,820 --> 00:10:43,450
到python。使用python -c，我们可以指定一个命令

186
00:10:43,450 --> 00:10:48,150
应该执行。然后我们可以使用print和pythons酷弦

187
00:10:48,150 --> 00:10:50,190
允许我们重复此字符的语法

188
00:10:50,190 --> 00:10:53,300
多次。有了这些知识，你应该能够

189
00:10:53,300 --> 00:10:57,630
解决stack1和stack2。这几乎是同一个任务，只是

190
00:10:57,630 --> 00:10:59,090
一些不同的输入方式和不同的方式

191
00:10:59,089 --> 00:11:02,659
脆弱的功能。但如果你投入一些时间，你绝对可以

192
00:11:02,660 --> 00:11:05,660
解决这个问题。

193
00:11:05,660 --> 00:11:08,030
我不会制作关于这些的视频。

194
00:11:08,029 --> 00:11:10,229
下一个视频将是关于stack3的。

195
00:11:10,230 --> 00:11:11,600
事情开始变得多汁的时候。

