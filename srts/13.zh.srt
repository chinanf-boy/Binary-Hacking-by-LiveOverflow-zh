1
00:00:06,370 --> 00:00:12,420
在这一集中，我们会从 exploit-exercises.com 中 protostar 的第一级开始查看。

2
00:00:12,420 --> 00:00:16,150
如果您对安装与设置有疑问，可以观看上一个视频。

3
00:00:16,150 --> 00:00:21,590
一般来说，我建议你在这里停止视频，并自己尝试一下。

4
00:00:21,590 --> 00:00:24,090
也许花一天时间，看看你能弄清多少东西。

5
00:00:24,090 --> 00:00:26,540
在之后，看我视频中的解释。

6
00:00:26,540 --> 00:00:29,910
但，如果你确实完全迷路了，那就跟上我，我带你出去。

7
00:00:29,910 --> 00:00:33,370
这视频应该给你足够的信息，让你独自解决下一等级的问题。

8
00:00:33,370 --> 00:00:37,050
所以，让我们先看看挑战的描述。

9
00:00:37,050 --> 00:00:42,400
这一级别引入了一个概念，就是可以在分配(内存)的区域之外，访问内存，

10
00:00:42,399 --> 00:00:47,359
栈变量的布局方式是怎么样的，以及在分配之外的内存，

11
00:00:47,359 --> 00:00:50,109
能通过 modified 程序执行，进行修改。

12
00:00:50,109 --> 00:00:53,239
这一级位于 "/opt/protostar/bin/stack0"

13
00:00:53,239 --> 00:00:54,809
好啊。

14
00:00:54,809 --> 00:00:58,259
接下来我们将看到，下面提供的源代码。

15
00:00:58,260 --> 00:01:01,370
让我们先从快速概述，开始。

16
00:01:01,370 --> 00:01:06,560
这显然是一个用 C 编写的程序。它用"get()"读取一些输入，

17
00:01:06,560 --> 00:01:10,900
然后检查 modified 变量，并打印成功或失败消息。

18
00:01:10,900 --> 00:01:16,050
所以显然，这个级的目标是，让程序打印成功字符串。

19
00:01:16,050 --> 00:01:20,970
注意，这个级不是执行任意代码，以获得根权限。

20
00:01:20,970 --> 00:01:23,060
首先，我们必须了解一些基本知识。

21
00:01:23,060 --> 00:01:26,780
一个真正的完整的根攻击，将出现在后面的级别问题。

22
00:01:26,780 --> 00:01:30,170
现在，让我们关注这个小目标。

23
00:01:30,170 --> 00:01:32,740
我们也可以执行 stack0 程序。

24
00:01:32,740 --> 00:01:37,570
我们可以看到它似乎在等待一些输入，然后打印“再试一次？“。

25
00:01:37,570 --> 00:01:39,780
好的，让我们更详细地看看代码。

26
00:01:39,780 --> 00:01:42,060
有两个局部变量。

27
00:01:42,060 --> 00:01:47,820
一个整数 modified ，以及一个可容纳 64个字符的字符数组缓冲(buffer)。

28
00:01:47,820 --> 00:01:51,310
C 中的字符数组，基本上只是一个字符串。

29
00:01:51,310 --> 00:01:52,790
然后 modified ，设置为 0。

30
00:01:52,790 --> 00:01:56,060
显然，并没有改变。

31
00:01:56,060 --> 00:01:59,820
接下来是，带有64个字符长字符缓冲的 gets 函数。

32
00:01:59,820 --> 00:02:03,060
让我们看一下“gets”手册页。

33
00:02:03,060 --> 00:02:06,520
所以，这个 gets 是可以从输入中，读取字符串。

34
00:02:06,520 --> 00:02:12,170
当我们向下滚动时，我们还可以找到一个 Bugs 部分，

35
00:02:12,170 --> 00:02:13,500
这部分(情况下)，告诉我们永远不要使用 gets()！

36
00:02:13,500 --> 00:02:17,410
不能再清楚啦，这是该 gets 的漏洞。

37
00:02:17,409 --> 00:02:22,679
这里解释一下，它说，gets 不可能知道会读到多少个字符。

38
00:02:22,680 --> 00:02:25,810
这，能被用来破坏计算机安全。

39
00:02:25,810 --> 00:02:28,970
在 gets 调用之后，会将 modified 与 0 进行比较。

40
00:02:28,970 --> 00:02:31,440
如果不是 0，我们就赢了。

41
00:02:31,440 --> 00:02:33,820
但是，modified 要怎么样，才能永远不为零？

42
00:02:33,819 --> 00:02:36,179
把它设为 0，且从不更改。

43
00:02:36,180 --> 00:02:42,020
顺便说一句，volatile 是会告诉编译器，它不应该优化，这个变量的用法。

44
00:02:42,019 --> 00:02:43,019
变量。

45
00:02:43,019 --> 00:02:47,189
因为乍一看，它看起来 modified 的值总是 0，

46
00:02:47,189 --> 00:02:50,329
因此它可能只是，移除不必要的 if-case。

47
00:02:50,329 --> 00:02:54,369
但是，使用 olatile，我们可以强制编译器保持原样。

48
00:02:54,370 --> 00:02:59,190
我想，我们现在对 这个 C程序，有了很好的理解，让我们用 gdb 打开它吧。

49
00:02:59,189 --> 00:03:01,999
开始调试。

50
00:03:01,999 --> 00:03:06,009
首先，让我们用 break *main ，在 main 中，设置一个断点。

51
00:03:06,010 --> 00:03:09,600
然后键入 run 或 r 简写，从头开始启动程序。

52
00:03:09,599 --> 00:03:12,319
现在它停在 main 的起点。

53
00:03:12,319 --> 00:03:15,889
使用反汇编可以，反汇编当前函数。

54
00:03:15,890 --> 00:03:19,970
但同时，也将反汇编风格设置为 Intel，因为我更喜欢它。

55
00:03:19,970 --> 00:03:22,750
让我们试着了解，这里发生的完整过程。

56
00:03:22,750 --> 00:03:28,910
在逆向工程介绍中，我忽略了这些部分，

57
00:03:28,910 --> 00:03:30,740
但这里我们需要完全理解栈的工作方式。

58
00:03:30,740 --> 00:03:34,680
那么让我们从第一条指令“push ebp”开始。

59
00:03:34,680 --> 00:03:37,050
然后，对我的 CPU 介绍视频，来个快速闪回印象。

60
00:03:37,049 --> 00:03:41,049
我提到栈，只是位于底部的一个内存区。

61
00:03:41,049 --> 00:03:46,649
当我们用'info proc mappings'，查看映射的内存时，

62
00:03:46,650 --> 00:03:51,610
我们可以看到栈，从 bffeb000 到 c0000。

63
00:03:51,609 --> 00:03:56,299
因为栈从底部往上增长，所以，它从最高地址开始(数起)。

64
00:03:56,299 --> 00:04:04,649
c0000不再属于它，所以基本上来说，栈是从 c0000-8 开始。也就是 bffff8。

65
00:04:04,650 --> 00:04:06,020
而，push ebp。

66
00:04:06,019 --> 00:04:10,259
ebp是一个寄存器，用作基本指针。

67
00:04:10,260 --> 00:04:13,900
它包含一个，指向栈中某个位置的地址。

68
00:04:13,900 --> 00:04:14,900
esp现在实际上是 bfff7bc。

69
00:04:14,900 --> 00:04:15,900
在那个位置是这个 b7 某值。

70
00:04:15,900 --> 00:04:19,930
好吧，不管这个地址的意思是什么，它似乎很重要，

71
00:04:19,930 --> 00:04:20,930
因为它推入栈上。

72
00:04:20,930 --> 00:04:22,310
这就像，保存值(变量)一样。

73
00:04:22,310 --> 00:04:25,790
在 main 函数结束时，你会找到一个 leave。

74
00:04:25,789 --> 00:04:31,759
英特尔指令参考告诉我们，leave 基本上只是一个 mov esp，

75
00:04:31,759 --> 00:04:33,459
push ebp 和 pop ebp。

76
00:04:33,460 --> 00:04:38,620
如您所见，函数的开始和结束是对称的。

77
00:04:38,620 --> 00:04:42,840
开始时，我们将 push ebp ，以及移动 mov ESP 进入 ebp。

78
00:04:42,840 --> 00:04:45,020
当函数完成后，我们做相反的操作。

79
00:04:45,020 --> 00:04:48,350
别担心，我一会儿会，好好说明这一点。

80
00:04:48,349 --> 00:04:50,279
还一件小事。

81
00:04:50,280 --> 00:04:54,960
在这两条指令之后，我们 mask esp，它基本上，

82
00:04:54,960 --> 00:04:57,280
只设置最后 4位 为0，使其保持对齐。

83
00:04:57,280 --> 00:04:58,280
没有很重要啦。

84
00:04:58,280 --> 00:05:00,860
然后我们从中，减去(subtract) hex 60。

85
00:05:00,860 --> 00:05:06,190
所以 ESP，栈指针现在指向比 ebp 低一点的地址。

86
00:05:06,190 --> 00:05:11,640
而下一条指令，是移动一个0，到

87
00:05:11,639 --> 00:05:12,639
与栈指针偏移 hex 5c 的内存位置。

88
00:05:12,639 --> 00:05:18,759
这似乎与我们被设置为 0 的 modified 变量完美匹配。

89
00:05:18,759 --> 00:05:20,369
一开始，要接受很多知识，确实不容易。

90
00:05:20,370 --> 00:05:24,400
但，我们可以再来一次，而这次是配上动画。

91
00:05:24,400 --> 00:05:26,910
所以在左边，你可以看到汇编代码。

92
00:05:26,910 --> 00:05:31,140
在右边，我将展示这个栈。使用3个重要寄存器，

93
00:05:31,140 --> 00:05:37,970
指令指针 eip 、栈指针 esp ，和 基指针 ebp。

94
00:05:37,970 --> 00:05:41,290
所以首先，它从另一个地方开始，有一个“call main”。

95
00:05:41,289 --> 00:05:46,089
调用（call）会将理论上的下一个指令指针，推到栈上。

96
00:05:46,090 --> 00:05:47,910
然后，跳到我们的 main 函数。

97
00:05:47,910 --> 00:05:52,980
如您所见，当下一条指令的地址被推入后，

98
00:05:52,980 --> 00:05:57,030
栈指针增加了地址。

99
00:05:57,030 --> 00:05:59,780
所以，现在是 push ebp 登场。

100
00:05:59,780 --> 00:06:04,450
我将用一些箭头，说明这个值是一个栈地址，

101
00:06:04,449 --> 00:06:06,669
它指向栈上的另一个位置。

102
00:06:06,669 --> 00:06:12,999
现在我们用"mov ebp, esp"，让 esp 的值覆盖 ebp。

103
00:06:13,000 --> 00:06:16,150
然后从 esp 中，减去 hex 0x60。

104
00:06:16,150 --> 00:06:18,690
现在，再看看这个栈。

105
00:06:18,689 --> 00:06:23,719
这个介于 esp和ebp 之间的区域，称为栈帧。

106
00:06:23,720 --> 00:06:29,360
现在，这就是一小块内存，我们可以用来，

107
00:06:29,360 --> 00:06:31,390
在 main 函数中进行局部变量和计算。

108
00:06:31,389 --> 00:06:34,099
你注意到 ebp 指向哪里了吗？

109
00:06:34,099 --> 00:06:36,929
它指向，*旧的* ebp。

110
00:06:36,930 --> 00:06:45,760
所以，这里的区域，基本上是前一个函数的栈帧，它叫 main。

111
00:06:45,759 --> 00:06:49,689
我们还知道，我们把 0 移动到 esp + 0x5c。

112
00:06:49,689 --> 00:06:53,409
我们认为，这是 modified 变量。

113
00:06:53,409 --> 00:06:54,579
事实说明，我们是对的。

114
00:06:54,580 --> 00:06:58,310
局部变量在这个栈帧中，都有自己的空间。

115
00:06:58,310 --> 00:07:02,440
但它太大了，因为它必须留出至少64个字符

116
00:07:02,439 --> 00:07:04,509
和一个 modified 整数的空间。

117
00:07:04,509 --> 00:07:07,449
在此函数结束时，我们将执行 leave。

118
00:07:07,449 --> 00:07:10,389
将 ebp 移动到 esp。

119
00:07:10,389 --> 00:07:13,669
有效地销毁以前的栈帧。

120
00:07:13,669 --> 00:07:16,719
然后我们 pop ebp，它将恢复先前的栈帧。

121
00:07:16,720 --> 00:07:17,890
神奇吧？！

122
00:07:17,890 --> 00:07:20,140
但是等等！还有更酷的。

123
00:07:20,140 --> 00:07:23,420
我们现在怎么知道，main 的返回是到哪里？

124
00:07:23,419 --> 00:07:28,999
如果你还记得的话，call 会在自身调用后，推指令的地址进栈。

125
00:07:29,000 --> 00:07:32,540
所以栈中的下一个值，就是我们想要返回的位置。

126
00:07:32,539 --> 00:07:36,969
而 ret 指令基本上，就是把这个地址 pop（弹出），

127
00:07:36,969 --> 00:07:37,969
送入指令指针。

128
00:07:37,969 --> 00:07:40,469
然后跳回我们来的地方。

129
00:07:40,469 --> 00:07:41,469
计算机（Computers）。

130
00:07:41,469 --> 00:07:43,669
哈！它们真是爆裂。

131
00:07:43,670 --> 00:07:45,660
里面，有太多聪明的东西。

132
00:07:45,659 --> 00:07:48,419
现在，让我们继续使用汇编程序代码。

133
00:07:48,419 --> 00:07:54,339
在栈上的一个值，设置为0之后，我们准备好 EAX寄存器，

134
00:07:54,340 --> 00:07:56,580
接收，栈偏移量为 0x1C 的地址。

135
00:07:56,580 --> 00:08:03,230
lea（加载有效地址）类似于移动，但不是

136
00:08:03,229 --> 00:08:08,189
将寄存器偏移量的内容，移入寄存器，而是

137
00:08:08,189 --> 00:08:09,599
将寄存器偏移量的地址移入寄存器。

138
00:08:09,599 --> 00:08:12,909
然后这个地址被放在栈顶。

139
00:08:12,909 --> 00:08:15,289
这叫做 调用约定。

140
00:08:15,289 --> 00:08:20,179
如何在汇编程序传递函数参数，这一命题，程序和函数必须达成一致。

141
00:08:20,180 --> 00:08:23,350
在这种情况下，参数被放置在栈上。

142
00:08:23,349 --> 00:08:28,129
gets函数接受一个参数，该参数指向一个字符缓冲区。

143
00:08:28,129 --> 00:08:32,599
以及字符缓冲区是在栈上的，因此我们必须将，

144
00:08:32,599 --> 00:08:34,999
字符缓冲区所在的开头地址，传递给它。

145
00:08:35,000 --> 00:08:40,020
然后我们读取之前设置为 0 的值，通过测试，

146
00:08:40,020 --> 00:08:41,040
我们可以检查它是否为0。

147
00:08:41,039 --> 00:08:45,019
然后进入分支，打印其中一条消息。

148
00:08:45,020 --> 00:08:48,570
因此，让我们用“del”，删除 main 的断点，

149
00:08:48,570 --> 00:08:49,900
并在 gets 之前和之后，设置一个断点。

150
00:08:49,899 --> 00:08:52,429
在我们重新开始之前，我想给你看一个很酷的技巧。

151
00:08:52,430 --> 00:08:58,000
我们将定义一个钩子，可当我们在一个断点停止时，执行一些 gdb 命令。

152
00:08:58,000 --> 00:09:01,260
输入定义的 hook-stop，来做到这一点。

153
00:09:01,260 --> 00:09:08,360
然后“info registers”显示寄存器和 x/24wx $esp。

154
00:09:08,360 --> 00:09:13,000
和 “x/2i $eip”，结束。

155
00:09:13,000 --> 00:09:19,260
现在每次我们遇到了一个断点，

156
00:09:19,260 --> 00:09:20,750
都会打印 寄存器，栈和下两个指令。

157
00:09:20,750 --> 00:09:21,750
现在重新启动程序。

158
00:09:21,750 --> 00:09:22,750
栋。第一个断点。

159
00:09:22,750 --> 00:09:23,750
现在，继续输入几个大写字母 A。

160
00:09:23,750 --> 00:09:28,820
你看到那些 hex 41s 了吗？这些都是你输入的 A。

161
00:09:28,820 --> 00:09:33,050
现在，让我们看看地址的内容，我们检查它是否为0。

162
00:09:33,050 --> 00:09:37,110
只需检查 $esp + hex 5c。

163
00:09:37,110 --> 00:09:38,240
仍为 0。

164
00:09:38,240 --> 00:09:42,740
但它告诉我们它在栈上的位置。当去看我们的栈时，

165
00:09:42,740 --> 00:09:46,430
我们看到我们的 A 们，还是有点太远了。

166
00:09:46,430 --> 00:09:48,110
让我们来计算一下，我们需要多少。

167
00:09:48,110 --> 00:09:49,440
这里有 4个字符。

168
00:09:49,440 --> 00:09:52,790
然后是，4次 乘以 4，就是16。

169
00:09:52,790 --> 00:09:54,140
我们有三排。

170
00:09:54,140 --> 00:09:57,880
在下一整行中，我们可以明显地，写进这些零。

171
00:09:57,880 --> 00:09:59,460
所以，再次运行。

172
00:09:59,460 --> 00:10:00,930
输入，这么多字符。

173
00:10:00,930 --> 00:10:02,780
我喜欢使用，可识别的模式。

174
00:10:02,780 --> 00:10:06,650
所以我可以清楚地看到，哪一行是哪个字母。

175
00:10:06,649 --> 00:10:10,429
看起来很实在。

176
00:10:10,430 --> 00:10:14,150
所以向前迈出一步，它会将 modified 变量，

177
00:10:14,149 --> 00:10:15,599
从栈加载到 EAX

178
00:10:15,600 --> 00:10:16,600
确实如此。

179
00:10:16,600 --> 00:10:18,690
这些是我们输入的字符。

180
00:10:18,690 --> 00:10:23,960
让我们在没有 gdb 的情况下，试试这个。

181
00:10:23,959 --> 00:10:29,709
我们可以使用 echo 和 前面的字符串，并将其传输到 stack0 程序中。

182
00:10:29,710 --> 00:10:32,820
酷！它奏效了。

183
00:10:32,820 --> 00:10:37,490
在我们结束之前，让我向您展示一下，如何使输入更加方便。

184
00:10:37,490 --> 00:10:38,820
谢谢 Python。

185
00:10:38,820 --> 00:10:43,450
使用 python -c，我们可以指定，应该执行的命令。

186
00:10:43,450 --> 00:10:48,150
然后我们可以使用，print 和 python 的酷字符串语法，

187
00:10:48,150 --> 00:10:50,190
它允许我们多次重复这个字符。

188
00:10:50,190 --> 00:10:53,300
有了这些知识，您应该能够解决 stack1 和 stack2 。

189
00:10:53,300 --> 00:10:57,630
因它几乎是相同的任务，只是有一些不同的输入方式，

190
00:10:57,630 --> 00:10:59,090
和一个不同的脆弱函数。

191
00:10:59,089 --> 00:11:02,659
但是如果你花点时间，你完全可以解决它。

192
00:11:02,660 --> 00:11:05,660
我不会录制一个关于这些的视频。

193
00:11:05,660 --> 00:11:08,030
下一个视频，将是关于 Stack3 的。

194
00:11:08,029 --> 00:11:10,229
这是'水果'，开始变得多汁的时候。

195
00:11:10,230 --> 00:11:11,600
下次见！

