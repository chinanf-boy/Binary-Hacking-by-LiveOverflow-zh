1
00:00:06,370 --> 00:00:12,420
在这一集中，我们将从exploit-exercises.com中查看第一级原恒星。

2
00:00:12,420 --> 00:00:16,150
如果您对设置有疑问，可以观看上一个视频。

3
00:00:16,150 --> 00:00:21,590
一般来说，我建议你在这里停下来，先自己处理。

4
00:00:21,590 --> 00:00:24,090
也许给它一天时间看看你能想出多少。

5
00:00:24,090 --> 00:00:26,540
然后，看我的解释。

6
00:00:26,540 --> 00:00:29,910
但如果你完全迷路了，就跟着我。

7
00:00:29,910 --> 00:00:33,370
这里应该给你足够的信息来独自解决下一个问题。

8
00:00:33,370 --> 00:00:37,050
所以，让我们先看看挑战描述。

9
00:00:37,050 --> 00:00:42,400
这一级别引入了一个概念，即可以在分配的区域之外访问内存，

10
00:00:42,399 --> 00:00:47,359
堆栈变量的布局方式，以及在分配的内存之外进行的修改

11
00:00:47,359 --> 00:00:50,109
可以修改程序执行。

12
00:00:50,109 --> 00:00:53,239
该层位于/opt/protostar/bin/stack0

13
00:00:53,239 --> 00:00:54,809
好啊。

14
00:00:54,809 --> 00:00:58,259
接下来我们将看到下面提供的源代码。

15
00:00:58,260 --> 00:01:01,370
让我们从第一个快速概述开始。

16
00:01:01,370 --> 00:01:06,560
这显然是一个用C编写的程序。它用get（）读取一些输入，然后检查

17
00:01:06,560 --> 00:01:10,900
修改后的变量并打印成功或失败消息。

18
00:01:10,900 --> 00:01:16,050
所以显然，这个级别的目标是让程序打印成功字符串。

19
00:01:16,050 --> 00:01:20,970
注意，这个级别不是执行任意代码以获得根权限。

20
00:01:20,970 --> 00:01:23,060
首先，我们必须了解一些基本知识。

21
00:01:23,060 --> 00:01:26,780
一个真正的完整的根攻击将出现在后面的级别。

22
00:01:26,780 --> 00:01:30,170
现在，让我们关注这个小目标。

23
00:01:30,170 --> 00:01:32,740
我们也可以执行stack0程序。

24
00:01:32,740 --> 00:01:37,570
我们可以看到它似乎在等待一些输入，然后打印“再试一次？“。

25
00:01:37,570 --> 00:01:39,780
好的，让我们更详细地看看代码。

26
00:01:39,780 --> 00:01:42,060
有两个局部变量。

27
00:01:42,060 --> 00:01:47,820
一个已修改的整数，以及一个可容纳64个字符的字符数组缓冲区。

28
00:01:47,820 --> 00:01:51,310
C中的字符数组基本上只是一个字符串。

29
00:01:51,310 --> 00:01:52,790
然后将修改设置为0。

30
00:01:52,790 --> 00:01:56,060
显然从未改变。

31
00:01:56,060 --> 00:01:59,820
接下来是带有64个字符长字符缓冲区的gets函数。

32
00:01:59,820 --> 00:02:03,060
让我们看一下“获取”手册页。

33
00:02:03,060 --> 00:02:06,520
所以gets用于从输入中读取字符串。

34
00:02:06,520 --> 00:02:12,170
当我们向下滚动时，我们还可以找到一个bugs部分，它告诉我们永远不要使用

35
00:02:12,170 --> 00:02:13,500
GET（）！

36
00:02:13,500 --> 00:02:17,410
这不能更清楚地表明这是该程序中的漏洞。

37
00:02:17,409 --> 00:02:22,679
作为一种解释，它说，不可能知道会读多少个字符。

38
00:02:22,680 --> 00:02:25,810
它被用来破坏计算机安全。

39
00:02:25,810 --> 00:02:28,970
在gets调用之后，将modified与0进行比较。

40
00:02:28,970 --> 00:02:31,440
如果不是0，我们就赢了。

41
00:02:31,440 --> 00:02:33,820
但是，如何修改才能成为非零？

42
00:02:33,819 --> 00:02:36,179
它设置为0且从未更改。

43
00:02:36,180 --> 00:02:42,020
顺便说一句，volatile是一种告诉编译器它不应该优化这个函数的用法的方法。

44
00:02:42,019 --> 00:02:43,019
变量。

45
00:02:43,019 --> 00:02:47,189
因为乍一看，它看起来修改后的值总是0，因此它可能只是

46
00:02:47,189 --> 00:02:50,329
移除不必要的if case。

47
00:02:50,329 --> 00:02:54,369
但是使用volatile，我们可以强制编译器保持原样。

48
00:02:54,370 --> 00:02:59,190
我想我们现在对C语言中的这个程序有了很好的理解，让我们用gdb打开它吧。

49
00:02:59,189 --> 00:03:01,999
开始调试。

50
00:03:01,999 --> 00:03:06,009
首先，让我们用break*main在main中设置一个断点。

51
00:03:06,010 --> 00:03:09,600
然后键入run或short r从头开始启动程序。

52
00:03:09,599 --> 00:03:12,319
现在它停在主管道的起点。

53
00:03:12,319 --> 00:03:15,889
使用反汇编可以反汇编当前函数。

54
00:03:15,890 --> 00:03:19,970
但同时也将反汇编风格设置为Intel，因为我更喜欢它。

55
00:03:19,970 --> 00:03:22,750
让我们试着充分了解这里发生了什么。

56
00:03:22,750 --> 00:03:28,910
我在我的逆向工程介绍中忽略了这些部分，但这里我们需要完全理解

57
00:03:28,910 --> 00:03:30,740
堆栈的工作方式。

58
00:03:30,740 --> 00:03:34,680
那么让我们从第一条指令“push ebp”开始。

59
00:03:34,680 --> 00:03:37,050
我的CPU介绍视频的快速闪回。

60
00:03:37,049 --> 00:03:41,049
我提到堆栈只是底部的一个内存区。

61
00:03:41,049 --> 00:03:46,649
当我们用'info proc mappings'查看映射的内存时，我们可以看到堆栈

62
00:03:46,650 --> 00:03:51,610
从BFFEB000到C0000。

63
00:03:51,609 --> 00:03:56,299
因为堆栈从底部增长，所以它从最高地址开始。

64
00:03:56,299 --> 00:04:04,649
c0000不再属于它，所以基本上堆栈从c0000-8开始。是bffff8。

65
00:04:04,650 --> 00:04:06,020
所以推EBP。

66
00:04:06,019 --> 00:04:10,259
EBP是一个寄存器，用作基指针。

67
00:04:10,260 --> 00:04:13,900
它包含一个指向堆栈中某个位置的地址。

68
00:04:13,900 --> 00:04:14,900
esp现在实际上是bfff7bc。

69
00:04:14,900 --> 00:04:15,900
在那个位置，这个b7something值。

70
00:04:15,900 --> 00:04:19,930
好吧，不管这个地址的意思是什么，它似乎很重要，因为它

71
00:04:19,930 --> 00:04:20,930
推到堆栈上。

72
00:04:20,930 --> 00:04:22,310
这就像保存值一样。

73
00:04:22,310 --> 00:04:25,790
在主功能结束时，你会找到一个休假。

74
00:04:25,789 --> 00:04:31,759
英特尔指令参考告诉我们，leave基本上只是一个mov esp，

75
00:04:31,759 --> 00:04:33,459
EBP和POP EBP。

76
00:04:33,460 --> 00:04:38,620
如您所见，函数的开始和结束是对称的。

77
00:04:38,620 --> 00:04:42,840
开始时，我们将EBP和MOV ESP推入EBP。

78
00:04:42,840 --> 00:04:45,020
当函数完成后，我们做相反的操作。

79
00:04:45,020 --> 00:04:48,350
别担心，我一会儿会很好地说明这一点。

80
00:04:48,349 --> 00:04:50,279
再多一件小事。

81
00:04:50,280 --> 00:04:54,960
在这两条指令之后，我们屏蔽esp，它基本上只设置最后4位

82
00:04:54,960 --> 00:04:57,280
为0，保持对齐。

83
00:04:57,280 --> 00:04:58,280
没那么重要。

84
00:04:58,280 --> 00:05:00,860
然后我们从中减去十六进制60。

85
00:05:00,860 --> 00:05:06,190
所以，堆栈指针现在指向比EBP低一点的地址。

86
00:05:06,190 --> 00:05:11,640
下一条指令将内存位置的0从

87
00:05:11,639 --> 00:05:12,639
堆栈指针。

88
00:05:12,639 --> 00:05:18,759
这似乎与我们的修改变量完美匹配，它被设置为0。

89
00:05:18,759 --> 00:05:20,369
一开始要接受很多。

90
00:05:20,370 --> 00:05:24,400
但是让我们再来一次，这次是动画。

91
00:05:24,400 --> 00:05:26,910
所以在左边你可以看到汇编代码。

92
00:05:26,910 --> 00:05:31,140
在右边，我将展示这个堆栈。使用3个重要寄存器，指令

93
00:05:31,140 --> 00:05:37,970
指针eip、堆栈指针esp和基指针ebp。

94
00:05:37,970 --> 00:05:41,290
所以首先，它从另一个地方开始，有一个“主叫”。

95
00:05:41,289 --> 00:05:46,089
调用会将理论上的下一个指令指针推送到堆栈上。

96
00:05:46,090 --> 00:05:47,910
然后跳到我们的主要功能。

97
00:05:47,910 --> 00:05:52,980
如您所见，当按下下一条指令的地址时，堆栈指针

98
00:05:52,980 --> 00:05:57,030
增加了地址。

99
00:05:57,030 --> 00:05:59,780
所以现在是我们的推手潮。

100
00:05:59,780 --> 00:06:04,450
我将用一些箭头说明这个值是一个堆栈地址，它指向

101
00:06:04,449 --> 00:06:06,669
堆栈上的另一个位置。

102
00:06:06,669 --> 00:06:12,999
现在我们用esp.mov ebp，esp的值覆盖ebp。

103
00:06:13,000 --> 00:06:16,150
然后从esp中减去hex 0x60。

104
00:06:16,150 --> 00:06:18,690
现在看看这个堆栈。

105
00:06:18,689 --> 00:06:23,719
这个介于esp和ebp之间的区域称为堆栈帧。

106
00:06:23,720 --> 00:06:29,360
现在这是一小块内存，我们可以用来进行局部变量和计算。

107
00:06:29,360 --> 00:06:31,390
在主功能中。

108
00:06:31,389 --> 00:06:34,099
你注意到EBP指向哪里了吗？

109
00:06:34,099 --> 00:06:36,929
它指向旧的经济衰退。

110
00:06:36,930 --> 00:06:45,760
所以这里的区域基本上是前一个函数的堆栈框架，它称为main。

111
00:06:45,759 --> 00:06:49,689
我们知道我们把0移动到esp+0x5c。

112
00:06:49,689 --> 00:06:53,409
我们认为这是修正变量。

113
00:06:53,409 --> 00:06:54,579
这是真的。

114
00:06:54,580 --> 00:06:58,310
局部变量在这个堆栈帧中都有自己的空间。

115
00:06:58,310 --> 00:07:02,440
它太大了，因为它必须留出至少64个字符的空间

116
00:07:02,439 --> 00:07:04,509
整数。

117
00:07:04,509 --> 00:07:07,449
在此函数结束时，我们将执行休假。

118
00:07:07,449 --> 00:07:10,389
将EBP移动到esp。

119
00:07:10,389 --> 00:07:13,669
有效地销毁以前的堆栈帧。

120
00:07:13,669 --> 00:07:16,719
然后我们弹出EBP，它将恢复先前的堆栈帧。

121
00:07:16,720 --> 00:07:17,890
这不是很神奇吗？

122
00:07:17,890 --> 00:07:20,140
但是等等！天气变凉了。

123
00:07:20,140 --> 00:07:23,420
我们现在怎么知道从梅因返回哪里？

124
00:07:23,419 --> 00:07:28,999
如果你还记得的话，call会在调用后按指令的地址。

125
00:07:29,000 --> 00:07:32,540
所以栈中的下一个值就是我们想要返回的位置。

126
00:07:32,539 --> 00:07:36,969
ret指令基本上就是把这个地址输入指令

127
00:07:36,969 --> 00:07:37,969
指针。

128
00:07:37,969 --> 00:07:40,469
然后从我们来的地方跳回来。

129
00:07:40,469 --> 00:07:41,469
计算机。

130
00:07:41,469 --> 00:07:43,669
哈！他们不是疯了吗？

131
00:07:43,670 --> 00:07:45,660
里面有那么多聪明的东西。

132
00:07:45,659 --> 00:07:48,419
现在让我们继续使用汇编程序代码。

133
00:07:48,419 --> 00:07:54,339
在堆栈上的一个值设置为0之后，我们用来自的地址准备EAX寄存器。

134
00:07:54,340 --> 00:07:56,580
偏移量为0x1C时的叠加。

135
00:07:56,580 --> 00:08:03,230
lea（加载有效地址）类似于移动，但不是移动内容

136
00:08:03,229 --> 00:08:08,189
将寄存器偏移量移入寄存器，它将寄存器偏移量的地址移入

137
00:08:08,189 --> 00:08:09,599
语域

138
00:08:09,599 --> 00:08:12,909
然后这个地址被放在栈顶。

139
00:08:12,909 --> 00:08:15,289
这叫做呼叫约定。

140
00:08:15,289 --> 00:08:20,179
程序和函数必须同意如何在汇编程序中传递函数参数。

141
00:08:20,180 --> 00:08:23,350
在这种情况下，参数被放置在堆栈上。

142
00:08:23,349 --> 00:08:28,129
gets函数接受一个参数，该参数指向一个字符缓冲区。以及

143
00:08:28,129 --> 00:08:32,599
字符缓冲区在堆栈上，因此我们必须将字符所在的地址传递给它

144
00:08:32,599 --> 00:08:34,999
缓冲器启动。

145
00:08:35,000 --> 00:08:40,020
然后我们读取之前设置为0的值，通过测试，我们可以检查它是否

146
00:08:40,020 --> 00:08:41,040
是0还是不。

147
00:08:41,039 --> 00:08:45,019
然后分支打印其中一条消息。

148
00:08:45,020 --> 00:08:48,570
因此，让我们用“del”delete删除主断点，并设置一个断点。

149
00:08:48,570 --> 00:08:49,900
得到之前和之后。

150
00:08:49,899 --> 00:08:52,429
在我们重新开始之前，我想给你看一个很酷的技巧。

151
00:08:52,430 --> 00:08:58,000
我们将定义一个钩子，当我们在一个断点停止时，它将执行一些gdb命令。

152
00:08:58,000 --> 00:09:01,260
要执行此类型，请定义挂钩停止

153
00:09:01,260 --> 00:09:08,360
然后信息寄存器显示寄存器和x/24wx$esp。

154
00:09:08,360 --> 00:09:13,000
和x/2i$eip，结束。

155
00:09:13,000 --> 00:09:19,260
现在每次当

156
00:09:19,260 --> 00:09:20,750
我们遇到了一个断点。

157
00:09:20,750 --> 00:09:21,750
现在重新启动程序。

158
00:09:21,750 --> 00:09:22,750
繁荣。第一个断点。

159
00:09:22,750 --> 00:09:23,750
现在继续输入几个大写字母A。

160
00:09:23,750 --> 00:09:28,820
你看到那些十六进制41s了吗？这些都是你输入的。

161
00:09:28,820 --> 00:09:33,050
现在让我们看看地址的内容，我们检查它是否为0。

162
00:09:33,050 --> 00:09:37,110
只需检查$esp+hex 5c。

163
00:09:37,110 --> 00:09:38,240
还有0。

164
00:09:38,240 --> 00:09:42,740
但它告诉我们它在堆栈上的位置。当我们看我们的堆栈时，我们看到

165
00:09:42,740 --> 00:09:46,430
我们的AS还是有点太远了。

166
00:09:46,430 --> 00:09:48,110
让我们来计算一下我们需要多少。

167
00:09:48,110 --> 00:09:49,440
这里有4个字符。

168
00:09:49,440 --> 00:09:52,790
然后是4乘以4，这就是16。

169
00:09:52,790 --> 00:09:54,140
我们有三排。

170
00:09:54,140 --> 00:09:57,880
在下一整行中，我们可以明显地写进这些零。

171
00:09:57,880 --> 00:09:59,460
所以再次运行。

172
00:09:59,460 --> 00:10:00,930
输入这么多字符。

173
00:10:00,930 --> 00:10:02,780
我喜欢使用可识别的模式。

174
00:10:02,780 --> 00:10:06,650
所以我可以清楚地看到哪一行是哪个字母。

175
00:10:06,649 --> 00:10:10,429
看起来很有前途。

176
00:10:10,430 --> 00:10:14,150
所以向前迈出一步，它会将修改后的变量从堆栈加载到

177
00:10:14,149 --> 00:10:15,599
EAX

178
00:10:15,600 --> 00:10:16,600
确实如此。

179
00:10:16,600 --> 00:10:18,690
这些是我们输入的字符。

180
00:10:18,690 --> 00:10:23,960
让我们在没有gdb的情况下试试这个。

181
00:10:23,959 --> 00:10:29,709
我们可以使用echo和前面的字符串，并将其传输到stack0程序中。

182
00:10:29,710 --> 00:10:32,820
酷！它奏效了。

183
00:10:32,820 --> 00:10:37,490
在我们结束之前，让我向您展示一下如何使输入更加方便。谢谢。

184
00:10:37,490 --> 00:10:38,820
到Python。

185
00:10:38,820 --> 00:10:43,450
使用python-c，我们可以指定应该执行的命令。

186
00:10:43,450 --> 00:10:48,150
然后我们可以使用print和pythons cool字符串语法，它允许我们重复这个字符

187
00:10:48,150 --> 00:10:50,190
多次。

188
00:10:50,190 --> 00:10:53,300
有了这些知识，您应该能够解决stack1和stack2。

189
00:10:53,300 --> 00:10:57,630
它几乎是相同的任务，只是有一些不同的输入方式和不同的

190
00:10:57,630 --> 00:10:59,090
脆弱的功能。

191
00:10:59,089 --> 00:11:02,659
但是如果你花点时间，你完全可以解决它。

192
00:11:02,660 --> 00:11:05,660
我不会拍一个关于这些的视频。

193
00:11:05,660 --> 00:11:08,030
下一个视频将是关于Stack3的。

194
00:11:08,029 --> 00:11:10,229
这是事情开始变得多汁的时候。

195
00:11:10,230 --> 00:11:11,600
下次见！

