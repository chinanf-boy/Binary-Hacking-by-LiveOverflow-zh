1
00:00:00,110 --> 00:00:03,990
让我们进入开发练习的最后一个阶段。

2
00:00:03,989 --> 00:00:10,279
这些级别稍微有点发达，而且是在非常简单的可编程级别上。

3
00:00:10,280 --> 00:00:14,140
CTF的挑战。

4
00:00:14,139 --> 00:00:18,099
让我们来看看最后的0级。

5
00:00:18,100 --> 00:00:22,190
网络设置基本上与以前的挑战相同，因此如果您是

6
00:00:22,189 --> 00:00:26,369
不熟悉这些自定义功能，您应该在

7
00:00:26,370 --> 00:00:27,900
弄清楚他们在做什么。

8
00:00:27,900 --> 00:00:33,340
因此，当客户端连接到运行在端口2995上的服务时，它将调用此函数

9
00:00:33,340 --> 00:00:35,290
GETUsUrNeNeX。

10
00:00:35,290 --> 00:00:41,190
此函数有一个本地512字节的大缓冲区，该缓冲区被0覆盖。

11
00:00:41,190 --> 00:00:45,190
然后使用gets将数据从用户读取到缓冲区中。

12
00:00:45,190 --> 00:00:50,330
正如我们之前所了解的，get是一个危险的功能。

13
00:00:50,329 --> 00:00:53,319
这显然是我们的缓冲区溢出。

14
00:00:53,320 --> 00:00:57,970
然后它检查是否有换行符或回车符，如果有，它将用覆盖换行符或回车符

15
00:00:57,970 --> 00:00:59,690
A 0。

16
00:00:59,690 --> 00:01:06,180
之后是一个循环，它将遍历缓冲区并对每个字符调用toupper。

17
00:01:06,180 --> 00:01:08,110
然后函数返回。

18
00:01:08,110 --> 00:01:13,400
这意味着我们应该能够覆盖这个函数的返回指针并重定向

19
00:01:13,400 --> 00:01:15,340
代码执行。

20
00:01:15,340 --> 00:01:20,680
我们只有一个问题，那就是我们将用于溢出的数据将被转换

21
00:01:20,680 --> 00:01:22,360
大写字母。

22
00:01:22,360 --> 00:01:26,770
这意味着我们的外壳代码，以及我们用来覆盖指令指针的地址。

23
00:01:26,770 --> 00:01:31,070
当使用TOUPPER时，堆栈上的不可更改。

24
00:01:31,070 --> 00:01:34,420
也就是说，不能使用小写的ASCII字符。

25
00:01:34,420 --> 00:01:39,130
或者有没有一个技巧可以让我们绕过这个限制？

26
00:01:39,130 --> 00:01:42,740
让我们考虑一下这个问题，然后向后努力。

27
00:01:42,740 --> 00:01:49,730
所以，为了不在我们的输入中使用toupper，必须满足什么条件。

28
00:01:49,729 --> 00:01:56,129
for循环使用strlen来确定它将执行此操作的字节数。

29
00:01:56,130 --> 00:01:59,200
strlen计算所有字节，直到in找到一个空字节。

30
00:01:59,200 --> 00:02:05,340
所以如果我们设法在实际溢出和shellcode之前得到一个空字节，

31
00:02:05,340 --> 00:02:07,480
我们会没事的。

32
00:02:07,479 --> 00:02:11,059
好吧，我们怎么能得到一个空字节呢？

33
00:02:11,060 --> 00:02:16,350
如果你查看Gets的手册页，你会看到，它会读取所有内容，直到

34
00:02:16,349 --> 00:02:18,079
换行或EOF。

35
00:02:18,080 --> 00:02:21,690
这意味着gets将不会有读取空字节的问题。

36
00:02:21,690 --> 00:02:22,690
容易的。

37
00:02:22,690 --> 00:02:25,490
所以我们可以完全忽略to大写的内容。

38
00:02:25,490 --> 00:02:30,200
出于创造性的原因，您还可以滥用

39
00:02:30,200 --> 00:02:31,200
回车。

40
00:02:31,200 --> 00:02:36,650
假设输入将使用strcpy，因此也将以空字节停止，您可以使用

41
00:02:36,650 --> 00:02:41,740
一个回车，然后被一个空字节替换。

42
00:02:41,740 --> 00:02:44,150
所以这也是可行的。

43
00:02:44,150 --> 00:02:49,260
缓冲区是512字节大，所以让我们使用knwoledge创建一个简单的

44
00:02:49,260 --> 00:02:51,210
概念缓冲区溢出。

45
00:02:51,209 --> 00:02:56,899
我们可以使用python和-c直接在参数中编写一个简短的脚本。

46
00:02:56,900 --> 00:03:02,810
所以我们可以打印510个小写字母A，然后我们可以看到它们被修改了。

47
00:03:02,810 --> 00:03:04,710
大写。

48
00:03:04,709 --> 00:03:10,149
然后我们附加一个空字节，继续使用一个典型的字母表，这样我们就可以识别

49
00:03:10,150 --> 00:03:12,150
溢出指令指针。

50
00:03:12,150 --> 00:03:17,780
我们也可以把字母表改成小写，以证明它不会被转换成大写。

51
00:03:17,780 --> 00:03:20,320
在空字节之后。

52
00:03:20,320 --> 00:03:25,090
和以前的网络挑战一样，我们可以连接到端口2995上的服务

53
00:03:25,090 --> 00:03:26,380
使用NETCAT。

54
00:03:26,379 --> 00:03:31,909
所以我们也可以简单地将python一行程序的输出通过管道传输到netcat。

55
00:03:31,909 --> 00:03:36,259
我们没有像以前那样看到输出“没有这样的用户…”。

56
00:03:36,260 --> 00:03:42,760
代码告诉我们，它将在主返回之后被打印，因此我们可以假设

57
00:03:42,760 --> 00:03:47,770
我们成功地重写了指令指针并使程序崩溃。

58
00:03:47,769 --> 00:03:50,399
但是我们现在如何调试它呢？

59
00:03:50,400 --> 00:03:54,920
如果你看一下原恒星虚拟机的描述，你会在这里看到一个标题。

60
00:03:54,920 --> 00:03:56,980
称为核心文件。

61
00:03:56,980 --> 00:04:00,910
文件名模式设置为/tmp/something。

62
00:04:00,909 --> 00:04:04,139
这意味着核心转储存储在TMP中。

63
00:04:04,140 --> 00:04:10,030
当我们查看/tmp/的内容时，我们将看到一个刚刚生成的核心文件。

64
00:04:10,030 --> 00:04:14,080
它们属于根目录，所以让我们切换到根目录，这样我们就可以使用它们了。

65
00:04:14,080 --> 00:04:15,700
但是什么是核心文件？

66
00:04:15,700 --> 00:04:19,620
让我们用“man core”来询问Linux手册。

67
00:04:19,620 --> 00:04:25,020
某些信号的默认动作是使进程终止并产生

68
00:04:25,020 --> 00:04:30,990
核心转储文件，包含进程内存图像的磁盘文件。

69
00:04:30,990 --> 00:04:32,000
终止的。

70
00:04:31,999 --> 00:04:37,559
这听起来不错，如果我们得到了它崩溃时的记忆状态，我们应该能够

71
00:04:37,559 --> 00:04:41,599
获取大量关于缓冲区溢出的信息。

72
00:04:41,599 --> 00:04:47,009
此图像可在调试器（例如，gdb（1））中用于检查程序的状态。

73
00:04:47,009 --> 00:04:48,949
在它终止的时候。

74
00:04:48,949 --> 00:04:54,209
哦，哇，我们可以用gdb来看看这些，我们已经非常熟悉如何

75
00:04:54,210 --> 00:04:56,080
使用GDB。

76
00:04:56,080 --> 00:05:02,270
在信号（7）中可以找到导致进程转储核心的信号列表。

77
00:05:02,270 --> 00:05:04,010
好的，很有趣。

78
00:05:04,009 --> 00:05:09,999
显然，进程收到了一个信号，因为它确实产生了一个核心文件，对吗？

79
00:05:10,000 --> 00:05:13,530
为了正确理解这一点，让我们也试着理解什么是信号。

80
00:05:13,529 --> 00:05:17,779
注意信号后括号中的7，这对于参考正确的页面很重要。

81
00:05:17,779 --> 00:05:19,489
关于手册中的信号。

82
00:05:19,490 --> 00:05:21,500
所以“曼7信号”。

83
00:05:21,500 --> 00:05:25,480
让我们再往下看一下标准信号。

84
00:05:25,479 --> 00:05:29,009
Linux支持下面列出的标准信号。

85
00:05:29,009 --> 00:05:34,599
如“值”一栏所示，几个信号号取决于体系结构。

86
00:05:34,599 --> 00:05:38,539
mhh，所以信号在不同的架构上是不同的。

87
00:05:38,539 --> 00:05:43,779
因此，如果它是一个Intel、ARM或SPARC处理器，这可能会有所不同，bug通常

88
00:05:43,779 --> 00:05:49,649
这告诉我们，信号可能与非常低级别的CPU和硬件有关。

89
00:05:49,649 --> 00:05:50,649
特征。

90
00:05:50,649 --> 00:05:53,219
让我们看看信号列表。

91
00:05:53,219 --> 00:05:58,939
例如，sigint是一个多次使用的信号，它是来自

92
00:05:58,940 --> 00:06:02,720
键盘，当你按下Control+C时会发生这种情况。

93
00:06:02,719 --> 00:06:07,709
或者记住，当你跳入无效的代码时，你有时是如何得到非法指令的，

94
00:06:07,710 --> 00:06:10,440
一个信号，这也是一个信号。

95
00:06:10,439 --> 00:06:14,939
很明显，这一定是由CPU触发的，它无法理解

96
00:06:14,939 --> 00:06:15,939
指令。

97
00:06:15,939 --> 00:06:19,679
或者我们最喜欢的系统调用，sigsegv，一个segfault。

98
00:06:19,679 --> 00:06:24,219
从illigel内存引用触发，例如当您跳转到不存在的

99
00:06:24,219 --> 00:06:25,219
记忆。

100
00:06:25,219 --> 00:06:27,719
或者尝试写入不存在的内存。

101
00:06:27,720 --> 00:06:33,990
很明显，当你试图执行坏的东西时，这也是由低级硬件触发的。

102
00:06:33,990 --> 00:06:39,560
这里的这一行也很有趣：信号sigkill和sigstop不能被捕获、阻止，

103
00:06:39,559 --> 00:06:40,779
或者忽略。

104
00:06:40,779 --> 00:06:44,839
这意味着这些信号中的大部分都可以被过程捕获。

105
00:06:44,839 --> 00:06:51,329
在GDB中运行一个进程时，您实际上也经历过这种情况，但是您忘记了

106
00:06:51,330 --> 00:06:56,260
若要设置断点且进程正在运行，可以使用ctrl+c返回

107
00:06:56,259 --> 00:06:57,259
进入GDB。

108
00:06:57,259 --> 00:07:02,309
您向进程发送了一个sigint，该进程将信号处理程序设置为

109
00:07:02,309 --> 00:07:05,219
抓住它并执行不同的操作。

110
00:07:05,220 --> 00:07:09,780
所以信号有点像内核对进程的中断。

111
00:07:09,779 --> 00:07:15,349
某些事件（如内存访问失败、按ctrl+c或同时终止进程）会导致

112
00:07:15,349 --> 00:07:18,469
向进程发送信号的内核。

113
00:07:18,469 --> 00:07:23,589
未处理的信号通常会导致进程死亡，但进程也可以设置信号

114
00:07:23,589 --> 00:07:28,059
处理程序在接收到这些信号时执行某些操作。

115
00:07:28,059 --> 00:07:29,059
所以。

116
00:07:29,059 --> 00:07:35,099
在我们的例子中，当我们在堆栈上溢出EIP时，函数返回一个分段错误

117
00:07:35,099 --> 00:07:38,019
发出并触发信号。

118
00:07:38,020 --> 00:07:41,050
进程不处理它，它被内核杀死。

119
00:07:41,050 --> 00:07:46,430
同时创建一个核心转储文件来保存导致

120
00:07:46,429 --> 00:07:47,649
这个信号。

121
00:07:47,649 --> 00:07:50,599
现在让我们用gdb来看看发生了什么。

122
00:07:50,599 --> 00:07:57,469
像前面一样，只需将二进制文件指定为第一个参数，然后添加核心文件

123
00:07:57,469 --> 00:07:58,539
文件作为第二个参数。

124
00:07:58,539 --> 00:08:04,439
当gdb打开时，会立即看到进程由于

125
00:08:04,439 --> 00:08:07,499
信号11，分段故障。

126
00:08:07,499 --> 00:08:11,449
我们还可以查看寄存器并查看EIP的值。

127
00:08:11,449 --> 00:08:14,199
这些绝对是我们已经输入的角色。

128
00:08:14,199 --> 00:08:17,849
我们还可以通过检查堆栈指针来探索堆栈。

129
00:08:17,849 --> 00:08:22,779
您可以看到拥有这些核心文件非常有用。

130
00:08:22,780 --> 00:08:27,720
现在我们知道哪些字符导致了溢出，现在我们可以计算到

131
00:08:27,719 --> 00:08:30,249
堆栈上的指令指针。

132
00:08:30,249 --> 00:08:35,729
另一种进一步调试的方法是使用gdb附加到已经运行的进程。

133
00:08:35,729 --> 00:08:37,749
确保你是根。

134
00:08:37,750 --> 00:08:42,430
只需找到进程ID并使用-p和p id调用gdb。

135
00:08:42,430 --> 00:08:48,080
如您所见，进程当前处于接受状态，等待客户机连接。

136
00:08:48,079 --> 00:08:51,169
但当我们发送POC溢出时，我们看不到segfault。

137
00:08:51,170 --> 00:08:55,500
这是因为如果您还记得，这个过程会创建一个分叉，一个新的过程，来处理

138
00:08:55,500 --> 00:08:56,500
客户端。

139
00:08:56,500 --> 00:08:58,330
我们总是呆在父母身边。

140
00:08:58,329 --> 00:09:03,559
但是我们可以在gdb中将follow fork模式设置为child，当我们现在继续并发送

141
00:09:03,560 --> 00:09:05,970
长的输入，我们得到了segfault。

142
00:09:05,970 --> 00:09:10,400
太棒了，现在你已经准备好了开发全部资源的一切。

