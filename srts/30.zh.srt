1
00:00:00,110 --> 00:00:03,990
让我们进入 exploit-exercises protostar 练习的最后一个阶段。

2
00:00:03,989 --> 00:00:10,279
这些级别挑战，稍微有点提升了，且是在非常简单的，

3
00:00:10,280 --> 00:00:14,140
可编程的CTF挑战。

4
00:00:14,139 --> 00:00:18,099
让我们来看看，final level 0。

5
00:00:18,100 --> 00:00:22,190
网络设置，基本上与以前的挑战相同，

6
00:00:22,189 --> 00:00:26,369
因此，如果您是不熟悉这些自定义函数，

7
00:00:26,370 --> 00:00:27,900
您应该在上集中，弄清楚他们在做什么。

8
00:00:27,900 --> 00:00:33,340
因此，当客户端连接到，运行在端口2995上的服务时，

9
00:00:33,340 --> 00:00:35,290
它将调用此函数 get_username。

10
00:00:35,290 --> 00:00:41,190
此函数有一个512字节的本地大缓冲区，该缓冲区被 0 覆盖。

11
00:00:41,190 --> 00:00:45,190
然后，用 gets 将数据从用户，读取到缓冲区中。

12
00:00:45,190 --> 00:00:50,330
正如我们之前视频中，所了解的，get是一个危险的函数。

13
00:00:50,329 --> 00:00:53,319
显然，这是我们的缓冲区溢出。

14
00:00:53,320 --> 00:00:57,970
然后，它检查是否有换行符或回车符，

15
00:00:57,970 --> 00:00:59,690
如果有，就用一个 0 覆盖。

16
00:00:59,690 --> 00:01:06,180
之后是一个循环，它将遍历缓冲区，并对每个字符调用 toupper。

17
00:01:06,180 --> 00:01:08,110
之后，函数返回。

18
00:01:08,110 --> 00:01:13,400
这意味着，我们应该能够覆盖这个函数的返回指针，

19
00:01:13,400 --> 00:01:15,340
并重定向代码执行。

20
00:01:15,340 --> 00:01:20,680
我们只有一个问题，那就是我们将用于溢出的数据，

21
00:01:20,680 --> 00:01:22,360
将被转换大写字母。

22
00:01:22,360 --> 00:01:26,770
就是，我们的 shellcode，还有当使用 toupper 时，

23
00:01:26,770 --> 00:01:31,070
我们用来覆盖栈上指令指针的地址，不可更改。

24
00:01:31,070 --> 00:01:34,420
也就是说，不能使用小写的ASCII字符。

25
00:01:34,420 --> 00:01:39,130
或者说，有没有一个技巧，可以让我们绕过这个限制？

26
00:01:39,130 --> 00:01:42,740
让我们考虑一下这个问题，同时往下看。

27
00:01:42,740 --> 00:01:49,730
所以，为了不在我们的输入中，使用 toupper，必须满足什么条件。

28
00:01:49,729 --> 00:01:56,129
for循环使用 strlen 来确定，执行操作的字节数。

29
00:01:56,130 --> 00:01:59,200
strlen 计算所有字节，直到在里面，找到一个空字节。

30
00:01:59,200 --> 00:02:05,340
所以，如果我们设法在实际溢出和 shellcode 之前，得到一个空字节，

31
00:02:05,340 --> 00:02:07,480
我们就会没事的。

32
00:02:07,479 --> 00:02:11,059
好吧，我们怎么能得到一个空字节呢？

33
00:02:11,060 --> 00:02:16,350
如果你查看 gets 的手册页，你会看到，

34
00:02:16,349 --> 00:02:18,079
它会读取所有内容，直到换行或EOF。

35
00:02:18,080 --> 00:02:21,690
这意味着,gets将不会有读取空字节的问题。

36
00:02:21,690 --> 00:02:22,690
那就简单。

37
00:02:22,690 --> 00:02:25,490
我们可以完全忽略变为大写的内容。

38
00:02:25,490 --> 00:02:30,200
出于创造性的原因，您还可以把回车符，

39
00:02:30,200 --> 00:02:31,200
换成空字节。

40
00:02:31,200 --> 00:02:36,650
假设，输入将使用 strcpy，因此也是以空字节结尾的，

41
00:02:36,650 --> 00:02:41,740
您可以使用一个回车替代，然后再用一个空字节替换。

42
00:02:41,740 --> 00:02:44,150
所以，这也是可行的。

43
00:02:44,150 --> 00:02:49,260
缓冲区是512字节大，所以让，我们集中知识，

44
00:02:49,260 --> 00:02:51,210
创建一个简单概念的缓冲区溢出。

45
00:02:51,209 --> 00:02:56,899
我们可以使用 python 和-c，直接在参数中，编写一个简短的脚本。

46
00:02:56,900 --> 00:03:02,810
所以，我们可以打印510个小写字母A，然后。我们可以看到

47
00:03:02,810 --> 00:03:04,710
它们被修改为大写。

48
00:03:04,709 --> 00:03:10,149
然后，我们附加一个空字节，继续使用一个典型的字母表，

49
00:03:10,150 --> 00:03:12,150
这样我们就可以识别指令指针是怎么溢出的。

50
00:03:12,150 --> 00:03:17,780
我们也可以把字母表改成小写，以证明在空字节之后，

51
00:03:17,780 --> 00:03:20,320
它不会被转换成大写。

52
00:03:20,320 --> 00:03:25,090
和以前的网络挑战一样，我们可以连接到端口2995上的服务

53
00:03:25,090 --> 00:03:26,380
使用 netcat。

54
00:03:26,379 --> 00:03:31,909
所以，我们也可以简单将python一行程序的输出，通过管道传输到netcat。

55
00:03:31,909 --> 00:03:36,259
我们没有像以前那样看到“没有这样的用户…”输出。

56
00:03:36,260 --> 00:03:42,760
代码告诉我们，它将在 main 返回之后被打印，因此我们可以假设，

57
00:03:42,760 --> 00:03:47,770
我们成功地重写了指令指针，并使程序崩溃。

58
00:03:47,769 --> 00:03:50,399
但是，我们现在如何调试它呢？

59
00:03:50,400 --> 00:03:54,920
如果你看一下 protostar 虚拟机的描述，。

60
00:03:54,920 --> 00:03:56,980
你会在这里看到一个标题，称为核心文件。

61
00:03:56,980 --> 00:04:00,910
它说，文件名模式设置为 /tmp/something。

62
00:04:00,909 --> 00:04:04,139
这意味着，核心日志，存储在 tmp 中。

63
00:04:04,140 --> 00:04:10,030
当我们查看 /tmp/ 的内容时，我们将看到一个刚刚生成的核心文件。

64
00:04:10,030 --> 00:04:14,080
它们属于根权限，所以让我们切换到根权限，这样我们就可以使用它们了。

65
00:04:14,080 --> 00:04:15,700
但是什么是核心文件？

66
00:04:15,700 --> 00:04:19,620
让我们用“man core”，来询问Linux手册。

67
00:04:19,620 --> 00:04:25,020
某些信号的默认动作，是使进程终止，并产生一个核心日志文件，

68
00:04:25,020 --> 00:04:30,990
就是一个包含终止进程的，

69
00:04:30,990 --> 00:04:32,000
内存图像的磁盘文件。

70
00:04:31,999 --> 00:04:37,559
这听起来不错，如果我们得到了它崩溃时的内存状态，

71
00:04:37,559 --> 00:04:41,599
我们应该能够获取大量关于缓冲区溢出的信息。

72
00:04:41,599 --> 00:04:47,009
此图像可在调试器（例如，gdb（1））中，用于检查，

73
00:04:47,009 --> 00:04:48,949
程序在它终止时候的状态。

74
00:04:48,949 --> 00:04:54,209
哦，哇，我们可以用gdb来看看这些，

75
00:04:54,210 --> 00:04:56,080
我们已经非常熟悉如何使用 gdb 。

76
00:04:56,080 --> 00:05:02,270
在 signal（7）中，可以找到导致，进程转储核心的信号(signal)列表。

77
00:05:02,270 --> 00:05:04,010
好的，很有趣。

78
00:05:04,009 --> 00:05:09,999
显然，进程收到了一个信号，因为它确实产生了一个核心文件，对吗？

79
00:05:10,000 --> 00:05:13,530
为了正确理解这一点，让我们也试着理解什么是信号。

80
00:05:13,529 --> 00:05:17,779
注意信号后括号中的 7 ，这很重要，

81
00:05:17,779 --> 00:05:19,489
关乎哪张参考手册页面。

82
00:05:19,490 --> 00:05:21,500
所以“man 7 signal”。

83
00:05:21,500 --> 00:05:25,480
让我们再往下看一下标准信号。

84
00:05:25,479 --> 00:05:29,009
Linux支持下面列出的标准信号。

85
00:05:29,009 --> 00:05:34,599
如“Value”一栏所示，几个信号数字取决于体系结构。

86
00:05:34,599 --> 00:05:38,539
嗯，所以信号在不同的架构上，是不同的。

87
00:05:38,539 --> 00:05:43,779
因此，如果它是一个Intel、ARM或SPARC处理器，这可能会有所不同，

88
00:05:43,779 --> 00:05:49,649
bug通常告诉我们，信号可能与，

89
00:05:49,649 --> 00:05:50,649
非常低级别的CPU和硬件特征有关。

90
00:05:50,649 --> 00:05:53,219
让我们看看信号列表。

91
00:05:53,219 --> 00:05:58,939
例如， SIGINT 是一个多次使用的信号，

92
00:05:58,940 --> 00:06:02,720
它是来自键盘，当你按下Control+C时，会发生这种情况。

93
00:06:02,719 --> 00:06:07,709
或记住，当你跳入无效的代码时，你有时是如何得到非法指令的，

94
00:06:07,710 --> 00:06:10,440
一个 SIGILL ，这也是一个信号。

95
00:06:10,439 --> 00:06:14,939
很明显，这一定是由CPU触发的，

96
00:06:14,939 --> 00:06:15,939
表示，它无法理解指令。

97
00:06:15,939 --> 00:06:19,679
或者我们最喜欢的 syscall，SIGSEGV，一个分段错误。

98
00:06:19,679 --> 00:06:24,219
从非法内存引用中，触发，例如当您跳转到不存在的

99
00:06:24,219 --> 00:06:25,219
内存。

100
00:06:25,219 --> 00:06:27,719
或者，尝试写入不存在的内存。

101
00:06:27,720 --> 00:06:33,990
很明显，都是再你试图执行坏的东西时，这也是由低级硬件触发的。

102
00:06:33,990 --> 00:06:39,560
这里的这一行也很有趣：信号 SIGKILL 和 SIGSTOP 不能被捕获、阻止，

103
00:06:39,559 --> 00:06:40,779
或者忽略。

104
00:06:40,779 --> 00:06:44,839
这意味着，这些信号中的大部分都可以被进程捕获。

105
00:06:44,839 --> 00:06:51,329
在 gdb 中运行一个进程时，您实际上，也经历过这种情况，但是您忘记了

106
00:06:51,330 --> 00:06:56,260
若要设置断点，且进程正在运行，

107
00:06:56,259 --> 00:06:57,259
可以使用ctrl+c 返回，进入 gdb 。

108
00:06:57,259 --> 00:07:02,309
这时，您是向进程发送了一个 SIGINT，而不是退出，会有一个信号处理程序，

109
00:07:02,309 --> 00:07:05,219
设置为抓住信号，并执行不同的操作。

110
00:07:05,220 --> 00:07:09,780
所以，信号有点像内核对进程的中断。

111
00:07:09,779 --> 00:07:15,349
某些事件（如内存访问失败、按 ctrl+c 或同时终止进程）会导致，

112
00:07:15,349 --> 00:07:18,469
内核向进程发送一个信号。

113
00:07:18,469 --> 00:07:23,589
未处理的信号，通常会导致进程死亡，但进程也可以设置信号处理程序

114
00:07:23,589 --> 00:07:28,059
，在接收到这些信号时，执行某些操作。

115
00:07:28,059 --> 00:07:29,059
所以。

116
00:07:29,059 --> 00:07:35,099
在我们的例子中，当我们在栈上，溢出 eip 时，函数返回，出现的一个分段错误，

117
00:07:35,099 --> 00:07:38,019
并触发信号。

118
00:07:38,020 --> 00:07:41,050
进程若不处理它，就被内核杀死。

119
00:07:41,050 --> 00:07:46,430
同时，创建一个核心转储文件，

120
00:07:46,429 --> 00:07:47,649
来保存导致这个信号的状态。

121
00:07:47,649 --> 00:07:50,599
现在让我们用gdb，来看看发生了什么。

122
00:07:50,599 --> 00:07:57,469
像前面一样，只需将二进制文件指定为第一个参数，

123
00:07:57,469 --> 00:07:58,539
然后，添加核心文件作为第二个参数。

124
00:07:58,539 --> 00:08:04,439
当gdb打开时，会立即看到进程由于

125
00:08:04,439 --> 00:08:07,499
信号11，分段错误。

126
00:08:07,499 --> 00:08:11,449
我们还可以查看寄存器，并查看 eip 的值。

127
00:08:11,449 --> 00:08:14,199
这些绝对是我们已经输入的字符。

128
00:08:14,199 --> 00:08:17,849
我们还可以通过检查栈指针，来探索栈。

129
00:08:17,849 --> 00:08:22,779
您可以看到，拥有这些核心文件非常有用。

130
00:08:22,780 --> 00:08:27,720
现在我们知道哪些字符导致了溢出，

131
00:08:27,719 --> 00:08:30,249
我们可以计算到栈上指令指针的偏移。

132
00:08:30,249 --> 00:08:35,729
另一种进一步调试的方法是，使用 gdb 附加到已经运行的进程。

133
00:08:35,729 --> 00:08:37,749
确保你是根权限。

134
00:08:37,750 --> 00:08:42,430
只需找到进程id，并使用 -p 和 pid 调用gdb。

135
00:08:42,430 --> 00:08:48,080
如您所见，进程当前处于接受状态，等待客户端连接。

136
00:08:48,079 --> 00:08:51,169
但，当我们发送PoC溢出时，我们看不到分段错误。

137
00:08:51,170 --> 00:08:55,500
如果您还记得的话，这是因为该进程会创建一个分叉，一个新的进程，

138
00:08:55,500 --> 00:08:56,500
来处理客户端。

139
00:08:56,500 --> 00:08:58,330
我们总是呆在父进程身边。

140
00:08:58,329 --> 00:09:03,559
但是，我们可以在gdb中，follow fork 模式设置为 child，

141
00:09:03,560 --> 00:09:05,970
若我们现在继续，并发送长的输入，我们会得到了分段错误。

142
00:09:05,970 --> 00:09:10,400
太棒了，现在你已经准备好全部的一切，开发完整的漏洞。

