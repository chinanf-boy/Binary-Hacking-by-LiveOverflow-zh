1
00:00:00,170 --> 00:00:04,480
在上一个视频中，我们学习了一些关于堆的工作方式，现在我们要应用

2
00:00:04,480 --> 00:00:15,450
这将从漏洞利用练习堆到1级原恒星来解决它。

3
00:00:15,450 --> 00:00:17,320
实际上我想试试。

4
00:00:17,320 --> 00:00:18,460
我们做一些角色扮演。

5
00:00:18,460 --> 00:00:23,220
让我们先做安全研究员想在这里找到一个漏洞

6
00:00:23,220 --> 00:00:24,600
二元的。

7
00:00:24,600 --> 00:00:29,680
之后我们扮演开发者试图理解解决问题的漏洞。

8
00:00:29,680 --> 00:00:36,440
所以我们穿上黑色的连帽衫开始…首先，我们在gdb中打开二进制堆1，然后

9
00:00:36,440 --> 00:00:37,500
执行它。

10
00:00:37,499 --> 00:00:38,499
我们得到一个SegFault。

11
00:00:38,499 --> 00:00:43,829
它还向我们展示了SegFault因为它试图复制

12
00:00:43,829 --> 00:00:49,539
从地址0到另一个的字符串地址在这里，0显然无效

13
00:00:49,539 --> 00:00:51,679
内存——所以它崩溃了。

14
00:00:51,679 --> 00:00:56,699
我们知道Linux二进制文件是如何工作的，所以我们有根据的推测，此应用程序可能

15
00:00:56,699 --> 00:01:00,369
需要一些输入，我们尝试参数。

16
00:01:00,369 --> 00:01:03,069
和AAAA一起跑步。

17
00:01:03,069 --> 00:01:07,679
又一次犯错了，但是专心查看者会注意到地址现在是

18
00:01:07,680 --> 00:01:13,820
不同，所以这是一个不同的strcpy，又不能从地址0复制，所以

19
00:01:13,820 --> 00:01:16,800
我们认为这需要另一个参数。

20
00:01:16,799 --> 00:01:21,359
这一次程序运行时没有错误。

21
00:01:21,360 --> 00:01:26,270
现在我们试图找到一个bug，所以最简单的要做的是，我们只需投入一些长时间的投入

22
00:01:26,270 --> 00:01:29,330
在程序中查看是否发生了什么。

23
00:01:29,329 --> 00:01:34,209
因此，对于第一个参数，我选择带字母和第二个参数的模式

24
00:01:34,210 --> 00:01:38,930
我做数字，只是为了能识别它们如果发生什么事。

25
00:01:38,930 --> 00:01:42,250
我们运行它，得到一个不同的segfault。

26
00:01:42,249 --> 00:01:48,109
再次因为strcpy，但这次目标地址无效。

27
00:01:48,109 --> 00:01:53,039
它试图复制带数字的字符串，我们知道这是第二个参数

28
00:01:53,040 --> 00:01:57,970
地址46,46,46,46，它是的十六进制代码FFFF。

29
00:01:57,969 --> 00:02:03,319
所以无论发生什么，我们都会以某种方式重写用作目的地的地址

30
00:02:03,319 --> 00:02:04,749
对的。

31
00:02:04,749 --> 00:02:10,649
这意味着我们现在可以用第一个参数完全控制我们想写的地方。

32
00:02:10,649 --> 00:02:14,879
我们可以选择写什么第二个参数。

33
00:02:14,879 --> 00:02:18,489
现在我们有了很多自由我们想要的改写。

34
00:02:18,489 --> 00:02:23,369
例如，我们可以覆盖返回指针在堆栈上重定向代码执行，或

35
00:02:23,370 --> 00:02:28,650
我们可以覆盖全局偏移量的条目表，我在之前的视频中解释过，

36
00:02:28,650 --> 00:02:29,720
达到同样的效果。

37
00:02:29,720 --> 00:02:34,060
让我们做后一个，通常是比堆栈更可靠-哪个喜欢

38
00:02:34,060 --> 00:02:36,420
四处走动

39
00:02:36,420 --> 00:02:39,960
那么让我们检查一下什么样的函数以邪恶的强盗的名字命名。

40
00:02:39,959 --> 00:02:44,109
我们可以在源代码中达到峰值并看到有打印件，我们可以假设

41
00:02:44,110 --> 00:02:47,690
我们想在全球覆盖printf偏移表，但这是欺骗。

42
00:02:47,689 --> 00:02:48,979
事实并非如此。

43
00:02:48,980 --> 00:02:51,950
所以我们最好还是坚持到大会上吧。

44
00:02:51,950 --> 00:02:56,870
首先我们要找到地点我们打电话给史崔比。

45
00:02:56,870 --> 00:03:01,640
我们可以使用backtrace，这将查看堆栈和存储的返回指针

46
00:03:01,640 --> 00:03:06,750
为了弄清楚我们在哪里——作为旁注，如果你发现了一个能破坏堆栈的错误，

47
00:03:06,750 --> 00:03:09,950
那么回溯就没有什么意义了它已经消失了。

48
00:03:09,950 --> 00:03:11,730
所以它并不总是有效的。

49
00:03:11,730 --> 00:03:18,000
现在我们可以看到但我们是从这个地址来的。

50
00:03:18,000 --> 00:03:23,680
那么让我们把反汇编的味道设为正常。英特尔语法和地址分解。

51
00:03:23,680 --> 00:03:27,380
这将分解整个函数这个地址属于。

52
00:03:27,380 --> 00:03:31,050
我们的地址以5a结尾，所以我们在后面笨拙的

53
00:03:31,050 --> 00:03:35,600
正如你所看到的，有一个叫Puts的电话下一步。

54
00:03:35,599 --> 00:03:38,139
哪一个btw在源文件中不像printf代码。

55
00:03:38,140 --> 00:03:42,820
这是因为编译器替换了出于优化原因，带Puts的printf。

56
00:03:42,819 --> 00:03:47,359
好的，那么让我们重写全局偏移量Puts的表条目。

57
00:03:47,360 --> 00:03:52,370
如视频所示，我们可以找到先拆放货地址

58
00:03:52,370 --> 00:03:56,710
程序链接中的函数Trapoline表，现在将跳转到一个地址

59
00:03:56,709 --> 00:03:58,759
存储在这个地址。

60
00:03:58,760 --> 00:04:03,260
这意味着这是看跌期权的地址全局偏移表条目。

61
00:04:03,260 --> 00:04:08,220
所以这是我们要写的目标，因此，我们把它放在第一个参数中。

62
00:04:08,219 --> 00:04:14,249
gdb运行，但我们在第一次使用backticks要执行的参数/bin/echo。

63
00:04:14,250 --> 00:04:18,830
正如你所知，Echo只输出你所需要的作为参数传递给它，我们可以使用它

64
00:04:18,830 --> 00:04:21,850
要用十六进制值获取字符，我们不能类型。

65
00:04:21,850 --> 00:04:23,880
例如十六进制值8。

66
00:04:23,880 --> 00:04:29,830
所以echo-ne，-n因为我们不想那样echo将换行符放在输出的末尾。

67
00:04:29,830 --> 00:04:35,190
和-e是因为我们希望echo转换十六进制将数字转义到原始字符中。

68
00:04:35,190 --> 00:04:40,150
只是为了确保一切正常我们回音整个测试字符串再次到达fs。

69
00:04:40,150 --> 00:04:45,130
现在将执行backticks中的echo它的输出将放在

70
00:04:45,130 --> 00:04:46,900
作为第一个参数。

71
00:04:46,900 --> 00:04:53,410
当我们运行这个程序时，我们会得到相同的segfault和以前一样，一切都很好。

72
00:04:53,410 --> 00:04:57,820
下一步显然是用Puts全局偏移表的地址

73
00:04:57,820 --> 00:05:02,010
条目。

74
00:05:02,010 --> 00:05:08,880
当我们现在运行它的时候，我们会得到一个SegFault否则，这次是因为30303030，

75
00:05:08,881 --> 00:05:11,481
是ASCII表示0000。

76
00:05:11,480 --> 00:05:16,540
当我们用信息查看寄存器时我们可以看到我们成功获得的寄存器

77
00:05:16,540 --> 00:05:23,280
控制EIP，这意味着我们现在可以重定向随时随地编码。

78
00:05:23,280 --> 00:05:27,980
在这种情况下，我们要打电话给赢家这里有这个地址。

79
00:05:27,980 --> 00:05:34,430
所以我们把它放在第二个参数中而不是argv2，在backticks中使用echo。

80
00:05:34,430 --> 00:05:38,810
我们执行它，我们就获得了胜利。

81
00:05:38,810 --> 00:05:42,880
它在gdb之外也很有效。

82
00:05:42,880 --> 00:05:47,160
总之，我们可以这样说：我们通过猜测和玩发现了一个虫子

83
00:05:47,160 --> 00:05:48,310
围绕着它。

84
00:05:48,310 --> 00:05:53,600
通过GDB我们了解到控制strcpy的目的地，我们

85
00:05:53,600 --> 00:05:56,660
学会了我们甚至控制我们想要复制的东西。

86
00:05:56,660 --> 00:06:02,380
我们滥用它来覆盖函数重定向代码执行的放置地址

87
00:06:02,380 --> 00:06:04,310
到Winner函数。

88
00:06:04,310 --> 00:06:09,000
都不知道为什么会这样甚至不知道堆

89
00:06:09,000 --> 00:06:11,020
完全。

90
00:06:11,020 --> 00:06:16,300
作为一名优秀的安全研究员，我们创造一份报告，一份建议。

91
00:06:16,300 --> 00:06:19,900
提供概念验证利用以及一些可能

92
00:06:19,900 --> 00:06:22,250
帮助开发者。

93
00:06:22,250 --> 00:06:28,580
现在让我们改变立场，成为开发者。

94
00:06:28,580 --> 00:06:32,180
我们脱下黑色连帽衫，穿上灰色帽衫。

95
00:06:32,180 --> 00:06:33,960
因为开发人员就是这么穿的。

96
00:06:33,960 --> 00:06:38,620
所以我们刚收到这个家伙的邮件在我们的程序中发现了一个错误。

97
00:06:38,620 --> 00:06:41,240
他甚至提供了利用概念的证据有了它。

98
00:06:41,240 --> 00:06:45,600
现在我们想弄清楚为什么会这样发生了，所以我们可以修复它。

99
00:06:45,600 --> 00:06:49,040
在公告中，它说必须这样做和strcpy有关。

100
00:06:49,040 --> 00:06:51,010
所以我们读了关于strcpy的手册。

101
00:06:51,010 --> 00:06:55,530
当我们意识到我们甚至没有阅读文档

102
00:06:55,530 --> 00:06:58,040
那会告诉我们这是个多么糟糕的主意是。

103
00:06:58,040 --> 00:06:59,830
现在我们可以解决这个问题了。

104
00:06:59,830 --> 00:07:05,080
例如，使用strncpy或使用strlen to在我们复制之前检查长度，然后

105
00:07:05,080 --> 00:07:06,910
出口。

106
00:07:06,910 --> 00:07:11,180
但是因为我们是一个优秀的开发者，所以我们尝试从这个建议中学习并试图理解

107
00:07:11,180 --> 00:07:13,070
该漏洞是如何工作的。

108
00:07:13,070 --> 00:07:18,330
在上一个视频中，heap malloc介绍视频，我们已经考虑过堆

109
00:07:18,330 --> 00:07:20,080
从这个程序中应该是这样的。

110
00:07:20,080 --> 00:07:23,160
让我们看看现实中的情况。

111
00:07:23,160 --> 00:07:26,650
为此，让我们在每个malloc和strcpy。

112
00:07:26,650 --> 00:07:33,650
我们把主要部分分解，寻找所有这些然后调用并设置断点。

113
00:07:33,650 --> 00:07:36,570
然后我们用概念验证来运行它争论。

114
00:07:36,570 --> 00:07:39,120
我们到达了第一个断点。

115
00:07:39,120 --> 00:07:40,210
所以现在第一个malloc发生了。

116
00:07:40,210 --> 00:07:44,130
所以我们现在在汇编程序中代码和malloc的结果在eax中。

117
00:07:44,130 --> 00:07:49,330
所以eax包含堆上的地址，其中我们有足够的空间用于互联网结构

118
00:07:49,330 --> 00:07:50,330
I1.

119
00:07:50,330 --> 00:07:54,930
我们可以看看这个地址看它只是0。

120
00:07:54,930 --> 00:07:59,840
通过信息过程映射，我们可以看到内存段，还有堆，我们

121
00:07:59,840 --> 00:08:01,570
可以看看那个。

122
00:08:01,570 --> 00:08:08,110
哦，也许这是个好主意输出也是一个gdb钩子。

123
00:08:08,110 --> 00:08:11,470
所以我们会在每个断点自动看到它。

124
00:08:11,470 --> 00:08:15,500
定义钩挡X/64 WX 0X

125
00:08:15,500 --> 00:08:16,690
结束

126
00:08:16,690 --> 00:08:25,210
所以如果我们现在继续，我们应该设置优先权从I1到1，然后是malloc作为名称。

127
00:08:25,210 --> 00:08:27,960
让我们仔细看看这个堆。

128
00:08:27,960 --> 00:08:31,330
我们在这里学习了I1变量点。

129
00:08:31,330 --> 00:08:35,740
所以这就是结构开始的地方，而你可以设置第一个属性，即

130
00:08:35,740 --> 00:08:37,900
优先级设置为1。

131
00:08:37,899 --> 00:08:42,659
在此之前，我们有堆元数据，块头，其中包含lnegth

132
00:08:42,659 --> 00:08:48,339
包括最后一个位集到1，这意味着前一个块是

133
00:08:48,339 --> 00:08:49,339
不是免费的。

134
00:08:49,339 --> 00:08:50,339
它正在使用中。

135
00:08:50,339 --> 00:08:56,509
我们看到的是我们所期望的，我们看到的这里有两个8字节的块，包括

136
00:08:56,509 --> 00:08:59,259
头，显然是16字节。

137
00:08:59,260 --> 00:09:04,290
我们能做的另一件很酷的事就是定义gdb中的变量i1并将其设置为地址

138
00:09:04,290 --> 00:09:05,420
这个物体的

139
00:09:05,420 --> 00:09:09,990
aa我们甚至可以添加这个变量的类型这就是"结构化互联网"。

140
00:09:09,990 --> 00:09:15,320
现在我们可以打印这个变量i1和gdb可以显示属性优先级和

141
00:09:15,319 --> 00:09:16,319
姓名。

142
00:09:16,319 --> 00:09:21,179
我们可以看到优先级是1，名字仍然是零，因为我们已经分配了内存

143
00:09:21,180 --> 00:09:24,860
但尚未将其分配给I1属性名称。

144
00:09:24,860 --> 00:09:30,580
如果我们继续到下一个断点，分配的名称和I2的地址

145
00:09:30,580 --> 00:09:32,190
对象已分配。

146
00:09:32,189 --> 00:09:37,639
malloc的结果又出现在eax中，这是I2对象的地址。

147
00:09:37,639 --> 00:09:40,149
所以我们也可以在gdb中定义变量i2。

148
00:09:40,149 --> 00:09:43,029
当我们打印出来的时候，我们可以看到还是空的。

149
00:09:43,029 --> 00:09:50,109
如果我们继续，I2的优先权应该设为2，我们可以通过查看

150
00:09:50,110 --> 00:09:55,430
当我们打印I2对象。

151
00:09:55,430 --> 00:09:59,500
我们的4个malloc现在都完成了。

152
00:09:59,500 --> 00:10:03,820
如果我们把它和我们期望的相比较在前面的视频中，我们可以看到它适合

153
00:10:03,819 --> 00:10:05,049
完美。

154
00:10:05,050 --> 00:10:11,390
只有一件事我们没说大约到现在为止，这是在

155
00:10:11,389 --> 00:10:13,719
最后的所有块。

156
00:10:13,720 --> 00:10:18,640
好吧，下面这个区域都是免费的内存从剥削的角度来说，这经常被提到

157
00:10:18,639 --> 00:10:19,989
像荒野一样。

158
00:10:19,990 --> 00:10:23,740
这是数字是堆。

159
00:10:23,740 --> 00:10:29,170
整个事情基本上是一个巨大的堆块，这个数字就是它的长度。

160
00:10:29,170 --> 00:10:35,850
我做了一个关于食谱的三部分视频来自CTF的挑战，利用滥用

161
00:10:35,850 --> 00:10:37,670
此数字用于重定向代码执行。

162
00:10:37,670 --> 00:10:38,670
太棒了。

163
00:10:38,670 --> 00:10:40,290
你应该看看。

164
00:10:40,290 --> 00:10:41,290
不管怎样。

165
00:10:41,290 --> 00:10:44,130
现在，i1的名称仍然是空的字符串。

166
00:10:44,129 --> 00:10:47,149
但这将随着下一个发生变化断点。

167
00:10:47,149 --> 00:10:51,919
因为我们要执行第一个strcpy，它首先复制这个超长的

168
00:10:51,920 --> 00:10:52,920
争论。

169
00:10:52,920 --> 00:10:53,920
继续。

170
00:10:53,920 --> 00:10:56,800
现在我们注意到的第一件事就是记忆。

171
00:10:56,800 --> 00:11:01,270
这些ASCII字符出现，看起来好像他们已经覆盖了很多stuf

172
00:11:01,269 --> 00:11:02,269
堆。

173
00:11:02,269 --> 00:11:07,809
之前应该是块头的东西元数据，就像现在的大小是44444444。

174
00:11:07,810 --> 00:11:11,820
让我们看一下对象I1和I2。

175
00:11:11,819 --> 00:11:16,409
所以I1看起来很好，I1还有优先权1用我们传递给的字符串命名

176
00:11:16,410 --> 00:11:18,400
它。

177
00:11:18,399 --> 00:11:19,629
I2怎么样？

178
00:11:19,630 --> 00:11:21,500
呃……看起来他妈的。

179
00:11:21,499 --> 00:11:23,109
优先权现在是一个巨大的数字。

180
00:11:23,110 --> 00:11:25,900
事实上，这只是45454545的小数点，这就是ES。

181
00:11:25,899 --> 00:11:26,899
我们知道的名字是46464646FS。

182
00:11:26,899 --> 00:11:27,899
是的，我们似乎已经改写了很多堆里的东西。

183
00:11:27,899 --> 00:11:32,039
事实上，我们已经覆盖了下一块在堆中I1名称之后。

184
00:11:32,040 --> 00:11:37,770
现在下一个strcpy将采用i2-&gt；名称，指的是一些糟糕的记忆

185
00:11:37,769 --> 00:11:40,049
复制第二个参数。

186
00:11:40,050 --> 00:11:42,320
真是太棒了。

187
00:11:42,320 --> 00:11:46,130
所以这个挑战展示了堆的一个方面功绩。

188
00:11:46,130 --> 00:11:51,070
它不会攻击堆算法本身，它攻击使用对象的应用程序

189
00:11:51,069 --> 00:11:56,149
在堆上，我们可以通过重写来修改东西。

190
00:11:56,149 --> 00:11:59,229
然后这些修改过的对象会弯曲执行流动。

191
00:11:59,230 --> 00:11:59,910
很酷，是吧？

