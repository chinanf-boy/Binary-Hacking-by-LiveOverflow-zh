1
00:00:00,170 --> 00:00:04,480
在上一个视频中，我们学习了堆工作的一些基本知识，

2
00:00:04,480 --> 00:00:15,450
现在应用到，exploit-exercsies protostar 的1级heap问题，解决它。

3
00:00:15,450 --> 00:00:17,320
实际上，我想试一些东西。

4
00:00:17,320 --> 00:00:18,460
我们做个角色扮演。

5
00:00:18,460 --> 00:00:23,220
让我们先做一个安全研究员，要在这个二进制中，

6
00:00:23,220 --> 00:00:24,600
找到一个可以利用的漏洞。

7
00:00:24,600 --> 00:00:29,680
之后，我们扮演开发人员的角色，试图理解，并修复漏洞问题。

8
00:00:29,680 --> 00:00:36,440
所以，我们穿上黑色的连帽衫，开始吧… 首先我们在gdb中，打开二进制 heap1

9
00:00:36,440 --> 00:00:37,500
并执行它。

10
00:00:37,499 --> 00:00:38,499
我们得到一个分段错误。

11
00:00:38,499 --> 00:00:43,829
同时，也说明该错误是由strcpy引起的，

12
00:00:43,829 --> 00:00:49,539
因为它试图从地址0 复制到，这里的另一个地址，

13
00:00:49,539 --> 00:00:51,679
而 0 显然是无效内存 —— 所以它崩溃了。

14
00:00:51,679 --> 00:00:56,699
我们知道Linux二进制文件是如何工作的，所以我们有理由，猜测这个应用程序可能

15
00:00:56,699 --> 00:01:00,369
需要一些输入，我们试试参数。

16
00:01:00,369 --> 00:01:03,069
和AAAA一起运行。

17
00:01:03,069 --> 00:01:07,679
又是另一个分段错误，但细心观察，会注意到地址

18
00:01:07,680 --> 00:01:13,820
现在不同了，所以，这是一个不同的strcpy，它同样不能从地址0复制，

19
00:01:13,820 --> 00:01:16,800
所以，我们认为这需要另一个参数。

20
00:01:16,799 --> 00:01:21,359
这一次程序运行无误。

21
00:01:21,360 --> 00:01:26,270
现在我们试图找到一个bug，所以最简单的事情就是，我们只需要抛给程序。一些长的输入

22
00:01:26,270 --> 00:01:29,330
看看是否发生了什么。

23
00:01:29,329 --> 00:01:34,209
所以对于第一个参数，我选择用字母做一个模式，

24
00:01:34,210 --> 00:01:38,930
对于第二个参数，则为数字，只是为了在有事情发生的时候，能识别它们。

25
00:01:38,930 --> 00:01:42,250
我们运行它，得到一个不同的分段错误。

26
00:01:42,249 --> 00:01:48,109
同样是因为 strcpy，但这次目标地址看起来无效。

27
00:01:48,109 --> 00:01:53,039
它试图将带有数字的字符串（我们知道这是第二个参数），复制到

28
00:01:53,040 --> 00:01:57,970
地址46,46,46,46，它是ffff的十六进制代码。

29
00:01:57,969 --> 00:02:03,319
所以，不管发生什么，我们以某种方式重写了一个地址，

30
00:02:03,319 --> 00:02:04,749
该地址是strcpy的目的地。

31
00:02:04,749 --> 00:02:10,649
这意味着我≤们现在可以使用第一个参数，来完全控制我们想写的地方。

32
00:02:10,649 --> 00:02:14,879
通过第二个参数，我们可以完全选择要写什么。

33
00:02:14,879 --> 00:02:18,489
现在我们要覆盖的东西，有了很高的自由度。

34
00:02:18,489 --> 00:02:23,369
例如，我们可以覆盖栈上的返回指针，来重定向代码执行，或者

35
00:02:23,370 --> 00:02:28,650
我们可以覆盖全局偏移表的一个条目，我在前面的视频中解释过，

36
00:02:28,650 --> 00:02:29,720
也能达到同样的效果。

37
00:02:29,720 --> 00:02:34,060
让我们来做后一个，它通常比栈更可靠，因为栈喜欢

38
00:02:34,060 --> 00:02:36,420
到处走动

39
00:02:36,420 --> 00:02:39,960
那么，让我们检查一下在邪恶的strcpy之后，调用了什么类型的函数。

40
00:02:39,959 --> 00:02:44,109
我们可以观察源代码，这能看到有一个 printf，我们可以假设

41
00:02:44,110 --> 00:02:47,690
我们想覆盖全局偏移表上的 printf，但这是欺骗。

42
00:02:47,689 --> 00:02:48,979
事实并非如此。

43
00:02:48,980 --> 00:02:51,950
所以，我们最好还是坚持在汇编。

44
00:02:51,950 --> 00:02:56,870
首先，我们要找到，我们调用strcpy的位置。

45
00:02:56,870 --> 00:03:01,640
我们可以使用 backtrace，它将查看栈和存储的返回指针

46
00:03:01,640 --> 00:03:06,750
为了弄清楚我们在哪里 —— 作为旁注，如果你发现了一个破坏栈的错误，

47
00:03:06,750 --> 00:03:09,950
那么 backtrace 就不再有什么意义了。

48
00:03:09,950 --> 00:03:11,730
所以，它并不总是可行的。

49
00:03:11,730 --> 00:03:18,000
在这里，我们可以看到我们现在位于 Strcpy，但我们来自这个地址。

50
00:03:18,000 --> 00:03:23,680
因此，让我们设置反汇编风格，变为英特尔语法，并反汇编该地址。

51
00:03:23,680 --> 00:03:27,380
这将反汇编，这个地址所属的整个函数。

52
00:03:27,380 --> 00:03:31,050
我们的地址以 5a 结尾，所以，我们正在 strcpy 后面。

53
00:03:31,050 --> 00:03:35,600
正如你所看到的，接下来有一个call 要 puts 下一个。

54
00:03:35,599 --> 00:03:38,139
(还有要注意：)与源代码 printf 不同。

55
00:03:38,140 --> 00:03:42,820
出于优化的原因，编译器用 puts 替换了printf。

56
00:03:42,819 --> 00:03:47,359
好的，那么让我们覆盖 puts 的全局偏移表条目。

57
00:03:47,360 --> 00:03:52,370
如 GOT 视频所示，我们可以弄清楚 puts 的 地址，。

58
00:03:52,370 --> 00:03:56,710
通过对过程链接表中的函数 trapoline，进行第一次反汇编，

59
00:03:56,709 --> 00:03:58,759
现在将跳转到一个，存储在这个地址的地址。

60
00:03:58,760 --> 00:04:03,260
这意味着，这是 puts 的全局偏移表条目地址。

61
00:04:03,260 --> 00:04:08,220
所以，这是我们要写的目标，让，我们把它放在第一个参数中。

62
00:04:08,219 --> 00:04:14,249
gdb运行，但我们在第一个参数中，使用 backticks 来执行/bin/echo。

63
00:04:14,250 --> 00:04:18,830
正如您所知，echo只输出您作为参数，传递给它的任何内容，

64
00:04:18,830 --> 00:04:21,850
我们可以使用它，获取我们不能键入的十六进制值字符。

65
00:04:21,850 --> 00:04:23,880
例如，十六进制值 8。

66
00:04:23,880 --> 00:04:29,830
所以， echo -ne，-n 是因为我们不希望 echo ，在输出的末尾放置新行。

67
00:04:29,830 --> 00:04:35,190
和 -e，因为我们希望echo，将十六进制转义数字，转换为原始字符。

68
00:04:35,190 --> 00:04:40,150
为了确保一切正常，我们再次将整个测试字符串 echo 到fs。

69
00:04:40,150 --> 00:04:45,130
现在，将执行 backticks 中的echo，

70
00:04:45,130 --> 00:04:46,900
并将其输出放入引号，作为第一个参数。

71
00:04:46,900 --> 00:04:53,410
当我们运行这个程序时，会得到和以前一样的分段错误，所以一切都很好。

72
00:04:53,410 --> 00:04:57,820
下一步，显然是用puts 的全局偏移表条目地址替换成 fs的。

73
00:04:57,820 --> 00:05:02,010
条目。

74
00:05:02,010 --> 00:05:08,880
当我们现在运行它的时候，我们在其他地方，得到一个分段错误，这次是因为 30303030，

75
00:05:08,881 --> 00:05:11,481
它是0000的Ascii格式。

76
00:05:11,480 --> 00:05:16,540
当我们用 info registers 查看寄存器时，我们可以看到

77
00:05:16,540 --> 00:05:23,280
我们成功地得到了EIP的控制权，这意味着，我们现在可以将代码重定向到我们想要的任何地方。

78
00:05:23,280 --> 00:05:27,980
在这种情况下，我们要调用 winner，winner 在这里有这个地址。

79
00:05:27,980 --> 00:05:34,430
所以，我们在backticks，使用 echo，把它放在第二个参数中，而不是 argv2 中。

80
00:05:34,430 --> 00:05:38,810
我们执行它，我们就获得了 winner。

81
00:05:38,810 --> 00:05:42,880
它在gdb之外，也很有效。

82
00:05:42,880 --> 00:05:47,160
总之，我们可以这样说：我们通过猜测和尝试，

83
00:05:47,160 --> 00:05:48,310
识别一个bug。

84
00:05:48,310 --> 00:05:53,600
通过gdb，我们了解，可通过某种方式，控制strcpy的目的地，

85
00:05:53,600 --> 00:05:56,660
还学会控制想要复制的东西。

86
00:05:56,660 --> 00:06:02,380
我们控制它来覆盖puts的函数地址，达到将代码执行重定向，到

87
00:06:02,380 --> 00:06:04,310
到 winner 函数的目的。

88
00:06:04,310 --> 00:06:09,000
这一切，其实都不太清楚，为什么会发生这种情况，甚至不知道

89
00:06:09,000 --> 00:06:11,020
堆在其中扮演角色。

90
00:06:11,020 --> 00:06:16,300
但作为一名优秀的安全研究员，我们为此撰写了一份报告和建议。

91
00:06:16,300 --> 00:06:19,900
提供概念验证漏洞以及，一些能

92
00:06:19,900 --> 00:06:22,250
帮助开发者的额外信息。

93
00:06:22,250 --> 00:06:28,580
现在让我们变装，成为开发者。

94
00:06:28,580 --> 00:06:32,180
我们脱下黑色的连帽衫，穿上灰色的连帽衫。

95
00:06:32,180 --> 00:06:33,960
因为开发人员就是这么穿的。

96
00:06:33,960 --> 00:06:38,620
所以，我们刚收到这个家伙发来的邮件，他在我们的程序中，发现了一个错误。

97
00:06:38,620 --> 00:06:41,240
他甚至用它提供了漏洞概念的证据。

98
00:06:41,240 --> 00:06:45,600
现在，我们想知道为什么会发生这种情况，以及如何发生，这样我们就才可以解决它了。

99
00:06:45,600 --> 00:06:49,040
报告说，它与strcpy有关。

100
00:06:49,040 --> 00:06:51,010
所以，我们要读一下，关于strcpy的手册。

101
00:06:51,010 --> 00:06:55,530
"噢，曹"，才意识到我们甚至没有阅读相关文档。哈哈

102
00:06:55,530 --> 00:06:58,040
文档，因为会告诉我们有哪些糟糕的用法事项。

103
00:06:58,040 --> 00:06:59,830
现在，我们可以解决这个问题了。

104
00:06:59,830 --> 00:07:05,080
例如，在复制之前，使用strncpy或使用strlen检查长度，

105
00:07:05,080 --> 00:07:06,910
然后，退出。

106
00:07:06,910 --> 00:07:11,180
但是因为我们是一个优秀的开发人员，所以我们试图从这个建议中，

107
00:07:11,180 --> 00:07:13,070
学习并理解该漏洞是如何工作的。

108
00:07:13,070 --> 00:07:18,330
在上一个视频，堆 malloc 介绍视频中，

109
00:07:18,330 --> 00:07:20,080
我们已经想过，这个程序中的堆应该是啥样子的。

110
00:07:20,080 --> 00:07:23,160
现在就让我们看看，它在现实中的样子。

111
00:07:23,160 --> 00:07:26,650
为此，我们在每个malloc和strcpy之后，设置一个断点。

112
00:07:26,650 --> 00:07:33,650
我们反汇编 main，并查找所有这些调用，然后设置断点。

113
00:07:33,650 --> 00:07:36,570
然后，我们用概念证明的漏洞参数来运行它。

114
00:07:36,570 --> 00:07:39,120
我们到达了第一个断点。

115
00:07:39,120 --> 00:07:40,210
所以，现在第一个malloc发生了。

116
00:07:40,210 --> 00:07:44,130
所以我们现在处于汇编代码中，malloc 的结果 在eax中。

117
00:07:44,130 --> 00:07:49,330
所以，eax包含堆上的地址，在那里我们有足够的空间

118
00:07:49,330 --> 00:07:50,330
给 Internet结构 i1 使用。

119
00:07:50,330 --> 00:07:54,930
我们可以看到这个地址，它只是0。

120
00:07:54,930 --> 00:07:59,840
使用info proc 映射，我们可以看到内存段，

121
00:07:59,840 --> 00:08:01,570
还有堆，我们可以看看那个。

122
00:08:01,570 --> 00:08:08,110
哦，也许把这个堆输出，添加为gdb挂钩，也是个好主意。

123
00:08:08,110 --> 00:08:11,470
所以，我们就能在每个断点，自动看到它。

124
00:08:11,470 --> 00:08:15,500
define hook-stop x/64wx 0x

125
00:08:15,500 --> 00:08:16,690
结束

126
00:08:16,690 --> 00:08:25,210
因此，如果我们现在继续，我们应该将 i1 的 priority 设置为1，然后将 malloc 设置为 name。

127
00:08:25,210 --> 00:08:27,960
让我们仔细看看，这个堆。

128
00:08:27,960 --> 00:08:31,330
所以，根据我们学过的，i1 变量指向这里。

129
00:08:31,330 --> 00:08:35,740
所以，这就是结构开始的地方，您可以将第一个属性，

130
00:08:35,740 --> 00:08:37,900
也就是 priority 设置为1。

131
00:08:37,899 --> 00:08:42,659
在此之前，我们有堆元数据，区块头，

132
00:08:42,659 --> 00:08:48,339
其中包含块的长度，包括最后一位设置为1，

133
00:08:48,339 --> 00:08:49,339
这意味着前一个块，不是空闲的。

134
00:08:49,339 --> 00:08:50,339
它正在使用中。

135
00:08:50,339 --> 00:08:56,509
我们看到的，正是我们所期望的，我们在这里看到两个8字节的块，

136
00:08:56,509 --> 00:08:59,259
包括 headers，显然是16字节。

137
00:08:59,260 --> 00:09:04,290
我们可以做的另一件很酷的事情是，在gdb中定义一个变量i1，

138
00:09:04,290 --> 00:09:05,420
并将其设置为这个对象的地址

139
00:09:05,420 --> 00:09:09,990
我们甚至可以添加这个变量的类型，也就是“struct internet”。

140
00:09:09,990 --> 00:09:15,320
现在，我们可以打印这个变量i1，gdb可以显示属性 priority和

141
00:09:15,319 --> 00:09:16,319
name。

142
00:09:16,319 --> 00:09:21,179
我们可以看到 priority 是1， name 仍然是零，这是因为，虽然我们已经为 name 分配了内存，

143
00:09:21,180 --> 00:09:24,860
但尚未分配 i1属性名 给它。

144
00:09:24,860 --> 00:09:30,580
如果，我们继续到下一个断点，name 的地址得到分配，

145
00:09:30,580 --> 00:09:32,190
i2对象也得到分配。

146
00:09:32,189 --> 00:09:37,639
malloc的结果，再次出现在eax中，这就是 i2 对象的地址。

147
00:09:37,639 --> 00:09:40,149
所以我们也可以在gdb中，定义变量 i2。

148
00:09:40,149 --> 00:09:43,029
当我们打印出来的时候，我们可以看到它，仍然是空的。

149
00:09:43,029 --> 00:09:50,109
现在，如果我们继续，i2 的 priority 应该设置为2，我们可以通过查看堆内存，

150
00:09:50,110 --> 00:09:55,430
或我们打印i2 对象，来验证。

151
00:09:55,430 --> 00:09:59,500
我们的4个malloc，现在都完成了。

152
00:09:59,500 --> 00:10:03,820
如果我们将其与之前视频中的预期，进行比较，

153
00:10:03,819 --> 00:10:05,049
我们会发现它完美符合

154
00:10:05,050 --> 00:10:11,390
只有一件事我们还没有讨论过，

155
00:10:11,389 --> 00:10:13,719
那就是在最后的所有块之外，有个大的值。

156
00:10:13,720 --> 00:10:18,640
这么说，这区域是所有的空闲内存，用漏洞的术语，

157
00:10:18,639 --> 00:10:19,989
经常称为，荒野(wilderness)。

158
00:10:19,990 --> 00:10:23,740
这是数字，表示堆，剩余大小。

159
00:10:23,740 --> 00:10:29,170
这整个东西，基本上是一个巨大的堆块，这个数字就是它的长度。

160
00:10:29,170 --> 00:10:35,850
我制作了一个由三部分组成的，关于CTF挑战食谱的视频，

161
00:10:35,850 --> 00:10:37,670
其中，有利用此数字，进行代码执行重定向的。

162
00:10:37,670 --> 00:10:38,670
太棒了。

163
00:10:38,670 --> 00:10:40,290
你应该看看。

164
00:10:40,290 --> 00:10:41,290
不管怎样。

165
00:10:41,290 --> 00:10:44,130
现在，i1的 name 仍然是一个空字符串。

166
00:10:44,129 --> 00:10:47,149
但这将随着，下一个断点而改变。

167
00:10:47,149 --> 00:10:51,919
因为，我们要执行第一个strcpy，它首先复制这个超长的

168
00:10:51,920 --> 00:10:52,920
参数。

169
00:10:52,920 --> 00:10:53,920
继续。

170
00:10:53,920 --> 00:10:56,800
现在，我们注意到的第一件事是堆内存中。

171
00:10:56,800 --> 00:11:01,270
这些ASCII字符出现了，看起来它们覆盖了堆的

172
00:11:01,269 --> 00:11:02,269
很多东西。

173
00:11:02,269 --> 00:11:07,809
之前应该是块的头元数据，比如，现在的大小是444444。

174
00:11:07,810 --> 00:11:11,820
让我们看看，对象i1 和i2 。

175
00:11:11,819 --> 00:11:16,409
所以，i1看起来很好，i1仍然具有 priority 1和 name ，以及我们传递给的字符串

176
00:11:16,410 --> 00:11:18,400
它。

177
00:11:18,399 --> 00:11:19,629
i2 怎么样？

178
00:11:19,630 --> 00:11:21,500
呃… 看起来很糟糕。

179
00:11:21,499 --> 00:11:23,109
 Priority 现在是一个巨大的数字。

180
00:11:23,110 --> 00:11:25,900
事实上，小数点后只有454545，这就是很多 E 。

181
00:11:25,899 --> 00:11:26,899
它的名字是46464646，我们知道它是 F。

182
00:11:26,899 --> 00:11:27,899
是的，我们似乎覆盖了，堆中的很多东西。

183
00:11:27,899 --> 00:11:32,039
实际上，我们已经覆盖了，堆中 i1 name 后面的下一个块。

184
00:11:32,040 --> 00:11:37,770
现在下一个strcpy，将采用i2-&gt；name ，它指向一些坏内存，

185
00:11:37,769 --> 00:11:40,049
并尝试把它们复制第二个参数。

186
00:11:40,050 --> 00:11:42,320
真是太棒了。

187
00:11:42,320 --> 00:11:46,130
所以这个挑战，展示了堆漏洞的一个方面。

188
00:11:46,130 --> 00:11:51,070
它不攻击堆算法本身，而是攻击应用程序，程序

189
00:11:51,069 --> 00:11:56,149
会使用在堆上的对象，而我们可以通过重写东西来修改。

190
00:11:56,149 --> 00:11:59,229
然后，这些修改过的对象会弯曲执行流。

191
00:11:59,230 --> 00:11:59,910
很酷，是吧？

