1
00:00:00,170 --> 00:00:04,480
在上一个视频中，我们学习了堆如何工作的一些基本知识，现在我们要应用

2
00:00:04,480 --> 00:00:15,450
这是为了将1级从剥削堆到原始星来解决它。

3
00:00:15,450 --> 00:00:17,320
实际上我想试试。

4
00:00:17,320 --> 00:00:18,460
我们做一些角色扮演。

5
00:00:18,460 --> 00:00:23,220
让我们先做一个安全研究员，他想找到一个可以利用的漏洞

6
00:00:23,220 --> 00:00:24,600
二元的。

7
00:00:24,600 --> 00:00:29,680
之后，我们扮演开发人员的角色，试图理解解决问题的漏洞。

8
00:00:29,680 --> 00:00:36,440
所以我们穿上黑色的连帽衫开始…首先我们在gdb中打开二进制堆1

9
00:00:36,440 --> 00:00:37,500
执行它。

10
00:00:37,499 --> 00:00:38,499
我们得到一个SegFault。

11
00:00:38,499 --> 00:00:43,829
同时也说明SEGCFAULT是由strcpy引起的，因为它试图复制

12
00:00:43,829 --> 00:00:49,539
从地址0到这里的另一个地址0的字符串显然无效

13
00:00:49,539 --> 00:00:51,679
内存-所以它崩溃了。

14
00:00:51,679 --> 00:00:56,699
我们知道Linux二进制文件是如何工作的，所以我们有根据地猜测这个应用程序可能

15
00:00:56,699 --> 00:01:00,369
需要一些输入，我们尝试参数。

16
00:01:00,369 --> 00:01:03,069
和AAAA一起跑步。

17
00:01:03,069 --> 00:01:07,679
又是另一个segfault，但是细心的观察者会注意到地址现在是

18
00:01:07,680 --> 00:01:13,820
不同，所以这是一个不同的strcpy，它同样不能从地址0复制，所以

19
00:01:13,820 --> 00:01:16,800
我们认为这需要另一个论点。

20
00:01:16,799 --> 00:01:21,359
这一次程序运行无误。

21
00:01:21,360 --> 00:01:26,270
现在我们试图找到一个bug，所以最简单的事情就是，我们只需要抛出一些长的输入

22
00:01:26,270 --> 00:01:29,330
在程序中查看是否发生了什么。

23
00:01:29,329 --> 00:01:34,209
所以对于第一个参数，我选择用字母做一个模式，对于第二个参数

24
00:01:34,210 --> 00:01:38,930
我做数字，只是为了在有事情发生的时候能识别它们。

25
00:01:38,930 --> 00:01:42,250
我们运行它，得到一个不同的segfault。

26
00:01:42,249 --> 00:01:48,109
同样是因为strcpy，但这次目标地址看起来无效。

27
00:01:48,109 --> 00:01:53,039
它试图将带有数字的字符串（我们知道这是第二个参数）复制到

28
00:01:53,040 --> 00:01:57,970
地址46,46,46,46，它是ffff的十六进制代码。

29
00:01:57,969 --> 00:02:03,319
所以不管发生什么，我们以某种方式重写了一个用作目的地的地址

30
00:02:03,319 --> 00:02:04,749
对的。

31
00:02:04,749 --> 00:02:10,649
这意味着我们现在可以使用第一个参数来完全控制我们想写的地方。

32
00:02:10,649 --> 00:02:14,879
通过第二个论点，我们可以完全选择要写什么。

33
00:02:14,879 --> 00:02:18,489
现在我们有了很多自由，我们想要覆盖的东西。

34
00:02:18,489 --> 00:02:23,369
例如，我们可以覆盖堆栈上的返回指针来重定向代码执行，或者

35
00:02:23,370 --> 00:02:28,650
我们可以覆盖全局偏移表的一个条目，我在前面的视频中解释过，

36
00:02:28,650 --> 00:02:29,720
达到同样的效果。

37
00:02:29,720 --> 00:02:34,060
让我们来做后一个，它通常比堆栈更可靠，后者喜欢

38
00:02:34,060 --> 00:02:36,420
四处走动

39
00:02:36,420 --> 00:02:39,960
那么让我们检查一下在邪恶的strcpy之后调用了什么类型的函数。

40
00:02:39,959 --> 00:02:44,109
我们可以到达源代码的峰值，看到有一个printf，我们可以假设

41
00:02:44,110 --> 00:02:47,690
我们想覆盖全局偏移表上的printf，但这是欺骗。

42
00:02:47,689 --> 00:02:48,979
事实并非如此。

43
00:02:48,980 --> 00:02:51,950
所以我们最好还是坚持到大会上吧。

44
00:02:51,950 --> 00:02:56,870
首先，我们要找到的位置是我们打电话给strcpy。

45
00:02:56,870 --> 00:03:01,640
我们可以使用backtrace，它将查看堆栈和存储的返回指针

46
00:03:01,640 --> 00:03:06,750
为了弄清楚我们在哪里——作为旁注，如果你发现了一个破坏堆栈的错误，

47
00:03:06,750 --> 00:03:09,950
那么回溯就不再有什么意义了。

48
00:03:09,950 --> 00:03:11,730
所以它并不总是有效的。

49
00:03:11,730 --> 00:03:18,000
在这里我们可以看到我们现在在Strcpy，但我们来自这个地址。

50
00:03:18,000 --> 00:03:23,680
因此，让我们设置disassemblu风格，使英特尔语法正常，并分解地址。

51
00:03:23,680 --> 00:03:27,380
这将分解这个地址所属的整个函数。

52
00:03:27,380 --> 00:03:31,050
我们的地址以5a结尾，所以我们在strcpy后面。

53
00:03:31,050 --> 00:03:35,600
正如你所看到的，接下来有一个电话要拨。

54
00:03:35,599 --> 00:03:38,139
在源代码中，btw与printf不同。

55
00:03:38,140 --> 00:03:42,820
这是因为编译器出于优化的原因用puts替换了printf。

56
00:03:42,819 --> 00:03:47,359
好的，那么让我们覆盖Puts的全局偏移表条目。

57
00:03:47,360 --> 00:03:52,370
如got视频所示，我们可以通过首先分解找出放置的地址。

58
00:03:52,370 --> 00:03:56,710
过程链接表中的函数trapoline，现在将跳转到一个地址

59
00:03:56,709 --> 00:03:58,759
存储在这个地址。

60
00:03:58,760 --> 00:04:03,260
这意味着这是Puts全局偏移表条目的地址。

61
00:04:03,260 --> 00:04:08,220
所以这是我们要写的目标，所以我们把它放在第一个论点中。

62
00:04:08,219 --> 00:04:14,249
gdb运行，但我们在第一个参数中使用backticks来执行/bin/echo。

63
00:04:14,250 --> 00:04:18,830
正如您所知，echo只输出您作为参数传递给它的任何内容，我们可以使用它

64
00:04:18,830 --> 00:04:21,850
要获取十六进制值的字符，我们不能键入。

65
00:04:21,850 --> 00:04:23,880
例如十六进制值8。

66
00:04:23,880 --> 00:04:29,830
所以echo-ne，-n是因为我们不希望echo在输出的末尾放置新行。

67
00:04:29,830 --> 00:04:35,190
和-e，因为我们希望echo将十六进制转义数转换为原始字符。

68
00:04:35,190 --> 00:04:40,150
为了确保一切正常，我们再次将整个测试字符串回送到fs。

69
00:04:40,150 --> 00:04:45,130
现在将执行backticks中的echo，并将其输出放入

70
00:04:45,130 --> 00:04:46,900
作为第一个参数。

71
00:04:46,900 --> 00:04:53,410
当我们运行这个程序时，会得到和以前一样的segfault，所以一切都很好。

72
00:04:53,410 --> 00:04:57,820
下一步显然是用puts全局偏移表的地址替换fs。

73
00:04:57,820 --> 00:05:02,010
条目。

74
00:05:02,010 --> 00:05:08,880
当我们现在运行它的时候，我们在其他地方得到一个SegFault，这次是因为30303030，它

75
00:05:08,881 --> 00:05:11,481
是ASCII表示0000。

76
00:05:11,480 --> 00:05:16,540
当我们用信息寄存器查看寄存器时，我们可以看到我们成功地得到了

77
00:05:16,540 --> 00:05:23,280
控制EIP，这意味着我们现在可以将代码重定向到我们想要的任何地方。

78
00:05:23,280 --> 00:05:27,980
在这种情况下，我们要打电话给Winner，Winner在这里有这个地址。

79
00:05:27,980 --> 00:05:34,430
所以我们把它放在第二个参数中，而不是argv2中，在backticks中使用echo。

80
00:05:34,430 --> 00:05:38,810
我们执行它，我们就获得了胜利。

81
00:05:38,810 --> 00:05:42,880
它在gdb之外也很有效。

82
00:05:42,880 --> 00:05:47,160
总之，我们可以这样说：我们通过猜测和玩来识别一个bug

83
00:05:47,160 --> 00:05:48,310
围绕着它。

84
00:05:48,310 --> 00:05:53,600
通过gdb，我们了解到我们可以通过某种方式控制strcpy的目的地，并且我们

85
00:05:53,600 --> 00:05:56,660
学会了我们甚至控制我们想要复制的东西。

86
00:05:56,660 --> 00:06:02,380
我们滥用它来覆盖puts的函数地址来重定向代码执行。

87
00:06:02,380 --> 00:06:04,310
到Winner函数。

88
00:06:04,310 --> 00:06:09,000
都不知道为什么会发生这种情况，甚至不知道涉及堆

89
00:06:09,000 --> 00:06:11,020
完全。

90
00:06:11,020 --> 00:06:16,300
作为一名优秀的安全研究员，我们为此撰写了一份报告和建议。

91
00:06:16,300 --> 00:06:19,900
提供概念验证利用以及一些可能

92
00:06:19,900 --> 00:06:22,250
帮助开发者。

93
00:06:22,250 --> 00:06:28,580
现在让我们改变立场，成为开发者。

94
00:06:28,580 --> 00:06:32,180
我们脱下黑色的连帽衫，穿上灰色的连帽衫。

95
00:06:32,180 --> 00:06:33,960
因为开发人员就是这么穿的。

96
00:06:33,960 --> 00:06:38,620
所以我们刚收到这个家伙发来的邮件，他在我们的程序中发现了一个错误。

97
00:06:38,620 --> 00:06:41,240
他甚至用它提供了概念利用的证据。

98
00:06:41,240 --> 00:06:45,600
现在我们想知道为什么会发生这种情况，以及如何发生，这样我们就可以解决它了。

99
00:06:45,600 --> 00:06:49,040
在公告中，它说它与strcpy有关。

100
00:06:49,040 --> 00:06:51,010
所以我们读了关于strcpy的手册。

101
00:06:51,010 --> 00:06:55,530
当我们意识到我们甚至没有阅读文档时，就有了这个“噢，该死的”时刻。

102
00:06:55,530 --> 00:06:58,040
那会告诉我们这是个多么糟糕的主意。

103
00:06:58,040 --> 00:06:59,830
现在我们可以解决这个问题了。

104
00:06:59,830 --> 00:07:05,080
例如，在复制之前使用strncpy或使用strlen检查长度，然后

105
00:07:05,080 --> 00:07:06,910
出口。

106
00:07:06,910 --> 00:07:11,180
但是因为我们是一个优秀的开发人员，所以我们试图从这个建议中学习并理解

107
00:07:11,180 --> 00:07:13,070
该漏洞是如何工作的。

108
00:07:13,070 --> 00:07:18,330
在上一个视频，堆malloc介绍视频中，我们已经考虑了堆

109
00:07:18,330 --> 00:07:20,080
从这个程序中应该是这样的。

110
00:07:20,080 --> 00:07:23,160
让我们看看它在现实中的样子。

111
00:07:23,160 --> 00:07:26,650
为此，我们在每个malloc和strcpy之后设置一个断点。

112
00:07:26,650 --> 00:07:33,650
我们分解main并查找所有这些调用，然后设置断点。

113
00:07:33,650 --> 00:07:36,570
然后我们用概念证明来运行它，利用论点。

114
00:07:36,570 --> 00:07:39,120
我们到达了第一个断点。

115
00:07:39,120 --> 00:07:40,210
所以现在第一个malloc发生了。

116
00:07:40,210 --> 00:07:44,130
所以我们现在在汇编代码中，malloc的结果在eax中。

117
00:07:44,130 --> 00:07:49,330
所以eax包含堆上的地址，在那里我们有足够的空间用于Internet结构

118
00:07:49,330 --> 00:07:50,330
I1.

119
00:07:50,330 --> 00:07:54,930
我们可以看到这个地址，它只是0。

120
00:07:54,930 --> 00:07:59,840
使用info-proc映射，我们可以看到内存段，还有堆和

121
00:07:59,840 --> 00:08:01,570
可以看看那个。

122
00:08:01,570 --> 00:08:08,110
哦，也许把这个堆输出添加为gdb挂钩也是个好主意。

123
00:08:08,110 --> 00:08:11,470
所以我们会在每个断点自动看到它。

124
00:08:11,470 --> 00:08:15,500
定义挂钩停止X/64WX 0x

125
00:08:15,500 --> 00:08:16,690
结束

126
00:08:16,690 --> 00:08:25,210
因此，如果我们现在继续，我们应该将I1的优先级设置为1，然后将malloc设置为名称。

127
00:08:25,210 --> 00:08:27,960
让我们仔细看看这个堆。

128
00:08:27,960 --> 00:08:31,330
所以我们在这里学习了I1变量点。

129
00:08:31,330 --> 00:08:35,740
所以这就是结构开始的地方，您可以将第一个属性

130
00:08:35,740 --> 00:08:37,900
优先级设置为1。

131
00:08:37,899 --> 00:08:42,659
在此之前，我们有堆元数据，即块头，其中包含

132
00:08:42,659 --> 00:08:48,339
包括最后一位设置为1，这意味着前一个块

133
00:08:48,339 --> 00:08:49,339
不是免费的。

134
00:08:49,339 --> 00:08:50,339
它正在使用中。

135
00:08:50,339 --> 00:08:56,509
我们看到的是我们所期望的，我们在这里看到两个8字节的块，包括

136
00:08:56,509 --> 00:08:59,259
头，显然是16字节。

137
00:08:59,260 --> 00:09:04,290
我们可以做的另一件很酷的事情是在gdb中定义一个变量i1并将其设置为地址

138
00:09:04,290 --> 00:09:05,420
这个物体的

139
00:09:05,420 --> 00:09:09,990
aa我们甚至可以添加这个变量的类型“struct internet”。

140
00:09:09,990 --> 00:09:15,320
现在我们可以打印这个变量i1，gdb可以显示属性priority和

141
00:09:15,319 --> 00:09:16,319
姓名。

142
00:09:16,319 --> 00:09:21,179
我们可以看到优先级是1，名称仍然是零，因为我们已经分配了内存

143
00:09:21,180 --> 00:09:24,860
但尚未将其分配给i1属性名。

144
00:09:24,860 --> 00:09:30,580
如果我们继续到下一个断点，将分配名称的地址和I2

145
00:09:30,580 --> 00:09:32,190
对象已分配。

146
00:09:32,189 --> 00:09:37,639
malloc的结果再次出现在eax中，这就是i2对象的地址。

147
00:09:37,639 --> 00:09:40,149
所以我们也可以在gdb中定义变量i2。

148
00:09:40,149 --> 00:09:43,029
当我们打印的时候，我们可以看到它仍然是空的。

149
00:09:43,029 --> 00:09:50,109
现在，如果我们继续，I2的优先级应该设置为2，我们可以通过查看来验证

150
00:09:50,110 --> 00:09:55,430
当我们打印I2对象的时候，也在堆内存中。

151
00:09:55,430 --> 00:09:59,500
我们的4个malloc现在都完成了。

152
00:09:59,500 --> 00:10:03,820
如果我们将其与之前视频中的预期进行比较，我们会发现它符合

153
00:10:03,819 --> 00:10:05,049
完美。

154
00:10:05,050 --> 00:10:11,390
只有一件事我们还没有讨论过，那就是在

155
00:10:11,389 --> 00:10:13,719
最后的所有块。

156
00:10:13,720 --> 00:10:18,640
好吧，下面这个区域是所有的空闲内存，用剥削的术语来说，这经常被提到

157
00:10:18,639 --> 00:10:19,989
像荒野一样。

158
00:10:19,990 --> 00:10:23,740
这是数字，是堆的剩余大小。

159
00:10:23,740 --> 00:10:29,170
这整个东西基本上是一个巨大的堆块，这个数字就是它的长度。

160
00:10:29,170 --> 00:10:35,850
我制作了一个由三部分组成的关于CTF挑战食谱的视频，其中利用了滥用

161
00:10:35,850 --> 00:10:37,670
此数字用于重定向代码执行。

162
00:10:37,670 --> 00:10:38,670
太棒了。

163
00:10:38,670 --> 00:10:40,290
你应该看看。

164
00:10:40,290 --> 00:10:41,290
不管怎样。

165
00:10:41,290 --> 00:10:44,130
现在，i1的名称仍然是一个空字符串。

166
00:10:44,129 --> 00:10:47,149
但这将随着下一个断点而改变。

167
00:10:47,149 --> 00:10:51,919
因为我们要执行第一个strcpy，它首先复制这个超长的

168
00:10:51,920 --> 00:10:52,920
争论。

169
00:10:52,920 --> 00:10:53,920
继续。

170
00:10:53,920 --> 00:10:56,800
现在我们注意到的第一件事是堆内存中。

171
00:10:56,800 --> 00:11:01,270
这些ASCII字符出现了，看起来它们覆盖了很多stuf

172
00:11:01,269 --> 00:11:02,269
堆。

173
00:11:02,269 --> 00:11:07,809
之前应该是块头元数据，比如现在的大小是444444。

174
00:11:07,810 --> 00:11:11,820
让我们看看对象I1和I2。

175
00:11:11,819 --> 00:11:16,409
所以i1看起来很好，i1仍然具有优先级1和名称以及我们传递给的字符串

176
00:11:16,410 --> 00:11:18,400
它。

177
00:11:18,399 --> 00:11:19,629
I2怎么样？

178
00:11:19,630 --> 00:11:21,500
呃……看起来他妈的。

179
00:11:21,499 --> 00:11:23,109
优先权现在是一个巨大的数字。

180
00:11:23,110 --> 00:11:25,900
事实上，小数点后只有454545，这就是es。

181
00:11:25,899 --> 00:11:26,899
它的名字是46464646，我们知道它是fs。

182
00:11:26,899 --> 00:11:27,899
是的，我们似乎覆盖了堆中的很多东西。

183
00:11:27,899 --> 00:11:32,039
实际上，我们已经覆盖了堆中I1名称后面的下一个块。

184
00:11:32,040 --> 00:11:37,770
现在下一个strcpy将采用i2-&gt；名称，它指向一些坏内存并尝试

185
00:11:37,769 --> 00:11:40,049
复制第二个参数。

186
00:11:40,050 --> 00:11:42,320
真是太棒了。

187
00:11:42,320 --> 00:11:46,130
所以这个挑战展示了堆利用的一个方面。

188
00:11:46,130 --> 00:11:51,070
它不攻击堆算法本身，而是攻击使用对象的应用程序

189
00:11:51,069 --> 00:11:56,149
在堆上，我们可以通过重写东西来修改。

190
00:11:56,149 --> 00:11:59,229
然后这些修改过的对象会弯曲执行流。

191
00:11:59,230 --> 00:11:59,910
很酷，是吧？

