1
00:00:00,170 --> 00:00:04,480
在上一个视频中，我们学习了堆如何工作的一些基本知识，现在我们要应用

2
00:00:04,480 --> 00:00:15,450
this to heap level 1 from exploit-exercsies protostar to solve it.

3
00:00:15,450 --> 00:00:17,320
Actually I want try something.

4
00:00:17,320 --> 00:00:18,460
We do some roleplaying.

5
00:00:18,460 --> 00:00:23,220
让我们先做一个安全研究员，他想找到一个可以利用的漏洞

6
00:00:23,220 --> 00:00:24,600
binary.

7
00:00:24,600 --> 00:00:29,680
Afterwards we play developer trying to understand the exploit to fix the issue.

8
00:00:29,680 --> 00:00:36,440
所以我们穿上黑色的连帽衫开始……首先我们在gdb中打开binary heap1，然后

9
00:00:36,440 --> 00:00:37,500
execute it.

10
00:00:37,499 --> 00:00:38,499
We get a segfault.

11
00:00:38,499 --> 00:00:43,829
同时也说明SEGCFAULT是由strcpy引起的，因为它试图复制

12
00:00:43,829 --> 00:00:49,539
从地址0到这里的另一个地址0的字符串显然无效

13
00:00:49,539 --> 00:00:51,679
memory - so it crashes.

14
00:00:51,679 --> 00:00:56,699
我们知道Linux二进制文件是如何工作的，所以我们有根据地猜测这个应用程序可能

15
00:00:56,699 --> 00:01:00,369
require some input and we try the arguments.

16
00:01:00,369 --> 00:01:03,069
Run with aaaa.

17
00:01:03,069 --> 00:01:07,679
又是另一个segfault，但是细心的观察者会注意到地址现在是

18
00:01:07,680 --> 00:01:13,820
不同，所以这是一个不同的strcpy，它同样不能从地址0复制，所以

19
00:01:13,820 --> 00:01:16,800
we guess that it requires another argument.

20
00:01:16,799 --> 00:01:21,359
And this time the program runs through without errors.

21
00:01:21,360 --> 00:01:26,270
现在我们试图找到一个bug，所以最简单的事情就是，我们只需要抛出一些长的输入

22
00:01:26,270 --> 00:01:29,330
at the program and see if something happens.

23
00:01:29,329 --> 00:01:34,209
所以对于第一个参数，我选择用字母做一个模式，对于第二个参数

24
00:01:34,210 --> 00:01:38,930
I do numbers, just so I could idnetify them if something would occur.

25
00:01:38,930 --> 00:01:42,250
We run that, and we got a different segfault.

26
00:01:42,249 --> 00:01:48,109
Again because of strcpy, but this time the destination address looks invalid.

27
00:01:48,109 --> 00:01:53,039
它试图将带有数字的字符串（我们知道这是第二个参数）复制到

28
00:01:53,040 --> 00:01:57,970
address 46,46,46,46 which is the hexcode for FFFF.

29
00:01:57,969 --> 00:02:03,319
所以不管发生什么，我们以某种方式重写了一个用作目的地的地址

30
00:02:03,319 --> 00:02:04,749
of the strcpy.

31
00:02:04,749 --> 00:02:10,649
And this means we can now use the first argument to fully control where we want to write.

32
00:02:10,649 --> 00:02:14,879
And we can fully choose what to write, with the second argument.

33
00:02:14,879 --> 00:02:18,489
Now we have a lot of freedom what we want to overwrite.

34
00:02:18,489 --> 00:02:23,369
例如，我们可以覆盖堆栈上的返回指针来重定向代码执行，或者

35
00:02:23,370 --> 00:02:28,650
我们可以覆盖全局偏移表的一个条目，我在前面的视频中解释过，

36
00:02:28,650 --> 00:02:29,720
to achieve the same.

37
00:02:29,720 --> 00:02:34,060
让我们来做后一个，它通常比堆栈更可靠，后者喜欢

38
00:02:34,060 --> 00:02:36,420
to move around.

39
00:02:36,420 --> 00:02:39,960
So let’s check what kind of function is called after the evil strcpy.

40
00:02:39,959 --> 00:02:44,109
我们可以到达源代码的峰值，看到有一个printf，我们可以假设

41
00:02:44,110 --> 00:02:47,690
we want to overwrite printf on the global offset table, but that is deceiving.

42
00:02:47,689 --> 00:02:48,979
That’s not the case.

43
00:02:48,980 --> 00:02:51,950
So let’s better stick to the assembly.

44
00:02:51,950 --> 00:02:56,870
First of all we have to find the location from were we were calling the strcpy.

45
00:02:56,870 --> 00:03:01,640
我们可以使用backtrace，它将查看堆栈和存储的返回指针

46
00:03:01,640 --> 00:03:06,750
为了弄清楚我们在哪里——作为旁注，如果你发现了一个破坏堆栈的错误，

47
00:03:06,750 --> 00:03:09,950
then backtrace can not make much sense of it anymore.

48
00:03:09,950 --> 00:03:11,730
So it doesn’t always work.

49
00:03:11,730 --> 00:03:18,000
And here we can see that currently we are in strcpy, but we were coming from this address.

50
00:03:18,000 --> 00:03:23,680
So let’s set the disassemblu flavor to sane intel syntax and disasemble the address.

51
00:03:23,680 --> 00:03:27,380
This will now disassemble the whole function this address belongs to.

52
00:03:27,380 --> 00:03:31,050
Our address ended in 5a, so we are here after the strcpy.

53
00:03:31,050 --> 00:03:35,600
And as you can see there is a call to puts next.

54
00:03:35,599 --> 00:03:38,139
Which btw is not printf like in the source code.

55
00:03:38,140 --> 00:03:42,820
That’s because the compiler replaced the printf with puts for optimization reasons.

56
00:03:42,819 --> 00:03:47,359
Ok, so let’s overwrite the global offset table entry for puts.

57
00:03:47,360 --> 00:03:52,370
如got视频所示，我们可以通过首先分解找出放置的地址。

58
00:03:52,370 --> 00:03:56,710
过程链接表中的函数trapoline，现在将跳转到一个地址

59
00:03:56,709 --> 00:03:58,759
stored at this address.

60
00:03:58,760 --> 00:04:03,260
So this means this is the address of the puts global offset table entry.

61
00:04:03,260 --> 00:04:08,220
So this is the target we want to write to, thus we place it in the first argument.

62
00:04:08,219 --> 00:04:14,249
gdb run, but we use backticks in the first argument to execute /bin/echo.

63
00:04:14,250 --> 00:04:18,830
正如您所知，echo只输出您作为参数传递给它的任何内容，我们可以使用它

64
00:04:18,830 --> 00:04:21,850
to get characters with hexvalues we can’t type.

65
00:04:21,850 --> 00:04:23,880
For example the hex value 8.

66
00:04:23,880 --> 00:04:29,830
所以echo-ne，-n是因为我们不希望echo在输出的末尾放置新行。

67
00:04:29,830 --> 00:04:35,190
and -e because we want echo to convert hex escaped numbers into the raw characters.

68
00:04:35,190 --> 00:04:40,150
Just to make sure everything works we echo the whole test string up to the Fs again.

69
00:04:40,150 --> 00:04:45,130
现在将执行backticks中的echo，并将其输出放入

70
00:04:45,130 --> 00:04:46,900
of the quotes as the first argument.

71
00:04:46,900 --> 00:04:53,410
And when we run this we get the same segfault as before, so all is fine.

72
00:04:53,410 --> 00:04:57,820
下一步显然是用puts全局偏移表的地址替换fs。

73
00:04:57,820 --> 00:05:02,010
entry.

74
00:05:02,010 --> 00:05:08,880
当我们现在运行它的时候，我们在其他地方得到一个SegFault，这次是因为30303030，它

75
00:05:08,881 --> 00:05:11,481
is ascii for 0000.

76
00:05:11,480 --> 00:05:16,540
当我们用信息寄存器查看寄存器时，我们可以看到我们成功地得到了

77
00:05:16,540 --> 00:05:23,280
control of EIP, which means we can now redirect code anywhere we want.

78
00:05:23,280 --> 00:05:27,980
In this case we want to call winner, winner has this address here.

79
00:05:27,980 --> 00:05:34,430
So we place that into the second argument instead of argv2 by using echo in backticks.

80
00:05:34,430 --> 00:05:38,810
We execute it and we get winner.

81
00:05:38,810 --> 00:05:42,880
Which also works great outside of gdb.

82
00:05:42,880 --> 00:05:47,160
总之，我们可以这样说：我们通过猜测和玩来识别一个bug

83
00:05:47,160 --> 00:05:48,310
around with it.

84
00:05:48,310 --> 00:05:53,600
通过gdb，我们了解到我们可以通过某种方式控制strcpy的目的地，并且我们

85
00:05:53,600 --> 00:05:56,660
learned we even control what we want to copy.

86
00:05:56,660 --> 00:06:02,380
我们滥用它来覆盖puts的函数地址来重定向代码执行。

87
00:06:02,380 --> 00:06:04,310
to the winner function.

88
00:06:04,310 --> 00:06:09,000
都不知道为什么会发生这种情况，甚至不知道涉及堆

89
00:06:09,000 --> 00:06:11,020
at all.

90
00:06:11,020 --> 00:06:16,300
Being a good security researcher we create a writeup, an advisory for this.

91
00:06:16,300 --> 00:06:19,900
提供概念验证利用以及一些可能

92
00:06:19,900 --> 00:06:22,250
help the developer.

93
00:06:22,250 --> 00:06:28,580
Now let’s change sides and become the developer.

94
00:06:28,580 --> 00:06:32,180
We take off our black hoodie, and put on our grey hoodie.

95
00:06:32,180 --> 00:06:33,960
Because that's what developers wear.

96
00:06:33,960 --> 00:06:38,620
So we just got this email from this dude who found a bug in our program.

97
00:06:38,620 --> 00:06:41,240
He even provided a Proof of Concept exploit with it.

98
00:06:41,240 --> 00:06:45,600
Now we want to figure out why and how this happened, so we can fix it.

99
00:06:45,600 --> 00:06:49,040
In the advisory it says that it has to do something with strcpy.

100
00:06:49,040 --> 00:06:51,010
So we read the manual about strcpy.

101
00:06:51,010 --> 00:06:55,530
当我们意识到我们甚至没有阅读文档时，就有了这个“噢，该死的”时刻。

102
00:06:55,530 --> 00:06:58,040
that would have told us what a bad idea that was.

103
00:06:58,040 --> 00:06:59,830
So now we could fix that.

104
00:06:59,830 --> 00:07:05,080
例如，在复制之前使用strncpy或使用strlen检查长度，然后

105
00:07:05,080 --> 00:07:06,910
exit.

106
00:07:06,910 --> 00:07:11,180
但是因为我们是一个优秀的开发人员，所以我们试图从这个建议中学习并理解

107
00:07:11,180 --> 00:07:13,070
how the exploit exactly works.

108
00:07:13,070 --> 00:07:18,330
在上一个视频，堆malloc介绍视频中，我们已经考虑了堆

109
00:07:18,330 --> 00:07:20,080
should look like from this program.

110
00:07:20,080 --> 00:07:23,160
So let’s see how it looks in reality.

111
00:07:23,160 --> 00:07:26,650
To do this let’s set a breakpoint after each malloc and strcpy.

112
00:07:26,650 --> 00:07:33,650
We dissasemble main and look for all those calls and set breakpoints afterwards.

113
00:07:33,650 --> 00:07:36,570
Then we run it with the proof of concept exploit arguments.

114
00:07:36,570 --> 00:07:39,120
And we hit the first breakpoint.

115
00:07:39,120 --> 00:07:40,210
So now the first malloc happened.

116
00:07:40,210 --> 00:07:44,130
So we are currently here in the assembler code and the result of malloc is in eax.

117
00:07:44,130 --> 00:07:49,330
所以eax包含堆上的地址，在那里我们有足够的空间用于Internet结构

118
00:07:49,330 --> 00:07:50,330
i1.

119
00:07:50,330 --> 00:07:54,930
And we can look at this address and we can see it’s simply 0.

120
00:07:54,930 --> 00:07:59,840
使用info-proc映射，我们可以看到内存段，还有堆和

121
00:07:59,840 --> 00:08:01,570
can have a look at that.

122
00:08:01,570 --> 00:08:08,110
Oh, maybe it’s a good idea to add this heap output as a gdb hook as well.

123
00:08:08,110 --> 00:08:11,470
So we see it automatically at each breakpoint.

124
00:08:11,470 --> 00:08:15,500
定义挂钩停止X/64WX 0x

125
00:08:15,500 --> 00:08:16,690
结束

126
00:08:16,690 --> 00:08:25,210
So if we now continue we should set the priority of i1 to 1, and then malloc for the name.

127
00:08:25,210 --> 00:08:27,960
Let’s have a closer look at the heap.

128
00:08:27,960 --> 00:08:31,330
So as we learned the i1 variable points here.

129
00:08:31,330 --> 00:08:35,740
所以这就是结构开始的地方，您可以将第一个属性

130
00:08:35,740 --> 00:08:37,900
the priority is set to 1.

131
00:08:37,899 --> 00:08:42,659
在此之前，我们有堆元数据，即块头，其中包含

132
00:08:42,659 --> 00:08:48,339
包括最后一位设置为1，这意味着前一个块

133
00:08:48,339 --> 00:08:49,339
not free.

134
00:08:49,339 --> 00:08:50,339
It’s in use.

135
00:08:50,339 --> 00:08:56,509
我们看到的是我们所期望的，我们在这里看到两个8字节的块，包括

136
00:08:56,509 --> 00:08:59,259
headers it’s obviously 16 bytes.

137
00:08:59,260 --> 00:09:04,290
我们可以做的另一件很酷的事情是在gdb中定义一个变量i1并将其设置为地址

138
00:09:04,290 --> 00:09:05,420
of this object.

139
00:09:05,420 --> 00:09:09,990
Aaand we can even add the type of this variable which is “struct internet”.

140
00:09:09,990 --> 00:09:15,320
现在我们可以打印这个变量i1，gdb可以显示属性priority和

141
00:09:15,319 --> 00:09:16,319
name.

142
00:09:16,319 --> 00:09:21,179
我们可以看到优先级是1，名称仍然是零，因为我们已经分配了内存

143
00:09:21,180 --> 00:09:24,860
for the name but not yet assigned it to the i1 attribute name.

144
00:09:24,860 --> 00:09:30,580
如果我们继续到下一个断点，将分配名称的地址和I2

145
00:09:30,580 --> 00:09:32,190
object got allocated.

146
00:09:32,189 --> 00:09:37,639
And the result of malloc is again in eax, that’s the address of the i2 object.

147
00:09:37,639 --> 00:09:40,149
So we can also define the variable i2 in gdb.

148
00:09:40,149 --> 00:09:43,029
And when we print that we can see that it’s still empty.

149
00:09:43,029 --> 00:09:50,109
现在，如果我们继续，I2的优先级应该设置为2，我们可以通过查看来验证

150
00:09:50,110 --> 00:09:55,430
at the heap memory as well when we print the i2 object.

151
00:09:55,430 --> 00:09:59,500
Also all of our 4 mallocs are done now.

152
00:09:59,500 --> 00:10:03,820
如果我们将其与之前视频中的预期进行比较，我们会发现它符合

153
00:10:03,819 --> 00:10:05,049
perfectly.

154
00:10:05,050 --> 00:10:11,390
只有一件事我们还没有讨论过，那就是在

155
00:10:11,389 --> 00:10:13,719
all chunks at the end.

156
00:10:13,720 --> 00:10:18,640
好吧，下面这个区域是所有的空闲内存，用剥削的术语来说，这经常被提到

157
00:10:18,639 --> 00:10:19,989
to as the wilderness.

158
00:10:19,990 --> 00:10:23,740
This is number is the remaining size of the heap.

159
00:10:23,740 --> 00:10:29,170
This whole thing is basically a huge heap chunk, and that number is its length.

160
00:10:29,170 --> 00:10:35,850
我制作了一个由三部分组成的关于CTF挑战食谱的视频，其中利用了滥用

161
00:10:35,850 --> 00:10:37,670
this number to redirect code execution.

162
00:10:37,670 --> 00:10:38,670
It’s super awesome.

163
00:10:38,670 --> 00:10:40,290
You should watch it.

164
00:10:40,290 --> 00:10:41,290
Anyway.

165
00:10:41,290 --> 00:10:44,130
Right now the name of i1 is still an empty string.

166
00:10:44,129 --> 00:10:47,149
But this is about to change with the next breakpoint.

167
00:10:47,149 --> 00:10:51,919
因为我们要执行第一个strcpy，它首先复制这个超长的

168
00:10:51,920 --> 00:10:52,920
argument.

169
00:10:52,920 --> 00:10:53,920
Continue.

170
00:10:53,920 --> 00:10:56,800
Now first thing we notice is here in the heap memory.

171
00:10:56,800 --> 00:11:01,270
这些ASCII字符出现了，看起来它们覆盖了很多stuf

172
00:11:01,269 --> 00:11:02,269
the heap.

173
00:11:02,269 --> 00:11:07,809
What earlier was supposed to be chunk header metadata, like the size is now 44444444.

174
00:11:07,810 --> 00:11:11,820
Let’s have a look at the objects i1 and i2.

175
00:11:11,819 --> 00:11:16,409
所以i1看起来很好，i1仍然具有优先级1和名称以及我们传递给的字符串

176
00:11:16,410 --> 00:11:18,400
it.

177
00:11:18,399 --> 00:11:19,629
I2怎么样？

178
00:11:19,630 --> 00:11:21,500
Uh… that looks fucked.

179
00:11:21,499 --> 00:11:23,109
Priority is now a super huge number.

180
00:11:23,110 --> 00:11:25,900
In fact that’s just 45454545 in decimal, and that’s the Es.

181
00:11:25,899 --> 00:11:26,899
And the name is 46464646, which we know are Fs.

182
00:11:26,899 --> 00:11:27,899
And yeah, we seem to have overwritten a lot of stuff on the heap.

183
00:11:27,899 --> 00:11:32,039
Infact we have overwritten the next chunk on the heap after the i1 name.

184
00:11:32,040 --> 00:11:37,770
现在下一个strcpy将采用i2-&gt；名称，它指向一些坏内存并尝试

185
00:11:37,769 --> 00:11:40,049
to copy there the 2nd argument.

186
00:11:40,050 --> 00:11:42,320
Really frckn awesome.

187
00:11:42,320 --> 00:11:46,130
So this challenge showed one aspect of heap exploits.

188
00:11:46,130 --> 00:11:51,070
它不攻击堆算法本身，而是攻击使用对象的应用程序

189
00:11:51,069 --> 00:11:56,149
on the heap that we can modify by overwriting stuff.

190
00:11:56,149 --> 00:11:59,229
And those modified objects then bend the execution flow.

191
00:11:59,230 --> 00:11:59,910
很酷，是吧？

