1
00:00:06,910 --> 00:00:12,780
在这段视频中，我们又进行了一次旅行反转C程序。具体来说，我们会

2
00:00:12,780 --> 00:00:18,580
讨论全局偏移表（简称got）和过程链接表（简称

3
00:00:18,580 --> 00:00:19,580
PLT）。

4
00:00:19,580 --> 00:00:24,660
我们先创建一个非常简单的C只调用两个libc函数的程序。

5
00:00:24,660 --> 00:00:30,120
所以我只写了两个printfs和一个出口。这些两个功能显然是外部功能，

6
00:00:30,119 --> 00:00:35,799
我自己还没有定义。而且他们来自libc。当我编译这个二进制文件时

7
00:00:35,800 --> 00:00:42,850
使用gcc，libc将动态链接到这个二进制。这意味着libc不是

8
00:00:42,850 --> 00:00:48,710
包括在程序中。用"ldd"我们可以查看引用的动态库

9
00:00:48,710 --> 00:00:54,560
这个二进制文件显示它想要libc，它还显示了我系统上的路径

10
00:00:54,559 --> 00:01:00,449
我的libc二进制文件在哪里。这很好，因为那么程序可以小得多，而且

11
00:01:00,449 --> 00:01:04,789
libc可以接收更新而无需重新编译我的二进制文件。

12
00:01:04,790 --> 00:01:10,860
但这也意味着libc对于每个版本可能是不同的。

13
00:01:10,860 --> 00:01:16,450
那么我怎样才能把一个二进制编译成汇编程序呢？当我必须知道确切的地址时，所以我

14
00:01:16,450 --> 00:01:22,270
可以创建调用指令吗？嗯，这是PLT和开始发挥作用的地方。

15
00:01:22,270 --> 00:01:28,000
让我们在漏斗拆卸器中打开这个二进制文件。让我们来看一下main 函数。

16
00:01:28,000 --> 00:01:32,940
所以我们首先注意到的是我们的printfs（）是吗？为什么有puts（）调用？

17
00:01:32,940 --> 00:01:37,150
拆卸器看到了我们指定的常量字符串，而不是动态格式字符串，

18
00:01:37,150 --> 00:01:42,270
因此决定用Puts替换printf。但不管怎样，我们这里有三个功能

19
00:01:42,270 --> 00:01:47,340
电话和Hopper决定给名字加前缀呼叫地点的J，可能是

20
00:01:47,340 --> 00:01:51,160
跳跃。不确定。所以如果我们接这个电话，我们注意到

21
00:01:51,160 --> 00:01:58,060
我们不会以libc-puts结尾。我们依然在我们的二进制中。我们会怎么做，因为

22
00:01:58,060 --> 00:02:05,830
libc不包含在此二进制文件中。我们着陆了在PLT部分。流程链接表。

23
00:02:05,830 --> 00:02:13,090
这里的电话马上就接通了跳到另一个地址

24
00:02:13,090 --> 00:02:20,490
位置。这个地方有名字得了。我们去那儿吧。

25
00:02:20,490 --> 00:02:26,940
现在我们进入了一个叫做got的部分。全球偏移表。跳跃会跳到任何地方

26
00:02:26,940 --> 00:02:32,420
地址存储在这里。现在存储在此处的地址正在引用

27
00:02:32,420 --> 00:02:38,670
外部符号。所以…他们在这里干什么？

28
00:02:38,670 --> 00:02:43,780
在汇编过程中我们不知道地址看跌期权或退出期权。所以我们只创建一个函数

29
00:02:43,780 --> 00:02:50,930
蹦床。我们呼叫一个我们知道在哪的地点它是PLT部分。其中包含一个跳转

30
00:02:50,930 --> 00:02:56,430
从这里引用跳转位置列表（或表，如果需要的话）。我们拥有的一切

31
00:02:56,430 --> 00:03:02,250
做，能够使用外部功能从图书馆，不知何故写的是

32
00:03:02,250 --> 00:03:06,940
此表中libc函数的地址。这就是我们执行的过程

33
00:03:06,940 --> 00:03:12,840
二进制。正如你现在所知道的，一个精灵二进制不仅仅是简单的汇编代码。在我们之前

34
00:03:12,840 --> 00:03:20,060
执行代码，复杂的ELF格式分析并基于该过程

35
00:03:20,060 --> 00:03:25,360
由内核设置。在那段时间里这样的引用可能会得到解决。

36
00:03:25,360 --> 00:03:30,500
所以让我们调试这个二进制文件。让我们使用这次是漏斗。首先我们设置一个断点

37
00:03:30,500 --> 00:03:37,540
单击中的红色列右行。然后我们打开调试器界面

38
00:03:37,540 --> 00:03:43,630
在右上角有一个按钮。所以让我们向前一步，直到我们按照puts（）的调用操作。

39
00:03:43,630 --> 00:03:49,860
如预期，我们到达PLT区，并且就要跳到引用的地址

40
00:03:49,860 --> 00:03:55,730
在全局偏移表中。让我们更进一步让我们看看会发生什么。哦……不。

41
00:03:55,730 --> 00:04:00,860
我们不去写libc。不知何故我们在跳跃后立即结束并推一个值

42
00:04:00,860 --> 00:04:04,840
现在在堆栈上。正如你看到的每一个PLT条目，也为我们的

43
00:04:04,840 --> 00:04:09,380
exit（）函数，我们有一个数字的推进(push)然后跳到上面这个地址。和

44
00:04:09,381 --> 00:04:14,541
当我们跟随这个跳跃时，我们最终得到一个函数调用了运行时解析。

45
00:04:14,540 --> 00:04:18,530
我们可以使用proc文件系统查看此进程的内存映射，然后

46
00:04:18,530 --> 00:04:25,100
我们可以看到来自运行时的地址解析属于这个ld.so二进制。男性页面

47
00:04:25,100 --> 00:04:31,180
因为'ld.so'告诉我们这是动态的链接器/加载器。所以这个图书馆帮助我们

48
00:04:31,180 --> 00:04:36,310
设置对libc的外部引用。这个函数有魔力。不知道它是什么

49
00:04:36,310 --> 00:04:42,020
做的很详细，但它会找到地址libc中的puts（）函数及其更新

50
00:04:42,020 --> 00:04:48,780
得到表并执行Puts。现在，第二次执行puts（），

51
00:04:48,780 --> 00:04:54,350
得到了更新，当我们跳到存储在全局偏移量表中的地址

52
00:04:54,350 --> 00:04:58,460
我们最终从libc得到了puts（）。

53
00:04:58,460 --> 00:05:04,640
这个全局偏移表非常有用当编写漏洞时，因为

54
00:05:04,639 --> 00:05:06,739
你可以用它做一些事情。

55
00:05:06,740 --> 00:05:12,600
首先，我们有一个任意的写入。我们可以在任何地方写一个我们想要的值

56
00:05:12,600 --> 00:05:18,050
记忆。所以你可以简单地覆盖地址在某个函数的全局偏移量表中。

57
00:05:18,050 --> 00:05:22,550
下次调用这个函数时，代码将被重定向到

58
00:05:22,550 --> 00:05:25,560
在全局偏移量表中输入。

59
00:05:25,560 --> 00:05:30,410
例如，假设您有内存泄漏通过类似于

60
00:05:30,410 --> 00:05:35,890
上一个视频。二进制文件没有使用ASLR。嗯，系统本身仍然可以

61
00:05:35,889 --> 00:05:42,139
启用了aslr，因此libc的位置总是随机的。但是地址

62
00:05:42,139 --> 00:05:47,439
二进制文件中的全局偏移量表是总是固定的。所以当你能从

63
00:05:47,440 --> 00:05:53,150
你控制的地址，你可以读取一个条目全局偏移量表的，它是一个地址

64
00:05:53,150 --> 00:05:58,650
在LBC。然后你可以用它来计算对伦敦银行同业拆借利率其他地点的抵消。哪个

65
00:05:58,651 --> 00:06:02,561
如果需要查找ROP小工具，则非常有用或者你想回到libc。

66
00:06:02,560 --> 00:06:03,560
即使二进制文件使用aslr，能够泄漏二进制文件的地址

67
00:06:03,560 --> 00:06:04,560
要克服地址随机化，您可以然后计算到全局偏移的偏移量

68
00:06:04,560 --> 00:06:05,560
然后泄露libc的地址方式。

69
00:06:05,560 --> 00:06:08,840
有时甚至有一个缓冲区溢出或者函数中的任意写入，但是

70
00:06:08,840 --> 00:06:14,840
函数本身永远不会返回，因为它永远调用exit（）或循环，从而覆盖

71
00:06:14,840 --> 00:06:20,840
堆栈上的返回指针没有帮助重定向代码执行。那是

72
00:06:20,840 --> 00:06:25,950
正是格式级别4的挑战利用-exercises.com。我们不能改写

73
00:06:25,949 --> 00:06:37,139
堆栈上的返回地址，所以我们有依靠不同的技术获得控制

74
00:06:37,139 --> 00:06:38,869
在程序执行过程中。

75
00:06:38,870 --> 00:06:44,600
下次使用格式字符串时再见覆盖上的条目的漏洞

76
00:06:44,600 --> 00:06:46,470
用于重定向代码执行的全局偏移量表。

