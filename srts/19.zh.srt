1
00:00:06,910 --> 00:00:12,780
在这段视频中，我们又进行了一次，反转C程序的旅行。具体来说，

2
00:00:12,780 --> 00:00:18,580
我们会讨论全局偏移表（GOT）

3
00:00:18,580 --> 00:00:19,580
和进程链接表（PLT）。

4
00:00:19,580 --> 00:00:24,660
我们先创建一个非常简单的 C 程序，它只调用两个 libc 函数。

5
00:00:24,660 --> 00:00:30,120
所以，我只写了两个 printf 和一个退出。

6
00:00:30,119 --> 00:00:35,799
这两个函数显然是外部函数，我自己没有定义。他们来自 libc。当我编译这个二进制文件时，

7
00:00:35,800 --> 00:00:42,850
使用 gcc，libc 将动态链接到此二进制文件。

8
00:00:42,850 --> 00:00:48,710
这意味着libc 不包括在程序中。使用“ldd”，

9
00:00:48,710 --> 00:00:54,560
我们可以看到来自这个二进制文件的动态引用，并显示说它想要libc，它还显示了我系统上，libc 二进制文件的路径位置。

10
00:00:54,559 --> 00:01:00,449
这很好，因为这样程序就可以小得多，而且

11
00:01:00,449 --> 00:01:04,789
libc 可以在不重新编译二进制文件的情况下，接收更新。

12
00:01:04,790 --> 00:01:10,860
但这也意味着，libc 中的地址，对于每个版本来说，可能都是不同的。

13
00:01:10,860 --> 00:01:16,450
所以，我怎样才能把一个二进制编译成汇编程序呢，因为我必须要知道确切地址，这样我才能创建一个call指令？

14
00:01:16,450 --> 00:01:22,270
好吧，这就是PLT和GOT 开始发挥作用的地方。

15
00:01:22,270 --> 00:01:28,000
让我们在 hopper 反汇编器中，打开这个二进制文件，看看 main 函数。

16
00:01:28,000 --> 00:01:32,940
所以，首先注意到的是，我们的 printfs() 到底在哪里？为什么有 puts() 调用？

17
00:01:32,940 --> 00:01:37,150
反汇编程序，发现我们指定了一个常量字符串，而不是动态格式字符串，

18
00:01:37,150 --> 00:01:42,270
因此，决定用 puts 替换 printf。但不管怎样，

19
00:01:42,270 --> 00:01:47,340
我们这里有三个函数调用，还有 Hopper决定在调用位置的名称前面，加上一个 j，

20
00:01:47,340 --> 00:01:51,160
可能是跳跃(jump)的意思。不确定。所以，如果我们跟着这个调用，

21
00:01:51,160 --> 00:01:58,060
会注意到，我们不会以 libc 的 puts 结尾。我们仍然在二进制。我们会怎么做呢？

22
00:01:58,060 --> 00:02:05,830
因为 libc 不包含在此二进制文件中。我们会在PLT区着陆。进程链接表。

23
00:02:05,830 --> 00:02:13,090
在这里的调用，会立即跳(jump)转到另一个人的地址

24
00:02:13,090 --> 00:02:20,490
位置。这个位置的名字是 puts @ GOT。所以，让我们一探究竟。

25
00:02:20,490 --> 00:02:26,940
现在，我们进入了一个叫做 got 的部分。全局偏移表。方

26
00:02:26,940 --> 00:02:32,420
而这个跳，会跳到存储在这里的任何地址。此时，

27
00:02:32,420 --> 00:02:38,670
存储在这里的地址，正在指向一个外部符号。那么… 那么他们会在这里做啥呢？

28
00:02:38,670 --> 00:02:43,780
在编译期间，我们不知道 puts 或 exit 的地址。所以，

29
00:02:43,780 --> 00:02:50,930
我们只创建一个函数 trampoline。我们会对一个我们知道它在哪里的位置(PLT区)进行调用。其中包含一个跳，

30
00:02:50,930 --> 00:02:56,430
来自该列表（或表，如果需要）指引的跳转位置。

31
00:02:56,430 --> 00:03:02,250
所以，我们要做到的，就是能够使用(libc)库中的外部函数，

32
00:03:02,250 --> 00:03:06,940
以某种方式编写，libc函数的地址存于此表。

33
00:03:06,940 --> 00:03:12,840
而这就是二进制的执行所会发生的。正如您现在所知道的，ELF二进制，不仅仅是简单的汇编程序代码。

34
00:03:12,840 --> 00:03:20,060
在我们代码被执行之前，复杂的ELF格式会被解析，

35
00:03:20,060 --> 00:03:25,360
基于由内核设置的进程。在这段时间内，这样的(地址)引用，可能会得到解决。

36
00:03:25,360 --> 00:03:30,500
所以，让我们调试这个二进制文件。这次我们用 hopper 吧。首先我们在 main 设置一个断点，

37
00:03:30,500 --> 00:03:37,540
单击对应行中的红色列就行。然后我们打开调试器界面，

38
00:03:37,540 --> 00:03:43,630
右上角有一个按钮。所以，让我们向前一步，直到我们跟到 puts() 的调用进行操作。

39
00:03:43,630 --> 00:03:49,860
如预期的那样，我们到达 PLT 部分，即将跳转到在全局偏移表中的引用地址。

40
00:03:49,860 --> 00:03:55,730
让我们更进一步，看看会发生什么。哦… 不。

41
00:03:55,730 --> 00:04:00,860
我们不去到 libc 的 puts。不知怎的，我们就在跳跃之后，

42
00:04:00,860 --> 00:04:04,840
推了一个值 now，在栈上。正如你看到的每一个PLT条目，

43
00:04:04,840 --> 00:04:09,380
也为我们的 exit() 函数的作用是：先推一个数字，然后跳到上面的这个地址。

44
00:04:09,381 --> 00:04:14,541
当我们跟着执行这个跳转后，最终以一个名为 _dl_runtime_resolve的函数结束。

45
00:04:14,540 --> 00:04:18,530
我们可以使用 proc 文件系统，来查看这个进程的内存映射，以及

46
00:04:18,530 --> 00:04:25,100
我们可以看到，来自 _dl_runtime_resolve 的地址，是属于这个 ld.so二进制文件的。

47
00:04:25,100 --> 00:04:31,180
“ld.so”手册，告诉我们这是动态链接器/加载程序。

48
00:04:31,180 --> 00:04:36,310
所以，这个库帮助我们，设置对 libc 的外部引用。这个函数有魔力。

49
00:04:36,310 --> 00:04:42,020
不知道它的详细操作，但它(应该)在 libc 里面，找到 puts() 函数的地址，

50
00:04:42,020 --> 00:04:48,780
并对 GOT 进行更新，而且执行了 puts。现在，第二次想要执行 puts()的话 ，

51
00:04:48,780 --> 00:04:54,350
GOT 会有所更新，且当我们跳转到全局偏移量表中存储的地址后，

52
00:04:54,350 --> 00:04:58,460
最终，会以libc中的 puts() 结尾。

53
00:04:58,460 --> 00:05:04,640
这个全局偏移表，在编写漏洞脚本时非常有用，

54
00:05:04,639 --> 00:05:06,739
因为你可以用它做一些事情。

55
00:05:06,740 --> 00:05:12,600
首先，我们有一个任意的写入。我们可以在内存任何地方，写入一个我们想要的值

56
00:05:12,600 --> 00:05:18,050
因此，您可以简单地覆盖某个函数，在全局偏移量表中的地址。

57
00:05:18,050 --> 00:05:22,550
下次调用这个函数时，代码将被重定向到

58
00:05:22,550 --> 00:05:25,560
你在全局偏移量表中的(任何)输入。

59
00:05:25,560 --> 00:05:30,410
假设您有一个内存泄漏，例如类似上一个视频的

60
00:05:30,410 --> 00:05:35,890
格式字符串漏洞。二进制文件并没有使用aslr。

61
00:05:35,889 --> 00:05:42,139
嗯，系统本身仍然可以启用 aslr，因此 libc 的位置总是随机的。

62
00:05:42,139 --> 00:05:47,439
但是二进制文件中的，全局偏移量表里面的地址总是固定的。所以，

63
00:05:47,440 --> 00:05:53,150
当你能读取您控制的地址，就可以读取全局偏移量表的一个条目，

64
00:05:53,150 --> 00:05:58,650
它是libc的一个地址。然后，您可以使用它，来计算到 libc 其他位置的偏移量。

65
00:05:58,651 --> 00:06:02,561
对你必须查找 ROP 小工具，或要返回到libc 来说，非常有用。

66
00:06:02,560 --> 00:06:03,560
即使，您的二进制文件使用aslr，如果您能够泄漏二进制文件的地址

67
00:06:03,560 --> 00:06:04,560
为了避免地址随机化，您可以计算到，全局偏移表的偏移量。

68
00:06:04,560 --> 00:06:05,560
然后，以这种方式泄漏libc的地址。

69
00:06:05,560 --> 00:06:08,840
有时，甚至一个函数，有缓冲区溢出或任意写入，

70
00:06:08,840 --> 00:06:14,840
但，函数本身并不会返回，因为它调用 exit() 或永远循环，

71
00:06:14,840 --> 00:06:20,840
那么，覆盖栈上的返回指针，对重定向代码执行没有帮助。

72
00:06:20,840 --> 00:06:25,950
这，正是 exploit-exercises.com 格式级别4的挑战。

73
00:06:25,949 --> 00:06:37,139
我们不能覆盖栈上的返回地址，因此我们必须依赖不同的技术，

74
00:06:37,139 --> 00:06:38,869
在程序执行过程中，获得控制权。

75
00:06:38,870 --> 00:06:44,600
下次再见，那时我们会使用格式字符串漏洞，覆盖全局偏移量表的一个条目，

76
00:06:44,600 --> 00:06:46,470
以达到代码执行的重定向。

