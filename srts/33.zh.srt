1
00:00:00,329 --> 00:00:05,139
我们在试图理解如何利用程序方面已经走了很长的路。

2
00:00:05,140 --> 00:00:07,170
through memory corruption.

3
00:00:07,169 --> 00:00:11,999
我们已经介绍了各种各样的示例，包括基本缓冲区溢出、格式字符串

4
00:00:12,000 --> 00:00:14,250
exploits and even heap exploits.

5
00:00:14,250 --> 00:00:17,510
And a lot of you might already find it quite complex.

6
00:00:17,510 --> 00:00:23,130
But if you put it into the context of history we are still like 16 years behind.

7
00:00:23,130 --> 00:00:28,940
我们在exploit-exercises.com上探讨的最后一个例子介绍了最先进的技术

8
00:00:28,940 --> 00:00:29,940
in like 2001.

9
00:00:29,940 --> 00:00:35,500
虽然它仍然直接适用于廉价的嵌入式设备，比如一些物联网设备，

10
00:00:35,500 --> 00:00:38,100
it’s very important to lay a foundation.

11
00:00:38,100 --> 00:00:42,180
但在我们开始谈论所有这些现代剥削缓解措施和我们如何才能

12
00:00:42,180 --> 00:00:47,460
绕过他们，我认为把我们学到的东西多放一点是个好主意。

13
00:00:47,460 --> 00:00:48,910
abstract terms.

14
00:00:48,910 --> 00:00:55,910
And try to get a feeling or an intuition about exploiting binaries.

15
00:00:55,910 --> 00:01:03,050
Let’s try to create a mental model of exploitation.

16
00:01:03,050 --> 00:01:07,450
But let’s first introduce some constraints, otherwise it will be too abstract.

17
00:01:07,450 --> 00:01:10,930
Let’s focus on programs like we have interacted before.

18
00:01:10,930 --> 00:01:13,800
this means intel architecture and on linux.

19
00:01:13,800 --> 00:01:14,800
Ok.

20
00:01:14,800 --> 00:01:16,540
Let’s start at the beginning.

21
00:01:16,540 --> 00:01:19,260
We want programs to execute on our CPU.

22
00:01:19,260 --> 00:01:23,280
That’s why a program contains assembler code - machine code.

23
00:01:23,280 --> 00:01:26,500
And machine code is just like any other data in our computers.

24
00:01:26,500 --> 00:01:28,280
It’s basically just bits.

25
00:01:28,280 --> 00:01:29,930
0 and 1s.

26
00:01:29,930 --> 00:01:32,250
A lot of times we combine them into bytes.

27
00:01:32,250 --> 00:01:35,850
And a CPU can interpret a byte as an instruction.

28
00:01:35,850 --> 00:01:39,050
Or multiple bytes can be interpreted as an instruction.

29
00:01:39,050 --> 00:01:44,730
CPU中一些疯狂的数字硬件魔法知道这个特殊的价值

30
00:01:44,729 --> 00:01:49,879
for “add the values stored in two registers and put the result in the first register.

31
00:01:49,880 --> 00:01:56,050
And registers are just like small memory cells in the CPU, which fullfil different purposes.

32
00:01:56,050 --> 00:02:00,480
And different architectures might have different registers for different purposes.

33
00:02:00,479 --> 00:02:05,629
但是在Intel上，我们有一些通用寄存器，例如EAX和EBX，它们

34
00:02:05,631 --> 00:02:08,831
a programmer is free to use however he wants to.

35
00:02:08,830 --> 00:02:12,800
But there are also special registers, like EIP, the instruction pointer.

36
00:02:12,800 --> 00:02:17,240
它只包含地址，地址指向内存，下一条指令

37
00:02:17,240 --> 00:02:18,240
will be.

38
00:02:18,240 --> 00:02:23,300
还有这个堆栈指针esp，指向堆栈的顶部，以及

39
00:02:23,300 --> 00:02:28,080
the base pointer EBP, which together with the stack pointer define a stack frame.

40
00:02:28,080 --> 00:02:30,850
And for beginners this might already feel complicated.

41
00:02:30,849 --> 00:02:35,029
There is code, there is data, there is a stack, there is a heap.

42
00:02:35,030 --> 00:02:36,450
There are functions you can call.

43
00:02:36,450 --> 00:02:37,670
Functions can return.

44
00:02:37,670 --> 00:02:41,090
不知何故，在堆栈上有一个返回指针，您可以用缓冲区覆盖它。

45
00:02:41,090 --> 00:02:42,090
overflow.

46
00:02:42,090 --> 00:02:43,900
There are a lot of different terms that we use.

47
00:02:43,900 --> 00:02:47,780
But it’s a lot less complex as it may sound.

48
00:02:47,780 --> 00:02:51,080
因为本质上只有两个部分很重要

49
00:02:51,080 --> 00:02:56,840
we have memory, which is just a huuuuuuge space of bits that can be 1 or 0.

50
00:02:56,840 --> 00:02:58,710
Usually we group them in bytes or words.

51
00:02:58,709 --> 00:03:05,079
还有一个CPU，它有一个定义良好的确定性行为，可以对它进行操作。

52
00:03:05,080 --> 00:03:06,100
memory.

53
00:03:06,100 --> 00:03:08,290
It’s really that simple.

54
00:03:08,290 --> 00:03:09,290
Well.

55
00:03:09,290 --> 00:03:13,640
关键在于实际细节，但本质上，当CPU打开时，它

56
00:03:13,640 --> 00:03:15,350
will start at some defined address.

57
00:03:15,349 --> 00:03:19,509
This could be 0, but could also be defined to be something else.

58
00:03:19,510 --> 00:03:24,170
它请求来自某个RAM的内存内容，查看存储在该地址的值，

59
00:03:24,170 --> 00:03:29,100
and performs the action according to whatever that value represents.

60
00:03:29,099 --> 00:03:33,509
现在，当我们要执行一个程序时，不能直接将代码写入

61
00:03:33,510 --> 00:03:36,130
RAM, and restart the CPU at address 0.

62
00:03:36,130 --> 00:03:39,820
Because if your program would cause an endless loop, the whole system would stop working.

63
00:03:39,820 --> 00:03:44,400
但是当你编程一个Arduino，一个小微控制器时，基本上就是你

64
00:03:44,400 --> 00:03:45,400
do.

65
00:03:45,400 --> 00:03:49,320
But that’s why some people developed something like the Linux kernel.

66
00:03:49,320 --> 00:03:53,910
它为您抽象出直接的硬件，并确保如果您的程序不好，

67
00:03:53,910 --> 00:03:55,170
you don’t kill the whole system.

68
00:03:55,170 --> 00:04:01,070
That’s why a program is not just plain assembler code, but it’s a fairly complex file format.

69
00:04:01,069 --> 00:04:02,099
An ELF file.

70
00:04:02,100 --> 00:04:05,710
Which does contain your raw code, but also a lot of other information.

71
00:04:05,709 --> 00:04:11,879
当你执行这个程序时，Linux系统会打开elf文件，读取

72
00:04:11,879 --> 00:04:17,319
并解释所有必要的元数据并为您设置执行环境，以及

73
00:04:17,319 --> 00:04:20,189
then jumps to the start of your actual code.

74
00:04:20,189 --> 00:04:23,409
那么执行环境是什么样子的呢？

75
00:04:23,409 --> 00:04:28,929
这一点很重要，因为在这种环境中，你试图利用程序，

76
00:04:28,930 --> 00:04:31,030
you need to understand it.

77
00:04:31,030 --> 00:04:33,400
And in some way it’s actyually very simple.

78
00:04:33,400 --> 00:04:37,020
Again, the devil is in the practical details, but it will make sense.

79
00:04:37,020 --> 00:04:41,570
Let’s say the CPU is just about to execute your first instruction.

80
00:04:41,569 --> 00:04:45,529
This means the kernel and the hardware magic has already set up everything.

81
00:04:45,530 --> 00:04:46,890
And this is how it looks like.

82
00:04:46,889 --> 00:04:49,509
You have a big blob of memory.

83
00:04:49,509 --> 00:04:53,339
It ranges from 0, to ffffff.

84
00:04:53,339 --> 00:04:58,609
In reality you don’t really have that much memory, that’s why we call it virtual memory.

85
00:04:58,610 --> 00:05:03,050
看起来你拥有所有的内存，但是硬件的魔力只会让你觉得你拥有

86
00:05:03,050 --> 00:05:04,050
it.

87
00:05:04,050 --> 00:05:09,700
But in anyway, the CPU now executes your program which is somewhere in that huge memory.

88
00:05:09,699 --> 00:05:13,919
Let’s have a look at how this memory is divided up in a real program.

89
00:05:13,919 --> 00:05:19,289
例如，在这里，我们看到从这个起始地址到这个结束地址，

90
00:05:19,289 --> 00:05:21,019
program is mapped.

91
00:05:21,020 --> 00:05:26,460
我们说是映射的，因为它实际上不在这个地址，但如果你愿意的话，它就在那里。

92
00:05:26,460 --> 00:05:30,150
read the value from that address, in your assembler code.

93
00:05:30,150 --> 00:05:35,370
所以忽略了底层的物质现实，只是接受了这个巨大的范围

94
00:05:35,369 --> 00:05:37,299
of memory you can work with.

95
00:05:37,300 --> 00:05:39,330
And infact the stack is also just here.

96
00:05:39,330 --> 00:05:42,930
It’s also just defined as starting from this address and ends at this address.

97
00:05:42,930 --> 00:05:47,780
所以堆栈并没有真正的增长或收缩，这只是计算机理论模型。

98
00:05:47,779 --> 00:05:48,779
of a stack.

99
00:05:48,779 --> 00:05:51,329
但是堆栈实际上是如何定义的呢？

100
00:05:51,330 --> 00:05:56,900
CPU有堆栈寄存器esp，它将包含一个指向

101
00:05:56,899 --> 00:05:58,529
this area here.

102
00:05:58,530 --> 00:06:01,830
So could you just point the stack pointer somewhere else.

103
00:06:01,830 --> 00:06:02,930
就像你的代码？

104
00:06:02,930 --> 00:06:03,930
是啊！

105
00:06:03,930 --> 00:06:04,930
You absolutely could.

106
00:06:04,930 --> 00:06:08,950
堆栈指针没有什么特别的，它只是一个包含地址的寄存器，

107
00:06:08,949 --> 00:06:11,499
and it could contain any address.

108
00:06:11,499 --> 00:06:18,229
What makes ESP actually special is just that it does some fancy stuff based on instructions.

109
00:06:18,229 --> 00:06:24,869
例如，pop eax指令将查找存储在该位置的值

110
00:06:24,869 --> 00:06:28,979
where ESP points to, usually that’s the stack, but doesn’t have to.

111
00:06:28,979 --> 00:06:33,089
And then writes the value from that location into the eax register.

112
00:06:33,089 --> 00:06:37,249
And you can absolutely abuse that in an exploit.

113
00:06:37,249 --> 00:06:41,169
例如，如果您发现一个bug，它允许您将堆栈指针设置为

114
00:06:41,169 --> 00:06:47,139
value, you could create a fake stack on the heap, and just point ESP there.

115
00:06:47,139 --> 00:06:49,849
Often times referred to as a stack pivot.

116
00:06:49,849 --> 00:06:54,999
因此，失去你在计算机科学中所学的一堆不断增长和缩小的精神图像，

117
00:06:54,999 --> 00:06:57,039
and just think of it what it really is.

118
00:06:57,039 --> 00:07:01,359
It’s just some memory where the ESP register points to.

119
00:07:01,360 --> 00:07:04,530
And instructions cause interesting effects based on that register.

120
00:07:04,529 --> 00:07:08,809
And in the same sense the instruction pointer is not special.

121
00:07:08,809 --> 00:07:12,089
Usually it points into your code, but it doesn’t have to.

122
00:07:12,089 --> 00:07:16,749
If you manage to control EIP somehow, you can just point it to other memory.

123
00:07:16,749 --> 00:07:20,379
For example the stack, which we have used in previous exploits.

124
00:07:20,379 --> 00:07:24,369
Because we placed data that is actually valid assembler code onto the stack.

125
00:07:24,369 --> 00:07:25,669
You know it as shellcode.

126
00:07:25,669 --> 00:07:27,729
The CPU doesn’t care.

127
00:07:27,729 --> 00:07:33,069
EIP寄存器指向一些内存，CPU很高兴地完成这些值。

128
00:07:33,069 --> 00:07:34,069
say.

129
00:07:34,069 --> 00:07:36,659
And well, that is just half true.

130
00:07:36,660 --> 00:07:41,670
因为正如您可能知道的，在现代系统中，堆栈不再是可执行的，所以

131
00:07:41,669 --> 00:07:43,109
CPU does kinda care, but also not really.

132
00:07:43,110 --> 00:07:48,050
It just means that certain areas in this memory can have different permissions.

133
00:07:48,050 --> 00:07:53,300
某些区域具有可执行标记，这意味着CPU允许EIP指向该区域，并且

134
00:07:53,300 --> 00:07:57,800
乐于将这些值解释为指令，但堆栈等其他区域没有

135
00:07:57,800 --> 00:07:58,800
it.

136
00:07:58,800 --> 00:08:01,860
And then the CPU refuses to interpret it as instructions.

137
00:08:01,860 --> 00:08:07,030
现在，当我们更接近于所有这些不同的数据中包含了什么类型的数据时

138
00:08:07,030 --> 00:08:12,520
memory areas, we can try to come up with creative ways of how to abuse the.

139
00:08:12,520 --> 00:08:15,580
One example is the typical stack structure.

140
00:08:15,580 --> 00:08:21,470
当CPU执行一条调用指令时，它将放置当前指令指针值

141
00:08:21,469 --> 00:08:23,919
at the address where the stack pointer points to.

142
00:08:23,919 --> 00:08:26,559
It places it ontop of the stack.

143
00:08:26,560 --> 00:08:30,840
当函数返回时，它获取堆栈指针指向和的值。

144
00:08:30,839 --> 00:08:33,409
sets the instruction pointer to it.

145
00:08:33,410 --> 00:08:38,220
因此，如果您设法在堆栈上修改这个值，您可以控制到什么EIP

146
00:08:38,220 --> 00:08:42,490
将设置为函数返回的时间，因此您可以决定执行什么操作

147
00:08:42,490 --> 00:08:43,490
next.

148
00:08:43,490 --> 00:08:44,880
That’s a classical buffer overflow.

149
00:08:44,880 --> 00:08:49,870
另一个有趣的数据结构是全局偏移表，它基本上只是

150
00:08:49,870 --> 00:08:56,620
内存中包含指向函数的指针的区域，如果覆盖其中的条目，也可以

151
00:08:56,620 --> 00:09:01,610
控制如果调用的函数引用的地址来自

152
00:09:01,610 --> 00:09:02,610
this table.

153
00:09:02,610 --> 00:09:06,750
我的意思是，通常你不能直接覆盖这些值，但这只是意味着你有

154
00:09:06,750 --> 00:09:08,680
to become creative.

155
00:09:08,680 --> 00:09:11,400
For example think of two objects on the heap.

156
00:09:11,400 --> 00:09:15,870
A user object and a name object, and the user object has a pointer to the name object.

157
00:09:15,870 --> 00:09:20,070
当您想更改这个用户的名称时，代码将跟随指针并

158
00:09:20,070 --> 00:09:26,030
将新名称写入该位置，这意味着如果您可以以某种方式覆盖该指针，

159
00:09:26,030 --> 00:09:29,120
you can control where it would write the name to.

160
00:09:29,120 --> 00:09:33,020
所以我们可以用堆栈上的地址覆盖名称指针，当我们写

161
00:09:33,021 --> 00:09:37,411
用户的新名称，我们将实际覆盖存储的指令指针

162
00:09:37,410 --> 00:09:38,430
the stack.

163
00:09:38,430 --> 00:09:39,680
看到我想说什么了吗？

164
00:09:39,680 --> 00:09:42,260
There is memory that contains data.

165
00:09:42,260 --> 00:09:47,830
Some restrictions apply, like certain memory areas are not writeable, others are not executable.

166
00:09:47,830 --> 00:09:53,250
And there is a CPU that is very dumb and just executes whatever EIP points to.

167
00:09:53,250 --> 00:09:57,020
And there is a program in the memory, which the CPU executes.

168
00:09:57,020 --> 00:10:00,170
And this code uses the memory to do whatever it is supposed to do.

169
00:10:00,170 --> 00:10:04,500
And it trusts in a certain integrity of the data in memory.

170
00:10:04,500 --> 00:10:08,590
但是如果有一个bug，它允许你改变内存中的一个值，程序

171
00:10:08,590 --> 00:10:12,700
did not intend to be modifiable, amazing things could happen.

172
00:10:12,700 --> 00:10:18,120
And what can happen, that’s just limited by your creativity and imagination.

173
00:10:18,120 --> 00:10:23,910
内存中的一个更改的字节可能会导致某段代码意外写入

174
00:10:23,910 --> 00:10:28,410
覆盖对象的函数指针的位置，代码的另一部分

175
00:10:28,410 --> 00:10:33,570
wanted to use, and suddenly executes something very different.

176
00:10:33,570 --> 00:10:38,630
我们将这些技术命名为堆栈缓冲区溢出、堆风水，

177
00:10:38,630 --> 00:10:44,940
免费使用ROP，都是解决内存中数据问题的创造性方法

178
00:10:44,940 --> 00:10:48,760
the program executed by the CPU reacts to it.

179
00:10:48,760 --> 00:10:54,020
I understand that this episode might not have contained actual useful information to you.

180
00:10:54,020 --> 00:10:58,440
但我有点想把它拿出来，因为也许有人不太喜欢看电视节目

181
00:10:58,440 --> 00:11:00,310
and exploits in this way.

182
00:11:00,310 --> 00:11:03,080
But I hope you can see the value in this way of thinking about it.

183
00:11:03,080 --> 00:11:07,350
I think it takes some away some of the fear that it all looks so complicated.

184
00:11:07,350 --> 00:11:11,200
I’m really interested to hear your critical opinion about this.

185
00:11:11,200 --> 00:11:13,930
So comment here on youtube or on the reddit thread linked below.

186
00:11:13,930 --> 00:11:17,850
但无论你是否喜欢，我们很快就会继续我们的学习之路

187
00:11:17,850 --> 00:11:19,850
more advanced memory corruption techniques.

188
00:11:19,850 --> 00:11:21,890
So, stay curious, and see you next time.

