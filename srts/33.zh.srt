1
00:00:00,329 --> 00:00:05,139
我们在试图理解如何利用程序方面已经走了很长的路。

2
00:00:05,140 --> 00:00:07,170
通过内存损坏。

3
00:00:07,169 --> 00:00:11,999
我们已经介绍了各种各样的示例，包括基本缓冲区溢出、格式字符串

4
00:00:12,000 --> 00:00:14,250
利用，甚至堆利用。

5
00:00:14,250 --> 00:00:17,510
很多人可能已经觉得这很复杂了。

6
00:00:17,510 --> 00:00:23,130
但如果你把它放到历史的背景下，我们仍然落后16年。

7
00:00:23,130 --> 00:00:28,940
我们在exploit-exercises.com上探讨的最后一个例子介绍了最先进的技术

8
00:00:28,940 --> 00:00:29,940
比如2001。

9
00:00:29,940 --> 00:00:35,500
虽然它仍然直接适用于廉价的嵌入式设备，比如一些物联网设备，

10
00:00:35,500 --> 00:00:38,100
打基础是很重要的。

11
00:00:38,100 --> 00:00:42,180
但在我们开始谈论所有这些现代剥削缓解措施和我们如何才能

12
00:00:42,180 --> 00:00:47,460
绕过他们，我认为把我们学到的东西多放一点是个好主意。

13
00:00:47,460 --> 00:00:48,910
抽象术语。

14
00:00:48,910 --> 00:00:55,910
试着对使用二进制文件有一种感觉或直觉。

15
00:00:55,910 --> 00:01:03,050
让我们试着创造一个剥削的心理模型。

16
00:01:03,050 --> 00:01:07,450
但是，让我们首先介绍一些约束，否则它将过于抽象。

17
00:01:07,450 --> 00:01:10,930
让我们把注意力集中在我们以前互动过的程序上。

18
00:01:10,930 --> 00:01:13,800
这意味着Intel体系结构和Linux。

19
00:01:13,800 --> 00:01:14,800
好啊。

20
00:01:14,800 --> 00:01:16,540
让我们从头开始。

21
00:01:16,540 --> 00:01:19,260
我们希望程序在我们的CPU上执行。

22
00:01:19,260 --> 00:01:23,280
这就是为什么程序包含汇编程序代码-机器代码的原因。

23
00:01:23,280 --> 00:01:26,500
机器代码就像我们电脑里的其他数据一样。

24
00:01:26,500 --> 00:01:28,280
基本上只是一点点。

25
00:01:28,280 --> 00:01:29,930
0和1s。

26
00:01:29,930 --> 00:01:32,250
很多时候我们把它们组合成字节。

27
00:01:32,250 --> 00:01:35,850
CPU可以将一个字节解释为一条指令。

28
00:01:35,850 --> 00:01:39,050
或者多个字节可以解释为一条指令。

29
00:01:39,050 --> 00:01:44,730
CPU中一些疯狂的数字硬件魔法知道这个特殊的价值

30
00:01:44,729 --> 00:01:49,879
对于“将存储在两个寄存器中的值相加，并将结果放入第一个寄存器。

31
00:01:49,880 --> 00:01:56,050
寄存器就像CPU中的小内存单元，可以满足不同的用途。

32
00:01:56,050 --> 00:02:00,480
不同的体系结构可能有不同的寄存器，用于不同的目的。

33
00:02:00,479 --> 00:02:05,629
但是在Intel上，我们有一些通用寄存器，例如EAX和EBX，它们

34
00:02:05,631 --> 00:02:08,831
程序员可以随心所欲地使用。

35
00:02:08,830 --> 00:02:12,800
但是也有一些特殊的寄存器，比如EIP，指令指针。

36
00:02:12,800 --> 00:02:17,240
它只包含地址，地址指向内存，下一条指令

37
00:02:17,240 --> 00:02:18,240
将。

38
00:02:18,240 --> 00:02:23,300
还有这个堆栈指针esp，指向堆栈的顶部，以及

39
00:02:23,300 --> 00:02:28,080
基本指针ebp，它与堆栈指针一起定义堆栈帧。

40
00:02:28,080 --> 00:02:30,850
对于初学者来说，这可能已经很复杂了。

41
00:02:30,849 --> 00:02:35,029
有代码，有数据，有堆栈，有堆。

42
00:02:35,030 --> 00:02:36,450
您可以调用一些函数。

43
00:02:36,450 --> 00:02:37,670
函数可以返回。

44
00:02:37,670 --> 00:02:41,090
不知何故，在堆栈上有一个返回指针，您可以用缓冲区覆盖它。

45
00:02:41,090 --> 00:02:42,090
溢出。

46
00:02:42,090 --> 00:02:43,900
我们使用了很多不同的术语。

47
00:02:43,900 --> 00:02:47,780
但听起来不那么复杂。

48
00:02:47,780 --> 00:02:51,080
因为本质上只有两个部分很重要

49
00:02:51,080 --> 00:02:56,840
我们有内存，它只是一个可以是1或0的位的huuuuuuge空间。

50
00:02:56,840 --> 00:02:58,710
通常我们用字节或单词对它们进行分组。

51
00:02:58,709 --> 00:03:05,079
还有一个CPU，它有一个定义良好的确定性行为，可以对它进行操作。

52
00:03:05,080 --> 00:03:06,100
记忆。

53
00:03:06,100 --> 00:03:08,290
这真的很简单。

54
00:03:08,290 --> 00:03:09,290
好。

55
00:03:09,290 --> 00:03:13,640
关键在于实际细节，但本质上，当CPU打开时，它

56
00:03:13,640 --> 00:03:15,350
将从某个定义的地址开始。

57
00:03:15,349 --> 00:03:19,509
这可以是0，但也可以定义为其他值。

58
00:03:19,510 --> 00:03:24,170
它请求来自某个RAM的内存内容，查看存储在该地址的值，

59
00:03:24,170 --> 00:03:29,100
并根据该值所代表的内容执行操作。

60
00:03:29,099 --> 00:03:33,509
现在，当我们要执行一个程序时，不能直接将代码写入

61
00:03:33,510 --> 00:03:36,130
RAM，并在地址0处重新启动CPU。

62
00:03:36,130 --> 00:03:39,820
因为如果你的程序会导致一个无休止的循环，整个系统就会停止工作。

63
00:03:39,820 --> 00:03:44,400
但是当你编程一个Arduino，一个小微控制器时，基本上就是你

64
00:03:44,400 --> 00:03:45,400
做。

65
00:03:45,400 --> 00:03:49,320
但这就是为什么有些人开发了类似Linux内核的东西。

66
00:03:49,320 --> 00:03:53,910
它为您抽象出直接的硬件，并确保如果您的程序不好，

67
00:03:53,910 --> 00:03:55,170
你不会杀死整个系统。

68
00:03:55,170 --> 00:04:01,070
这就是为什么一个程序不仅仅是简单的汇编程序代码，而是一种相当复杂的文件格式。

69
00:04:01,069 --> 00:04:02,099
一个ELF文件。

70
00:04:02,100 --> 00:04:05,710
它包含了您的原始代码，但也包含了很多其他信息。

71
00:04:05,709 --> 00:04:11,879
当你执行这个程序时，Linux系统会打开elf文件，读取

72
00:04:11,879 --> 00:04:17,319
并解释所有必要的元数据并为您设置执行环境，以及

73
00:04:17,319 --> 00:04:20,189
然后跳到实际代码的开头。

74
00:04:20,189 --> 00:04:23,409
那么执行环境是什么样子的呢？

75
00:04:23,409 --> 00:04:28,929
这一点很重要，因为在这种环境中，你试图利用程序，

76
00:04:28,930 --> 00:04:31,030
你需要理解它。

77
00:04:31,030 --> 00:04:33,400
从某种意义上说，这很简单。

78
00:04:33,400 --> 00:04:37,020
再说一次，魔鬼在实际的细节中，但它是有意义的。

79
00:04:37,020 --> 00:04:41,570
假设CPU即将执行第一条指令。

80
00:04:41,569 --> 00:04:45,529
这意味着内核和硬件魔法已经设置好了一切。

81
00:04:45,530 --> 00:04:46,890
这就是它的样子。

82
00:04:46,889 --> 00:04:49,509
你的记忆力很强。

83
00:04:49,509 --> 00:04:53,339
范围从0到ffffff。

84
00:04:53,339 --> 00:04:58,609
实际上，你没有那么多的记忆，所以我们称之为虚拟记忆。

85
00:04:58,610 --> 00:05:03,050
看起来你拥有所有的内存，但是硬件的魔力只会让你觉得你拥有

86
00:05:03,050 --> 00:05:04,050
它。

87
00:05:04,050 --> 00:05:09,700
但是无论如何，CPU现在执行你的程序，它就在那巨大的内存中的某个地方。

88
00:05:09,699 --> 00:05:13,919
让我们看看这个内存是如何在一个真正的程序中划分的。

89
00:05:13,919 --> 00:05:19,289
例如，在这里，我们看到从这个起始地址到这个结束地址，

90
00:05:19,289 --> 00:05:21,019
程序已映射。

91
00:05:21,020 --> 00:05:26,460
我们说是映射的，因为它实际上不在这个地址，但如果你愿意的话，它就在那里。

92
00:05:26,460 --> 00:05:30,150
用汇编代码从该地址读取值。

93
00:05:30,150 --> 00:05:35,370
所以忽略了底层的物质现实，只是接受了这个巨大的范围

94
00:05:35,369 --> 00:05:37,299
你能用的记忆。

95
00:05:37,300 --> 00:05:39,330
事实上，堆栈也就在这里。

96
00:05:39,330 --> 00:05:42,930
它也被定义为从这个地址开始到这个地址结束。

97
00:05:42,930 --> 00:05:47,780
所以堆栈并没有真正的增长或收缩，这只是计算机理论模型。

98
00:05:47,779 --> 00:05:48,779
堆栈的

99
00:05:48,779 --> 00:05:51,329
但是堆栈实际上是如何定义的呢？

100
00:05:51,330 --> 00:05:56,900
CPU有堆栈寄存器esp，它将包含一个指向

101
00:05:56,899 --> 00:05:58,529
这里是这个地区。

102
00:05:58,530 --> 00:06:01,830
所以你可以把栈指针指向其他地方吗？

103
00:06:01,830 --> 00:06:02,930
就像你的代码？

104
00:06:02,930 --> 00:06:03,930
是啊！

105
00:06:03,930 --> 00:06:04,930
你完全可以。

106
00:06:04,930 --> 00:06:08,950
堆栈指针没有什么特别的，它只是一个包含地址的寄存器，

107
00:06:08,949 --> 00:06:11,499
它可以包含任何地址。

108
00:06:11,499 --> 00:06:18,229
使esp真正特别的是它根据指令做一些有趣的事情。

109
00:06:18,229 --> 00:06:24,869
例如，pop eax指令将查找存储在该位置的值

110
00:06:24,869 --> 00:06:28,979
esp指向的地方，通常是堆栈，但不必。

111
00:06:28,979 --> 00:06:33,089
然后将该位置的值写入EAX寄存器。

112
00:06:33,089 --> 00:06:37,249
你完全可以在剥削中滥用它。

113
00:06:37,249 --> 00:06:41,169
例如，如果您发现一个bug，它允许您将堆栈指针设置为

114
00:06:41,169 --> 00:06:47,139
值，您可以在堆上创建一个伪堆栈，并将esp指向那里。

115
00:06:47,139 --> 00:06:49,849
通常被称为堆栈轴心。

116
00:06:49,849 --> 00:06:54,999
因此，失去你在计算机科学中所学的一堆不断增长和缩小的精神图像，

117
00:06:54,999 --> 00:06:57,039
想想它到底是什么。

118
00:06:57,039 --> 00:07:01,359
ESP寄存器指向的只是一些内存。

119
00:07:01,360 --> 00:07:04,530
指令会根据寄存器产生有趣的效果。

120
00:07:04,529 --> 00:07:08,809
同样，指令指针也不是特殊的。

121
00:07:08,809 --> 00:07:12,089
通常它指向您的代码，但不必。

122
00:07:12,089 --> 00:07:16,749
如果你设法控制了EIP，你可以把它指向其他内存。

123
00:07:16,749 --> 00:07:20,379
例如，我们在以前的开发中使用的堆栈。

124
00:07:20,379 --> 00:07:24,369
因为我们将实际上是有效汇编程序代码的数据放在堆栈上。

125
00:07:24,369 --> 00:07:25,669
你知道它是shellcode。

126
00:07:25,669 --> 00:07:27,729
CPU不关心。

127
00:07:27,729 --> 00:07:33,069
EIP寄存器指向一些内存，CPU很高兴地完成这些值。

128
00:07:33,069 --> 00:07:34,069
说。

129
00:07:34,069 --> 00:07:36,659
好吧，这只是半真半假。

130
00:07:36,660 --> 00:07:41,670
因为正如您可能知道的，在现代系统中，堆栈不再是可执行的，所以

131
00:07:41,669 --> 00:07:43,109
CPU有点在意，但也不是真的。

132
00:07:43,110 --> 00:07:48,050
它只是意味着内存中的某些区域可以具有不同的权限。

133
00:07:48,050 --> 00:07:53,300
某些区域具有可执行标记，这意味着CPU允许EIP指向该区域，并且

134
00:07:53,300 --> 00:07:57,800
乐于将这些值解释为指令，但堆栈等其他区域没有

135
00:07:57,800 --> 00:07:58,800
它。

136
00:07:58,800 --> 00:08:01,860
然后CPU拒绝将其解释为指令。

137
00:08:01,860 --> 00:08:07,030
现在，当我们更接近于所有这些不同的数据中包含了什么类型的数据时

138
00:08:07,030 --> 00:08:12,520
记忆区，我们可以尝试想出创造性的方法来滥用。

139
00:08:12,520 --> 00:08:15,580
一个例子是典型的堆栈结构。

140
00:08:15,580 --> 00:08:21,470
当CPU执行一条调用指令时，它将放置当前指令指针值

141
00:08:21,469 --> 00:08:23,919
堆栈指针指向的地址。

142
00:08:23,919 --> 00:08:26,559
它将它放在堆栈的顶部。

143
00:08:26,560 --> 00:08:30,840
当函数返回时，它获取堆栈指针指向和的值。

144
00:08:30,839 --> 00:08:33,409
设置指向它的指令指针。

145
00:08:33,410 --> 00:08:38,220
因此，如果您设法在堆栈上修改这个值，您可以控制到什么EIP

146
00:08:38,220 --> 00:08:42,490
将设置为函数返回的时间，因此您可以决定执行什么操作

147
00:08:42,490 --> 00:08:43,490
下一步。

148
00:08:43,490 --> 00:08:44,880
这是典型的缓冲区溢出。

149
00:08:44,880 --> 00:08:49,870
另一个有趣的数据结构是全局偏移表，它基本上只是

150
00:08:49,870 --> 00:08:56,620
内存中包含指向函数的指针的区域，如果覆盖其中的条目，也可以

151
00:08:56,620 --> 00:09:01,610
控制如果调用的函数引用的地址来自

152
00:09:01,610 --> 00:09:02,610
这张桌子。

153
00:09:02,610 --> 00:09:06,750
我的意思是，通常你不能直接覆盖这些值，但这只是意味着你有

154
00:09:06,750 --> 00:09:08,680
变得有创造力。

155
00:09:08,680 --> 00:09:11,400
例如，考虑堆上的两个对象。

156
00:09:11,400 --> 00:09:15,870
一个用户对象和一个名称对象，并且该用户对象具有指向该名称对象的指针。

157
00:09:15,870 --> 00:09:20,070
当您想更改这个用户的名称时，代码将跟随指针并

158
00:09:20,070 --> 00:09:26,030
将新名称写入该位置，这意味着如果您可以以某种方式覆盖该指针，

159
00:09:26,030 --> 00:09:29,120
您可以控制将名称写入的位置。

160
00:09:29,120 --> 00:09:33,020
所以我们可以用堆栈上的地址覆盖名称指针，当我们写

161
00:09:33,021 --> 00:09:37,411
用户的新名称，我们将实际覆盖上存储的指令指针

162
00:09:37,410 --> 00:09:38,430
堆栈。

163
00:09:38,430 --> 00:09:39,680
看到我想说什么了吗？

164
00:09:39,680 --> 00:09:42,260
内存中包含数据。

165
00:09:42,260 --> 00:09:47,830
某些限制适用，例如某些内存区域不可写，其他区域不可执行。

166
00:09:47,830 --> 00:09:53,250
还有一个非常愚蠢的CPU，只执行EIP指向的任何操作。

167
00:09:53,250 --> 00:09:57,020
内存中有一个程序，由CPU执行。

168
00:09:57,020 --> 00:10:00,170
这段代码使用内存来做它应该做的事情。

169
00:10:00,170 --> 00:10:04,500
它信任内存中数据的某种完整性。

170
00:10:04,500 --> 00:10:08,590
但是如果有一个bug，它允许你改变内存中的一个值，程序

171
00:10:08,590 --> 00:10:12,700
不打算修改，会发生惊人的事情。

172
00:10:12,700 --> 00:10:18,120
可能发生的事情，只是受到你的创造力和想象力的限制。

173
00:10:18,120 --> 00:10:23,910
内存中的一个更改的字节可能会导致某段代码意外写入

174
00:10:23,910 --> 00:10:28,410
覆盖对象的函数指针的位置，代码的另一部分

175
00:10:28,410 --> 00:10:33,570
想要使用，突然执行一些非常不同的东西。

176
00:10:33,570 --> 00:10:38,630
我们将这些技术命名为堆栈缓冲区溢出、堆风水，

177
00:10:38,630 --> 00:10:44,940
免费使用ROP，都是解决内存中数据问题的创造性方法

178
00:10:44,940 --> 00:10:48,760
由CPU执行的程序对其作出反应。

179
00:10:48,760 --> 00:10:54,020
我知道这一集可能没有包含你真正有用的信息。

180
00:10:54,020 --> 00:10:58,440
但我有点想把它拿出来，因为也许有人不太喜欢看电视节目

181
00:10:58,440 --> 00:11:00,310
以这种方式进行剥削。

182
00:11:00,310 --> 00:11:03,080
但我希望你能以这种方式思考它的价值。

183
00:11:03,080 --> 00:11:07,350
我认为这消除了人们对一切看起来如此复杂的恐惧。

184
00:11:07,350 --> 00:11:11,200
我真的很想听听你对这件事的批评意见。

185
00:11:11,200 --> 00:11:13,930
所以请在YouTube或下面链接的Reddit线程上发表评论。

186
00:11:13,930 --> 00:11:17,850
但无论你是否喜欢，我们很快就会继续我们的学习之路

187
00:11:17,850 --> 00:11:19,850
更高级的内存损坏技术。

188
00:11:19,850 --> 00:11:21,890
所以，保持好奇，下次见。

