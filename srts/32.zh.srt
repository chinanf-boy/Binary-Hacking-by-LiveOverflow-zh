1
00:00:00,110 --> 00:00:03,480
所以我在浏览Reddit，这个新的面向初学者的CTF出现了。

2
00:00:03,479 --> 00:00:09,079
显然，我必须检查它，然后直接进入我最喜欢的类别，二进制开发

3
00:00:09,080 --> 00:00:10,080
东西。

4
00:00:10,080 --> 00:00:14,080
当然，有一个服务器可以作为普通用户连接，当您利用

5
00:00:14,079 --> 00:00:18,129
您将向另一个用户提升权限以访问机密的挑战

6
00:00:18,130 --> 00:00:19,240
旗帜。

7
00:00:19,240 --> 00:00:23,810
但最大的挑战是，我找不到禁止这样做的规则

8
00:00:23,810 --> 00:00:24,810
生根

9
00:00:24,810 --> 00:00:32,480
那我们就这么做吧。

10
00:00:32,480 --> 00:00:34,990
还记得我的脏母牛解释视频吗？

11
00:00:34,990 --> 00:00:40,030
让我们使用我们在那里的概念验证工具，并测试它是否适用于此

12
00:00:40,030 --> 00:00:41,030
服务器。

13
00:00:41,030 --> 00:00:44,370
所以我们可以简单地将这个代码复制到tmp中的一个文件中并编译它。

14
00:00:44,370 --> 00:00:49,180
测试是否可以覆盖不属于我们的文件，而不覆盖关键文件

15
00:00:49,180 --> 00:00:55,050
根拥有的文件，我们作为系统上的另一个挑战用户登录，创建一个包含

16
00:00:55,050 --> 00:00:56,050
内容。

17
00:00:56,050 --> 00:01:00,850
然后我们返回到第一个用户，对该文件执行dirty cow并尝试写入

18
00:01:00,850 --> 00:01:02,790
还有其他一些角色。

19
00:01:02,790 --> 00:01:04,950
当我们检查的时候，我们可以看到它起作用了。

20
00:01:04,949 --> 00:01:09,849
此时，我在Reddit上给作者写了一条消息，通知他服务器是

21
00:01:09,850 --> 00:01:12,070
易受攻击，他应该迅速更新。

22
00:01:12,070 --> 00:01:16,550
但是现在我们需要一个计划，我们可以覆盖什么根文件来自己成为根文件。

23
00:01:16,550 --> 00:01:21,650
我们的限制是，我们必须覆盖文件中的某些内容，我们不能追加或

24
00:01:21,650 --> 00:01:23,500
准备好任何东西。

25
00:01:23,500 --> 00:01:29,520
第一个明显的想法是使用setuid二进制文件，但问题是为了编写一个

26
00:01:29,520 --> 00:01:34,190
从后门shell到二进制文件，我们必须解析elf文件格式并找出

27
00:01:34,189 --> 00:01:36,549
入口点在哪里。

28
00:01:36,549 --> 00:01:40,589
更简单的策略是覆盖文本文件中的数据。

29
00:01:40,590 --> 00:01:43,280
我选择了/etc/passwd。

30
00:01:43,280 --> 00:01:48,200
您可以在这里看到用户的用户ID，如果我们要更改pwn1的uid

31
00:01:48,200 --> 00:01:51,280
用户为0时，我们将以根用户身份登录。

32
00:01:51,280 --> 00:01:52,280
所以。

33
00:01:52,280 --> 00:01:55,560
脏母牛概念证明写入文件的开头。

34
00:01:55,560 --> 00:01:58,560
所以我们首先要计算出/etc/passwd内部的偏移量。

35
00:01:58,560 --> 00:02:02,160
我们可以用hexdump来计算。

36
00:02:02,159 --> 00:02:06,839
所以pwn1用户的偏移量是hex 4c0加上一点。

37
00:02:06,840 --> 00:02:12,970
我使用python作为计算程序，并修改漏洞代码以写入固定的偏移量。

38
00:02:12,970 --> 00:02:14,960
我认为这是个好计划。

39
00:02:14,959 --> 00:02:20,089
你必须非常小心地选择这些补偿和选择什么

40
00:02:20,091 --> 00:02:23,951
写，因为如果你不写的话，你可以把整个系统搞砸。

41
00:02:23,950 --> 00:02:30,150
所以我复制/etc/passwd来尝试我想做的事情，然后再对真正的二进制文件进行操作。

42
00:02:30,150 --> 00:02:33,730
当然，我的第一次尝试会破坏系统。

43
00:02:33,730 --> 00:02:40,670
因此，稍微调整偏移量，并在末尾附加新行，最终是成功的。

44
00:02:40,670 --> 00:02:43,360
我写信给真正的/etc/passwd。

45
00:02:43,360 --> 00:02:47,870
现在，当我们切换到pwn1或ssh登录到pwn1时，会得到一个根shell。

46
00:02:47,870 --> 00:02:51,770
然后我们可以读出所有的标记。

47
00:02:51,770 --> 00:02:57,290
完成后，我们将/etc/passwd恢复到原始状态。

48
00:02:57,290 --> 00:02:58,550
一些重要的注释。

49
00:02:58,550 --> 00:03:01,930
非常小心你用这样的漏洞覆盖了什么。

50
00:03:01,930 --> 00:03:08,730
只有一个字节计算错误，您可能会使系统不稳定、崩溃、DOS或

51
00:03:08,730 --> 00:03:10,400
把自己锁在外面。

52
00:03:10,400 --> 00:03:15,590
另外，如果您发现服务器易受攻击，请考虑您所处的影响或上下文。

53
00:03:15,590 --> 00:03:21,070
这个小的私有CTF服务器项目，打算被锤击，不同于

54
00:03:21,069 --> 00:03:23,789
从某个随机公司开发的Web服务器。

55
00:03:23,790 --> 00:03:27,950
因此，如果您没有权限或可能导致

56
00:03:27,950 --> 00:03:30,400
损坏。

57
00:03:30,400 --> 00:03:32,210
做出合乎道德的决定。

58
00:03:32,209 --> 00:03:34,519
注意你所冒的风险。

59
00:03:34,519 --> 00:03:39,239
感谢Maro对这件事的冷静，并允许我制作一个关于它的视频。

60
00:03:39,239 --> 00:03:40,299
祝你的鸭嘴兽好运。

