1
00:00:00,380 --> 00:00:06,770
 exploit-exercises.com 的堆级别2 是，我们经常遇到的一个非常常见的问题。

2
00:00:06,770 --> 00:00:12,780
这是经典的 use-after-free 漏洞。

3
00:00:12,780 --> 00:00:19,530
让我们先试着理解代码。

4
00:00:19,529 --> 00:00:22,599
我们在 main 内部，有一个大的while循环。

5
00:00:22,599 --> 00:00:28,779
它每次循环，打印变量auth，该变量是指针，指向

6
00:00:28,779 --> 00:00:30,459
在这里的这个auth对象结构。

7
00:00:30,460 --> 00:00:36,260
auth有个属性 name，是一个最多32个字符的字符串和一个整数。

8
00:00:36,260 --> 00:00:41,330
另一个被打印的变量，是char指针 service ，

9
00:00:41,330 --> 00:00:42,410
它可以指向内存中的字符串。

10
00:00:42,410 --> 00:00:46,400
所以，这两个都是地址指针。

11
00:00:46,400 --> 00:00:48,970
然后，我们从标准输入中，读取一行。

12
00:00:48,970 --> 00:00:53,620
最大128字节，因此这是一个安全的 fgets 读取。

13
00:00:53,620 --> 00:00:55,610
没有缓冲区溢出。

14
00:00:55,610 --> 00:00:59,990
然后，我们有几个if，检查输入行是否

15
00:00:59,989 --> 00:01:00,989
为下列命令之一。

16
00:01:00,989 --> 00:01:03,869
“auth”、“reset”、“service”或“login”。

17
00:01:03,870 --> 00:01:08,190
让我们也执行程序，然后讨论每个命令。

18
00:01:08,189 --> 00:01:12,639
当我们第一次启动程序时，auth和 service 指针都为空。

19
00:01:12,640 --> 00:01:13,980
现在，我们等待输入。

20
00:01:13,979 --> 00:01:16,489
让我们看看“auth”命令。

21
00:01:16,490 --> 00:01:22,960
当我们键入auth时，它将分配 auth结构的大小，

22
00:01:22,960 --> 00:01:25,790
因此应该是32字节给 name ，加上整数的4字节。

23
00:01:25,789 --> 00:01:29,379
然后整个分配的内存，都被零覆盖。

24
00:01:29,380 --> 00:01:35,080
这是有意义的，因为如果在堆中，数据被不断地分配和释放，

25
00:01:35,079 --> 00:01:38,329
那么新分配的区域中，可以有旧数据。

26
00:01:38,329 --> 00:01:41,259
空闲状态，不会使内存归零。

27
00:01:41,259 --> 00:01:44,349
所以，这里的分配(值)就会保持为0。

28
00:01:44,350 --> 00:01:48,650
然后，检查输入行的长度，所以，在auth结构中，

29
00:01:48,649 --> 00:01:51,579
name 不超过32字节。

30
00:01:51,579 --> 00:01:56,209
如果这是安全的，那么在auth命令之后，字符将复制到

31
00:01:56,209 --> 00:01:57,209
 auth 对象 的 name。

32
00:01:57,209 --> 00:02:00,799
让我们试试，让我们作为管理员进行身份验证。

33
00:02:00,799 --> 00:02:05,089
很酷，我们可以看到变量auth，现在包含一个地址。

34
00:02:05,090 --> 00:02:08,260
这是auth对象，在堆中的位置。

35
00:02:08,259 --> 00:02:12,539
现在，最后一个命令是“login”，它检查auth对象的整数，

36
00:02:12,540 --> 00:02:15,850
是否不为零，如果是这样，我们就成功登录了。

37
00:02:15,850 --> 00:02:20,170
否则，如果它是零，那么它会告诉我们，要输入密码。

38
00:02:20,170 --> 00:02:23,330
不过，在这种情况下，没有比这更强大的安全功能了。

39
00:02:23,330 --> 00:02:28,300
但是，想象一下，你试图以管理员身份登录，但不知道我的密码。

40
00:02:28,300 --> 00:02:33,250
所以，我们的目标是将整数设置为一个值，然后，我们就可以通过验证。

41
00:02:33,250 --> 00:02:37,780
目前似乎不可能，因为整数 auth，从未在任何位置，设置过，

42
00:02:37,780 --> 00:02:42,290
但是我们从一开始就知道，存在允许我们修改变量的 bug。

43
00:02:42,290 --> 00:02:46,460
这里的另一个命令是 reset（重置），它将释放，堆上的auth对象。

44
00:02:46,460 --> 00:02:49,240
这就是真正的问题所在。

45
00:02:49,240 --> 00:02:54,460
您注意到，当我们 reset 登录过程时，它会释放 auth对象，

46
00:02:54,460 --> 00:02:59,370
但是正如您所看到的那样，auth变量没有重置为零，它仍然包含指向堆的指针，

47
00:02:59,370 --> 00:03:01,690
而堆中的对象是以前的。

48
00:03:01,690 --> 00:03:06,110
例如，当我们现在登录时，它将检查该对象的name属性。

49
00:03:06,110 --> 00:03:10,260
嗯，它没有改变，所以，我们还没有通过身份验证。

50
00:03:10,260 --> 00:03:15,680
但是，login 命令会“使用(use)”变量 auth，就在释放(free)它之后(after)。

51
00:03:15,680 --> 00:03:16,680
“Use-after-free”。

52
00:03:16,680 --> 00:03:17,680
听懂了吗？

53
00:03:17,680 --> 00:03:23,070
现在，这里的最后一个命令是service，它将执行一个strdup、字符串复制，

54
00:03:23,070 --> 00:03:25,160
在 service 命令后，关于字符。

55
00:03:25,160 --> 00:03:29,110
例如，我们可以指定，要使用黑客 service 。

56
00:03:29,110 --> 00:03:32,900
现在，我们在 service 变量中，还有一个地址。

57
00:03:32,900 --> 00:03:36,150
奇怪的是，它和 auth 是同一个。

58
00:03:36,150 --> 00:03:37,900
真奇怪。

59
00:03:37,900 --> 00:03:39,680
那么，strdup是做什么的呢？

60
00:03:39,680 --> 00:03:41,730
让我们看一下手册页。

61
00:03:41,730 --> 00:03:46,820
strdup返回一个指向新字符串的指针，该字符串是字符串 s 的副本。

62
00:03:46,820 --> 00:03:52,050
新字符串的内存，是用malloc获得的，可以用free释放。

63
00:03:52,050 --> 00:03:56,710
啊哈。所以它只是一个方便的函数，用来分配我们传递的

64
00:03:56,710 --> 00:03:59,400
字符串的长度，还有复制到那里。

65
00:03:59,400 --> 00:04:03,240
所以，它也会调用malloc，从而在堆上分配东西。

66
00:04:03,240 --> 00:04:07,880
你已经可以猜到，为什么 service 得到的，是和auth相同的地址，

67
00:04:07,880 --> 00:04:11,950
因为auth 释放后，就有了空闲空间， service 在那里获得了空闲空间。

68
00:04:11,950 --> 00:04:14,650
让我们在gdb中，看看这个。

69
00:04:14,650 --> 00:04:16,690
首先，我们将汇编程序语法，设置为intel。

70
00:04:16,690 --> 00:04:18,460
然后我们反汇编 main 。

71
00:04:18,459 --> 00:04:23,379
我们首先运行它，并使用auth一次，所以，我们至少执行了一个malloc。

72
00:04:23,380 --> 00:04:27,860
然后，按 control+c，并使用 info proc mappings 检查堆的地址。

73
00:04:27,860 --> 00:04:32,120
现在的检查手段就是，我们从堆中，打印20个单词。

74
00:04:32,120 --> 00:04:35,930
另外，因为这个应用程序，仍然拥有二进制文件中的所有符号和内容，

75
00:04:35,930 --> 00:04:40,940
gdb还知道auth，来自 auth 结构类型，我们可以再次打印它。

76
00:04:40,940 --> 00:04:44,940
这里我们可以看到字符串 name 和 auth整数。

77
00:04:44,940 --> 00:04:47,750
我们可以对 service 字符串，执行相同的操作。

78
00:04:47,750 --> 00:04:51,250
现在。让我们在printf之前。创建一个断点。

79
00:04:51,250 --> 00:04:57,440
通过钩子命令，我们可以键入当我们到达这个断点时，（gdb）应该执行什么命令。

80
00:04:57,440 --> 00:05:00,910
我们可以用 echo 打印一些字符串，使其看起来更漂亮。

81
00:05:00,910 --> 00:05:02,630
首先，我们要打印堆。

82
00:05:02,630 --> 00:05:03,810
我们 echo 一行。

83
00:05:03,810 --> 00:05:06,410
然后，我们要打印auth变量。

84
00:05:06,410 --> 00:05:07,410
另一行。

85
00:05:07,410 --> 00:05:08,410
以及 service 变量。

86
00:05:08,410 --> 00:05:09,780
最后，我们自动继续。

87
00:05:09,780 --> 00:05:12,930
结尾，完成命令序列。

88
00:05:12,930 --> 00:05:15,030
现在，让我们重新运行这个二进制文件。

89
00:05:15,030 --> 00:05:19,330
好的，首先我们会得到一些内存错误，因为堆还不存在，所以用 malloc

90
00:05:19,330 --> 00:05:23,750
我们的第一个值，是以“auth”作为管理员，进行身份验证。

91
00:05:23,750 --> 00:05:28,930
另外，让我们禁用gdb的分页，这样我们会打印所有内容，

92
00:05:28,930 --> 00:05:31,880
而不获取“type &lt;return&gt; to continue”对话框。set pagination off

93
00:05:31,880 --> 00:05:35,150
现在，我们可以看到我们的堆了。

94
00:05:35,150 --> 00:05:38,730
就像我们期望的那样，这带有我们 name 字符串的  admin 的块。

95
00:05:38,730 --> 00:05:39,730
蛋蛋是

96
00:05:39,730 --> 00:05:40,730
有点奇怪。

97
00:05:40,730 --> 00:05:46,970
为什么这个块的长度，只有十六进制10，即减去 8 字节，

98
00:05:46,970 --> 00:05:48,050
你就只剩下，8字节的块头….

99
00:05:48,050 --> 00:05:51,900
它不应该是，32字节的 name 加上 整数吗？

100
00:05:51,900 --> 00:05:53,840
怎么了？

101
00:05:53,840 --> 00:05:57,550
好吧，这对解决方案来说，并不重要，但如果你写得很糟糕的代码，

102
00:05:57,550 --> 00:05:59,810
到处命名 auth，就会发生这种情况。

103
00:05:59,810 --> 00:06:03,810
结构称为 auth，auth结构指针又称为auth，

104
00:06:03,810 --> 00:06:05,120
这里的整数又又叫做 auth。

105
00:06:05,120 --> 00:06:10,210
当程序员计算auth的大小时，

106
00:06:10,210 --> 00:06:11,870
它计算auth变量的大小，而不是结构auth。

107
00:06:11,870 --> 00:06:16,060
因此，它只有4个字节，但 malloc 将它与8个字节对齐。

108
00:06:16,060 --> 00:06:17,060
天哪。

109
00:06:17,060 --> 00:06:18,060
人。

110
00:06:18,060 --> 00:06:19,090
请更好地命名变量。

111
00:06:19,090 --> 00:06:21,500
这就是，错误和安全要考虑的问题。

112
00:06:21,500 --> 00:06:24,630
不管怎样，我们暂时忽略这一点。

113
00:06:24,630 --> 00:06:26,920
早些时候，我们想知道 free 是如何运作的。

114
00:06:26,919 --> 00:06:31,439
因此，让我们用 reset 释放auth对象，并注意哪些更改。

115
00:06:31,440 --> 00:06:32,610
好吧，哈哈哈。

116
00:06:32,610 --> 00:06:34,410
基本上，没有改变。

117
00:06:34,410 --> 00:06:38,610
除了，块数据的第一个字，被替换为0。

118
00:06:38,610 --> 00:06:42,650
这是因为 free 块中的第一个词，

119
00:06:42,650 --> 00:06:43,870
被定义为前一个 free 块地址(表明前一个块的状态)。

120
00:06:43,870 --> 00:06:46,890
因为 free 块是一个链表。

121
00:06:46,890 --> 00:06:50,670
但是，我们在这个列表中，没有另一个空闲块，因此它是 null 的。

122
00:06:50,669 --> 00:06:54,639
所以，除了malloc算法之外，实际上没有发生什么事情

123
00:06:54,639 --> 00:06:58,739
在开始时，重新开始，它不关心在堆中，是否还有剩余值

124
00:06:58,740 --> 00:07:03,060
只要元数据像前一个地址指针这样的，就是正确的。

125
00:07:03,060 --> 00:07:06,430
因此，它只是改了那个特定的值。

126
00:07:06,430 --> 00:07:10,990
不管怎样，我们现在可以看到auth对象仍然存在，

127
00:07:10,990 --> 00:07:11,990
且该指针在这里，指向堆中。

128
00:07:11,990 --> 00:07:15,560
但是， name 现在是空的，带有 null，整数仍然是 null。

129
00:07:15,560 --> 00:07:16,560
但是。

130
00:07:16,560 --> 00:07:19,540
让我们使用 service ，在堆上分配一个字符串。

131
00:07:19,540 --> 00:07:22,300
让我们只分配，一些便于识别的字符。

132
00:07:22,300 --> 00:07:23,860
像AAA一样。

133
00:07:23,860 --> 00:07:28,700
注意只有3个A，因为代码很糟糕，它还占用了 A 前面的空间。

134
00:07:28,700 --> 00:07:31,300
在堆中，我们可以看到字符串已被分配。

135
00:07:31,300 --> 00:07:35,430
我们看到auth对象的 name ，现在有一些不同的值。

136
00:07:35,430 --> 00:07:38,940
现在让我们为 service ，分配一个新的字符串。

137
00:07:38,940 --> 00:07:40,110
BBB。

138
00:07:40,110 --> 00:07:42,150
另一个是CCC。

139
00:07:42,150 --> 00:07:44,690
我们看到堆慢慢地填满了。

140
00:07:44,690 --> 00:07:45,690
呃！

141
00:07:45,690 --> 00:07:46,690
那是什么？

142
00:07:46,690 --> 00:07:49,490
突然间，auth整数有一个巨大的值。

143
00:07:49,490 --> 00:07:53,970
这是因为，它指向存储了CCC的堆。

144
00:07:53,970 --> 00:07:57,640
如果，我们现在登录，那么我们会收到一条消息，说明我们已经登录了。

145
00:07:57,640 --> 00:07:58,640
雕！

146
00:07:58,640 --> 00:08:02,580
我不得不说，这个级别太糟糕了。

147
00:08:02,580 --> 00:08:07,050
正如我前面提到的，代码太糟糕了，它为auth对象

148
00:08:07,050 --> 00:08:08,050
分配了错误的大小。

149
00:08:08,050 --> 00:08:09,050
空间太小了。

150
00:08:09,050 --> 00:08:10,280
我指给你看。

151
00:08:10,280 --> 00:08:12,980
让我们重新启动它，并作为管理员再次进行身份验证。

152
00:08:12,979 --> 00:08:16,569
现在，只需输入一个 along service 字符串。

153
00:08:16,570 --> 00:08:18,950
而炸裂，我们也覆盖了整数。

154
00:08:18,949 --> 00:08:20,999
同样，我们也收到登录信息。

155
00:08:21,000 --> 00:08:26,220
所以，我们不需要用 reset 释放 auth对象，来解决它，但是我想介绍一下

156
00:08:26,220 --> 00:08:29,740
“use-after-free”这一术语，而这也是该挑战的一个可行计划。

