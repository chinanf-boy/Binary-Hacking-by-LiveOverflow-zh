1
00:00:00,380 --> 00:00:06,770
一个非常普遍的问题，我们仍然不断
遭遇在exploit-exercises.com的堆级别2中显示。

2
00:00:06,770 --> 00:00:12,780
这是自由漏洞后的经典用法。

3
00:00:12,780 --> 00:00:19,530
让我们先试着理解代码。

4
00:00:19,529 --> 00:00:22,599
我们在主管道内部有一个大的while循环。

5
00:00:22,599 --> 00:00:28,779
在每一轮中，它打印变量auth，
它是指向此身份验证对象的指针

6
00:00:28,779 --> 00:00:30,459
结构在这里。

7
00:00:30,460 --> 00:00:36,260
auth的属性名是
最多32个字符的字符串和一个整数。

8
00:00:36,260 --> 00:00:41,330
打印的另一个变量是
char指针服务，可以指向

9
00:00:41,330 --> 00:00:42,410
内存中的字符串。

10
00:00:42,410 --> 00:00:46,400
所以这两个都是地址指针。

11
00:00:46,400 --> 00:00:48,970
然后我们从标准输入中读取一行。

12
00:00:48,970 --> 00:00:53,620
最大128字节，因此这是一个安全的fgets
读。

13
00:00:53,620 --> 00:00:55,610
没有缓冲区溢出。

14
00:00:55,610 --> 00:00:59,990
然后我们有几个国际单项体育联合会检查
如果输入行是下列之一

15
00:00:59,989 --> 00:01:00,989
命令。

16
00:01:00,989 --> 00:01:03,869
"auth"，"reset"，"service"
或"登录"。

17
00:01:03,870 --> 00:01:08,190
让我们也执行程序，然后
我们来谈谈每个命令。

18
00:01:08,189 --> 00:01:12,639
当我们第一次启动程序时，
auth和服务指针为空。

19
00:01:12,640 --> 00:01:13,980
现在我们等待输入。

20
00:01:13,979 --> 00:01:16,489
让我们看看"auth"命令。

21
00:01:16,490 --> 00:01:22,960
当我们键入auth时，它将分配大小
身份验证结构的，因此应该是32字节

22
00:01:22,960 --> 00:01:25,790
对于名称+整数的4字节。

23
00:01:25,789 --> 00:01:29,379
然后覆盖整个分配的内存
用零。

24
00:01:29,380 --> 00:01:35,080
这是有意义的，因为如果在堆中，
不断地分配和释放，然后

25
00:01:35,079 --> 00:01:38,329
新分配的区域中可以有旧数据
那里。

26
00:01:38,329 --> 00:01:41,259
空闲状态不会使内存归零。

27
00:01:41,259 --> 00:01:44,349
所以这里的分配是零。

28
00:01:44,350 --> 00:01:48,650
然后输入行的长度为
已检查，因此不超过32个字节

29
00:01:48,649 --> 00:01:51,579
在auth结构中可用于该名称。

30
00:01:51,579 --> 00:01:56,209
如果安全的话，后面的角色
auth命令被复制到

31
00:01:56,209 --> 00:01:57,209
身份验证对象。

32
00:01:57,209 --> 00:02:00,799
让我们试试，让我们验证为
管理员。

33
00:02:00,799 --> 00:02:05,089
很酷，我们可以看到变量auth包含
现在是一个地址。

34
00:02:05,090 --> 00:02:08,260
这是auth对象在堆中的位置。

35
00:02:08,259 --> 00:02:12,539
现在最后一个命令是"login"，它是
检查auth对象的整数是否为

36
00:02:12,540 --> 00:02:15,850
不是零，如果是这样的话，我们就成功了
登录。

37
00:02:15,850 --> 00:02:20,170
否则，如果它是零，那么它会告诉我们
输入密码。

38
00:02:20,170 --> 00:02:23,330
但是在这种情况下，没有更多的功能
比那个。

39
00:02:23,330 --> 00:02:28,300
但想象一下你正在尝试登录
作为管理员，不知道我的密码。

40
00:02:28,300 --> 00:02:33,250
所以我们的目标是设置整数
到一个值，然后我们被验证。

41
00:02:33,250 --> 00:02:37,780
目前似乎不可能，因为
整数身份验证从不在任何地方设置，但是

42
00:02:37,780 --> 00:02:42,290
我们从一开始就知道
是允许我们修改变量的错误。

43
00:02:42,290 --> 00:02:46,460
这里的另一个命令是reset，它将
释放堆上的auth对象。

44
00:02:46,460 --> 00:02:49,240
这就是问题所在。

45
00:02:49,240 --> 00:02:54,460
您注意到当我们重置登录过程时，
它释放auth对象，但如您所见

46
00:02:54,460 --> 00:02:59,370
auth变量没有重置为零，它
仍然包含指向堆的指针，其中

47
00:02:59,370 --> 00:03:01,690
对象是以前的。

48
00:03:01,690 --> 00:03:06,110
例如，当我们现在登录时，它会
检查该对象的名称属性。

49
00:03:06,110 --> 00:03:10,260
嗯，它没有改变，所以我们还是
未经身份验证。

50
00:03:10,260 --> 00:03:15,680
但是login命令将"使用"变量
在我们刚刚释放它之后。

51
00:03:15,680 --> 00:03:16,680
"免费使用"。

52
00:03:16,680 --> 00:03:17,680
了解了？

53
00:03:17,680 --> 00:03:23,070
现在这里最后一个命令是service，它
将执行strdup、字符串复制，

54
00:03:23,070 --> 00:03:25,160
服务命令后的字符数。

55
00:03:25,160 --> 00:03:29,110
例如，我们可以指定
使用黑客服务。

56
00:03:29,110 --> 00:03:32,900
现在我们还有一个服务地址
变量。

57
00:03:32,900 --> 00:03:36,150
奇怪的是，它和auth是同一个。

58
00:03:36,150 --> 00:03:37,900
真奇怪。

59
00:03:37,900 --> 00:03:39,680
那么strdup是做什么的呢？

60
00:03:39,680 --> 00:03:41,730
让我们看一下手册页。

61
00:03:41,730 --> 00:03:46,820
strdup返回指向新字符串的指针，该字符串
是字符串S的一个二元。

62
00:03:46,820 --> 00:03:52,050
获取新字符串的内存
使用malloc，可以免费释放。

63
00:03:52,050 --> 00:03:56,710
啊哈。所以这只是一个方便的功能
它分配字符串的长度

64
00:03:56,710 --> 00:03:59,400
传过去，复制到那里。

65
00:03:59,400 --> 00:04:03,240
所以它也会调用malloc，从而分配
堆里的东西。

66
00:04:03,240 --> 00:04:07,880
你已经可以猜到为什么服务
与auth地址相同，因为auth是

67
00:04:07,880 --> 00:04:11,950
释放，有空闲空间，服务得到
那里的自由空间。

68
00:04:11,950 --> 00:04:14,650
让我们在gdb中看看这个。

69
00:04:14,650 --> 00:04:16,690
首先，我们将汇编程序语法设置为intel。

70
00:04:16,690 --> 00:04:18,460
然后我们拆卸主管道。

71
00:04:18,459 --> 00:04:23,379
让我们先运行它并使用auth一次，所以
我们至少做了一次malloc。

72
00:04:23,380 --> 00:04:27,860
然后按control+c并检查地址
具有信息进程映射的堆。

73
00:04:27,860 --> 00:04:32,120
现在我们可以用
检查。

74
00:04:32,120 --> 00:04:35,930
另外，因为这个应用程序仍然
二进制文件中的符号和内容，

75
00:04:35,930 --> 00:04:40,940
gdb还知道auth来自类型
结构认证，我们可以再次打印。

76
00:04:40,940 --> 00:04:44,940
我们可以在这里看到字符串名称和
Auth-整数。

77
00:04:44,940 --> 00:04:47,750
我们可以对服务字符串执行相同的操作。

78
00:04:47,750 --> 00:04:51,250
现在让我们在
打印输出。

79
00:04:51,250 --> 00:04:57,440
通过命令，我们可以输入什么（gdb）命令
将在我们到达该断点时执行。

80
00:04:57,440 --> 00:05:00,910
我们可以用echo打印一些字符串
看起来更漂亮。

81
00:05:00,910 --> 00:05:02,630
首先我们要打印堆。

82
00:05:02,630 --> 00:05:03,810
我们回响一条线。

83
00:05:03,810 --> 00:05:06,410
然后我们要打印auth变量。

84
00:05:06,410 --> 00:05:07,410
另一条线。

85
00:05:07,410 --> 00:05:08,410
以及服务变量。

86
00:05:08,410 --> 00:05:09,780
最后我们自动继续。

87
00:05:09,780 --> 00:05:12,930
finsih命令序列结束。

88
00:05:12,930 --> 00:05:15,030
现在让我们重新运行这个二进制文件。

89
00:05:15,030 --> 00:05:19,330
好的，首先我们会得到一些内存错误，因为
堆还不存在，所以我们来看看malloc

90
00:05:19,330 --> 00:05:23,750
我们的第一个值是通过"auth"进行身份验证
作为管理员。

91
00:05:23,750 --> 00:05:28,930
另外，让我们禁用gdbs分页，这样我们
总是打印所有内容，而不获取

92
00:05:28,930 --> 00:05:31,880
"键入&lt；返回&gt；继续"对话框。
关闭分页

93
00:05:31,880 --> 00:05:35,150
现在我们可以看到我们的堆了。

94
00:05:35,150 --> 00:05:38,730
就像我们期望的那样，我们在这里有一大块
字符串名称管理。

95
00:05:38,730 --> 00:05:39,730
布鲁尤特

96
00:05:39,730 --> 00:05:40,730
有点奇怪。

97
00:05:40,730 --> 00:05:46,970
为什么这个块的长度只有十六进制10，
减去

98
00:05:46,970 --> 00:05:48,050
8字节块头….

99
00:05:48,050 --> 00:05:51,900
它不应该是32字节的名称+整数吗？

100
00:05:51,900 --> 00:05:53,840
怎么了？

101
00:05:53,840 --> 00:05:57,550
这对解决方案来说并不重要，
但如果你写的很糟糕，就会发生这种情况

102
00:05:57,550 --> 00:05:59,810
代码，并命名所有身份验证。

103
00:05:59,810 --> 00:06:03,810
结构被称为auth，结构auth
指针被称为auth，整数在

104
00:06:03,810 --> 00:06:05,120
这里叫auth。

105
00:06:05,120 --> 00:06:10,210
当程序员计算出
对于auth，它计算变量的大小

106
00:06:10,210 --> 00:06:11,870
auth，而不是结构auth。

107
00:06:11,870 --> 00:06:16,060
因此只有4个字节，但malloc对齐
它为8字节。

108
00:06:16,060 --> 00:06:17,060
天哪。

109
00:06:17,060 --> 00:06:18,060
人。

110
00:06:18,060 --> 00:06:19,090
请更好地命名变量。

111
00:06:19,090 --> 00:06:21,500
这就是如何创建错误和安全问题。

112
00:06:21,500 --> 00:06:24,630
不管怎样，我们暂时忽略这一点。

113
00:06:24,630 --> 00:06:26,920
早些时候，我们想知道自由是如何运作的。

114
00:06:26,919 --> 00:06:31,439
让我们用reset释放auth对象，
注意变化。

115
00:06:31,440 --> 00:06:32,610
好吧，LOL。

116
00:06:32,610 --> 00:06:34,410
基本上没有改变。

117
00:06:34,410 --> 00:06:38,610
除了块数据的第一个字
被0替换。

118
00:06:38,610 --> 00:06:42,650
因为这是自由的第一个词
块定义为上一个可用块

119
00:06:42,650 --> 00:06:43,870
地址。

120
00:06:43,870 --> 00:06:46,890
因为自由块是一个链表。

121
00:06:46,890 --> 00:06:50,670
但是我们没有另一个自由区
这个列表，因此它是空的。

122
00:06:50,669 --> 00:06:54,639
所以除了
malloc算法知道自由堆

123
00:06:54,639 --> 00:06:58,739
从一开始就重新开始，但没有
注意是否还有剩余值

124
00:06:58,740 --> 00:07:03,060
堆，只要元数据像
上一个地址指针正确。

125
00:07:03,060 --> 00:07:06,430
因此它只改变了那个特定的值。

126
00:07:06,430 --> 00:07:10,990
不管怎样，我们现在可以看到auth对象
指针仍存在于堆中

127
00:07:10,990 --> 00:07:11,990
在这里。

128
00:07:11,990 --> 00:07:15,560
但是名称现在是空的，带有空值，并且
整数仍然为空。

129
00:07:15,560 --> 00:07:16,560
但是。

130
00:07:16,560 --> 00:07:19,540
让我们使用服务在
堆。

131
00:07:19,540 --> 00:07:22,300
让我们只分配一些可识别的字符。

132
00:07:22,300 --> 00:07:23,860
像AAA一样。

133
00:07:23,860 --> 00:07:28,700
注意只有3个as，因为代码很糟糕
它还占用了AS之前的空间。

134
00:07:28,700 --> 00:07:31,300
在堆上，我们可以看到字符串
得到分配。

135
00:07:31,300 --> 00:07:35,430
我们看到auth对象的名称
现在有了一些不同的值。

136
00:07:35,430 --> 00:07:38,940
现在让我们为服务分配一个新的字符串。

137
00:07:38,940 --> 00:07:40,110
血脑屏障。

138
00:07:40,110 --> 00:07:42,150
另一个是CCC。

139
00:07:42,150 --> 00:07:44,690
我们看到堆慢慢地填满了。

140
00:07:44,690 --> 00:07:45,690
哼！

141
00:07:45,690 --> 00:07:46,690
那是什么？

142
00:07:46,690 --> 00:07:49,490
突然间，auth整数有一个巨大的值。

143
00:07:49,490 --> 00:07:53,970
那是因为它指向堆中
存储CCC。

144
00:07:53,970 --> 00:07:57,640
如果我们现在登录，我们就会收到消息
我们已经登录。

145
00:07:57,640 --> 00:07:58,640
令人惊叹的！

146
00:07:58,640 --> 00:08:02,580
我不得不说这个水平太糟糕了。

147
00:08:02,580 --> 00:08:07,050
正如我在前面提到的，代码太糟糕了
它为auth分配了错误的大小

148
00:08:07,050 --> 00:08:08,050
对象。

149
00:08:08,050 --> 00:08:09,050
空间太小了。

150
00:08:09,050 --> 00:08:10,280
我指给你看。

151
00:08:10,280 --> 00:08:12,980
让我们重新启动它并作为管理员再次进行身份验证。

152
00:08:12,979 --> 00:08:16,569
现在只需输入一个伴随服务字符串。

153
00:08:16,570 --> 00:08:18,950
而Boom，我们也覆盖了整数。

154
00:08:18,949 --> 00:08:20,999
我们收到登录信息。

155
00:08:21,000 --> 00:08:26,220
所以我们不需要释放auth对象
用重置来解决，但我想介绍一下

156
00:08:26,220 --> 00:08:29,740
"免费使用"一词，也是
有点像预期的挑战。

