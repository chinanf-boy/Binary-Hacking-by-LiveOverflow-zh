1
00:00:00,380 --> 00:00:06,770
我们经常遇到的一个非常常见的问题显示在exploit-exercises.com的堆级别2中。

2
00:00:06,770 --> 00:00:12,780
这是自由漏洞后的经典用法。

3
00:00:12,780 --> 00:00:19,530
让我们先试着理解代码。

4
00:00:19,529 --> 00:00:22,599
我们在主管道内部有一个大的while循环。

5
00:00:22,599 --> 00:00:28,779
在每一轮中，它打印变量auth，该变量是指向此auth对象的指针。

6
00:00:28,779 --> 00:00:30,459
结构在这里。

7
00:00:30,460 --> 00:00:36,260
auth的属性名是一个最多32个字符的字符串和一个整数。

8
00:00:36,260 --> 00:00:41,330
另一个被打印的变量是char指针服务，它可以指向

9
00:00:41,330 --> 00:00:42,410
内存中的字符串。

10
00:00:42,410 --> 00:00:46,400
所以这两个都是地址指针。

11
00:00:46,400 --> 00:00:48,970
然后我们从标准输入中读取一行。

12
00:00:48,970 --> 00:00:53,620
最大128字节，因此这是一个安全的fgets读取。

13
00:00:53,620 --> 00:00:55,610
没有缓冲区溢出。

14
00:00:55,610 --> 00:00:59,990
然后，我们有几个IFS检查输入行是否是下列之一

15
00:00:59,989 --> 00:01:00,989
命令。

16
00:01:00,989 --> 00:01:03,869
“auth”、“reset”、“service”或“login”。

17
00:01:03,870 --> 00:01:08,190
让我们也执行程序，然后讨论每个命令。

18
00:01:08,189 --> 00:01:12,639
当我们第一次启动程序时，auth和服务指针都为空。

19
00:01:12,640 --> 00:01:13,980
现在我们等待输入。

20
00:01:13,979 --> 00:01:16,489
让我们看看“auth”命令。

21
00:01:16,490 --> 00:01:22,960
当我们键入auth时，它将分配auth结构的大小，因此应该是32字节

22
00:01:22,960 --> 00:01:25,790
对于名称+整数的4字节。

23
00:01:25,789 --> 00:01:29,379
然后整个分配的内存被零覆盖。

24
00:01:29,380 --> 00:01:35,080
这是有意义的，因为如果在堆中，数据被不断地分配和释放，那么

25
00:01:35,079 --> 00:01:38,329
新分配的区域中可以有旧数据。

26
00:01:38,329 --> 00:01:41,259
空闲状态不会使内存归零。

27
00:01:41,259 --> 00:01:44,349
所以这里的分配是零。

28
00:01:44,350 --> 00:01:48,650
然后检查输入行的长度，使其不超过32字节

29
00:01:48,649 --> 00:01:51,579
在auth结构中可用于该名称。

30
00:01:51,579 --> 00:01:56,209
如果这是安全的，那么auth命令后的字符将复制到

31
00:01:56,209 --> 00:01:57,209
身份验证对象。

32
00:01:57,209 --> 00:02:00,799
让我们试试，让我们作为管理员进行身份验证。

33
00:02:00,799 --> 00:02:05,089
很酷，我们可以看到变量auth现在包含一个地址。

34
00:02:05,090 --> 00:02:08,260
这是auth对象在堆中的位置。

35
00:02:08,259 --> 00:02:12,539
现在最后一个命令是“login”，它检查auth对象的整数是否为

36
00:02:12,540 --> 00:02:15,850
不是零，如果是这样，我们就成功登录了。

37
00:02:15,850 --> 00:02:20,170
否则，如果它是零，那么它会告诉我们输入密码。

38
00:02:20,170 --> 00:02:23,330
不过，在这种情况下，没有比这更强大的功能了。

39
00:02:23,330 --> 00:02:28,300
但是想象一下，你试图以管理员身份登录，而不知道我的密码。

40
00:02:28,300 --> 00:02:33,250
所以我们的目标是将整数设置为一个值，然后我们就得到了验证。

41
00:02:33,250 --> 00:02:37,780
目前似乎不可能，因为integer auth从未设置在任何位置，但是

42
00:02:37,780 --> 00:02:42,290
我们从一开始就知道，存在允许我们修改变量的错误。

43
00:02:42,290 --> 00:02:46,460
这里的另一个命令是reset，它将释放堆上的auth对象。

44
00:02:46,460 --> 00:02:49,240
这就是问题所在。

45
00:02:49,240 --> 00:02:54,460
您注意到，当我们重置登录过程时，它会释放auth对象，但是正如您所看到的那样

46
00:02:54,460 --> 00:02:59,370
auth变量没有重置为零，它仍然包含指向堆的指针，其中

47
00:02:59,370 --> 00:03:01,690
对象是以前的。

48
00:03:01,690 --> 00:03:06,110
例如，当我们现在登录时，它将检查该对象的name属性。

49
00:03:06,110 --> 00:03:10,260
嗯，它没有改变，所以我们还没有经过身份验证。

50
00:03:10,260 --> 00:03:15,680
但是在释放变量auth之后，login命令将“使用”它。

51
00:03:15,680 --> 00:03:16,680
“免费使用”。

52
00:03:16,680 --> 00:03:17,680
了解了？

53
00:03:17,680 --> 00:03:23,070
现在这里的最后一个命令是service，它将执行strdup、string duplication，

54
00:03:23,070 --> 00:03:25,160
服务命令后的字符数。

55
00:03:25,160 --> 00:03:29,110
例如，我们可以指定要使用黑客服务。

56
00:03:29,110 --> 00:03:32,900
现在我们在服务变量中还有一个地址。

57
00:03:32,900 --> 00:03:36,150
奇怪的是，它和auth是同一个。

58
00:03:36,150 --> 00:03:37,900
真奇怪。

59
00:03:37,900 --> 00:03:39,680
那么strdup是做什么的呢？

60
00:03:39,680 --> 00:03:41,730
让我们看一下手册页。

61
00:03:41,730 --> 00:03:46,820
strdup返回一个指向新字符串的指针，该字符串是字符串s的两个副本。

62
00:03:46,820 --> 00:03:52,050
新字符串的内存是用malloc获得的，可以用free释放。

63
00:03:52,050 --> 00:03:56,710
啊哈。所以它只是一个方便的函数，用来分配字符串的长度

64
00:03:56,710 --> 00:03:59,400
传过去，复制到那里。

65
00:03:59,400 --> 00:04:03,240
所以它也会调用malloc，从而在堆上分配东西。

66
00:04:03,240 --> 00:04:07,880
你已经可以猜到为什么服务得到和auth相同的地址，因为auth是

67
00:04:07,880 --> 00:04:11,950
释放后，就有了可用空间，服务部门在那里获得了可用空间。

68
00:04:11,950 --> 00:04:14,650
让我们在gdb中看看这个。

69
00:04:14,650 --> 00:04:16,690
首先，我们将汇编程序语法设置为intel。

70
00:04:16,690 --> 00:04:18,460
然后我们拆卸主管道。

71
00:04:18,459 --> 00:04:23,379
我们首先运行它并使用auth一次，所以我们至少执行了一个malloc。

72
00:04:23,380 --> 00:04:27,860
然后按control+c并使用info proc映射检查堆的地址。

73
00:04:27,860 --> 00:04:32,120
现在我们可以用examine从堆中打印20个单词。

74
00:04:32,120 --> 00:04:35,930
另外，因为这个应用程序仍然拥有二进制文件中的所有符号和内容，

75
00:04:35,930 --> 00:04:40,940
gdb还知道auth来自类型struct auth，我们可以再次打印它。

76
00:04:40,940 --> 00:04:44,940
这里我们可以看到字符串名和auth整数。

77
00:04:44,940 --> 00:04:47,750
我们可以对服务字符串执行相同的操作。

78
00:04:47,750 --> 00:04:51,250
现在让我们在printf之前创建一个断点。

79
00:04:51,250 --> 00:04:57,440
通过命令，我们可以键入当我们到达这个断点时应该执行什么（gdb）命令。

80
00:04:57,440 --> 00:05:00,910
我们可以用echo打印一些字符串，使其看起来更漂亮。

81
00:05:00,910 --> 00:05:02,630
首先我们要打印堆。

82
00:05:02,630 --> 00:05:03,810
我们回响一条线。

83
00:05:03,810 --> 00:05:06,410
然后我们要打印auth变量。

84
00:05:06,410 --> 00:05:07,410
另一条线。

85
00:05:07,410 --> 00:05:08,410
以及服务变量。

86
00:05:08,410 --> 00:05:09,780
最后我们自动继续。

87
00:05:09,780 --> 00:05:12,930
finsih命令序列结束。

88
00:05:12,930 --> 00:05:15,030
现在让我们重新运行这个二进制文件。

89
00:05:15,030 --> 00:05:19,330
好的，首先我们会得到一些内存错误，因为堆还不存在，所以让我们来看看malloc

90
00:05:19,330 --> 00:05:23,750
我们的第一个值是以“auth”作为管理员进行身份验证。

91
00:05:23,750 --> 00:05:28,930
另外，让我们禁用gdbs分页，这样我们总是打印所有内容，而不获取

92
00:05:28,930 --> 00:05:31,880
“键入&lt；返回&gt；继续”对话框。关闭分页

93
00:05:31,880 --> 00:05:35,150
现在我们可以看到我们的堆了。

94
00:05:35,150 --> 00:05:38,730
就像我们期望的那样，这里有一个字符串名为admin的块。

95
00:05:38,730 --> 00:05:39,730
布鲁尤特

96
00:05:39,730 --> 00:05:40,730
有点奇怪。

97
00:05:40,730 --> 00:05:46,970
为什么这个块的长度只有十六进制10，即减去

98
00:05:46,970 --> 00:05:48,050
8字节块头….

99
00:05:48,050 --> 00:05:51,900
它不应该是32字节的名称+整数吗？

100
00:05:51,900 --> 00:05:53,840
怎么了？

101
00:05:53,840 --> 00:05:57,550
好吧，这对解决方案来说并不重要，但如果你写得很糟糕，就会发生这种情况。

102
00:05:57,550 --> 00:05:59,810
代码，并命名所有身份验证。

103
00:05:59,810 --> 00:06:03,810
结构称为auth，结构auth指针称为auth，整数位于

104
00:06:03,810 --> 00:06:05,120
这里叫auth。

105
00:06:05,120 --> 00:06:10,210
当程序员计算auth的大小时，它计算变量的大小

106
00:06:10,210 --> 00:06:11,870
auth，而不是结构auth。

107
00:06:11,870 --> 00:06:16,060
因此，它只有4个字节，但malloc将它与8个字节对齐。

108
00:06:16,060 --> 00:06:17,060
天哪。

109
00:06:17,060 --> 00:06:18,060
人。

110
00:06:18,060 --> 00:06:19,090
请更好地命名变量。

111
00:06:19,090 --> 00:06:21,500
这就是如何创建错误和安全问题。

112
00:06:21,500 --> 00:06:24,630
不管怎样，我们暂时忽略这一点。

113
00:06:24,630 --> 00:06:26,920
早些时候，我们想知道自由是如何运作的。

114
00:06:26,919 --> 00:06:31,439
因此，让我们用reset释放auth对象，并注意哪些更改。

115
00:06:31,440 --> 00:06:32,610
好吧，LOL。

116
00:06:32,610 --> 00:06:34,410
基本上没有改变。

117
00:06:34,410 --> 00:06:38,610
但块数据的第一个字被替换为0。

118
00:06:38,610 --> 00:06:42,650
这是因为自由块中的第一个词被定义为前一个自由块

119
00:06:42,650 --> 00:06:43,870
地址。

120
00:06:43,870 --> 00:06:46,890
因为自由块是一个链表。

121
00:06:46,890 --> 00:06:50,670
但是我们在这个列表中没有另一个空闲块，因此它是空的。

122
00:06:50,669 --> 00:06:54,639
所以除了malloc算法之外，实际上没有发生什么事情

123
00:06:54,639 --> 00:06:58,739
在开始时重新开始，它不关心是否还有剩余值

124
00:06:58,740 --> 00:07:03,060
堆，只要像前一个地址指针这样的元数据是正确的。

125
00:07:03,060 --> 00:07:06,430
因此它只改变了那个特定的值。

126
00:07:06,430 --> 00:07:10,990
不管怎样，我们现在可以看到auth对象仍然存在，指针指向堆中

127
00:07:10,990 --> 00:07:11,990
在这里。

128
00:07:11,990 --> 00:07:15,560
但是名称现在是空的，带有空值，整数仍然是空值。

129
00:07:15,560 --> 00:07:16,560
但是。

130
00:07:16,560 --> 00:07:19,540
让我们使用服务在堆上分配一个字符串。

131
00:07:19,540 --> 00:07:22,300
让我们只分配一些可识别的字符。

132
00:07:22,300 --> 00:07:23,860
像AAA一样。

133
00:07:23,860 --> 00:07:28,700
注意只有3as，因为代码很糟糕，它还占用了as前面的空间。

134
00:07:28,700 --> 00:07:31,300
在堆中，我们可以看到字符串已被分配。

135
00:07:31,300 --> 00:07:35,430
我们看到auth对象的名称现在有一些不同的值。

136
00:07:35,430 --> 00:07:38,940
现在让我们为服务分配一个新的字符串。

137
00:07:38,940 --> 00:07:40,110
血脑屏障。

138
00:07:40,110 --> 00:07:42,150
另一个是CCC。

139
00:07:42,150 --> 00:07:44,690
我们看到堆慢慢地填满了。

140
00:07:44,690 --> 00:07:45,690
哼！

141
00:07:45,690 --> 00:07:46,690
那是什么？

142
00:07:46,690 --> 00:07:49,490
突然间，auth整数有一个巨大的值。

143
00:07:49,490 --> 00:07:53,970
这是因为它指向存储CCC的堆。

144
00:07:53,970 --> 00:07:57,640
如果我们现在登录，那么我们会收到一条消息，说明我们已经登录了。

145
00:07:57,640 --> 00:07:58,640
令人惊叹的！

146
00:07:58,640 --> 00:08:02,580
我不得不说这个水平太糟糕了。

147
00:08:02,580 --> 00:08:07,050
正如我前面提到的，代码太糟糕了，它为auth分配了错误的大小

148
00:08:07,050 --> 00:08:08,050
对象。

149
00:08:08,050 --> 00:08:09,050
空间太小了。

150
00:08:09,050 --> 00:08:10,280
我指给你看。

151
00:08:10,280 --> 00:08:12,980
让我们重新启动它并作为管理员再次进行身份验证。

152
00:08:12,979 --> 00:08:16,569
现在只需输入一个伴随服务字符串。

153
00:08:16,570 --> 00:08:18,950
而Boom，我们也覆盖了整数。

154
00:08:18,949 --> 00:08:20,999
我们收到登录信息。

155
00:08:21,000 --> 00:08:26,220
所以我们不需要用reset释放auth对象来解决它，但是我想介绍一下

156
00:08:26,220 --> 00:08:29,740
“免费后使用”这一术语也是一个有计划的挑战。

