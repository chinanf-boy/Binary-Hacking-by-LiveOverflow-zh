1
00:00:06,339 --> 00:00:07,669
这是第 10 集。

2
00:00:07,669 --> 00:00:12,689
正如你在标题中，看到的，我正在以十六进制计算集数。

3
00:00:12,690 --> 00:00:17,280
我想知道谷歌解决这个问题的算法，

4
00:00:17,279 --> 00:00:18,339
下一个视频是否错误。

5
00:00:18,340 --> 00:00:23,180
无论如何，我想在这段视频中，解释为什么十六进制很酷

6
00:00:23,180 --> 00:00:25,110
以及，当涉及到计算机时，你应该使用

7
00:00:25,110 --> 00:00:30,350
我还将向您展示如何来回转换值，以及我平常是如何使用它们的。

8
00:00:30,350 --> 00:00:31,350
OK。

9
00:00:31,350 --> 00:00:32,350
所以。

10
00:00:32,350 --> 00:00:35,230
我们的计算机是二进制的，0 和 1。

11
00:00:35,230 --> 00:00:40,550
因为它代表了我们电路晶体管的物理行为，

12
00:00:40,550 --> 00:00:44,140
它们就像开关，要么打开，要么关闭。

13
00:00:44,140 --> 00:00:49,790
一个 0 或 1 的值，称为位。

14
00:00:49,790 --> 00:00:52,150
您可能知道，一个字节是 8 位。

15
00:00:52,149 --> 00:00:53,939
但你可能，想知道为什么。

16
00:00:53,940 --> 00:00:56,040
虽说情况并不总这样。

17
00:00:56,040 --> 00:00:58,820
早期的计算机，可能每字节有 6 位。

18
00:00:58,820 --> 00:01:03,350
我们现在用 8 位来表示一个字节，正是历史的结果。

19
00:01:03,350 --> 00:01:08,330
这是 IBM 的 360 系统的故障，大力推动了 8 位字节。

20
00:01:08,329 --> 00:01:13,769
还有一些人说，用八进制，而不是字节，来表明 8 位的意思。

21
00:01:13,770 --> 00:01:20,480
一个有趣的例子是 ascii，因为您会注意到它实际上，只使用 7 位。

22
00:01:20,479 --> 00:01:25,829
但是因为，我们现在通常使用 8 位字节，所以，我们有点浪费第一位。

23
00:01:25,829 --> 00:01:28,259
我们人类是，用十进制长大的。

24
00:01:28,259 --> 00:01:31,829
我们习惯于用 0 到 9 的符号，来计数。

25
00:01:31,829 --> 00:01:33,129
但这是相当武断的。

26
00:01:33,130 --> 00:01:35,160
当然，我们有 10 根手指。

27
00:01:35,159 --> 00:01:39,439
但是我们也可以用 12 分来计算，因为我们有 12 根手指骨，

28
00:01:39,439 --> 00:01:42,169
我们可以使用拇指，指向我们所处的号码。

29
00:01:42,170 --> 00:01:46,490
这是双十进制系统，我们在时钟上使用它。

30
00:01:46,490 --> 00:01:50,450
所以，如果你长大后，用十六进制或二进制计数的话，

31
00:01:50,450 --> 00:01:51,450
你会觉得这很自然。

32
00:01:51,450 --> 00:01:55,600
不要把数字，当作固定的东西，把它当作一种工具。

33
00:01:55,600 --> 00:02:00,710
对于一个特定的问题，你可以使用任何一个数字系统。

34
00:02:00,709 --> 00:02:02,349
所以我们的电脑，可以和比特(位)一起工作。

35
00:02:02,350 --> 00:02:08,520
对于我们的现代计算机，我们已经定义了，通常使用的是 8 位字节。

36
00:02:08,520 --> 00:02:15,220
6 位、32 位或 64 位体系结构，只需利用这个值，

37
00:02:15,219 --> 00:02:17,179
就可以很好地将 8 分割开来。

38
00:02:17,180 --> 00:02:24,480
当我们将数据看作原始位：0000 0000 时，我们很快就会发现

39
00:02:24,480 --> 00:02:27,850
如果我们以这种方式显示它的话，一个字节会需要许多空间。

40
00:02:27,849 --> 00:02:30,959
也许十进制，是一种很酷的表示法。

41
00:02:30,959 --> 00:02:33,949
显示它们的空间，肯定会减少。

42
00:02:33,950 --> 00:02:38,760
我现在将使用 python 向您展示，如何将二进制数字转换为十进制数字。

43
00:02:38,760 --> 00:02:42,600
我们简单地说，这个字符串表示以 2 为基数的数字。

44
00:02:42,599 --> 00:02:48,579
让我们用一个简单的 for 循环，来做几个例子。

45
00:02:48,579 --> 00:02:51,199
好啊。

46
00:02:51,200 --> 00:02:53,820
好。

47
00:02:53,819 --> 00:02:54,889
占用了更少的空间。

48
00:02:54,890 --> 00:03:01,200
不过，8 位的最大值是，一个奇怪的十进制数字，这让我有点困扰。

49
00:03:01,200 --> 00:03:04,270
一个没有任何有趣性质或意义的数字。

50
00:03:04,269 --> 00:03:07,589
让我们看看，那些十六进制的数字。

51
00:03:07,590 --> 00:03:14,300
十六进制数字使用 0-9 和 a-f 中的符号，来描述数字。

52
00:03:14,299 --> 00:03:17,419
我们可以在 python 中扩展，for 循环。

53
00:03:17,420 --> 00:03:24,420
现在你可以看到十六进制数字，代表 8 位有多漂亮。

54
00:03:24,420 --> 00:03:29,290
最大的 8 位值，也是十六进制的最大值，

55
00:03:29,290 --> 00:03:30,540
可以用两个数表示。

56
00:03:30,540 --> 00:03:35,940
如果我们再加 1 个位，这样我们就有 9 个位，

57
00:03:35,939 --> 00:03:37,359
我们还必须再加一个字符。

58
00:03:37,359 --> 00:03:42,449
不仅如此，如果你仔细观察，它也很好地代表了

59
00:03:42,450 --> 00:03:45,620
两个字节，即 4 位。

60
00:03:45,620 --> 00:03:50,110
所以十六进制的 8 位数字，可以用 2 个符号表示。

61
00:03:50,110 --> 00:03:53,140
每一个符号都是指一个笔尖。

62
00:03:53,139 --> 00:03:57,509
所以这使得它，非常清晰和容易阅读。

63
00:03:57,510 --> 00:04:01,500
现在你可以理解为什么小数表示法，

64
00:04:01,500 --> 00:04:03,120
不适合这种东西了。

65
00:04:03,120 --> 00:04:08,030
你能告诉我一个无符号 32 位整数，所能代表的最大数是多少吗？

66
00:04:08,030 --> 00:04:09,650
我不知道十进制。

67
00:04:09,650 --> 00:04:17,510
我只知道 32 位是 8 位的 4 倍，因此 max int 是 0xffffffff。

68
00:04:17,510 --> 00:04:22,070
现在让我快速地向，您展示一些关于 Python 的很酷的技巧用于，来回转换东西。

69
00:04:22,070 --> 00:04:25,290
python 有一些内置函数，来转换数字。

70
00:04:25,289 --> 00:04:27,269
例如 hex() 和 bin() 。

71
00:04:27,270 --> 00:04:32,330
还可以使用 int() 函数解析二进制或十六进制数，

72
00:04:32,330 --> 00:04:34,960
并指定它是哪个基数。

73
00:04:34,960 --> 00:04:39,400
如果您有一个二进制字符串，这意味着该，字符串中的每个值

74
00:04:39,400 --> 00:04:43,750
可能不是一个 ASCII 可打印字符，您可以使用对字符串的编码和解码来

75
00:04:43,750 --> 00:04:46,050
获取字符的十六进制表示。

76
00:04:46,050 --> 00:04:49,390
所以 hex 41 用 ASCII 表示，是一个大写字母“A”。

77
00:04:49,389 --> 00:04:54,579
python struct 提供了一个更强大、更重要的函数。

78
00:04:54,580 --> 00:04:58,570
在处理二进制数据时，我一直使用它。

79
00:04:58,569 --> 00:04:59,999
首先，导入 struct 。

80
00:05:00,000 --> 00:05:03,980
然后我们可以对数据使用 struct.unpack。

81
00:05:03,979 --> 00:05:07,759
在本例中，我定义此数据是无符号整数。

82
00:05:07,759 --> 00:05:13,769
你可以看到，我现在可以把这些二进制数据，转换成一个整数。

83
00:05:13,770 --> 00:05:20,460
如果仔细观察，你可能会想知道，为什么大写字母 A 似乎在数字的末尾。

84
00:05:20,460 --> 00:05:24,160
原因是我们有一个 little-endian 系统。

85
00:05:24,160 --> 00:05:26,670
位(bit)可以用两种方式解释。

86
00:05:26,669 --> 00:05:30,539
第一位或最后一位，可以指最低有效位。

87
00:05:30,539 --> 00:05:34,149
我认为维基百科上的图片，非常清楚。

88
00:05:34,150 --> 00:05:38,190
当您从 big endian 系统接收数据时，这可能非常重要，

89
00:05:38,190 --> 00:05:40,570
因为，您必须注意如何解释这些数据。

90
00:05:40,569 --> 00:05:44,739
但是使用 python struct 很容易，我们可以定义我们想要的 endian 系统

91
00:05:44,740 --> 00:05:46,970
来解释这些数据。

92
00:05:46,970 --> 00:05:51,540
如果你看我的一些 CTF 开发挑战视频，

93
00:05:51,539 --> 00:05:52,759
你会看到我经常使用 python struct。

94
00:05:52,760 --> 00:05:56,540
因为，它来回转换地址和其他数据很好。

95
00:05:56,540 --> 00:06:00,800
例如，如果我们想要覆盖一个地址，我们必须以字符串的形式提供数据。

96
00:06:00,800 --> 00:06:05,760
所以我们可以使用 struct.pack ，并将数字打包为二进制字符串。

97
00:06:05,759 --> 00:06:10,269
所以十六进制系统，使得使用计算机变得更简单，

98
00:06:10,270 --> 00:06:12,270
你应该习惯下。

99
00:06:12,270 --> 00:06:14,700
但我们刚刚谈到了正数。

100
00:06:14,699 --> 00:06:16,989
从 0 到 0xFF。

101
00:06:16,990 --> 00:06:19,980
但是我们怎样才能表示负数呢？

102
00:06:19,980 --> 00:06:24,500
也许你听过有符号的位，第一位就能告诉你，

103
00:06:24,500 --> 00:06:25,500
是不是负数。

104
00:06:25,500 --> 00:06:30,850
不过，它并不像简单地读取，剩余的 7 位，

105
00:06:30,849 --> 00:06:33,479
并根据第一个位，决定它是否为正那样简单。

106
00:06:33,479 --> 00:06:36,739
-1 实际上是 0xff。

107
00:06:36,740 --> 00:06:41,560
它有第一个位集，但不是-127。

108
00:06:41,560 --> 00:06:45,200
这个轮子也许能让我们更清楚地了解，负数是如何被解释的。

109
00:06:45,199 --> 00:06:51,409
将其绝对值转换为负值的操作，

110
00:06:51,409 --> 00:06:58,499
例如 255（0xff）到 -1 被称为，二的补码，你可以在维基百科上读到。

111
00:06:58,500 --> 00:07:08,730
你也可以很容易地反转一个给定的数字，反转所有的位，然后加 1。

112
00:07:08,729 --> 00:07:11,009
许多函数出错时，会返回-1。

113
00:07:11,009 --> 00:07:14,699
起初听起来很奇怪，但现在你知道这只是所有的 fs。

114
00:07:14,699 --> 00:07:21,159
因此，当您读取数据，并且只获得 1s（或十六进制的 fs）时，您可能会读取一个错误。

115
00:07:21,159 --> 00:07:22,969
带分数的数字怎么样？

116
00:07:22,970 --> 00:07:23,970
最好。

117
00:07:23,970 --> 00:07:24,970
别让我开始这件事。

118
00:07:24,970 --> 00:07:26,600
真的很难看。

119
00:07:26,599 --> 00:07:30,779
但是你可以猜测，用逗号后面的许多数字，表示一个值可以得到

120
00:07:30,780 --> 00:07:34,480
如果你只有 0 和 1，就很有创造力。

121
00:07:34,480 --> 00:07:38,310
现在，在我们结束之前，让我们总结一下术语：

122
00:07:38,310 --> 00:07:39,640
我们先从 位(比特) 开始。

123
00:07:39,639 --> 00:07:41,019
可以是 ：0 或 1。

124
00:07:41,020 --> 00:07:43,140
4 位是一个半字节。

125
00:07:43,139 --> 00:07:44,829
8 位是一个字节。

126
00:07:44,830 --> 00:07:48,540
在十六进制中，我们可以用两位数，表示一个字节。

127
00:07:48,539 --> 00:07:53,829
在 32 位体系结构中，一个字是指 32 位或 4 个字节。

128
00:07:53,830 --> 00:07:57,080
但是在 64 位体系结构中，一个字是 64 位，或者 8 个字节。

129
00:07:57,080 --> 00:08:01,830
一个双倍字(Dword)，显然是它的两倍。

130
00:08:01,830 --> 00:08:04,910
如你所见，计算机只有比特。

131
00:08:04,910 --> 00:08:08,420
我们如何处理这些位，取决于我们的解释。

132
00:08:08,419 --> 00:08:13,419
我知道这是一个有点短，和技术含量较低的视频，但我认为它比较适合

133
00:08:13,419 --> 00:08:15,579
下次，我们深入研究，并利用第一个缓冲区溢出。

