1
00:00:06,339 --> 00:00:07,669
这是第10集。

2
00:00:07,669 --> 00:00:12,689
正如你在标题中看到的，我正在以十六进制计算剧集。

3
00:00:12,690 --> 00:00:17,280
我想知道谷歌的算法是否会用下一个视频来解决这个问题

4
00:00:17,279 --> 00:00:18,339
是错的。

5
00:00:18,340 --> 00:00:23,180
无论如何，我想在这段视频中解释为什么十六进制很酷，以及为什么你应该使用

6
00:00:23,180 --> 00:00:25,110
当涉及到计算机时。

7
00:00:25,110 --> 00:00:30,350
我还将向您展示如何来回转换值，以及如何经常使用它们。

8
00:00:30,350 --> 00:00:31,350
好啊。

9
00:00:31,350 --> 00:00:32,350
所以。

10
00:00:32,350 --> 00:00:35,230
我们的计算机是二进制的，0和1。

11
00:00:35,230 --> 00:00:40,550
因为它代表了我们电路的物理行为，我们有晶体管，

12
00:00:40,550 --> 00:00:44,140
它们就像开关，要么打开要么关闭。

13
00:00:44,140 --> 00:00:49,790
一个0或1的值称为位。

14
00:00:49,790 --> 00:00:52,150
您可能知道一个字节是8位。

15
00:00:52,149 --> 00:00:53,939
但你可能想知道为什么。

16
00:00:53,940 --> 00:00:56,040
嗯，情况并不总是这样。

17
00:00:56,040 --> 00:00:58,820
早期的计算机可能每字节有6位。

18
00:00:58,820 --> 00:01:03,350
我们现在用8位来表示一个字节，这正是历史的结果。

19
00:01:03,350 --> 00:01:08,330
这是IBM的360系统的故障，严重推动了8位字节。

20
00:01:08,329 --> 00:01:13,769
还有一些人说八进制而不是字节来表明他们的意思是8位。

21
00:01:13,770 --> 00:01:20,480
一个有趣的例子是ascii，因为您会注意到它实际上只使用7bit。

22
00:01:20,479 --> 00:01:25,829
但是因为我们现在通常使用8位字节，所以我们有点浪费第一位。

23
00:01:25,829 --> 00:01:28,259
我们人类是用十进制长大的。

24
00:01:28,259 --> 00:01:31,829
我们习惯于用0到9的符号来计数。

25
00:01:31,829 --> 00:01:33,129
但这是相当武断的。

26
00:01:33,130 --> 00:01:35,160
当然，我们有10根手指。

27
00:01:35,159 --> 00:01:39,439
但是我们也可以用12分来计算，因为我们有12根手指骨，我们可以使用

28
00:01:39,439 --> 00:01:42,169
拇指指向我们所处的号码。

29
00:01:42,170 --> 00:01:46,490
这是双十进制系统，我们在时钟上使用它。

30
00:01:46,490 --> 00:01:50,450
所以，如果你长大后用十六进制或二进制计数的话，你会觉得这很自然

31
00:01:50,450 --> 00:01:51,450
给你。

32
00:01:51,450 --> 00:01:55,600
不要把数字当作固定的东西，把它当作一种工具。

33
00:01:55,600 --> 00:02:00,710
对于一个特定的问题，你可以使用任何一个数字系统。

34
00:02:00,709 --> 00:02:02,349
所以我们的电脑可以和比特一起工作。

35
00:02:02,350 --> 00:02:08,520
对于我们的现代计算机，我们已经定义了我们通常使用8位字节。

36
00:02:08,520 --> 00:02:15,220
16位、32位或64位体系结构只需利用这个值，就可以很好地将其分割开来。

37
00:02:15,219 --> 00:02:17,179
到8点。

38
00:02:17,180 --> 00:02:24,480
当我们将数据看作原始位：0000 0000时，我们很快就会发现一个字节需要

39
00:02:24,480 --> 00:02:27,850
如果我们以这种方式显示它的话，就是空间。

40
00:02:27,849 --> 00:02:30,959
也许十进制是一种很酷的表示法。

41
00:02:30,959 --> 00:02:33,949
显示它们的空间肯定会减少。

42
00:02:33,950 --> 00:02:38,760
我现在将使用python向您展示如何将二进制数字转换为十进制数字。

43
00:02:38,760 --> 00:02:42,600
我们简单地说，这个字符串表示以2为基数的数字。

44
00:02:42,599 --> 00:02:48,579
让我们用一个简单的for循环来做几个例子。

45
00:02:48,579 --> 00:02:51,199
好啊。

46
00:02:51,200 --> 00:02:53,820
好。

47
00:02:53,819 --> 00:02:54,889
占用更少的空间。

48
00:02:54,890 --> 00:03:01,200
不过，8位的最大值是一个奇怪的十进制数字，这让我有点困扰。

49
00:03:01,200 --> 00:03:04,270
一个没有任何有趣性质或意义的数字。

50
00:03:04,269 --> 00:03:07,589
让我们看看那些十六进制的数字。

51
00:03:07,590 --> 00:03:14,300
十六进制数字使用0-9和a-f中的符号来描述数字。

52
00:03:14,299 --> 00:03:17,419
我们可以在python中扩展循环。

53
00:03:17,420 --> 00:03:24,420
现在你可以看到十六进制数字代表8位有多漂亮。

54
00:03:24,420 --> 00:03:29,290
最大的8位值也是十六进制的最大值，可以用两个表示

55
00:03:29,290 --> 00:03:30,540
数字。

56
00:03:30,540 --> 00:03:35,940
如果我们再加1个位，这样我们就有9个位，我们还必须再加一个

57
00:03:35,939 --> 00:03:37,359
性格。

58
00:03:37,359 --> 00:03:42,449
不仅如此，如果你仔细观察，它也很好地代表了两个人

59
00:03:42,450 --> 00:03:45,620
半字节，即4位。

60
00:03:45,620 --> 00:03:50,110
所以十六进制的8位数字可以用2个符号表示。

61
00:03:50,110 --> 00:03:53,140
每一个符号都是指一个笔尖。

62
00:03:53,139 --> 00:03:57,509
所以这使得它非常清晰和容易阅读。

63
00:03:57,510 --> 00:04:01,500
现在你可以理解为什么小数表示法不适合这个了

64
00:04:01,500 --> 00:04:03,120
那种东西。

65
00:04:03,120 --> 00:04:08,030
你能告诉我一个无符号32位整数所能代表的最大数是多少吗？

66
00:04:08,030 --> 00:04:09,650
我不知道十进制。

67
00:04:09,650 --> 00:04:17,510
我只知道32位是8位的4倍，因此max int是0xffffffff。

68
00:04:17,510 --> 00:04:22,070
现在让我快速地向您展示一些关于Python的很酷的技巧来来回转换东西。

69
00:04:22,070 --> 00:04:25,290
python有一些内置函数来转换数字。

70
00:04:25,289 --> 00:04:27,269
例如hex（）和bin（）。

71
00:04:27,270 --> 00:04:32,330
还可以使用int（）函数解析二进制或十六进制数，并指定哪个基数

72
00:04:32,330 --> 00:04:34,960
它是。

73
00:04:34,960 --> 00:04:39,400
如果您有一个二进制字符串，这意味着该字符串中的每个值可能不是

74
00:04:39,400 --> 00:04:43,750
不错的ASCII可打印字符，您可以使用对字符串的编码和解码来获取

75
00:04:43,750 --> 00:04:46,050
字符的十六进制表示。

76
00:04:46,050 --> 00:04:49,390
所以hex 41是一个大写字母“A”，用ASCII表示。

77
00:04:49,389 --> 00:04:54,579
python结构提供了一个更强大、更重要的功能。

78
00:04:54,580 --> 00:04:58,570
在处理二进制数据时，我一直使用它。

79
00:04:58,569 --> 00:04:59,999
第一个导入结构。

80
00:05:00,000 --> 00:05:03,980
然后我们可以对数据使用struct.unpack。

81
00:05:03,979 --> 00:05:07,759
在本例中，我定义此数据是无符号整数。

82
00:05:07,759 --> 00:05:13,769
你可以看到我现在可以把这些二进制数据转换成一个整数。

83
00:05:13,770 --> 00:05:20,460
如果仔细观察，你可能会想知道为什么大写字母A似乎在数字的末尾。

84
00:05:20,460 --> 00:05:24,160
原因是我们有一个小的endian系统。

85
00:05:24,160 --> 00:05:26,670
位可以用两种方式解释。

86
00:05:26,669 --> 00:05:30,539
第一位或最后一位可以指最低有效位。

87
00:05:30,539 --> 00:05:34,149
我认为维基百科上的图片非常清楚。

88
00:05:34,150 --> 00:05:38,190
当您从big endian系统接收数据时，这可能非常重要，因为

89
00:05:38,190 --> 00:05:40,570
您必须注意如何解释这些数据。

90
00:05:40,569 --> 00:05:44,739
但是使用python结构很容易，我们可以定义我们想要的endian系统

91
00:05:44,740 --> 00:05:46,970
解释这些数据。

92
00:05:46,970 --> 00:05:51,540
如果你看我的一些CTF开发挑战视频，你会看到我使用python结构

93
00:05:51,539 --> 00:05:52,759
很多。

94
00:05:52,760 --> 00:05:56,540
因为来回转换地址和其他数据很好。

95
00:05:56,540 --> 00:06:00,800
例如，如果我们想要覆盖一个地址，我们必须以字符串的形式提供数据。

96
00:06:00,800 --> 00:06:05,760
所以我们可以使用struct.pack并将数字打包为二进制字符串。

97
00:06:05,759 --> 00:06:10,269
所以十六进制系统使得使用计算机变得更简单，你应该

98
00:06:10,270 --> 00:06:12,270
习惯了。

99
00:06:12,270 --> 00:06:14,700
但我们刚刚谈到了正数。

100
00:06:14,699 --> 00:06:16,989
从0到0xFF。

101
00:06:16,990 --> 00:06:19,980
但是我们怎样才能表示负数呢？

102
00:06:19,980 --> 00:06:24,500
也许你听过有符号的位，第一位告诉你它是不是负数

103
00:06:24,500 --> 00:06:25,500
号码与否。

104
00:06:25,500 --> 00:06:30,850
不过，它并不像简单地读取剩余的7位并决定它是否为正那样简单。

105
00:06:30,849 --> 00:06:33,479
或者根据第一个结果是否定的。

106
00:06:33,479 --> 00:06:36,739
-1实际上是0xff。

107
00:06:36,740 --> 00:06:41,560
它有第一个位集，但不是-127。

108
00:06:41,560 --> 00:06:45,200
这个轮子也许能让我们更清楚地了解负数是如何被解释的。

109
00:06:45,199 --> 00:06:51,409
将其绝对值转换为负值的操作，例如255

110
00:06:51,409 --> 00:06:58,499
（0xff）to-1被称为二的补码，你可以在维基百科上读到。

111
00:06:58,500 --> 00:07:08,730
你也可以很容易地否定一个给定的数字，否定所有的位，然后加1。

112
00:07:08,729 --> 00:07:11,009
许多函数出错时返回-1。

113
00:07:11,009 --> 00:07:14,699
起初听起来很奇怪，但现在你知道这只是所有的fs。

114
00:07:14,699 --> 00:07:21,159
因此，当您读取数据，并且只获得1s（或十六进制的fs）时，您可能会读取一个错误。

115
00:07:21,159 --> 00:07:22,969
带分数的数字怎么样？

116
00:07:22,970 --> 00:07:23,970
好。

117
00:07:23,970 --> 00:07:24,970
别让我开始这件事。

118
00:07:24,970 --> 00:07:26,600
真的很难看。

119
00:07:26,599 --> 00:07:30,779
但是你可以猜测，用逗号后面的许多数字表示一个值可以得到

120
00:07:30,780 --> 00:07:34,480
如果你只有0和1，就很有创造力。

121
00:07:34,480 --> 00:07:38,310
现在，在我们结束之前，让我们总结一下术语：

122
00:07:38,310 --> 00:07:39,640
我们先从一点开始。

123
00:07:39,639 --> 00:07:41,019
0或1。

124
00:07:41,020 --> 00:07:43,140
4位是一个半字节。

125
00:07:43,139 --> 00:07:44,829
8位是一个字节。

126
00:07:44,830 --> 00:07:48,540
在十六进制中，我们可以用两位数字表示一个字节。

127
00:07:48,539 --> 00:07:53,829
在32位体系结构中，字是指32位或4个字节。

128
00:07:53,830 --> 00:07:57,080
但是在64位体系结构中，一个字是64位，或者8个字节。

129
00:07:57,080 --> 00:08:01,830
一个双字，显然是它的两倍。

130
00:08:01,830 --> 00:08:04,910
如你所见，计算机只有比特。

131
00:08:04,910 --> 00:08:08,420
我们如何处理这些小问题取决于我们的解释。

132
00:08:08,419 --> 00:08:13,419
我知道这是一个有点短和技术含量较低的视频，但我认为它适合下次

133
00:08:13,419 --> 00:08:15,579
我们将深入研究并利用第一个缓冲区溢出。

