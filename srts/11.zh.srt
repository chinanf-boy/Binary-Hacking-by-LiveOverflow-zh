1
00:00:06,339 --> 00:00:07,669
这是第10集。

2
00:00:07,669 --> 00:00:12,689
正如你在标题中看到的那样，我在数
十六进制的剧集。

3
00:00:12,690 --> 00:00:17,280
我想知道谷歌算法是否会
用推荐的下一个视频搞砸了

4
00:00:17,279 --> 00:00:18,339
是错的。

5
00:00:18,340 --> 00:00:23,180
无论如何，我想在这个视频中解释为什么
十六进制很酷，为什么你应该使用

6
00:00:23,180 --> 00:00:25,110
它，当谈到计算机。

7
00:00:25,110 --> 00:00:30,350
我还将向您展示我如何转换价值观
来回和我经常如何与他们合作。

8
00:00:30,350 --> 00:00:31,350
好。

9
00:00:31,350 --> 00:00:32,350
所以。

10
00:00:32,350 --> 00:00:35,230
我们的计算机工作在二进制，0和1。

11
00:00:35,230 --> 00:00:40,550
因为它是物理的代表
我们有晶体管的电路行为，

12
00:00:40,550 --> 00:00:44,140
就像开关一样，它们也是
打开或关闭。

13
00:00:44,140 --> 00:00:49,790
调用单个值0或1
一点点。

14
00:00:49,790 --> 00:00:52,150
您可能知道一个字节是8位。

15
00:00:52,149 --> 00:00:53,939
但也许你想知道为什么会这样。

16
00:00:53,940 --> 00:00:56,040
嗯，事情并非总是这样。

17
00:00:56,040 --> 00:00:58,820
早期的计算机每个可能有6位
字节。

18
00:00:58,820 --> 00:01:03,350
我们现在使用8位作为字节
就是历史如何发展出来的。

19
00:01:03,350 --> 00:01:08,330
这是IBM在System 360中的错误
大量推动了8位字节。

20
00:01:08,329 --> 00:01:13,769
也有人说octad而不是字节
要明确他们的意思是8位。

21
00:01:13,770 --> 00:01:20,480
一个有趣的例子是ascii，因为你
会注意到它实际上只使用7位。

22
00:01:20,479 --> 00:01:25,829
但是因为我们现在一般使用8位字节，
我们有点浪费第一点。

23
00:01:25,829 --> 00:01:28,259
我们人类在小数系统中长大。

24
00:01:28,259 --> 00:01:31,829
我们习惯用来自的符号计数
0到9。

25
00:01:31,829 --> 00:01:33,129
但那是相当随意的。

26
00:01:33,130 --> 00:01:35,160
当然，我们有10个手指。

27
00:01:35,159 --> 00:01:39,439
但是我们也可以算在12日，因为
我们有12个手指骨头，我们可以使用

28
00:01:39,439 --> 00:01:42,169
拇指指向我们所在的号码。

29
00:01:42,170 --> 00:01:46,490
这是Duodecimal系统，我们实际上
在我们的时钟上使用它。

30
00:01:46,490 --> 00:01:50,450
所以，如果你有成长的计数
在十六进制或二进制中，它会感觉很自然

31
00:01:50,450 --> 00:01:51,450
给你。

32
00:01:51,450 --> 00:01:55,600
而不是将数字视为某种东西
修复后，将其视为一种工具。

33
00:01:55,600 --> 00:02:00,710
您可以使用系统中的任何数字
对特定问题的感觉。

34
00:02:00,709 --> 00:02:02,349
所以我们的计算机使用位。

35
00:02:02,350 --> 00:02:08,520
而对于我们现代的计算机，我们已经定义
我们通常使用8位字节。

36
00:02:08,520 --> 00:02:15,220
和16位，32位或64位架构
使用此值来保持它可以完全整除

37
00:02:15,219 --> 00:02:17,179
8点。

38
00:02:17,180 --> 00:02:24,480
当我们将数据看作原始位时：0000 0000，
我们很快发现一个字节占用了很多

39
00:02:24,480 --> 00:02:27,850
如果我们以这种方式显示空间。

40
00:02:27,849 --> 00:02:30,959
也许十进制将是一个很酷的表示。

41
00:02:30,959 --> 00:02:33,949
它肯定会占用更少的空间来展示
他们。

42
00:02:33,950 --> 00:02:38,760
我现在将使用python向您展示我们如何做到
将二进制转换为十进制数。

43
00:02:38,760 --> 00:02:42,600
我们只是说这个字符串代表
基数为2的数字。

44
00:02:42,599 --> 00:02:48,579
让我们来做几个例子吧
一个简单的for循环。

45
00:02:48,579 --> 00:02:51,199
好。

46
00:02:51,200 --> 00:02:53,820
好。

47
00:02:53,819 --> 00:02:54,889
占用更少的空间。

48
00:02:54,890 --> 00:03:01,200
虽然，最大的问题让我感到困扰
8位的值，是十进制的奇怪数字。

49
00:03:01,200 --> 00:03:04,270
没有任何有趣属性的数字
或意义。

50
00:03:04,269 --> 00:03:07,589
我们来看看这些十六进制的数字。

51
00:03:07,590 --> 00:03:14,300
十六进制数字使用0-9和A-F中的符号
描述一个数字。

52
00:03:14,299 --> 00:03:17,419
我们可以在python中扩展我们的循环。

53
00:03:17,420 --> 00:03:24,420
现在你可以看到十六进制了
数字代表8位。

54
00:03:24,420 --> 00:03:29,290
最大的8位值也是最大的
以十六进制表示的值，可以用两个表示

55
00:03:29,290 --> 00:03:30,540
数字。

56
00:03:30,540 --> 00:03:35,940
如果我们再添加1位，那么我们就有了
9位，我们还要添加另一个

57
00:03:35,939 --> 00:03:37,359
字符。

58
00:03:37,359 --> 00:03:42,449
不仅如此，如果你仔细观察，它
也很好地代表了两个人

59
00:03:42,450 --> 00:03:45,620
半字节，这意味着4位。

60
00:03:45,620 --> 00:03:50,110
因此可以表示十六进制的8位数
由2个符号组成。

61
00:03:50,110 --> 00:03:53,140
每个符号都指一个半字节。

62
00:03:53,139 --> 00:03:57,509
所以这使得它非常清晰和容易
阅读。

63
00:03:57,510 --> 00:04:01,500
现在你可以理解为什么小数
表示不适合这个

64
00:04:01,500 --> 00:04:03,120
有点东西。

65
00:04:03,120 --> 00:04:08,030
你能告诉我最大数量是多少吗？
无符号32位整数可以表示？

66
00:04:08,030 --> 00:04:09,650
好吧，我不知道十进制。

67
00:04:09,650 --> 00:04:17,510
我只知道32位是8位的4倍
因此max int是0xFFFFFFFF。

68
00:04:17,510 --> 00:04:22,070
现在让我快速向您展示一些很酷的技巧
用python来回转换东西。

69
00:04:22,070 --> 00:04:25,290
Python有一些内置函数可以转换
数字。

70
00:04:25,289 --> 00:04:27,269
例如hex（）和bin（）。

71
00:04:27,270 --> 00:04:32,330
并且还要解析二进制或十六进制数
int（）函数并指定哪个基数

72
00:04:32,330 --> 00:04:34,960
它是。

73
00:04:34,960 --> 00:04:39,400
如果你有一个二进制字符串，这意味着
也许不是这个字符串中的每个值都是a

74
00:04:39,400 --> 00:04:43,750
漂亮的ascii可打印字符，你可以使用
对字符串进行编码和解码以获得

75
00:04:43,750 --> 00:04:46,050
十六进制表示的字符。

76
00:04:46,050 --> 00:04:49,390
因此，十六进制41是ascii中的首都'A'。

77
00:04:49,389 --> 00:04:54,579
更强大，更重要的功能
由python结构提供。

78
00:04:54,580 --> 00:04:58,570
当我处理时，我一直在使用它
二进制数据。

79
00:04:58,569 --> 00:04:59,999
第一个导入结构。

80
00:05:00,000 --> 00:05:03,980
然后我们可以在我们的数据上使用struct.unpack。

81
00:05:03,979 --> 00:05:07,759
在这种情况下，我定义这个数据是一个
无符号整数。

82
00:05:07,759 --> 00:05:13,769
你可以看到我可以转换这个二进制文件
数据现在为整数。

83
00:05:13,770 --> 00:05:20,460
如果你仔细观察，你可能想知道为什么
资本A似乎在数字的末尾。

84
00:05:20,460 --> 00:05:24,160
原因是我们有一个小端
系统。

85
00:05:24,160 --> 00:05:26,670
bit可以用两种方式解释。

86
00:05:26,669 --> 00:05:30,539
第一位或最后一位可以引用
到最不重要的位。

87
00:05:30,539 --> 00:05:34,149
我认为维基百科上的图片就是这样的
非常清楚。

88
00:05:34,150 --> 00:05:38,190
收到后这可能非常重要
因为那时来自大端系统的数据

89
00:05:38,190 --> 00:05:40,570
你必须要小心你如何解释这一点
数据。

90
00:05:40,569 --> 00:05:44,739
但是使用python结构很简单，我们
可以定义我们想要的端序系统

91
00:05:44,740 --> 00:05:46,970
解释这些数据。

92
00:05:46,970 --> 00:05:51,540
如果你看一些我的CTF开发挑战
视频，你会看到我使用python结构

93
00:05:51,539 --> 00:05:52,759
很多。

94
00:05:52,760 --> 00:05:56,540
因为转换地址很棒
和来回的其他数据。

95
00:05:56,540 --> 00:06:00,800
例如，如果我们要覆盖一个地址，
我们必须以字符串形式提供数据。

96
00:06:00,800 --> 00:06:05,760
所以我们可以使用struct.pack并打包一个数字
作为二进制字符串。

97
00:06:05,759 --> 00:06:10,269
所以十六进制系统使用
电脑更简单，你应该

98
00:06:10,270 --> 00:06:12,270
习惯它。

99
00:06:12,270 --> 00:06:14,700
但我们刚才谈到了积极的数字。

100
00:06:14,699 --> 00:06:16,989
从0到0xFF。

101
00:06:16,990 --> 00:06:19,980
但我们怎样才能代表负数。

102
00:06:19,980 --> 00:06:24,500
也许你已经听说过签名位了
第一位告诉你它是否是否定的

103
00:06:24,500 --> 00:06:25,500
数量与否。

104
00:06:25,500 --> 00:06:30,850
虽然，它并不像简单阅读那么简单
剩余的7位并确定它是否为正

105
00:06:30,849 --> 00:06:33,479
或者基于第一个否定。

106
00:06:33,479 --> 00:06:36,739
-1实际上是0xFF。

107
00:06:36,740 --> 00:06:41,560
嗯它确实有第一位设置，但它是
不是-127。

108
00:06:41,560 --> 00:06:45,200
这个轮子可能会让它更清晰
如何实际解释负数。

109
00:06:45,199 --> 00:06:51,409
转换其绝对值的操作
进入负值，例如255

110
00:06:51,409 --> 00:06:58,499
（0xFF）到-1称为二进制补码，
你可以在维基百科上阅读。

111
00:06:58,500 --> 00:07:08,730
你也很容易否定一个给定的
通过否定所有位并加1来编号。

112
00:07:08,729 --> 00:07:11,009
许多函数在出错时返回-1。

113
00:07:11,009 --> 00:07:14,699
起初听起来很奇怪，但现在你知道了
这只是所有的Fs。

114
00:07:14,699 --> 00:07:21,159
因此，当您读取数据时，您只能获得1秒
（或十六进制的Fs）你可能会读错了。

115
00:07:21,159 --> 00:07:22,969
带分数的数字怎么样？

116
00:07:22,970 --> 00:07:23,970
好。

117
00:07:23,970 --> 00:07:24,970
不要让我开始。

118
00:07:24,970 --> 00:07:26,600
它变得非常难看。

119
00:07:26,599 --> 00:07:30,779
但你可以猜测它代表一个价值
逗号后面有很多数字可以得到

120
00:07:30,780 --> 00:07:34,480
如果你只有0和1，那就非常有创意。

121
00:07:34,480 --> 00:07:38,310
在我们结束之前，让我们总结一下
术语：

122
00:07:38,310 --> 00:07:39,640
我们从一点开始。

123
00:07:39,639 --> 00:07:41,019
0或1。

124
00:07:41,020 --> 00:07:43,140
4位是半字节。

125
00:07:43,139 --> 00:07:44,829
8位是一个字节。

126
00:07:44,830 --> 00:07:48,540
在十六进制中，我们可以表示一个字节
有两位数。

127
00:07:48,539 --> 00:07:53,829
在32位架构上，一个字指的是32位
或4个字节。

128
00:07:53,830 --> 00:07:57,080
但在64位架构上，一个字是64位，
或8个字节。

129
00:07:57,080 --> 00:08:01,830
一个双字显然是双重的
金额。

130
00:08:01,830 --> 00:08:04,910
如您所见，计算机只有位。

131
00:08:04,910 --> 00:08:08,420
我们如何处理这些比特取决于我们的
解释。

132
00:08:08,419 --> 00:08:13,419
我知道这有点短，技术性较差
视频，但我觉得它适合下次

133
00:08:13,419 --> 00:08:15,579
我们将深入挖掘并利用我们的第一个缓冲区
溢出。

