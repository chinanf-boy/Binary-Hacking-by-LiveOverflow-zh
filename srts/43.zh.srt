1
00:00:00,120 --> 00:00:03,120
好吧，我给你看的最后一段视频

2
00:00:03,120 --> 00:00:05,780
我用的语言，难看但有用。

3
00:00:05,779 --> 00:00:09,119
我们把它编译成这个奇怪的二进制格式。

4
00:00:09,120 --> 00:00:14,340
然后把这个二进制文件传递给这个叫做invoice的程序，它执行我们的

5
00:00:14,339 --> 00:00:15,339
程序。

6
00:00:15,339 --> 00:00:19,199
在上一个视频中，我还向您展示了这个二进制格式的开头

7
00:00:19,200 --> 00:00:23,090
触发缓冲区溢出并覆盖堆栈上的返回指针。

8
00:00:23,090 --> 00:00:27,070
在那一点上，您可能认为我们的程序只是shellcode，所以汇编程序

9
00:00:27,070 --> 00:00:31,300
代码，我们注入然后跳转到，缓冲区溢出。

10
00:00:31,300 --> 00:00:34,930
但这甚至是不可能的，因为堆栈是不可执行的。

11
00:00:34,929 --> 00:00:39,969
所以即使我们不能注入实际的汇编程序指令来执行，我们还是

12
00:00:39,969 --> 00:00:42,399
能够执行我的程序。

13
00:00:42,399 --> 00:00:47,839
在这一点上，很明显，这是可能的，多亏了面向返回的编程。

14
00:00:47,839 --> 00:00:50,399
让我们来研究一下这是如何工作的。

15
00:00:50,399 --> 00:00:51,819
但是我警告你。

16
00:00:51,820 --> 00:00:55,880
你真的需要让你的大脑进入一种抽象的哲学思维模式。

17
00:00:55,879 --> 00:00:57,439
这会变得很奇怪。

18
00:00:57,440 --> 00:01:02,110
也许你以后得重新看一遍，也许结账时会更“正常”

19
00:01:02,109 --> 00:01:05,119
返回面向编程的教程，然后回到这里。

20
00:01:05,120 --> 00:01:09,580
但如果你能看到这段视频，我想它会让你更加深入地了解

21
00:01:09,580 --> 00:01:10,580
为你。

22
00:01:10,580 --> 00:01:12,870
所以试着…

23
00:01:12,870 --> 00:01:14,520
不管怎样。

24
00:01:14,520 --> 00:01:19,480
我们进去吧。

25
00:01:19,480 --> 00:01:24,490
所以在x86汇编程序中有一个称为“call”的指令。

26
00:01:24,490 --> 00:01:27,090
而Call实际上有两件事。

27
00:01:27,090 --> 00:01:30,490
首先，它推送返回地址（即呼叫后的地址

28
00:01:30,491 --> 00:01:32,631
指令）。

29
00:01:32,630 --> 00:01:37,620
然后它将当前指令指针EIP更改为调用目标。

30
00:01:37,620 --> 00:01:40,750
所以CPU继续在那里执行。

31
00:01:40,750 --> 00:01:46,690
现在，当我们在C语言中调用一个函数时，它将被编译成一个汇编程序调用指令。

32
00:01:46,690 --> 00:01:51,020
但是要理解面向返回的编程，必须忘记这一点。

33
00:01:51,020 --> 00:01:54,030
忽略调用函数的概念。

34
00:01:54,030 --> 00:01:59,140
只需记住，此指令会在调用指令后立即推送地址

35
00:01:59,140 --> 00:02:04,730
在堆栈上，然后将指令指针设置为目标地址。

36
00:02:04,730 --> 00:02:07,530
返回指令的行为也一样。

37
00:02:07,530 --> 00:02:12,480
是的，ret是从c中的返回编译而来的。但是不要再考虑这个连接了。

38
00:02:12,480 --> 00:02:17,560
ret只是弹出一个地址，我们称之为返回地址，从堆栈中取出并设置

39
00:02:17,560 --> 00:02:19,900
指令指针回到那个位置。

40
00:02:19,900 --> 00:02:25,070
从堆栈中“pooping a value”也是一种抽象的解释。

41
00:02:25,069 --> 00:02:29,639
它的字面意思是，它查看堆栈指针寄存器，在地址之后，

42
00:02:29,640 --> 00:02:30,720
接受这个价值。

43
00:02:30,719 --> 00:02:33,369
然后它增加堆栈指针寄存器。

44
00:02:33,370 --> 00:02:35,430
它递增是因为堆栈向下增长。

45
00:02:35,430 --> 00:02:38,560
所以如果我们缩小它，当我们弹出一个值，我们就增加它。

46
00:02:38,560 --> 00:02:40,890
所以它再次接近最高地址。

47
00:02:40,889 --> 00:02:41,889
不管怎样。

48
00:02:41,889 --> 00:02:42,979
这就是惩戒所做的。

49
00:02:42,980 --> 00:02:47,070
它在堆栈寄存器指向的地方取这个值，增加堆栈指针地址，

50
00:02:47,069 --> 00:02:52,289
然后使用它得到的值来设置指令指针。

51
00:02:52,290 --> 00:02:54,270
（用引号）。

52
00:02:54,269 --> 00:02:56,339
这就是第一课。

53
00:02:56,340 --> 00:03:01,920
忽略指令的名称或它的典型含义和典型用法，只需理解

54
00:03:01,920 --> 00:03:04,660
指令本身的作用。

55
00:03:04,660 --> 00:03:08,530
所以，再次记住“ret”（返回）指令的作用。

56
00:03:08,530 --> 00:03:12,110
首先查看堆栈寄存器，按照这个地址并取这个值。

57
00:03:12,109 --> 00:03:13,189
增加堆栈指针。

58
00:03:13,190 --> 00:03:15,110
将指令指针设置为该值。

59
00:03:15,110 --> 00:03:16,110
完成。

60
00:03:16,110 --> 00:03:18,170
现在让我们想想别的。

61
00:03:18,170 --> 00:03:22,140
机器执行指令意味着什么？

62
00:03:22,139 --> 00:03:26,339
CPU是执行指令的硬件。

63
00:03:26,340 --> 00:03:30,350
这些指令是机器代码或汇编代码，对吗？

64
00:03:30,349 --> 00:03:33,099
从抽象的意义上讲，这是如何工作的？

65
00:03:33,099 --> 00:03:38,279
有内存，存储指令，这个内存有地址。

66
00:03:38,279 --> 00:03:43,359
然后CPU有一个指令指针寄存器，其中包含指向内存的地址

67
00:03:43,360 --> 00:03:45,950
下一条要执行的指令。

68
00:03:45,950 --> 00:03:48,140
所以如果它是0，它将执行这个。

69
00:03:48,139 --> 00:03:51,049
然后它就做了这个指令定义要做的任何事情。

70
00:03:51,049 --> 00:03:53,889
这条指令所做的并不重要。

71
00:03:53,890 --> 00:03:58,800
但通过执行任何指令，指令指针只需递增并向前移动。

72
00:03:58,799 --> 00:04:00,949
指向下一条指令。

73
00:04:00,950 --> 00:04:05,030
然后执行，指令指针将更新为指向下一个

74
00:04:05,029 --> 00:04:06,029
一个。

75
00:04:06,029 --> 00:04:07,029
诸如此类。

76
00:04:07,029 --> 00:04:10,539
当然，这会随指令而改变，如跳转、调用或返回，其中

77
00:04:10,540 --> 00:04:12,060
指针直接更新。

78
00:04:12,059 --> 00:04:13,059
但你明白了。

79
00:04:13,059 --> 00:04:17,199
从抽象的意义上讲，计算机是一种给出指令的计算机

80
00:04:17,199 --> 00:04:19,429
或者执行这些指令。

81
00:04:19,430 --> 00:04:21,890
所以CPU是一个硬件实现的机器。

82
00:04:21,889 --> 00:04:25,149
当然也有虚拟机。

83
00:04:25,150 --> 00:04:28,200
所以机器实现在我们的CPU机器之上。

84
00:04:28,199 --> 00:04:33,769
例如JVM，Java虚拟机以相同的方式运行。

85
00:04:33,770 --> 00:04:35,170
这是一台机器。

86
00:04:35,169 --> 00:04:40,589
所以在内存的某个地方有字节码，而软件，JVM有一个指令

87
00:04:40,590 --> 00:04:46,020
指向下一指令的指针，或称为程序计数器PC的指针，或

88
00:04:46,020 --> 00:04:47,550
这里叫操作码。

89
00:04:47,550 --> 00:04:52,550
当JVM执行一个操作码时，它还必须更新程序计数器并移动

90
00:04:52,550 --> 00:04:54,330
到下一个。

91
00:04:54,330 --> 00:04:55,810
在这里，我查找了它的源代码。

92
00:04:55,810 --> 00:04:59,240
这里是openjdk源代码，您可以看到更新“pc”和“continue”

93
00:04:59,240 --> 00:05:04,610
宏，它将当前操作码的大小（或长度）添加到程序中

94
00:05:04,610 --> 00:05:07,430
计数器，所以它向前移动。

95
00:05:07,430 --> 00:05:10,790
就像CPU会增加指令指针一样。

96
00:05:10,790 --> 00:05:12,200
这是第二课。

97
00:05:12,199 --> 00:05:14,339
抽象意义上的机器很简单。

98
00:05:14,340 --> 00:05:17,340
有存储代码或指令的存储器。

99
00:05:17,340 --> 00:05:21,700
机器指向代码，接受指令，执行它，然后更新

100
00:05:21,699 --> 00:05:25,409
程序计数器指向下一个。

101
00:05:25,409 --> 00:05:29,879
那么F'与面向返回的编程有什么关系？

102
00:05:29,879 --> 00:05:34,429
最后一段视频我还介绍了一个奇怪的机器的概念。

103
00:05:34,430 --> 00:05:38,300
不知怎么的，这个发票程序实现了一个奇怪的机器。

104
00:05:38,300 --> 00:05:43,110
我知道，这个概念是非常混乱的，但请原谅，它在

105
00:05:43,110 --> 00:05:44,110
时刻。

106
00:05:44,110 --> 00:05:48,500
如果这个发票程序实现了一个奇怪的机器，而你编程了那个奇怪的机器

107
00:05:48,501 --> 00:05:53,201
使用一种称为面向返回编程的技术，那么您现在应该问问自己。

108
00:05:53,199 --> 00:05:58,219
包含指令的内存在哪里，指向的指令指针在哪里

109
00:05:58,220 --> 00:06:03,290
对于这些指令，以及执行任何定义的指令的逻辑在哪里

110
00:06:03,290 --> 00:06:04,290
做什么？

111
00:06:04,290 --> 00:06:08,920
幸运的是，我们有一些示例程序，我们可以用gdb调试这台奇怪的机器。

112
00:06:08,919 --> 00:06:13,189
让我们将发票程序加载到gdb中，并学习它是如何执行的。

113
00:06:13,189 --> 00:06:17,089
我不想再解释缓冲区溢出，请检查我的二进制攻击

114
00:06:17,090 --> 00:06:18,470
播放列表。

115
00:06:18,470 --> 00:06:22,820
但是当你熟悉它时，你知道我们重写了堆栈上的内容。

116
00:06:22,820 --> 00:06:26,730
如果查看add_invoice函数，可以找到危险函数gets（），其中

117
00:06:26,730 --> 00:06:28,400
导致缓冲区溢出。

118
00:06:28,400 --> 00:06:31,980
所以我们可以在这里设置一个断点，在返回处设置一个断点。

119
00:06:31,979 --> 00:06:36,489
然后让我们运行二进制文件，作为输入，我们传入helloworld.binary。

120
00:06:36,490 --> 00:06:40,090
现在我们知道了输入触发了缓冲区溢出。

121
00:06:40,090 --> 00:06:42,480
所以在这里，我们碰到了get的断点。

122
00:06:42,480 --> 00:06:46,970
如果我们执行gets并检查这个堆栈，我们可以在这里找到所有的输入。

123
00:06:46,971 --> 00:06:50,121
这里是所有填充缓冲区的内容。

124
00:06:50,120 --> 00:06:55,280
然后我们有这些随机查找的，但实际上仔细选择了它之后的值。

125
00:06:55,280 --> 00:06:57,840
但让我们继续执行返回指令。

126
00:06:57,840 --> 00:07:03,930
所以现在我们要执行返回，请记住返回的含义。

127
00:07:03,930 --> 00:07:08,760
它查看堆栈寄存器中的地址，所以这里这个地址指向这个内存，

128
00:07:08,759 --> 00:07:11,649
所以这是堆栈，这是顶部元素。

129
00:07:11,650 --> 00:07:16,750
返回指令现在将该值作为地址，并设置指令

130
00:07:16,750 --> 00:07:17,820
指向它的指针。

131
00:07:17,820 --> 00:07:20,800
同时增加堆栈指针。

132
00:07:20,800 --> 00:07:22,040
那我们就这么做吧。

133
00:07:22,039 --> 00:07:23,709
向前迈出一步。

134
00:07:23,710 --> 00:07:27,020
现在让我们比较一下回归前后的情况。

135
00:07:27,020 --> 00:07:28,730
它做了我们所期望的。

136
00:07:28,729 --> 00:07:35,389
堆栈指针寄存器从0x18增加到了0x20，所以向前移动8个字节。

137
00:07:35,389 --> 00:07:40,229
指令指针被设置为先前在堆栈顶部的值。

138
00:07:40,229 --> 00:07:45,719
顺便说一句。。。当执行“ret”时，我们还经常使用短语“we return into&lt；something&gt；”。

139
00:07:45,719 --> 00:07:51,849
不管我们说“我们回到了”，说“我们回到了”还是说“我们

140
00:07:51,849 --> 00:07:53,019
继续执行”。

141
00:07:53,020 --> 00:07:54,140
一切都一样。

142
00:07:54,139 --> 00:07:57,449
不要被“回报”这个词混淆。

143
00:07:57,449 --> 00:07:59,729
你知道RET指令的真正作用。

144
00:07:59,729 --> 00:08:03,429
它只是从堆栈中获取一个值并设置指向它的指令指针。

145
00:08:03,430 --> 00:08:04,430
不管怎样。

146
00:08:04,430 --> 00:08:05,430
那么现在发生了什么？

147
00:08:05,430 --> 00:08:08,140
我们的指示指针指向哪里？

148
00:08:08,139 --> 00:08:09,139
它指向这里…

149
00:08:09,139 --> 00:08:10,209
到这个汇编代码。

150
00:08:10,210 --> 00:08:13,380
一个流行RDX和一个流行RBX。

151
00:08:13,380 --> 00:08:15,790
然后又回来了？

152
00:08:15,789 --> 00:08:20,449
这意味着它从堆栈中获取一个值并将其放入RDX中。

153
00:08:20,449 --> 00:08:21,709
再次增加RSP。

154
00:08:21,710 --> 00:08:25,670
然后获取堆栈上的下一个值并将其移动到RBX中。

155
00:08:25,670 --> 00:08:28,130
增加RSP，然后我们再次返回。

156
00:08:28,130 --> 00:08:32,360
现在返回获取堆栈上的下一个值，并将指令指针设置为

157
00:08:32,360 --> 00:08:33,360
它。

158
00:08:33,360 --> 00:08:35,810
那么它现在在哪里继续执行呢？

159
00:08:35,810 --> 00:08:36,810
可以。

160
00:08:36,810 --> 00:08:37,820
现在我们到了？

161
00:08:37,820 --> 00:08:39,670
这里有一个流行的RDI。

162
00:08:39,669 --> 00:08:43,049
所以它获取栈中的下一个值，将其移动到RDI中。

163
00:08:43,050 --> 00:08:47,660
然后是ret，它获取下一个值并设置指向它的指令指针。

164
00:08:47,660 --> 00:08:49,210
我们现在在哪里？

165
00:08:49,209 --> 00:08:50,609
现在我们开始行动。

166
00:08:50,610 --> 00:08:55,480
我们把EDX移动到RDI所指的地址。

167
00:08:55,480 --> 00:08:57,970
还记得我们设置EDX的时候吗？

168
00:08:57,970 --> 00:09:03,470
在开始的pop rdx中，将edx的值设置为堆栈上的值。

169
00:09:03,470 --> 00:09:09,040
还有rdi，我们现在写的地址，我们在堆栈上也有，并把它放入rdi

170
00:09:09,040 --> 00:09:11,440
一个流行的RDI。

171
00:09:11,440 --> 00:09:13,700
想想这段代码现在做了什么！

172
00:09:13,700 --> 00:09:18,470
我知道它看起来很奇怪，但它只是把我们想要的值移到一个地址

173
00:09:18,470 --> 00:09:19,930
我们指定了。

174
00:09:19,930 --> 00:09:25,360
我们将一个值移入RDX，然后将一个地址移入RDI，然后编写EDX值

175
00:09:25,360 --> 00:09:28,070
到地址RDI指向。

176
00:09:28,070 --> 00:09:31,110
现在看看hello world程序的源代码。

177
00:09:31,110 --> 00:09:36,300
这里的代码说我们将字符串“hell”移动到变量中，当然是4个字节。

178
00:09:36,300 --> 00:09:37,300
4。

179
00:09:37,300 --> 00:09:40,130
然后将变量4存储在内存位置
1。

180
00:09:40,130 --> 00:09:44,420
这只是另一种说法，我们移动字符串，或者4个字节，“地狱”

181
00:09:44,420 --> 00:09:45,570
进入RDX。

182
00:09:45,570 --> 00:09:49,820
然后我们将RDX移动到在RDI中指定的内存位置。

183
00:09:49,820 --> 00:09:53,600
哪个内存位置，以及将字符串“hell”转换为四个字节

184
00:09:53,600 --> 00:09:55,260
我的编译器程序可以。

185
00:09:55,260 --> 00:10:01,200
我知道，也许这有点太令人困惑了，也许最好还是忽略我的编译器恶作剧。

186
00:10:01,199 --> 00:10:02,809
但如果想想我们做了什么。

187
00:10:02,810 --> 00:10:07,620
我们执行了这些将值移动到某个内存位置的指令。

188
00:10:07,620 --> 00:10:14,990
我们通过使用超奇怪的指令做到了这一点，我们通常称之为“小工具”。

189
00:10:14,990 --> 00:10:19,150
为了执行这个内存写入，我们使用了三个小工具。

190
00:10:19,150 --> 00:10:24,530
首先我们使用“pop rdx，pop rbx”小工具，然后使用“pop rdi”小工具，然后使用“mov”

191
00:10:24,529 --> 00:10:25,529
小玩意儿

192
00:10:25,529 --> 00:10:28,059
看看这些小玩意有什么共同点？

193
00:10:28,060 --> 00:10:31,210
它们都以返回指令结束。

194
00:10:31,210 --> 00:10:32,830
现在弯下腰。

195
00:10:32,829 --> 00:10:37,739
把我们刚才看到的情况，试着把它融入到机器执行的概念中去。

196
00:10:37,740 --> 00:10:38,740
指令。

197
00:10:38,740 --> 00:10:41,340
首先，我们有内存，这就是我们的堆栈。

198
00:10:41,339 --> 00:10:44,039
在那里我们有所有这些地址和价值观。

199
00:10:44,040 --> 00:10:50,480
以一种奇怪的方式，堆栈指针是我们的指令指针，对吗？

200
00:10:50,480 --> 00:10:55,700
我们的奇怪机器基本上是从一个返回操作码开始的，它取了第一个地址

201
00:10:55,699 --> 00:10:59,139
在堆栈上继续执行CPU。

202
00:10:59,140 --> 00:11:03,160
然后栈指针指向下一个值，我们弹出它并将其移到下一个值。

203
00:11:03,160 --> 00:11:04,880
pooled另一个值将其移动到下一个值。

204
00:11:04,880 --> 00:11:10,660
然后又出现了另一个返回，它获取值并让CPU在那里执行代码。

205
00:11:10,660 --> 00:11:13,770
再次将堆栈移动到下一个值。

206
00:11:13,769 --> 00:11:19,789
因此，在某种程度上，栈上的地址，当我们有返回时，定义指令

207
00:11:19,790 --> 00:11:21,270
处理程序，对吗？

208
00:11:21,269 --> 00:11:25,829
你可以说这个地址实际上是操作码，执行一个pop的指令

209
00:11:25,830 --> 00:11:28,420
然后是一个流行的RBX。

210
00:11:28,420 --> 00:11:33,760
另一个小工具，这里的地址，是将EDX移动到

211
00:11:33,760 --> 00:11:35,060
RDI地址。

212
00:11:35,060 --> 00:11:41,120
这与x86汇编程序“调用”指令的实际方式不一样吗？

213
00:11:41,120 --> 00:11:45,550
意味着我们在堆栈上推送一个地址，并将指令指针设置到给定的目标。

214
00:11:45,550 --> 00:11:49,930
这种“调用”x86指令与我们怪异的机器小工具有何不同？

215
00:11:49,930 --> 00:11:50,930
不是！

216
00:11:50,930 --> 00:11:54,760
两者都定义了一些动作，它做什么，然后机器移动到下一条指令。

217
00:11:54,760 --> 00:11:59,800
CPU通过递增指令指针来执行此操作，Java虚拟机执行此操作。

218
00:11:59,800 --> 00:12:04,140
通过简单地增加程序计数器，我们的奇怪的机器通过增加

219
00:12:04,140 --> 00:12:05,900
堆栈指针。

220
00:12:05,899 --> 00:12:08,899
我知道，这些小玩意是非常奇怪的指令。

221
00:12:08,899 --> 00:12:13,199
以及每个程序，这取决于它包含多少代码以及函数的类型

222
00:12:13,199 --> 00:12:17,519
写在那里，编译器把代码放在内存中的什么地方，改变了什么类型的代码

223
00:12:17,519 --> 00:12:19,619
个小工具可用。

224
00:12:19,620 --> 00:12:24,620
使用小工具ropgadgets，我们实际上可以列出所有小工具，因此汇编程序片段

225
00:12:24,620 --> 00:12:28,460
让这几个指令的模式后面跟着一个“ret”。

226
00:12:28,459 --> 00:12:32,839
基本上，这些都是我们可以用来实现我们想要的任何东西的奇怪指令

227
00:12:32,840 --> 00:12:34,270
在这台奇怪的机器上。

228
00:12:34,269 --> 00:12:35,589
我知道这很糟糕。

229
00:12:35,590 --> 00:12:40,670
没有人说它必须像CPU或Java虚拟机那样是一个经过深思熟虑的机器。

230
00:12:40,670 --> 00:12:41,690
机器。

231
00:12:41,690 --> 00:12:45,520
但基本上可以进行任何计算。

232
00:12:45,519 --> 00:12:50,379
对我来说，足够收集一些看起来有用的小工具，并构建一个编译程序来翻译

233
00:12:50,380 --> 00:12:56,140
此文本表示指向这些小工具的实际地址。

234
00:12:56,140 --> 00:13:01,530
这就是为什么每个程序都有这样一个漏洞，不小心制造了自己的漏洞。

235
00:13:01,529 --> 00:13:03,039
奇怪的机器。

236
00:13:03,040 --> 00:13:07,640
每个易受攻击的程序都有自己的指令集，它是

237
00:13:07,640 --> 00:13:08,640
小工具。

238
00:13:08,640 --> 00:13:11,800
它是自己的初始化代码来设置这台奇怪的机器。

239
00:13:11,800 --> 00:13:15,720
基本上，首先触发我们漏洞的代码。

240
00:13:15,720 --> 00:13:17,650
所以写这样一篇文章。

241
00:13:17,649 --> 00:13:23,289
本质上是通过触发缓冲区来设置和实例化一个奇怪的机器

242
00:13:23,290 --> 00:13:24,290
溢出。

243
00:13:24,290 --> 00:13:28,730
然后我们用一个ROP链，一组链接的小工具来编程这台奇怪的机器。

244
00:13:28,730 --> 00:13:34,740
由于x86“ret”指令

245
00:13:34,740 --> 00:13:36,620
和烟囱一起工作。

246
00:13:36,620 --> 00:13:43,530
我们可以编程的只是我们的创造力和有用小工具的可用性。

247
00:13:43,529 --> 00:13:47,639
但是如果你有大量的小工具，你可以理解你可以实现

248
00:13:47,639 --> 00:13:49,149
任何你想要的。

249
00:13:49,149 --> 00:13:53,579
您只需将这些小的汇编程序片段链接在一起就可以构建任何东西。

250
00:13:53,579 --> 00:13:58,209
在一次攻击中，你通常试图创建一个远程外壳或其他东西，但实际上它可以

251
00:13:58,209 --> 00:13:59,939
做一个普通的计划。

252
00:13:59,940 --> 00:14:04,650
就像我创建了这些ROP链，例如将两个数字作为输入，

253
00:14:04,649 --> 00:14:06,619
将它们加在一起，并打印结果。

254
00:14:06,620 --> 00:14:07,620
就这样。

255
00:14:07,620 --> 00:14:11,640
这就是以一种非常混乱的方式解释的面向返回的编程。

256
00:14:11,639 --> 00:14:14,849
我知道，这可能不是最好的ROP教程。

257
00:14:14,850 --> 00:14:19,590
但是有太多的“普通”教程，我只是想尝试一些不同的东西

258
00:14:19,589 --> 00:14:24,459
我希望你们中的一些人在这个问题上有不同的观点

259
00:14:24,459 --> 00:14:25,459
打开。

260
00:14:25,459 --> 00:14:30,839
至少对我来说，这是一个令人难忘和美丽的时刻，正如你所知道的，它成为了一个口号。

261
00:14:30,839 --> 00:14:32,609
为了我的频道。

262
00:14:32,610 --> 00:14:37,010
另外，我想提醒你检查一下我在描述中列出的文件和谈话。

263
00:14:37,009 --> 00:14:39,579
即使你不理解这段视频，也请阅读。

264
00:14:39,579 --> 00:14:44,459
它们也许更好，但更准确地解释了这一奇怪机器的概念。

265
00:14:44,459 --> 00:14:46,129
开拓发展。

266
00:14:46,130 --> 00:14:50,250
不管怎样……谢谢你看了我的Patreon和YouTube会员的描述，也许还可以结账。

