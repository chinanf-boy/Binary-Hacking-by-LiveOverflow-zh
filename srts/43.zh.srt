奇怪的面向返回的编程教程1
00:00:00,120 --> 00:00:03,120
可以，上一个视频我给你看了这个程序

2
00:00:03,120 --> 00:00:05,780
我用的语言，难看但有用。

3
00:00:05,779 --> 00:00:09,119
我们把它编译成一个奇怪的二进制文件格式。

4
00:00:09,120 --> 00:00:14,340
然后把这个二进制文件传递给程序名为invoice，它执行

5
00:00:14,339 --> 00:00:15,339
程序。

6
00:00:15,339 --> 00:00:19,199
在上一段视频中，我也向你展示了这个二进制格式的开头

7
00:00:19,200 --> 00:00:23,090
触发缓冲区溢出并覆盖堆栈上的返回指针。

8
00:00:23,090 --> 00:00:27,070
在那一点上，你可能认为我们的程序只是shellcode，所以汇编程序

9
00:00:27,070 --> 00:00:31,300
我们注入然后跳转到的代码，缓冲区溢出。

10
00:00:31,300 --> 00:00:34,930
但这是不可能的，因为堆栈不可执行。

11
00:00:34,929 --> 00:00:39,969
所以即使我们不能注入实际的汇编程序执行指令，我们还是

12
00:00:39,969 --> 00:00:42,399
能够执行我的程序。

13
00:00:42,399 --> 00:00:47,839
在这一点上，很明显，这可以归功于面向返回的编程。

14
00:00:47,839 --> 00:00:50,399
让我们来研究一下这是如何工作的。

15
00:00:50,399 --> 00:00:51,819
但是我警告你。

16
00:00:51,820 --> 00:00:55,880
你真的需要把你的大脑抽象哲学思维模式。

17
00:00:55,879 --> 00:00:57,439
这会变得很奇怪。

18
00:00:57,440 --> 00:01:02,110
也许你得重新看一下在未来，也许可以结帐一些"正常的"

19
00:01:02,109 --> 00:01:05,119
面向返回的编程教程和那就回到这里来。

20
00:01:05,120 --> 00:01:09,580
但是如果你收到这个视频，我想会的更深入更深入的理解

21
00:01:09,580 --> 00:01:10,580
为你。

22
00:01:10,580 --> 00:01:12,870
所以试着…

23
00:01:12,870 --> 00:01:14,520
不管怎样。

24
00:01:14,520 --> 00:01:19,480
我们进去吧。

25
00:01:19,480 --> 00:01:24,490
所以在x86汇编程序中有一个指令称为"呼叫"。

26
00:01:24,490 --> 00:01:27,090
而Call实际上有两件事。

27
00:01:27,090 --> 00:01:30,490
首先，它推进(push)返回地址电话后地址马上就到吗

28
00:01:30,491 --> 00:01:32,631
指令）。

29
00:01:32,630 --> 00:01:37,620
然后它改变EIP，即当前的指令指针，指向调用目标。

30
00:01:37,620 --> 00:01:40,750
所以CPU继续在那里执行。

31
00:01:40,750 --> 00:01:46,690
现在，当我们在C中调用一个函数时，这将编译成汇编程序调用指令。

32
00:01:46,690 --> 00:01:51,020
但是要理解面向返回的编程，你必须忘记这个。

33
00:01:51,020 --> 00:01:54,030
忽略调用函数的概念。

34
00:01:54,030 --> 00:01:59,140
只需记住，此指令推动呼叫指令后的地址

35
00:01:59,140 --> 00:02:04,730
放到堆栈上，然后设置指令指针目标地址。

36
00:02:04,730 --> 00:02:07,530
返回指令在同样的方法。

37
00:02:07,530 --> 00:02:12,480
是的，ret是根据c中的返回进行编译的。忘记这个连接。

38
00:02:12,480 --> 00:02:17,560
一个ret只是弹出一个地址，我们称之为返回地址，离开堆栈并设置

39
00:02:17,560 --> 00:02:19,900
指令指针回到那个位置。

40
00:02:19,900 --> 00:02:25,070
从堆栈中"pooping a value"是又是一个抽象的解释。

41
00:02:25,069 --> 00:02:29,639
它的字面意思是堆栈指针寄存器，在该地址之后，

42
00:02:29,640 --> 00:02:30,720
接受这个价值。

43
00:02:30,719 --> 00:02:33,369
然后它增加堆栈指针寄存器。

44
00:02:33,370 --> 00:02:35,430
它递增是因为堆栈向下增长。

45
00:02:35,430 --> 00:02:38,560
所以如果我们缩小它，当我们弹出一个值时，我们增加它。

46
00:02:38,560 --> 00:02:40,890
所以它再次接近最高地址。

47
00:02:40,889 --> 00:02:41,889
不管怎样。

48
00:02:41,889 --> 00:02:42,979
这就是惩戒所做的。

49
00:02:42,980 --> 00:02:47,070
在堆栈寄存器的位置取这个值指向，增加堆栈指针地址，

50
00:02:47,069 --> 00:02:52,289
然后使用它得到的值来设置指令指针。这就是我们"返回"的方式

51
00:02:52,290 --> 00:02:54,270
（用引号）。

52
00:02:54,269 --> 00:02:56,339
这就是第一课。

53
00:02:56,340 --> 00:03:01,920
忽略指令的名称或典型意义和典型用法，只要理解

54
00:03:01,920 --> 00:03:04,660
指令本身的作用。

55
00:03:04,660 --> 00:03:08,530
所以，再次记住"ret"（the返回）指令执行。

56
00:03:08,530 --> 00:03:12,110
首先查看堆栈寄存器，然后执行以下操作地址和价值。

57
00:03:12,109 --> 00:03:13,189
增加堆栈指针。

58
00:03:13,190 --> 00:03:15,110
将指令指针设置为该值。

59
00:03:15,110 --> 00:03:16,110
完成。

60
00:03:16,110 --> 00:03:18,170
现在让我们想想别的。

61
00:03:18,170 --> 00:03:22,140
机器执行是什么意思指令？

62
00:03:22,139 --> 00:03:26,339
CPU是执行指令。

63
00:03:26,340 --> 00:03:30,350
这些指令是机器代码或汇编程序代码，对吧？

64
00:03:30,349 --> 00:03:33,099
从抽象的意义上讲，这是如何工作的？

65
00:03:33,099 --> 00:03:38,279
嗯，有记忆，指令在哪里存储，并且这个内存有地址。

66
00:03:38,279 --> 00:03:43,359
然后CPU有一个指令指针寄存器，包含指向内存的地址

67
00:03:43,360 --> 00:03:45,950
下一条要执行的指令。

68
00:03:45,950 --> 00:03:48,140
所以如果它是0，它将执行这个。

69
00:03:48,139 --> 00:03:51,049
然后它就可以执行这条指令定义为要执行。

70
00:03:51,049 --> 00:03:53,889
不太重要，这说明是什么做。

71
00:03:53,890 --> 00:03:58,800
但是通过执行任何指令指针简单地递增并向前移动

72
00:03:58,799 --> 00:04:00,949
指向下一条指令。

73
00:04:00,950 --> 00:04:05,030
然后执行指令指针将更新为指向下一个

74
00:04:05,029 --> 00:04:06,029
一个。

75
00:04:06,029 --> 00:04:07,029
诸如此类。

76
00:04:07,029 --> 00:04:10,539
当然，这会随着指令而改变，比如跳转、调用或返回，其中

77
00:04:10,540 --> 00:04:12,060
指针直接更新。

78
00:04:12,059 --> 00:04:13,059
但你明白了。

79
00:04:13,059 --> 00:04:17,199
一台计算机，实际上是抽象的，发出指令的机器会计算

80
00:04:17,199 --> 00:04:19,429
或者执行这些指令。

81
00:04:19,430 --> 00:04:21,890
所以CPU是一个硬件实现的机器。

82
00:04:21,889 --> 00:04:25,149
当然也有虚拟机。

83
00:04:25,150 --> 00:04:28,200
所以机器是在我们的CPU上实现的机器。

84
00:04:28,199 --> 00:04:33,769
例如JVM，Java虚拟机器的工作原理是一样的。

85
00:04:33,770 --> 00:04:35,170
这是一台机器。

86
00:04:35,169 --> 00:04:40,589
所以在记忆的某个地方有字节码，在软件方面，JVM有一个指令

87
00:04:40,590 --> 00:04:46,020
指针，或者有一个叫做程序计数器PC，指向下一个指令，或

88
00:04:46,020 --> 00:04:47,550
这里叫操作码。

89
00:04:47,550 --> 00:04:52,550
当JVM执行一个操作码时，必须更新程序计数器并移动

90
00:04:52,550 --> 00:04:54,330
到下一个。

91
00:04:54,330 --> 00:04:55,810
在这里，我查找了它的源代码。

92
00:04:55,810 --> 00:04:59,240
这里是OpenJDK源代码在那里你会看到一个更新，继续

93
00:04:59,240 --> 00:05:04,610
宏，字面上加上大小（或当前操作码到程序上的长度）

94
00:05:04,610 --> 00:05:07,430
计数器，所以它向前移动。

95
00:05:07,430 --> 00:05:10,790
就像CPU会增加指令一样指针。

96
00:05:10,790 --> 00:05:12,200
这是第二课。

97
00:05:12,199 --> 00:05:14,339
抽象意义上的机器很简单。

98
00:05:14,340 --> 00:05:17,340
有存储代码或指令的存储器。

99
00:05:17,340 --> 00:05:21,700
机器指向代码，一条指令，执行它，然后更新

100
00:05:21,699 --> 00:05:25,409
程序计数器指向下一个。

101
00:05:25,409 --> 00:05:29,879
那么这和F'有什么关系呢？面向返回编程？

102
00:05:29,879 --> 00:05:34,429
最后一段视频我也介绍了这个概念一台奇怪的机器。

103
00:05:34,430 --> 00:05:38,300
不知怎么的，这个发票程序实现了奇怪的机器。

104
00:05:38,300 --> 00:05:43,110
我知道，这个概念太令人困惑了但请原谅我，这在

105
00:05:43,110 --> 00:05:44,110
时刻。

106
00:05:44,110 --> 00:05:48,500
如果这个发票程序实现了一个奇怪的机器，你给那个奇怪的机器编程

107
00:05:48,501 --> 00:05:53,201
使用一种称为面向返回编程的技术，那你现在就问问自己吧。

108
00:05:53,199 --> 00:05:58,219
包含我们指令的存储器在哪里？指向的指令指针在哪里

109
00:05:58,220 --> 00:06:03,290
对那些指令，逻辑在哪里执行任何定义的指令

110
00:06:03,290 --> 00:06:04,290
做什么？

111
00:06:04,290 --> 00:06:08,920
好吧，幸运的是我们有一些示例程序，我们可以用gdb调试这台奇怪的机器。

112
00:06:08,919 --> 00:06:13,189
让我们把发票程序加载到gdb中让我们来学习它是如何执行的。

113
00:06:13,189 --> 00:06:17,089
我不想解释缓冲区溢出再次，请检查我的二进制攻击

114
00:06:17,090 --> 00:06:18,470
播放列表。

115
00:06:18,470 --> 00:06:22,820
但是当你熟悉它的时候，你知道我们重写了堆栈上的内容。

116
00:06:22,820 --> 00:06:26,730
如果您查看"添加发票"功能，可以找到危险函数gets（），其中

117
00:06:26,730 --> 00:06:28,400
导致缓冲区溢出。

118
00:06:28,400 --> 00:06:31,980
所以我们可以在这里设置一个断点，一个在返回。

119
00:06:31,979 --> 00:06:36,489
然后让我们运行二进制文件并作为输入我们进入了地狱世界。

120
00:06:36,490 --> 00:06:40,090
现在我们知道输入触发了缓冲区溢出。

121
00:06:40,090 --> 00:06:42,480
所以在这里，我们碰到了get的断点。

122
00:06:42,480 --> 00:06:46,970
如果我们执行get并检查th堆栈，我们可以在这里找到所有的输入。

123
00:06:46,971 --> 00:06:50,121
这里是所有填充缓冲区的内容。

124
00:06:50,120 --> 00:06:55,280
然后我们有这些随机的，但是实际上，在它之后仔细选择了值。

125
00:06:55,280 --> 00:06:57,840
但让我们继续执行返回指令。

126
00:06:57,840 --> 00:07:03,930
所以现在我们要执行返回，请记住"回报"是什么意思。

127
00:07:03,930 --> 00:07:08,760
它查看堆栈寄存器中的地址，所以这个地址指向这个记忆，

128
00:07:08,759 --> 00:07:11,649
所以这是堆栈，那是顶部元素。

129
00:07:11,650 --> 00:07:16,750
返回指令现在接受了值作为地址，并设置指令

130
00:07:16,750 --> 00:07:17,820
指向它的指针。

131
00:07:17,820 --> 00:07:20,800
同时增加堆栈指针。

132
00:07:20,800 --> 00:07:22,040
那我们就这么做吧。

133
00:07:22,039 --> 00:07:23,709
向前迈出一步。

134
00:07:23,710 --> 00:07:27,020
现在让我们比较一下返回。

135
00:07:27,020 --> 00:07:28,730
它做了我们所期望的。

136
00:07:28,729 --> 00:07:35,389
堆栈指针寄存器已递增从0x18到0x20，所以向前移动8个字节。

137
00:07:35,389 --> 00:07:40,229
指令指针被设置为以前在堆栈顶部的值。

138
00:07:40,229 --> 00:07:45,719
顺便说一句。。。当我们执行一个"ret"时，我们也经常使用短语"we return into&lt；something&gt；"。

139
00:07:45,719 --> 00:07:51,849
不管我们说"我们回来了"去"，说"我们回到"或者说"我们

140
00:07:51,849 --> 00:07:53,019
继续执行"。

141
00:07:53,020 --> 00:07:54,140
一切都一样。

142
00:07:54,139 --> 00:07:57,449
不要被"回报"这个词搞混了。

143
00:07:57,449 --> 00:07:59,729
你知道RET指令的真正作用。

144
00:07:59,729 --> 00:08:03,429
它只是从堆栈中获取一个值，设置指向它的指令指针。

145
00:08:03,430 --> 00:08:04,430
不管怎样。

146
00:08:04,430 --> 00:08:05,430
那么现在发生了什么？

147
00:08:05,430 --> 00:08:08,140
我们的指示指针指向哪里去？

148
00:08:08,139 --> 00:08:09,139
它指向这里…

149
00:08:09,139 --> 00:08:10,209
到这个汇编代码。

150
00:08:10,210 --> 00:08:13,380
一个流行RDX和一个流行RBX。

151
00:08:13,380 --> 00:08:15,790
然后又回来了？

152
00:08:15,789 --> 00:08:20,449
这意味着它从堆叠并放入RDX。

153
00:08:20,449 --> 00:08:21,709
再次增加RSP。

154
00:08:21,710 --> 00:08:25,670
然后获取堆栈上的下一个值，将其移动到RBX。

155
00:08:25,670 --> 00:08:28,130
增加RSP，然后返回再一次。

156
00:08:28,130 --> 00:08:32,360
现在返回的值是堆栈并将指令指针设置为

157
00:08:32,360 --> 00:08:33,360
它。

158
00:08:33,360 --> 00:08:35,810
那么它现在在哪里继续执行呢？

159
00:08:35,810 --> 00:08:36,810
可以。

160
00:08:36,810 --> 00:08:37,820
现在我们到了？

161
00:08:37,820 --> 00:08:39,670
这里有一个流行的RDI。

162
00:08:39,669 --> 00:08:43,049
所以它取栈中的下一个值，移动进入RDI。

163
00:08:43,050 --> 00:08:47,660
然后是ret，它取下一个值并设置指向它的指令指针。

164
00:08:47,660 --> 00:08:49,210
我们现在在哪里？

165
00:08:49,209 --> 00:08:50,609
现在我们开始行动。

166
00:08:50,610 --> 00:08:55,480
我们把edx移动到RDI。

167
00:08:55,480 --> 00:08:57,970
还记得我们设置EDX的时候吗？

168
00:08:57,970 --> 00:09:03,470
在开始时弹出RDX，设置值将EDX转换为堆栈上的值。

169
00:09:03,470 --> 00:09:09,040
还有RDI，我们现在写信的地址，我们还把它放进了RDI

170
00:09:09,040 --> 00:09:11,440
一个流行的RDI。

171
00:09:11,440 --> 00:09:13,700
想想这段代码现在做了什么！

172
00:09:13,700 --> 00:09:18,470
我知道它看起来很奇怪，但它所做的只是它把我们想要的值移到一个地址

173
00:09:18,470 --> 00:09:19,930
我们指定了。

174
00:09:19,930 --> 00:09:25,360
我们将一个值移入RDX，然后是一个地址在RDI中，然后我们写下EDX值

175
00:09:25,360 --> 00:09:28,070
到地址RDI指向。

176
00:09:28,070 --> 00:09:31,110
现在看看hello世界的源代码程序。

177
00:09:31,110 --> 00:09:36,300
在这里，代码说我们移动字符串，"地狱"当然是4个字节，输入变量

178
00:09:36,300 --> 00:09:37,300
4.

179
00:09:37,300 --> 00:09:40,130
然后将变量4存储在内存位置
1.

180
00:09:40,130 --> 00:09:44,420
这只是另一种说法，我们移动字符串或4个字节，"地狱"

181
00:09:44,420 --> 00:09:45,570
进入RDX。

182
00:09:45,570 --> 00:09:49,820
然后我们将RDX移动到内存位置我们在RDI中指定。

183
00:09:49,820 --> 00:09:53,600
哪个内存位置，并转换字符串"hell"到四个字节是什么

184
00:09:53,600 --> 00:09:55,260
我的编译器程序可以。

185
00:09:55,260 --> 00:10:01,200
我知道，也许这太令人困惑了，也许最好不要理会我的编译器恶作剧。

186
00:10:01,199 --> 00:10:02,809
但如果想想我们做了什么。

187
00:10:02,810 --> 00:10:07,620
我们执行了这几条移动指令某个内存位置的值。

188
00:10:07,620 --> 00:10:14,990
我们通过使用超奇怪的指令做到了这一点，我们通常称之为"小工具"。

189
00:10:14,990 --> 00:10:19,150
为了执行这个内存写入，我们使用了三个小工具。

190
00:10:19,150 --> 00:10:24,530
首先我们使用了一个"pop-rdx，pop-rbx"小工具，然后是"pop rdi"小工具，然后是"mov"

191
00:10:24,529 --> 00:10:25,529
小玩意儿

192
00:10:25,529 --> 00:10:28,059
看看这些小玩意有什么共同点？

193
00:10:28,060 --> 00:10:31,210
它们都以返回指令结束。

194
00:10:31,210 --> 00:10:32,830
现在弯下腰。

195
00:10:32,829 --> 00:10:37,739
接受我们刚才看到的，并努力适应它进入了机器执行的概念

196
00:10:37,740 --> 00:10:38,740
指令。

197
00:10:38,740 --> 00:10:41,340
首先，我们有内存，这就是我们的堆栈。

198
00:10:41,339 --> 00:10:44,039
在那里我们有所有这些地址和价值观。

199
00:10:44,040 --> 00:10:50,480
用一种奇怪的该死的方式，堆栈指针是我们的指示指针吗？

200
00:10:50,480 --> 00:10:55,700
我们的奇怪机器基本上是从返回操作码，它取第一个地址

201
00:10:55,699 --> 00:10:59,139
在堆栈上继续执行CPU。

202
00:10:59,140 --> 00:11:03,160
然后堆栈指针指向下一个值，我们弹出并移动到下一个。

203
00:11:03,160 --> 00:11:04,880
pooled另一个值将其移动到下一个值。

204
00:11:04,880 --> 00:11:10,660
然后又回来了，带着值并让CPU在那里执行代码。

205
00:11:10,660 --> 00:11:13,770
再次将堆栈移动到下一个值。

206
00:11:13,769 --> 00:11:19,789
所以在某种程度上这些地址在堆栈上，当我们有返回时，定义指令

207
00:11:19,790 --> 00:11:21,270
处理程序，对吗？

208
00:11:21,269 --> 00:11:25,829
你可以说这里的地址实际上是操作码，执行POP的指令

209
00:11:25,830 --> 00:11:28,420
然后是一个流行的RBX。

210
00:11:28,420 --> 00:11:33,760
还有这个小器具，这个地址，是将EDX移动到

211
00:11:33,760 --> 00:11:35,060
RDI地址。

212
00:11:35,060 --> 00:11:41,120
这基本上不是同一件事吗实际上是一个x86汇编程序"调用"指令

213
00:11:41,120 --> 00:11:45,550
意味着我们在堆栈上推一个地址，将指令指针设置到给定的目标。

214
00:11:45,550 --> 00:11:49,930
那"调用"x86指令有什么不同？从我们奇怪的机器设备里？

215
00:11:49,930 --> 00:11:50,930
不是！

216
00:11:50,930 --> 00:11:54,760
两者都定义了一些动作，它做什么，以及然后机器转到下一个指令。

217
00:11:54,760 --> 00:11:59,800
CPU通过增加指令来实现这一点指针，Java虚拟机这样做

218
00:11:59,800 --> 00:12:04,140
只需增加程序计数器，我们的奇怪机器通过增加

219
00:12:04,140 --> 00:12:05,900
堆栈指针。

220
00:12:05,899 --> 00:12:08,899
我知道，这些小玩意是非常奇怪的指令。

221
00:12:08,899 --> 00:12:13,199
每个程序，取决于代码的多少它包含什么类型的函数

222
00:12:13,199 --> 00:12:17,519
写在那里，在记忆中编译器放置代码，更改类型

223
00:12:17,519 --> 00:12:19,619
个小工具可用。

224
00:12:19,620 --> 00:12:24,620
使用小工具，我们实际上可以列出所有小工具，以便汇编程序片段

225
00:12:24,620 --> 00:12:28,460
遵循以下几个说明的模式用"RET"。

226
00:12:28,459 --> 00:12:32,839
基本上这些都是奇怪的指示我们可以用它来实现我们想要的一切

227
00:12:32,840 --> 00:12:34,270
在这台奇怪的机器上。

228
00:12:34,269 --> 00:12:35,589
我知道这很糟糕。

229
00:12:35,590 --> 00:12:40,670
没人说这必须是个好主意像CPU或Java虚拟机

230
00:12:40,670 --> 00:12:41,690
机器。

231
00:12:41,690 --> 00:12:45,520
但这基本上就足够了计算方式。

232
00:12:45,519 --> 00:12:50,379
对我来说，收集那些似乎很有用，并构建了一个编译程序

233
00:12:50,380 --> 00:12:56,140
此文本表示实际地址指那些小玩意儿。

234
00:12:56,140 --> 00:13:01,530
这就是为什么每个程序都有这样一个脆弱性，不小心制造了自己的

235
00:13:01,529 --> 00:13:03,039
奇怪的机器。

236
00:13:03,040 --> 00:13:07,640
每个易受攻击的程序都有自己的指令集，它是

237
00:13:07,640 --> 00:13:08,640
小工具。

238
00:13:08,640 --> 00:13:11,800
它是自己的初始化代码那个奇怪的机器。

239
00:13:11,800 --> 00:13:15,720
基本上是触发我们脆弱性的代码首先。

240
00:13:15,720 --> 00:13:17,650
所以写这样一篇文章。

241
00:13:17,649 --> 00:13:23,289
本质上是设置和实例化通过触发缓冲区

242
00:13:23,290 --> 00:13:24,290
溢出。

243
00:13:24,290 --> 00:13:28,730
然后我们用一个ROP链，一组链接的小工具

244
00:13:28,730 --> 00:13:34,740
一起被我们的怪人处决机器，这要归功于x86"ret"指令

245
00:13:34,740 --> 00:13:36,620
和烟囱一起工作。

246
00:13:36,620 --> 00:13:43,530
我们所能规划的只是创意和实用小工具的可用性。

247
00:13:43,529 --> 00:13:47,639
但是如果你有大量的小工具你可以理解你可以实现

248
00:13:47,639 --> 00:13:49,149
任何你想要的。

249
00:13:49,149 --> 00:13:53,579
你只要把这些小汇编代码串起来一起建造任何东西。

250
00:13:53,579 --> 00:13:58,209
在攻击中，您通常尝试创建一个远程贝壳之类的，但它可以

251
00:13:58,209 --> 00:13:59,939
做一个普通的项目。

252
00:13:59,940 --> 00:14:04,650
就像我创造了这些ROP链例如，以两个数字作为输入，

253
00:14:04,649 --> 00:14:06,619
将它们加在一起，并打印结果。

254
00:14:06,620 --> 00:14:07,620
就这样。

255
00:14:07,620 --> 00:14:11,640
这就是面向返回的编程以一种非常混乱的方式。

256
00:14:11,639 --> 00:14:14,849
我知道，这可能不是最好的ROP教程。

257
00:14:14,850 --> 00:14:19,590
但是有很多"普通"的教程，我只是想尝试一些不同的东西

258
00:14:19,589 --> 00:14:24,459
我希望你们中的一些人关于这个话题的不同角度是头脑

259
00:14:24,459 --> 00:14:25,459
打开。

260
00:14:25,459 --> 00:14:30,839
至少对我来说，这太令人吃惊了很漂亮，正如你所知，它成了一个口号

261
00:14:30,839 --> 00:14:32,609
为了我的频道。

262
00:14:32,610 --> 00:14:37,010
我还想提醒你我在描述中列出的论文和谈话。

263
00:14:37,009 --> 00:14:39,579
即使你不明白，也请你读一下这个视频。

264
00:14:39,579 --> 00:14:44,459
它们也许更好，但肯定更多正确解释这一奇怪机器的概念

265
00:14:44,459 --> 00:14:46,129
开拓发展。

266
00:14:46,130 --> 00:14:50,250
不管怎样……谢谢你的收看，也许还可以结账我的Patreon和YouTube会员描述。

