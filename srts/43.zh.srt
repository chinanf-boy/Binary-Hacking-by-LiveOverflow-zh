1
00:00:00,120 --> 00:00:03,120
好吧，我给你看的最后一段视频

2
00:00:03,120 --> 00:00:05,780
language I made, ugly but works.

3
00:00:05,779 --> 00:00:09,119
And we compiled this into this weird binary format.

4
00:00:09,120 --> 00:00:14,340
然后把这个二进制文件传递给这个叫做invoice的程序，它执行我们的

5
00:00:14,339 --> 00:00:15,339
program.

6
00:00:15,339 --> 00:00:19,199
在上一个视频中，我还向您展示了这个二进制格式的开头

7
00:00:19,200 --> 00:00:23,090
triggers a buffer overflow and overwrites the return pointer on the stack.

8
00:00:23,090 --> 00:00:27,070
在那一点上，您可能认为我们的程序只是shellcode，所以汇编程序

9
00:00:27,070 --> 00:00:31,300
code, that we inject and then jump to, with the buffer overflow.

10
00:00:31,300 --> 00:00:34,930
But that is not even possible, because the stack is not executable.

11
00:00:34,929 --> 00:00:39,969
所以即使我们不能注入实际的汇编程序指令来执行，我们还是

12
00:00:39,969 --> 00:00:42,399
able to execute my programs.

13
00:00:42,399 --> 00:00:47,839
And at this point it’s pretty clear, that this is possible thanks to return-oriented-programming.

14
00:00:47,839 --> 00:00:50,399
So let’s examine how this works.

15
00:00:50,399 --> 00:00:51,819
But I warn you.

16
00:00:51,820 --> 00:00:55,880
You really need to get your brain into an abstract philosophical thinking mode.

17
00:00:55,879 --> 00:00:57,439
This will get weird.

18
00:00:57,440 --> 00:01:02,110
也许你以后得重新看一遍，也许结账时会更“正常”

19
00:01:02,109 --> 00:01:05,119
Return Oriented Programming tutorials and then come back to this.

20
00:01:05,120 --> 00:01:09,580
但如果你能看到这段视频，我想它会让你更加深入地了解

21
00:01:09,580 --> 00:01:10,580
for you.

22
00:01:10,580 --> 00:01:12,870
So just try...

23
00:01:12,870 --> 00:01:14,520
Anyway.

24
00:01:14,520 --> 00:01:19,480
Let’s head in.

25
00:01:19,480 --> 00:01:24,490
So in x86 assembler there is an instuction called “call”.

26
00:01:24,490 --> 00:01:27,090
And call actually does two things.

27
00:01:27,090 --> 00:01:30,490
首先，它推送返回地址（即呼叫后的地址

28
00:01:30,491 --> 00:01:32,631
instruction) on the stack.

29
00:01:32,630 --> 00:01:37,620
And then it changes EIP, the current instruction pointer, to the call destination.

30
00:01:37,620 --> 00:01:40,750
So the CPU continues execution there.

31
00:01:40,750 --> 00:01:46,690
Now when we in C call a function, this will be compiled to an assembler call instruction.

32
00:01:46,690 --> 00:01:51,020
But to understand return-oriented-programming, you have to forget this.

33
00:01:51,020 --> 00:01:54,030
Ignore the concept of calling functions.

34
00:01:54,030 --> 00:01:59,140
只需记住，此指令会在调用指令后立即推送地址

35
00:01:59,140 --> 00:02:04,730
onto the stack, and then set instruction pointer to the target address.

36
00:02:04,730 --> 00:02:07,530
And the return instruction behaves in the same way.

37
00:02:07,530 --> 00:02:12,480
YES ret is compiled from a return in C. But forget this connection.

38
00:02:12,480 --> 00:02:17,560
ret只是弹出一个地址，我们称之为返回地址，从堆栈中取出并设置

39
00:02:17,560 --> 00:02:19,900
instruction pointer back to that.

40
00:02:19,900 --> 00:02:25,070
And “pooping a value” from the stack is also already again an abstract interpretation.

41
00:02:25,069 --> 00:02:29,639
它的字面意思是，它查看堆栈指针寄存器，在地址之后，

42
00:02:29,640 --> 00:02:30,720
takes that value.

43
00:02:30,719 --> 00:02:33,369
And then it increments the stack pointer register.

44
00:02:33,370 --> 00:02:35,430
It increments because the stack grows downwards.

45
00:02:35,430 --> 00:02:38,560
So if we shrink it, when we POP a value, we increase it.

46
00:02:38,560 --> 00:02:40,890
So it gets closer to the highest address again.

47
00:02:40,889 --> 00:02:41,889
Anyway.

48
00:02:41,889 --> 00:02:42,979
This is what ret does.

49
00:02:42,980 --> 00:02:47,070
它在堆栈寄存器指向的地方取这个值，增加堆栈指针地址，

50
00:02:47,069 --> 00:02:52,289
然后使用它得到的值来设置指令指针。

51
00:02:52,290 --> 00:02:54,270
(in quotation marks).

52
00:02:54,269 --> 00:02:56,339
So this was lesson one.

53
00:02:56,340 --> 00:03:01,920
忽略指令的名称或它的典型含义和典型用法，只需理解

54
00:03:01,920 --> 00:03:04,660
what the instruction itself does.

55
00:03:04,660 --> 00:03:08,530
So again, remember what the “ret” (the return) instruction does.

56
00:03:08,530 --> 00:03:12,110
First look at the stack register, follow this address and take that value.

57
00:03:12,109 --> 00:03:13,189
Increment the stack pointer.

58
00:03:13,190 --> 00:03:15,110
Set the instruction pointer to that value.

59
00:03:15,110 --> 00:03:16,110
Done.

60
00:03:16,110 --> 00:03:18,170
Now let’s think about something else.

61
00:03:18,170 --> 00:03:22,140
机器执行指令意味着什么？

62
00:03:22,139 --> 00:03:26,339
A CPU is a piece of hardware that executes instructions.

63
00:03:26,340 --> 00:03:30,350
这些指令是机器代码或汇编代码，对吗？

64
00:03:30,349 --> 00:03:33,099
从抽象的意义上讲，这是如何工作的？

65
00:03:33,099 --> 00:03:38,279
Well there is memory, where instructions are stored, and this memory has addresses.

66
00:03:38,279 --> 00:03:43,359
然后CPU有一个指令指针寄存器，其中包含指向内存的地址

67
00:03:43,360 --> 00:03:45,950
with the next instruction to execute.

68
00:03:45,950 --> 00:03:48,140
So if it’s 0, it will execute this.

69
00:03:48,139 --> 00:03:51,049
And then it does whatever this instruction is defined to do.

70
00:03:51,049 --> 00:03:53,889
Not that important what this instruction exactly does.

71
00:03:53,890 --> 00:03:58,800
但通过执行任何指令，指令指针只需递增并向前移动。

72
00:03:58,799 --> 00:04:00,949
to point to the next instruction.

73
00:04:00,950 --> 00:04:05,030
然后执行，指令指针将更新为指向下一个

74
00:04:05,029 --> 00:04:06,029
one.

75
00:04:06,029 --> 00:04:07,029
And so forth.

76
00:04:07,029 --> 00:04:10,539
当然，这会随指令而改变，如跳转、调用或返回，其中

77
00:04:10,540 --> 00:04:12,060
pointer is directly updated.

78
00:04:12,059 --> 00:04:13,059
But you get it.

79
00:04:13,059 --> 00:04:17,199
从抽象的意义上讲，计算机是一种给出指令的计算机

80
00:04:17,199 --> 00:04:19,429
or executes those instructions.

81
00:04:19,430 --> 00:04:21,890
So the CPU is a machine implemented in hardware.

82
00:04:21,889 --> 00:04:25,149
But of course there are also virtual machines.

83
00:04:25,150 --> 00:04:28,200
So machines implemented on top of our CPU machines.

84
00:04:28,199 --> 00:04:33,769
And for example the JVM, the Java Virtual Machine behaves in the same way.

85
00:04:33,770 --> 00:04:35,170
It is a machine.

86
00:04:35,169 --> 00:04:40,589
所以在内存的某个地方有字节码，而软件，JVM有一个指令

87
00:04:40,590 --> 00:04:46,020
指向下一指令的指针，或称为程序计数器PC的指针，或

88
00:04:46,020 --> 00:04:47,550
there called opcode.

89
00:04:47,550 --> 00:04:52,550
当JVM执行一个操作码时，它还必须更新程序计数器并移动

90
00:04:52,550 --> 00:04:54,330
it to the next one.

91
00:04:54,330 --> 00:04:55,810
Here I looked up the source code for that.

92
00:04:55,810 --> 00:04:59,240
这里是openjdk源代码，您可以看到更新“pc”和“continue”

93
00:04:59,240 --> 00:05:04,610
宏，它将当前操作码的大小（或长度）添加到程序中

94
00:05:04,610 --> 00:05:07,430
counter, so this moves it forward.

95
00:05:07,430 --> 00:05:10,790
Like the CPU would increment the instruction pointer.

96
00:05:10,790 --> 00:05:12,200
So this is lesson two.

97
00:05:12,199 --> 00:05:14,339
A machine in an abstract sense is simple.

98
00:05:14,340 --> 00:05:17,340
There is memory that holds code or instructions.

99
00:05:17,340 --> 00:05:21,700
机器指向代码，接受指令，执行它，然后更新

100
00:05:21,699 --> 00:05:25,409
the program counter to point to the next one.

101
00:05:25,409 --> 00:05:29,879
那么F'与面向返回的编程有什么关系？

102
00:05:29,879 --> 00:05:34,429
Well last video I also introduced the concept of a weird machine.

103
00:05:34,430 --> 00:05:38,300
Somehow this invoice program implemented a weird machine.

104
00:05:38,300 --> 00:05:43,110
我知道，这个概念是非常混乱的，但请原谅，它在

105
00:05:43,110 --> 00:05:44,110
moment.

106
00:05:44,110 --> 00:05:48,500
如果这个发票程序实现了一个奇怪的机器，而你编程了那个奇怪的机器

107
00:05:48,501 --> 00:05:53,201
with a technique called return-oriented-programming, then you should ask yourself now.

108
00:05:53,199 --> 00:05:58,219
包含指令的内存在哪里，指向的指令指针在哪里

109
00:05:58,220 --> 00:06:03,290
对于这些指令，以及执行任何定义的指令的逻辑在哪里

110
00:06:03,290 --> 00:06:04,290
做什么？

111
00:06:04,290 --> 00:06:08,920
Well, luckily we have some example programs, and we can debug this weird machine with GDB.

112
00:06:08,919 --> 00:06:13,189
Let’s load the invoice program into GDB and let’s learn how it executes.

113
00:06:13,189 --> 00:06:17,089
我不想再解释缓冲区溢出，请检查我的二进制攻击

114
00:06:17,090 --> 00:06:18,470
playlist for that.

115
00:06:18,470 --> 00:06:22,820
But when you are familiar with it, you know that we overwrote stuff on the stack.

116
00:06:22,820 --> 00:06:26,730
如果查看add_invoice函数，可以找到危险函数gets（），其中

117
00:06:26,730 --> 00:06:28,400
cause the buffer overflow.

118
00:06:28,400 --> 00:06:31,980
So we can set a breakpoint here, and we set one at the return.

119
00:06:31,979 --> 00:06:36,489
Then let’s run the binary and as an input we pass in the helloworld.binary.

120
00:06:36,490 --> 00:06:40,090
And we know now that input triggers the buffer overflow.

121
00:06:40,090 --> 00:06:42,480
So here we hit the breakpoint at the gets.

122
00:06:42,480 --> 00:06:46,970
If we execute the gets and examine th stack, we can find all of our input here.

123
00:06:46,971 --> 00:06:50,121
Here are all the As that fill up the buffer.

124
00:06:50,120 --> 00:06:55,280
And then we have these randomly looking, but actually carefully chosen values after it.

125
00:06:55,280 --> 00:06:57,840
But let’s go forward to the return instruction.

126
00:06:57,840 --> 00:07:03,930
So now we are about to execute the return, and please remember what return means.

127
00:07:03,930 --> 00:07:08,760
它查看堆栈寄存器中的地址，所以这里这个地址指向这个内存，

128
00:07:08,759 --> 00:07:11,649
so this is the stack and that’s the top element.

129
00:07:11,650 --> 00:07:16,750
返回指令现在将该值作为地址，并设置指令

130
00:07:16,750 --> 00:07:17,820
pointer to it.

131
00:07:17,820 --> 00:07:20,800
And at the same time increments the stack pointer.

132
00:07:20,800 --> 00:07:22,040
So let’s do that.

133
00:07:22,039 --> 00:07:23,709
Single step forward.

134
00:07:23,710 --> 00:07:27,020
ANd now let’s compare before and after the return.

135
00:07:27,020 --> 00:07:28,730
It did exactly what we expected.

136
00:07:28,729 --> 00:07:35,389
The stack pointer register was incremented from 0x18 to 0x20, so move 8 bytes forward.

137
00:07:35,389 --> 00:07:40,229
And the instruction pointer got set to the value previously on top of the stack.

138
00:07:40,229 --> 00:07:45,719
Btw... when we execute a “ret” we also often use the phrase “we return into &lt;something&gt;”.

139
00:07:45,719 --> 00:07:51,849
不管我们说“我们回到了”，说“我们回到了”还是说“我们

140
00:07:51,849 --> 00:07:53,019
continued execution here”.

141
00:07:53,020 --> 00:07:54,140
It’s all the same.

142
00:07:54,139 --> 00:07:57,449
Don’t get confused by the term “return”.

143
00:07:57,449 --> 00:07:59,729
You know what the ret instruction really does.

144
00:07:59,729 --> 00:08:03,429
It simply takes a value from the stack and sets the instruction pointer to it.

145
00:08:03,430 --> 00:08:04,430
Anyway.

146
00:08:04,430 --> 00:08:05,430
那么现在发生了什么？

147
00:08:05,430 --> 00:08:08,140
我们的指示指针指向哪里？

148
00:08:08,139 --> 00:08:09,139
It points here...

149
00:08:09,139 --> 00:08:10,209
To this assembler code.

150
00:08:10,210 --> 00:08:13,380
A pop rdx and a pop rbx.

151
00:08:13,380 --> 00:08:15,790
然后又回来了？

152
00:08:15,789 --> 00:08:20,449
So this means it takes one value from the stack and puts it into rdx.

153
00:08:20,449 --> 00:08:21,709
Increments rsp again.

154
00:08:21,710 --> 00:08:25,670
Then takes the next value on the stack and moves it into rbx.

155
00:08:25,670 --> 00:08:28,130
Increments rsp and then we are at the return again.

156
00:08:28,130 --> 00:08:32,360
现在返回获取堆栈上的下一个值，并将指令指针设置为

157
00:08:32,360 --> 00:08:33,360
it.

158
00:08:33,360 --> 00:08:35,810
那么它现在在哪里继续执行呢？

159
00:08:35,810 --> 00:08:36,810
Okay.

160
00:08:36,810 --> 00:08:37,820
现在我们到了？

161
00:08:37,820 --> 00:08:39,670
Here we have a pop rdi.

162
00:08:39,669 --> 00:08:43,049
So it takes the next value on the stack, moves it into rdi.

163
00:08:43,050 --> 00:08:47,660
And then comes ret, which takes the next value and sets the instruction pointer to it.

164
00:08:47,660 --> 00:08:49,210
我们现在在哪里？

165
00:08:49,209 --> 00:08:50,609
Now we execute a move.

166
00:08:50,610 --> 00:08:55,480
We move edx, into the address pointed to by rdi.

167
00:08:55,480 --> 00:08:57,970
还记得我们设置EDX的时候吗？

168
00:08:57,970 --> 00:09:03,470
The pop RDX at the beginning, set the value of EDX to a value we had on the stack.

169
00:09:03,470 --> 00:09:09,040
还有rdi，我们现在写的地址，我们在堆栈上也有，并把它放入rdi

170
00:09:09,040 --> 00:09:11,440
with a pop RDI.

171
00:09:11,440 --> 00:09:13,700
想想这段代码现在做了什么！

172
00:09:13,700 --> 00:09:18,470
我知道它看起来很奇怪，但它只是把我们想要的值移到一个地址

173
00:09:18,470 --> 00:09:19,930
we specified.

174
00:09:19,930 --> 00:09:25,360
我们将一个值移入RDX，然后将一个地址移入RDI，然后编写EDX值

175
00:09:25,360 --> 00:09:28,070
to the address RDI points to.

176
00:09:28,070 --> 00:09:31,110
Now look at the source code of the hello world program.

177
00:09:31,110 --> 00:09:36,300
这里的代码说我们将字符串“hell”移动到变量中，当然是4个字节。

178
00:09:36,300 --> 00:09:37,300
4.

179
00:09:37,300 --> 00:09:40,130
然后将变量4存储在内存位置
1.

180
00:09:40,130 --> 00:09:44,420
这只是另一种说法，我们移动字符串，或者4个字节，“地狱”

181
00:09:44,420 --> 00:09:45,570
into rdx.

182
00:09:45,570 --> 00:09:49,820
And then we move rdx to a memory location we specify in RDI.

183
00:09:49,820 --> 00:09:53,600
哪个内存位置，以及将字符串“hell”转换为四个字节

184
00:09:53,600 --> 00:09:55,260
my compiler program does.

185
00:09:55,260 --> 00:10:01,200
I know, maybe that is a bit too confusing, maybe better just ignore my compiler shenanigans.

186
00:10:01,199 --> 00:10:02,809
But if think about what we did.

187
00:10:02,810 --> 00:10:07,620
We executed these few instructions that move a value into some memory location.

188
00:10:07,620 --> 00:10:14,990
And we did that by using super weird instructions, which we usually refer to as “gadgets”.

189
00:10:14,990 --> 00:10:19,150
To perform this memory write, we used three gadgets.

190
00:10:19,150 --> 00:10:24,530
首先我们使用“pop rdx，pop rbx”小工具，然后使用“pop rdi”小工具，然后使用“mov”

191
00:10:24,529 --> 00:10:25,529
gadget”.

192
00:10:25,529 --> 00:10:28,059
看看这些小玩意有什么共同点？

193
00:10:28,060 --> 00:10:31,210
They all end with a return instruction.

194
00:10:31,210 --> 00:10:32,830
Now bend you mind.

195
00:10:32,829 --> 00:10:37,739
把我们刚才看到的情况，试着把它融入到机器执行的概念中去。

196
00:10:37,740 --> 00:10:38,740
instructions.

197
00:10:38,740 --> 00:10:41,340
First, we have memory, that is our stack.

198
00:10:41,339 --> 00:10:44,039
On there we had all these addresses and values.

199
00:10:44,040 --> 00:10:50,480
以一种奇怪的方式，堆栈指针是我们的指令指针，对吗？

200
00:10:50,480 --> 00:10:55,700
我们的奇怪机器基本上是从一个返回操作码开始的，它取了第一个地址

201
00:10:55,699 --> 00:10:59,139
on the stack and continued CPU execution there.

202
00:10:59,140 --> 00:11:03,160
Then the stack pointer pointed to the next value, we popped it and moved it to the next.

203
00:11:03,160 --> 00:11:04,880
Pooped another value moved it to the next.

204
00:11:04,880 --> 00:11:10,660
And then came another return which took the value and let the CPU execute code there.

205
00:11:10,660 --> 00:11:13,770
Moving the stack again to the next value.

206
00:11:13,769 --> 00:11:19,789
因此，在某种程度上，栈上的地址，当我们有返回时，定义指令

207
00:11:19,790 --> 00:11:21,270
处理程序，对吗？

208
00:11:21,269 --> 00:11:25,829
你可以说这个地址实际上是操作码，执行一个pop的指令

209
00:11:25,830 --> 00:11:28,420
rdx and then a pop rbx.

210
00:11:28,420 --> 00:11:33,760
另一个小工具，这里的地址，是将EDX移动到

211
00:11:33,760 --> 00:11:35,060
address of rdi.

212
00:11:35,060 --> 00:11:41,120
这与x86汇编程序“调用”指令的实际方式不一样吗？

213
00:11:41,120 --> 00:11:45,550
means we push an address on the stack and set the instruction pointer to the given destination.

214
00:11:45,550 --> 00:11:49,930
这种“调用”x86指令与我们怪异的机器小工具有何不同？

215
00:11:49,930 --> 00:11:50,930
不是！

216
00:11:50,930 --> 00:11:54,760
Both define some action, what it does, and then the machine moves to the next instruction.

217
00:11:54,760 --> 00:11:59,800
CPU通过递增指令指针来执行此操作，Java虚拟机执行此操作。

218
00:11:59,800 --> 00:12:04,140
通过简单地增加程序计数器，我们的奇怪的机器通过增加

219
00:12:04,140 --> 00:12:05,900
the stack pointer.

220
00:12:05,899 --> 00:12:08,899
I know, these gadgets are super weird instructions.

221
00:12:08,899 --> 00:12:13,199
以及每个程序，这取决于它包含多少代码以及函数的类型

222
00:12:13,199 --> 00:12:17,519
写在那里，编译器把代码放在内存中的什么地方，改变了什么类型的代码

223
00:12:17,519 --> 00:12:19,619
of gadgets are available.

224
00:12:19,620 --> 00:12:24,620
使用小工具ropgadgets，我们实际上可以列出所有小工具，因此汇编程序片段

225
00:12:24,620 --> 00:12:28,460
have this pattern of a few instructions followed by a “ret”.

226
00:12:28,459 --> 00:12:32,839
基本上，这些都是我们可以用来实现我们想要的任何东西的奇怪指令

227
00:12:32,840 --> 00:12:34,270
on this weird machine.

228
00:12:34,269 --> 00:12:35,589
I know it’s crappy.

229
00:12:35,590 --> 00:12:40,670
没有人说它必须像CPU或Java虚拟机那样是一个经过深思熟虑的机器。

230
00:12:40,670 --> 00:12:41,690
Machine.

231
00:12:41,690 --> 00:12:45,520
But it’s enough to basically perform any kind of computation.

232
00:12:45,519 --> 00:12:50,379
对我来说，足够收集一些看起来有用的小工具，并构建一个编译程序来翻译

233
00:12:50,380 --> 00:12:56,140
this text representation to actual addresses that point to those gadgets.

234
00:12:56,140 --> 00:13:01,530
这就是为什么每个程序都有这样一个漏洞，不小心制造了自己的漏洞。

235
00:13:01,529 --> 00:13:03,039
weird machine.

236
00:13:03,040 --> 00:13:07,640
每个易受攻击的程序都有自己的指令集，它是

237
00:13:07,640 --> 00:13:08,640
gadgets.

238
00:13:08,640 --> 00:13:11,800
And it’s own initialisation code that setups that weird machine.

239
00:13:11,800 --> 00:13:15,720
Basically the code that triggered our vulnerability in the first place.

240
00:13:15,720 --> 00:13:17,650
So writing such an exploit.

241
00:13:17,649 --> 00:13:23,289
本质上是通过触发缓冲区来设置和实例化一个奇怪的机器

242
00:13:23,290 --> 00:13:24,290
overflow.

243
00:13:24,290 --> 00:13:28,730
然后我们用一个ROP链，一组链接的小工具来编程这台奇怪的机器。

244
00:13:28,730 --> 00:13:34,740
由于x86“ret”指令

245
00:13:34,740 --> 00:13:36,620
together with the stack works.

246
00:13:36,620 --> 00:13:43,530
And what we can program is just bound by our creativity and availability of useful gadgets.

247
00:13:43,529 --> 00:13:47,639
但是如果你有大量的小工具，你可以理解你可以实现

248
00:13:47,639 --> 00:13:49,149
ANYTHING you want.

249
00:13:49,149 --> 00:13:53,579
You just chain these small assembler snippets together to build anything.

250
00:13:53,579 --> 00:13:58,209
在一次攻击中，你通常试图创建一个远程外壳或其他东西，但实际上它可以

251
00:13:58,209 --> 00:13:59,939
be just a regular program.

252
00:13:59,940 --> 00:14:04,650
就像我创建了这些ROP链，例如将两个数字作为输入，

253
00:14:04,649 --> 00:14:06,619
adds them together, and prints the result.

254
00:14:06,620 --> 00:14:07,620
And that’s it.

255
00:14:07,620 --> 00:14:11,640
That is return oriented programming explained in a super confused way.

256
00:14:11,639 --> 00:14:14,849
I know, this is maybe not the best ROP tutorial.

257
00:14:14,850 --> 00:14:19,590
但是有太多的“普通”教程，我只是想尝试一些不同的东西

258
00:14:19,589 --> 00:14:24,459
我希望你们中的一些人在这个问题上有不同的观点

259
00:14:24,459 --> 00:14:25,459
opening.

260
00:14:25,459 --> 00:14:30,839
至少对我来说，这是一个令人难忘和美丽的时刻，正如你所知道的，它成为了一个口号。

261
00:14:30,839 --> 00:14:32,609
for my channel.

262
00:14:32,610 --> 00:14:37,010
Also I like to remind you to checkout the papers and talks I have listed in the description.

263
00:14:37,009 --> 00:14:39,579
Please read them even if you didn’t understand this video.

264
00:14:39,579 --> 00:14:44,459
它们也许更好，但更准确地解释了这一奇怪机器的概念。

265
00:14:44,459 --> 00:14:46,129
and exploit development.

266
00:14:46,130 --> 00:14:50,250
Anyway… thanks for watching and maybe checkout my Patreon and YouTube membership in the description.

