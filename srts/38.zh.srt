1
00:00:00,149 --> 00:00:06,409
上周的视频是关于重新访问上的剥削练习/Protostar的0级格式。

2
00:00:06,410 --> 00:00:08,370
a modern ubuntu system.

3
00:00:08,370 --> 00:00:12,790
我们玩弄它，看是否能找到利用它的方法，但是

4
00:00:12,789 --> 00:00:15,329
the end I wasn’t able to solve it.

5
00:00:15,329 --> 00:00:22,139
但对我来说幸运的是，一个名为wcbowling on reddit的用户认为它也很有趣，实际上

6
00:00:22,140 --> 00:00:24,660
had a method to exploit it.

7
00:00:24,660 --> 00:00:32,630
So let’s have a look at it.

8
00:00:32,630 --> 00:00:35,450
这是wcbowlings post：

9
00:00:35,450 --> 00:00:40,250
我喜欢回到像这样的老挑战中去：）设法得到了相当可靠的利用，

10
00:00:40,250 --> 00:00:43,320
normally under 500 iterations.

11
00:00:43,320 --> 00:00:46,750
对它的工作方式有一个更高层次的描述：

12
00:00:46,750 --> 00:00:52,550
Overwrite the GOT entry for __stack_chk_fail with an address so we jump there instead.

13
00:00:52,550 --> 00:00:59,390
地址可以通过argv传入，不能使用空值，但可以使用空字符串

14
00:00:59,390 --> 00:01:00,930
instead.

15
00:01:00,930 --> 00:01:07,050
由于argv的位置是半随机的，它需要大约500次迭代，这是非常合理的

16
00:01:07,050 --> 00:01:09,440
64位

17
00:01:09,440 --> 00:01:14,740
所以很明显我没有弄明白，这意味着我不知道什么

18
00:01:14,740 --> 00:01:17,480
and here is a learning opportunity for me.

19
00:01:17,480 --> 00:01:19,590
So I’m not going to pretend I knew this.

20
00:01:19,590 --> 00:01:25,300
For whatever reason I never noticed that __stack_chk_fail is in the global offset table.

21
00:01:25,300 --> 00:01:31,620
原因可能是，我从未遇到过有这些限制的挑战？

22
00:01:31,620 --> 00:01:37,810
我们有a）一个格式字符串漏洞，通常允许我们在任何地方写任何东西b）

23
00:01:37,810 --> 00:01:42,830
在格式字符串vuln之后没有libc函数，我们可以在全局偏移量中覆盖它

24
00:01:42,830 --> 00:01:47,000
表和c）其中还存在缓冲区溢出

25
00:01:47,000 --> 00:01:49,540
with a stack cookie.

26
00:01:49,540 --> 00:01:54,320
So I really like this challenge now, because the solution is so clever.

27
00:01:54,320 --> 00:01:57,680
因此，当堆栈cookie通过

28
00:01:57,680 --> 00:02:01,100
buffer overflow is also on the global offset table.

29
00:02:01,100 --> 00:02:07,130
这意味着我们的目标是通过覆盖got将代码执行重定向到获胜消息。

30
00:02:07,130 --> 00:02:08,970
entry for __stack_chk_fail.

31
00:02:08,970 --> 00:02:13,110
And then do a buffer overflow, to trigger that function.

32
00:02:13,109 --> 00:02:17,649
要写入全局偏移表条目，我们必须将地址放在

33
00:02:17,650 --> 00:02:22,700
the stack, so that we can use %n with the format string vulnerability.

34
00:02:22,700 --> 00:02:29,840
And the issue is that it contains nullbytes which we can’t pass in via the arguments.

35
00:02:29,840 --> 00:02:34,030
我认为这些参数是字符串复制到堆栈上的？

36
00:02:34,030 --> 00:02:36,400
So we can’t enter arbitrary nullbytes.

37
00:02:36,400 --> 00:02:42,380
But wcbowling had a cool trick with empty strings as arguments.

38
00:02:42,379 --> 00:02:47,579
Because a string ends with a nullbyte, so an empty string is just null.

39
00:02:47,580 --> 00:02:52,100
我想我有一个超早期的视频来讨论环境和争论

40
00:02:52,099 --> 00:02:58,189
堆栈，但快速回顾一下，您有argv[]char指针数组，所以它是一个带有

41
00:02:58,189 --> 00:03:00,819
addresses that point to the strings.

42
00:03:00,819 --> 00:03:03,349
And then you just have memory with all the strings.

43
00:03:03,349 --> 00:03:08,729
And so this way you can get the address with null-bytes on to the stack.

44
00:03:08,730 --> 00:03:11,610
Pretty clever, I never thought about this before.

45
00:03:11,609 --> 00:03:15,639
And now you basically just have to put everything together.

46
00:03:15,639 --> 00:03:20,349
wcbowling使用pwnlib来实现这个漏洞，它是一个非常有用的python库，检查

47
00:03:20,349 --> 00:03:21,519
it out.

48
00:03:21,519 --> 00:03:26,919
所以这里的magic格式字符串是用一个大的偏移量构建在堆栈中的，希望

49
00:03:26,919 --> 00:03:30,649
hits the addresses passed in via the arguments.

50
00:03:30,650 --> 00:03:33,980
And so there are two single byte writes.

51
00:03:33,980 --> 00:03:36,270
为什么只写两个字节？

52
00:03:36,269 --> 00:03:41,549
好吧，got已经包含了一个几乎是目标地址的地址，除了最后一个

53
00:03:41,549 --> 00:03:42,549
two bytes.

54
00:03:42,549 --> 00:03:45,839
So you can just reuse most of it.

55
00:03:45,840 --> 00:03:50,610
Then this is being executed in a loop until the winning message is shown.

56
00:03:50,610 --> 00:03:55,430
The stack has some randomized offsets, thus you have to try it a few times.

57
00:03:55,430 --> 00:03:57,880
Here is the asciicinema recording by wcbowling.

58
00:03:57,879 --> 00:04:03,259
顺便说一下，如果你对挑战有问题，你给我写封电子邮件，你可以用它

59
00:04:03,260 --> 00:04:09,170
to record a screencast so I can actually see how you debug it and what the problem is.

60
00:04:09,169 --> 00:04:14,459
So while I understand now the basic idea, I still wanted to implement it myself.

61
00:04:14,459 --> 00:04:20,329
您必须解决一些挑战，例如，什么是良好的堆栈偏移

62
00:04:20,329 --> 00:04:25,879
to hit the arguments, and the alignment of the address through the arguments.

63
00:04:25,879 --> 00:04:31,909
And while I was doing that and struggling with exactly those details, I had an epiphany.

64
00:04:31,910 --> 00:04:37,630
我很快就感激WCbowling分享了这一成果，因为它促使我发现

65
00:04:37,629 --> 00:04:38,749
this.

66
00:04:38,750 --> 00:04:44,050
所以我发现了一个100%可靠的利用这个挑战，你不能相信

67
00:04:44,050 --> 00:04:46,160
how excited that makes me.

68
00:04:46,159 --> 00:04:50,739
尽管我不得不承认，它可能只对我编译的二进制文件有效，对某些人也有效。

69
00:04:50,740 --> 00:04:54,660
else it might not work, you will see in a second why.

70
00:04:54,660 --> 00:04:55,990
So here it is.

71
00:04:55,990 --> 00:04:56,990
That’s all.

72
00:04:56,990 --> 00:05:02,570
And when we execute it, you can see it gets into an execution loop of the winning message.

73
00:05:02,569 --> 00:05:07,609
虽然它看起来像一个简单的格式字符串漏洞，但填充会增加

74
00:05:07,610 --> 00:05:14,140
打印字符数、地址和写入地址的%n或%hn

75
00:05:14,139 --> 00:05:17,559
are quite a few beautiful puzzle pieces here.

76
00:05:17,560 --> 00:05:22,810
所以，当我在玩重写got条目

77
00:05:22,810 --> 00:05:24,060
__stack_check_fail.

78
00:05:24,060 --> 00:05:30,050
wcbowling had two writes and placed the address in the arguments, which made it so unreliable.

79
00:05:30,050 --> 00:05:36,330
我想，如果我们把地址放在字符串中，就像我在字符串中那样，也许我们会幸运的。

80
00:05:36,330 --> 00:05:37,870
the last video.

81
00:05:37,870 --> 00:05:40,030
But there is one problem.

82
00:05:40,030 --> 00:05:45,330
打印的字符串来自参数，参数具有不可预测的

83
00:05:45,330 --> 00:05:46,520
position.

84
00:05:46,520 --> 00:05:51,240
但是字符串是用sprintf格式化为缓冲区的，缓冲区将具有固定的相对值

85
00:05:51,240 --> 00:05:52,920
position on our stack.

86
00:05:52,919 --> 00:06:00,359
所以基本上格式字符串将被计算，所以首先它用1640字符处理%d

87
00:06:00,360 --> 00:06:03,290
padding and places it into the buffer.

88
00:06:03,289 --> 00:06:07,259
Then comes the raw bytes of the address, and places it.

89
00:06:07,259 --> 00:06:11,459
And then comes the format modifier to write to an address on the stack.

90
00:06:11,460 --> 00:06:17,300
所以现在这个地址的位置，刚刚写入缓冲区，是在一个固定的

91
00:06:17,300 --> 00:06:21,140
偏移位置，我们总是用
214.

92
00:06:21,139 --> 00:06:27,009
Though the problem is, we can’t have an arbitrary amount of bytes padding.

93
00:06:27,010 --> 00:06:29,710
Because the address has to be 8byte alligned.

94
00:06:29,710 --> 00:06:35,100
So we can only increase or decrease the padding in 8 byte steps.

95
00:06:35,099 --> 00:06:37,699
Which affects the amounts of bytes we can write.

96
00:06:37,699 --> 00:06:38,699
With %n.

97
00:06:38,699 --> 00:06:42,389
It’s always in these 8 steps.

98
00:06:42,389 --> 00:06:48,499
所以我们没有写任何东西的条件，但是我们可以写一些接近wilining的东西。

99
00:06:48,500 --> 00:06:49,500
address.

100
00:06:49,500 --> 00:06:51,180
Now there are two challenges.

101
00:06:51,180 --> 00:06:57,010
首先，堆栈相当小，格式化结果被写入

102
00:06:57,009 --> 00:07:03,669
堆栈，所以如果我们使用太多的填充来用%n写一个大的数字，那么堆栈就用完了

103
00:07:03,669 --> 00:07:05,709
memory and get a segfault.

104
00:07:05,710 --> 00:07:12,130
但wcbowling的技巧让我意识到，事实上我们可以增加

105
00:07:12,129 --> 00:07:14,869
stack by just using more arguments.

106
00:07:14,870 --> 00:07:19,400
It will add entries to the argv array and increase it.

107
00:07:19,400 --> 00:07:25,570
第二个问题是，地址只写3个字节，所以如果

108
00:07:25,569 --> 00:07:29,409
on the stack had other values in it, it won’t work.

109
00:07:29,409 --> 00:07:34,519
我们需要把地址写在一个零的堆栈上，或者通常是一个小的堆栈上。

110
00:07:34,520 --> 00:07:36,410
number before.

111
00:07:36,410 --> 00:07:41,110
这也是论点再次帮助我们的地方，因为我们可以整理堆栈，

112
00:07:41,110 --> 00:07:47,330
通过在argv数组中添加或删除条目，使堆栈足够大，并且我们

113
00:07:47,330 --> 00:07:49,660
have a zero at the correct spot.

114
00:07:49,659 --> 00:07:52,519
&lt；grunt&gt；我喜欢它！

115
00:07:52,520 --> 00:07:57,810
所以现在我们知道了如何整理堆栈以写入got条目，但是我们仍然有这个问题

116
00:07:57,810 --> 00:08:03,010
that we are not sure what to write because of our multiples of 8 restrictions.

117
00:08:03,009 --> 00:08:08,179
我编写了一个简单的python函数，它用不同的

118
00:08:08,180 --> 00:08:12,700
paddings and adjusts the amount of arguments and the write offset accordingly.

119
00:08:12,699 --> 00:08:17,399
And I started by looking around the printing of the winning message.

120
00:08:17,400 --> 00:08:24,500
所以理想情况下我们想写0x670，那是1648，但是由于我们的对齐限制

121
00:08:24,499 --> 00:08:25,899
that doesn’t work.

122
00:08:25,900 --> 00:08:31,740
Anyway, I was then just trying them, to see if anything interesting would come from it.

123
00:08:31,740 --> 00:08:34,760
And luckily this one worked.

124
00:08:34,760 --> 00:08:40,460
让我用gdb调试它，在sprintf之后，在检查堆栈之前设置一个断点。

125
00:08:40,460 --> 00:08:41,460
cookie.

126
00:08:41,460 --> 00:08:43,530
Let’s look at the stack.

127
00:08:43,530 --> 00:08:49,210
这是用空格填充的%d个字符，用来打印我们想要的字符数。

128
00:08:49,210 --> 00:08:50,660
write to.

129
00:08:50,660 --> 00:08:54,480
And then here at the end is the target address we want to write to.

130
00:08:54,480 --> 00:08:56,250
The GOT address.

131
00:08:56,250 --> 00:09:00,170
We can also look now what value has been written there.

132
00:09:00,170 --> 00:09:03,550
So we will jump to 0x40066b.

133
00:09:03,550 --> 00:09:08,450
Let’s look at the disassembly and see where that would be.

134
00:09:08,450 --> 00:09:09,450
66b.

135
00:09:09,450 --> 00:09:11,280
嗯…等等！

136
00:09:11,280 --> 00:09:14,620
地址无效，对吗？

137
00:09:14,620 --> 00:09:17,760
It’s in between the compare and the jump-not-equal.

138
00:09:17,760 --> 00:09:25,180
Let’s use x to print 3 instructions, instead of the disassemble command.

139
00:09:25,180 --> 00:09:26,240
Do you see that.

140
00:09:26,240 --> 00:09:29,650
WTF现在有移动，而不是CMP？

141
00:09:29,650 --> 00:09:31,440
搞什么鬼？

142
00:09:31,440 --> 00:09:34,850
Welcome to intel assembler and more advanced ROP.

143
00:09:34,850 --> 00:09:39,980
这种性质被称为英特尔汇编程序的几何，在著名的ROP论文中，

144
00:09:39,980 --> 00:09:42,280
but never heard anybody using that term.

145
00:09:42,280 --> 00:09:48,770
总之，我们在预期指令的字节之间跳转，CPU是哑的，

146
00:09:48,770 --> 00:09:52,090
it will just read those bytes and interpret them as assembler.

147
00:09:52,090 --> 00:09:59,900
And so in this case, the cmp and jne turned into two simple moves.

148
00:09:59,900 --> 00:10:06,010
这就是说，现在没有空头支票了，我们就跑到印刷品上印上了胜利的字样。

149
00:10:06,010 --> 00:10:07,850
message.

150
00:10:07,850 --> 00:10:13,250
当我们现在单步前进时，我们进入程序链接表进行堆栈检查失败，

151
00:10:13,250 --> 00:10:19,390
我们跳到got条目，这是我们在vuln中的奇怪地址，我们执行mov，并且

152
00:10:19,390 --> 00:10:22,440
then we call puts to print the message.

