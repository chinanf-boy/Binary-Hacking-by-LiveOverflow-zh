1
00:00:00,149 --> 00:00:06,409
上周的视频是关于重新访问格式的利用练习的0级/Protostar on

2
00:00:06,410 --> 00:00:08,370
现代Ubuntu系统。

3
00:00:08,370 --> 00:00:12,790
我们玩弄它看看可以找到利用它的方法，但是

4
00:00:12,789 --> 00:00:15,329
结果我没能解决。

5
00:00:15,329 --> 00:00:22,139
但对我来说幸运的是一个名为wcbowling的用户Reddit认为这也很有趣，事实上

6
00:00:22,140 --> 00:00:24,660
有办法利用它。

7
00:00:24,660 --> 00:00:32,630
我们来看看。

8
00:00:32,630 --> 00:00:35,450
下面是wcbowlings post：

9
00:00:35,450 --> 00:00:40,250
我喜欢回到像这样被挑战的老地方：）设法获得了相当可靠的利用，

10
00:00:40,250 --> 00:00:43,320
通常在500次迭代下。

11
00:00:43,320 --> 00:00:46,750
还有一个关于如何它的工作原理是：

12
00:00:46,750 --> 00:00:52,550
覆盖\堆栈\ chk \失败的获取项有地址，所以我们跳过去。

13
00:00:52,550 --> 00:00:59,390
地址可以通过argv传入，我们不能使用空值，但可以使用空字符串

14
00:00:59,390 --> 00:01:00,930
相反。

15
00:01:00,930 --> 00:01:07,050
由于argv位置是半随机的，因此需要大约500次迭代，这是相当合理的

16
00:01:07,050 --> 00:01:09,440
64位

17
00:01:09,440 --> 00:01:14,740
所以很明显我没想到出去，这意味着我什么都不知道

18
00:01:14,740 --> 00:01:17,480
这是我学习的机会。

19
00:01:17,480 --> 00:01:19,590
所以我不会假装我知道这些。

20
00:01:19,590 --> 00:01:25,300
无论出于什么原因，我从来没有注意到uu stack chk fail在全局偏移量表中。

21
00:01:25,300 --> 00:01:31,620
原因可能是，我从来没有遇到这些限制的挑战？

22
00:01:31,620 --> 00:01:37,810
我们有一个）格式字符串漏洞允许我们在任何地方写任何东西b）

23
00:01:37,810 --> 00:01:42,830
格式字符串vuln之后没有libc函数我们可以在全局偏移中覆盖

24
00:01:42,830 --> 00:01:47,000
桌子c）我们还有一个缓冲区溢出

25
00:01:47,000 --> 00:01:49,540
用一堆饼干。

26
00:01:49,540 --> 00:01:54,320
所以我现在真的很喜欢这个挑战，因为解决方案是如此巧妙。

27
00:01:54,320 --> 00:01:57,680
所以当堆栈cookie通过

28
00:01:57,680 --> 00:02:01,100
缓冲区溢出也在全局偏移量上表。

29
00:02:01,100 --> 00:02:07,130
这意味着我们的目标是重定向代码执行通过覆盖got

30
00:02:07,130 --> 00:02:08,970
_uuu stack_chk_的条目失败。

31
00:02:08,970 --> 00:02:13,110
然后执行缓冲区溢出，以触发那个函数。

32
00:02:13,109 --> 00:02:17,649
要写入该全局偏移表条目，我们得把地址弄到某个地方

33
00:02:17,650 --> 00:02:22,700
堆栈，以便我们可以将%n与格式字符串漏洞。

34
00:02:22,700 --> 00:02:29,840
问题是它包含空字节我们不能通过参数传递。

35
00:02:29,840 --> 00:02:34,030
我认为这些参数是字符串复制到堆栈？

36
00:02:34,030 --> 00:02:36,400
所以我们不能输入任意的空字节。

37
00:02:36,400 --> 00:02:42,380
但是wccolling有一个很酷的空球技巧字符串作为参数。

38
00:02:42,379 --> 00:02:47,579
因为字符串以空字节结尾，所以空字符串仅为空。

39
00:02:47,580 --> 00:02:52,100
我想我有一个超早期的视频要讲关于环境和关于

40
00:02:52,099 --> 00:02:58,189
叠加，但快速回顾，你有argv[]char指针数组，所以它是一个带有

41
00:02:58,189 --> 00:03:00,819
指向字符串的地址。

42
00:03:00,819 --> 00:03:03,349
然后你就有了记忆串。

43
00:03:03,349 --> 00:03:08,729
这样你就可以得到地址堆栈上有空字节。

44
00:03:08,730 --> 00:03:11,610
很聪明，我从没想过这个以前。

45
00:03:11,609 --> 00:03:15,639
现在你基本上只需要把一切一起。

46
00:03:15,639 --> 00:03:20,349
wcBowling使用pwnlib来实现该漏洞，这是一个非常有用的python库，检查

47
00:03:20,349 --> 00:03:21,519
它出来了。

48
00:03:21,519 --> 00:03:26,919
因此，这里构建了magic格式字符串在堆栈中有很大的偏移，希望

49
00:03:26,919 --> 00:03:30,649
点击通过参数传入的地址。

50
00:03:30,650 --> 00:03:33,980
所以有两个单字节的写入。

51
00:03:33,980 --> 00:03:36,270
为什么只写两个字节？

52
00:03:36,269 --> 00:03:41,549
好吧，got已经包含了一个地址几乎是目标地址，除了最后一个

53
00:03:41,549 --> 00:03:42,549
两个字节。

54
00:03:42,549 --> 00:03:45,839
所以你可以重新使用它的大部分。

55
00:03:45,840 --> 00:03:50,610
然后在循环中执行，直到显示获胜消息。

56
00:03:50,610 --> 00:03:55,430
堆栈有一些随机偏移，因此你必须试几次。

57
00:03:55,430 --> 00:03:57,880
这是wcbowling的电影录音。

58
00:03:57,879 --> 00:04:03,259
顺便说一下，如果你对挑战有问题的话你给我写封电子邮件，你可以用它

59
00:04:03,260 --> 00:04:09,170
录制一个屏幕放映，这样我才能真正看到如何调试它以及问题是什么。

60
00:04:09,169 --> 00:04:14,459
所以当我现在明白了基本的想法，我仍然想自己去实现它。

61
00:04:14,459 --> 00:04:20,329
你必须面对一些挑战解决方法是，什么是好的偏移到堆栈中

62
00:04:20,329 --> 00:04:25,879
去打击争论，和通过参数的地址。

63
00:04:25,879 --> 00:04:31,909
当我这样做和挣扎的时候有了这些细节，我顿悟了。

64
00:04:31,910 --> 00:04:37,630
我很高兴能和你一起打保龄球因为它促使我发现

65
00:04:37,629 --> 00:04:38,749
这个。

66
00:04:38,750 --> 00:04:44,050
所以我发现了一个100%可靠的漏洞你不能相信

67
00:04:44,050 --> 00:04:46,160
这让我多么兴奋。

68
00:04:46,159 --> 00:04:50,739
尽管我不得不承认，这可能只是为我编译的二进制文件工作

69
00:04:50,740 --> 00:04:54,660
否则可能不起作用，您将在第二，为什么？

70
00:04:54,660 --> 00:04:55,990
就在这里。

71
00:04:55,990 --> 00:04:56,990
仅此而已。

72
00:04:56,990 --> 00:05:02,570
当我们执行它时，你可以看到它进入获胜消息的执行循环。

73
00:05:02,569 --> 00:05:07,609
虽然它看起来像一个简单的格式字符串填充增加的漏洞

74
00:05:07,610 --> 00:05:14,140
打印字符的数量，地址还有一个%n或%hn写到一个地址，那里

75
00:05:14,139 --> 00:05:17,559
这里有很多漂亮的拼图块。

76
00:05:17,560 --> 00:05:22,810
所以当我玩的时候，基本的想法就出现了重写got条目

77
00:05:22,810 --> 00:05:24,060
_堆栈检查失败。

78
00:05:24,060 --> 00:05:30,050
wcbowling写了两个字，并把地址在争论中，这使得它如此不可靠。

79
00:05:30,050 --> 00:05:36,330
我想，如果我们能把地址输入我们的字符串，就像我在

80
00:05:36,330 --> 00:05:37,870
最后一段视频。

81
00:05:37,870 --> 00:05:40,030
但有一个问题。

82
00:05:40,030 --> 00:05:45,330
打印的字符串来自参数，它有一个不可预测的

83
00:05:45,330 --> 00:05:46,520
位置。

84
00:05:46,520 --> 00:05:51,240
但字符串是用sprintf格式化为具有固定相对值的缓冲区

85
00:05:51,240 --> 00:05:52,920
在我们的堆栈上的位置。

86
00:05:52,919 --> 00:06:00,359
所以基本上格式字符串将被计算，所以首先它用1640字符处理%d

87
00:06:00,360 --> 00:06:03,290
填充并将其放入缓冲区。

88
00:06:03,289 --> 00:06:07,259
然后是地址的原始字节，以及放置它。

89
00:06:07,259 --> 00:06:11,459
然后格式修饰符来写到堆栈上的地址。

90
00:06:11,460 --> 00:06:17,300
所以现在这个地址的位置刚刚写入缓冲区的

91
00:06:17,300 --> 00:06:21,140
偏移位置，我们总是用
214.

92
00:06:21,139 --> 00:06:27,009
尽管问题是，我们不能任意字节填充量。

93
00:06:27,010 --> 00:06:29,710
因为地址必须是8字节的联合签名。

94
00:06:29,710 --> 00:06:35,100
所以我们只能增加或减少填充8字节步进。

95
00:06:35,099 --> 00:06:37,699
这会影响我们可以写。

96
00:06:37,699 --> 00:06:38,699
使用%N。

97
00:06:38,699 --> 00:06:42,389
它总是在这8个步骤。

98
00:06:42,389 --> 00:06:48,499
所以我们没有写任何条件，但我们可以写一些接近线绳的东西

99
00:06:48,500 --> 00:06:49,500
地址。

100
00:06:49,500 --> 00:06:51,180
现在有两个挑战。

101
00:06:51,180 --> 00:06:57,010
首先，堆栈相当小，格式结果写入缓冲区

102
00:06:57,009 --> 00:07:03,669
堆栈，所以如果我们使用了太多的填充来写入一个有%n的大数字，堆栈用完了

103
00:07:03,669 --> 00:07:05,709
记忆并得到一个SEGAULT。

104
00:07:05,710 --> 00:07:12,130
但是wcbowling的技巧让我意识到，我们实际上可以增加

105
00:07:12,129 --> 00:07:14,869
通过使用更多参数进行叠加。

106
00:07:14,870 --> 00:07:19,400
它将向argv数组添加条目，并增加它。

107
00:07:19,400 --> 00:07:25,570
第二个问题是，地址是只写3个字节，所以如果

108
00:07:25,569 --> 00:07:29,409
堆栈中有其他值，但不会工作。

109
00:07:29,409 --> 00:07:34,519
我们需要把地址写在堆栈上如果是零，或者通常是小的

110
00:07:34,520 --> 00:07:36,410
以前的号码。

111
00:07:36,410 --> 00:07:41,110
这也是参数有帮助的地方我们又来了，因为我们可以整理这堆东西，

112
00:07:41,110 --> 00:07:47,330
通过在argv数组中添加或删除条目，这样堆就足够大了，我们

113
00:07:47,330 --> 00:07:49,660
在正确的位置有一个零。

114
00:07:49,659 --> 00:07:52,519
&lt；grunt&gt；我喜欢它！

115
00:07:52,520 --> 00:07:57,810
所以现在我们知道了如何整理堆栈来编写但我们仍然有问题

116
00:07:57,810 --> 00:08:03,010
我们不知道写什么，因为我们的8倍限制。

117
00:08:03,009 --> 00:08:08,179
我编写了一个简单的python函数，我有效利用不同的参数

118
00:08:08,180 --> 00:08:12,700
填充并调整参数的数量以及相应的写偏移量。

119
00:08:12,699 --> 00:08:17,399
我先看看印刷品赢的消息。

120
00:08:17,400 --> 00:08:24,500
所以理想情况下我们要写0x670，这是1648年，但由于我们的路线限制

121
00:08:24,499 --> 00:08:25,899
那不管用。

122
00:08:25,900 --> 00:08:31,740
不管怎样，当时我只是想试试看如果有什么有趣的事情能从中得到的话。

123
00:08:31,740 --> 00:08:34,760
幸运的是，这一个成功了。

124
00:08:34,760 --> 00:08:40,460
让我用gdb调试这个，我设置一个断点在sprintf之后，在我们检查堆栈之前

125
00:08:40,460 --> 00:08:41,460
饼干。

126
00:08:41,460 --> 00:08:43,530
让我们看看这个堆栈。

127
00:08:43,530 --> 00:08:49,210
这是用空格填充的%d，to打印要打印的字符数

128
00:08:49,210 --> 00:08:50,660
写信给某人。

129
00:08:50,660 --> 00:08:54,480
最后是目标地址我们要写信给。

130
00:08:54,480 --> 00:08:56,250
得到的地址。

131
00:08:56,250 --> 00:09:00,170
我们现在也可以看看写了什么值那里。

132
00:09:00,170 --> 00:09:03,550
所以我们将跳转到0x40066B。

133
00:09:03,550 --> 00:09:08,450
让我们看一下分解图，看看在哪里那就是。

134
00:09:08,450 --> 00:09:09,450
66 B。

135
00:09:09,450 --> 00:09:11,280
嗯…等等！

136
00:09:11,280 --> 00:09:14,620
地址无效，对吗？

137
00:09:14,620 --> 00:09:17,760
它在比较和跳跃之间不相等。

138
00:09:17,760 --> 00:09:25,180
我们用x来打印3条指令反汇编命令。

139
00:09:25,180 --> 00:09:26,240
你看到了吗？

140
00:09:26,240 --> 00:09:29,650
WTF现在有移动，而不是CMP？

141
00:09:29,650 --> 00:09:31,440
搞什么鬼？

142
00:09:31,440 --> 00:09:34,850
欢迎使用Intel汇编程序和更高级的ROP。

143
00:09:34,850 --> 00:09:39,980
这种性质被称为几何在著名的ROP论文中，

144
00:09:39,980 --> 00:09:42,280
但从未听人用过这个词。

145
00:09:42,280 --> 00:09:48,770
总之，我们在预期指令，CPU是哑的，

146
00:09:48,770 --> 00:09:52,090
它只读取这些字节并解释他们是装配工。

147
00:09:52,090 --> 00:09:59,900
在这种情况下，CMP和JNE分成两个简单的动作。

148
00:09:59,900 --> 00:10:06,010
也就是说，现在没有空头支票了我们在印刷品上看到了胜利的图案

149
00:10:06,010 --> 00:10:07,850
消息。

150
00:10:07,850 --> 00:10:13,250
当我们向前迈出一步时，我们就进入了堆栈检查失败的过程链接表，

151
00:10:13,250 --> 00:10:19,390
我们跳到入口，这很奇怪地址输入vuln，我们执行mov，并且

152
00:10:19,390 --> 00:10:22,440
然后我们调用Puts来打印消息。

