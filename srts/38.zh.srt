1
00:00:00,149 --> 00:00:06,409
上周的视频是关于重新访问上的剥削练习/Protostar的0级格式。

2
00:00:06,410 --> 00:00:08,370
现代Ubuntu系统。

3
00:00:08,370 --> 00:00:12,790
我们玩弄它，看是否能找到利用它的方法，但是

4
00:00:12,789 --> 00:00:15,329
结果我没能解决。

5
00:00:15,329 --> 00:00:22,139
但对我来说幸运的是，一个名为wcbowling on reddit的用户认为它也很有趣，实际上

6
00:00:22,140 --> 00:00:24,660
有办法利用它。

7
00:00:24,660 --> 00:00:32,630
我们来看看。

8
00:00:32,630 --> 00:00:35,450
下面是wcbowlings post：

9
00:00:35,450 --> 00:00:40,250
我喜欢回到像这样的老挑战中去：）设法得到了相当可靠的利用，

10
00:00:40,250 --> 00:00:43,320
通常在500次迭代下。

11
00:00:43,320 --> 00:00:46,750
对它的工作方式有一个更高层次的描述：

12
00:00:46,750 --> 00:00:52,550
用地址覆盖\堆栈\的got项失败，因此我们跳到那里。

13
00:00:52,550 --> 00:00:59,390
地址可以通过argv传入，不能使用空值，但可以使用空字符串

14
00:00:59,390 --> 00:01:00,930
相反。

15
00:01:00,930 --> 00:01:07,050
由于argv的位置是半随机的，它需要大约500次迭代，这是非常合理的

16
00:01:07,050 --> 00:01:09,440
64位

17
00:01:09,440 --> 00:01:14,740
所以很明显我没有弄明白，这意味着我不知道什么

18
00:01:14,740 --> 00:01:17,480
这是我学习的机会。

19
00:01:17,480 --> 00:01:19,590
所以我不会假装我知道这些。

20
00:01:19,590 --> 00:01:25,300
无论出于什么原因，我从未注意到uu stack_chk_fail在全局偏移表中。

21
00:01:25,300 --> 00:01:31,620
原因可能是，我从未遇到过有这些限制的挑战？

22
00:01:31,620 --> 00:01:37,810
我们有a）一个格式字符串漏洞，通常允许我们在任何地方写任何东西b）

23
00:01:37,810 --> 00:01:42,830
在格式字符串vuln之后没有libc函数，我们可以在全局偏移量中覆盖它

24
00:01:42,830 --> 00:01:47,000
表和c）其中还存在缓冲区溢出

25
00:01:47,000 --> 00:01:49,540
用一堆饼干。

26
00:01:49,540 --> 00:01:54,320
所以我现在真的很喜欢这个挑战，因为这个解决方案很聪明。

27
00:01:54,320 --> 00:01:57,680
因此，当堆栈cookie通过

28
00:01:57,680 --> 00:02:01,100
缓冲区溢出也在全局偏移表上。

29
00:02:01,100 --> 00:02:07,130
这意味着我们的目标是通过覆盖got将代码执行重定向到获胜消息。

30
00:02:07,130 --> 00:02:08,970
_uuu stack_chk_的条目失败。

31
00:02:08,970 --> 00:02:13,110
然后执行缓冲区溢出，以触发该函数。

32
00:02:13,109 --> 00:02:17,649
要写入全局偏移表条目，我们必须将地址放在

33
00:02:17,650 --> 00:02:22,700
堆栈，以便我们可以将%n与格式字符串漏洞一起使用。

34
00:02:22,700 --> 00:02:29,840
问题是它包含nullbytes，我们不能通过参数传递。

35
00:02:29,840 --> 00:02:34,030
我认为这些参数是字符串复制到堆栈上的？

36
00:02:34,030 --> 00:02:36,400
所以我们不能输入任意的空字节。

37
00:02:36,400 --> 00:02:42,380
但是wcpowling有一个很酷的技巧，用空字符串作为参数。

38
00:02:42,379 --> 00:02:47,579
因为字符串以空字节结尾，所以空字符串只是空字符串。

39
00:02:47,580 --> 00:02:52,100
我想我有一个超早期的视频来讨论环境和争论

40
00:02:52,099 --> 00:02:58,189
堆栈，但快速回顾一下，您有argv[]char指针数组，所以它是一个带有

41
00:02:58,189 --> 00:03:00,819
指向字符串的地址。

42
00:03:00,819 --> 00:03:03,349
然后你就有了所有字符串的内存。

43
00:03:03,349 --> 00:03:08,729
这样就可以把空字节的地址放到堆栈上。

44
00:03:08,730 --> 00:03:11,610
很聪明，我以前从没想过这个。

45
00:03:11,609 --> 00:03:15,639
现在你基本上要把所有的东西都放在一起。

46
00:03:15,639 --> 00:03:20,349
wcbowling使用pwnlib来实现这个漏洞，它是一个非常有用的python库，检查

47
00:03:20,349 --> 00:03:21,519
它出来了。

48
00:03:21,519 --> 00:03:26,919
所以这里的magic格式字符串是用一个大的偏移量构建在堆栈中的，希望

49
00:03:26,919 --> 00:03:30,649
点击通过参数传入的地址。

50
00:03:30,650 --> 00:03:33,980
所以有两个单字节的写入。

51
00:03:33,980 --> 00:03:36,270
为什么只写两个字节？

52
00:03:36,269 --> 00:03:41,549
好吧，got已经包含了一个几乎是目标地址的地址，除了最后一个

53
00:03:41,549 --> 00:03:42,549
两个字节。

54
00:03:42,549 --> 00:03:45,839
所以你可以重新使用它的大部分。

55
00:03:45,840 --> 00:03:50,610
然后循环执行，直到显示获胜消息。

56
00:03:50,610 --> 00:03:55,430
堆栈有一些随机偏移，因此您必须尝试几次。

57
00:03:55,430 --> 00:03:57,880
这是wcbowling的电影录音。

58
00:03:57,879 --> 00:04:03,259
顺便说一下，如果你对挑战有问题，你给我写封电子邮件，你可以用它

59
00:04:03,260 --> 00:04:09,170
录制一个屏幕广播，这样我就可以看到您如何调试它以及问题是什么。

60
00:04:09,169 --> 00:04:14,459
所以，虽然我现在了解了这个基本概念，但我仍然想自己去实现它。

61
00:04:14,459 --> 00:04:20,329
您必须解决一些挑战，例如，什么是良好的堆栈偏移

62
00:04:20,329 --> 00:04:25,879
点击参数，并通过参数调整地址。

63
00:04:25,879 --> 00:04:31,909
当我在做这件事，并与这些细节斗争时，我有了一个顿悟。

64
00:04:31,910 --> 00:04:37,630
我很快就感激WCbowling分享了这一成果，因为它促使我发现

65
00:04:37,629 --> 00:04:38,749
这个。

66
00:04:38,750 --> 00:04:44,050
所以我发现了一个100%可靠的利用这个挑战，你不能相信

67
00:04:44,050 --> 00:04:46,160
这让我多么兴奋。

68
00:04:46,159 --> 00:04:50,739
尽管我不得不承认，它可能只对我编译的二进制文件有效，对某些人也有效。

69
00:04:50,740 --> 00:04:54,660
否则可能不起作用，你马上就会明白原因。

70
00:04:54,660 --> 00:04:55,990
就在这里。

71
00:04:55,990 --> 00:04:56,990
仅此而已。

72
00:04:56,990 --> 00:05:02,570
当我们执行它时，您可以看到它进入了获胜消息的执行循环。

73
00:05:02,569 --> 00:05:07,609
虽然它看起来像一个简单的格式字符串漏洞，但填充会增加

74
00:05:07,610 --> 00:05:14,140
打印字符数、地址和写入地址的%n或%hn

75
00:05:14,139 --> 00:05:17,559
这里有很多漂亮的拼图。

76
00:05:17,560 --> 00:05:22,810
所以，当我在玩重写got条目

77
00:05:22,810 --> 00:05:24,060
_堆栈检查失败。

78
00:05:24,060 --> 00:05:30,050
wcbowling有两个写操作，并将地址放在参数中，这使得它非常不可靠。

79
00:05:30,050 --> 00:05:36,330
我想，如果我们把地址放在字符串中，就像我在字符串中那样，也许我们会幸运的。

80
00:05:36,330 --> 00:05:37,870
最后一段视频。

81
00:05:37,870 --> 00:05:40,030
但有一个问题。

82
00:05:40,030 --> 00:05:45,330
打印的字符串来自参数，参数具有不可预测的

83
00:05:45,330 --> 00:05:46,520
位置。

84
00:05:46,520 --> 00:05:51,240
但是字符串是用sprintf格式化为缓冲区的，缓冲区将具有固定的相对值

85
00:05:51,240 --> 00:05:52,920
在我们的堆栈上的位置。

86
00:05:52,919 --> 00:06:00,359
所以基本上格式字符串将被计算，所以首先它用1640字符处理%d

87
00:06:00,360 --> 00:06:03,290
填充并将其放入缓冲区。

88
00:06:03,289 --> 00:06:07,259
然后是地址的原始字节，并将其放置。

89
00:06:07,259 --> 00:06:11,459
然后，格式修饰符来写入堆栈上的地址。

90
00:06:11,460 --> 00:06:17,300
所以现在这个地址的位置，刚刚写入缓冲区，是在一个固定的

91
00:06:17,300 --> 00:06:21,140
偏移位置，我们总是用
214。

92
00:06:21,139 --> 00:06:27,009
尽管问题是，我们不能有任意数量的字节填充。

93
00:06:27,010 --> 00:06:29,710
因为地址必须是8字节的联合签名。

94
00:06:29,710 --> 00:06:35,100
所以我们只能在8字节的步骤中增加或减少填充。

95
00:06:35,099 --> 00:06:37,699
这会影响我们可以写入的字节数。

96
00:06:37,699 --> 00:06:38,699
使用%N。

97
00:06:38,699 --> 00:06:42,389
它总是在这8个步骤。

98
00:06:42,389 --> 00:06:48,499
所以我们没有写任何东西的条件，但是我们可以写一些接近wilining的东西。

99
00:06:48,500 --> 00:06:49,500
地址。

100
00:06:49,500 --> 00:06:51,180
现在有两个挑战。

101
00:06:51,180 --> 00:06:57,010
首先，堆栈相当小，格式化结果被写入

102
00:06:57,009 --> 00:07:03,669
堆栈，所以如果我们使用太多的填充来用%n写一个大的数字，那么堆栈就用完了

103
00:07:03,669 --> 00:07:05,709
记忆并得到一个SEGAULT。

104
00:07:05,710 --> 00:07:12,130
但wcbowling的技巧让我意识到，事实上我们可以增加

105
00:07:12,129 --> 00:07:14,869
通过使用更多参数进行叠加。

106
00:07:14,870 --> 00:07:19,400
它将向argv数组添加条目并增加它。

107
00:07:19,400 --> 00:07:25,570
第二个问题是，地址只写3个字节，所以如果

108
00:07:25,569 --> 00:07:29,409
在堆栈中还有其他值，它将不起作用。

109
00:07:29,409 --> 00:07:34,519
我们需要把地址写在一个零的堆栈上，或者通常是一个小的堆栈上。

110
00:07:34,520 --> 00:07:36,410
以前的号码。

111
00:07:36,410 --> 00:07:41,110
这也是参数再次帮助我们的地方，因为我们可以整理堆栈，

112
00:07:41,110 --> 00:07:47,330
通过在argv数组中添加或删除条目，使堆栈足够大，并且我们

113
00:07:47,330 --> 00:07:49,660
在正确的位置有一个零。

114
00:07:49,659 --> 00:07:52,519
&lt；grunt&gt；我喜欢它！

115
00:07:52,520 --> 00:07:57,810
所以现在我们知道了如何整理堆栈以写入got条目，但是我们仍然有这个问题

116
00:07:57,810 --> 00:08:03,010
由于我们的8倍限制，我们不确定要写什么。

117
00:08:03,009 --> 00:08:08,179
我编写了一个简单的python函数，它用不同的

118
00:08:08,180 --> 00:08:12,700
填充并相应地调整参数量和写入偏移量。

119
00:08:12,699 --> 00:08:17,399
我开始四处看看获奖信息的打印。

120
00:08:17,400 --> 00:08:24,500
所以理想情况下我们想写0x670，那是1648，但是由于我们的对齐限制

121
00:08:24,499 --> 00:08:25,899
那不管用。

122
00:08:25,900 --> 00:08:31,740
不管怎样，我当时只是在尝试，看看是否有什么有趣的东西会从中产生。

123
00:08:31,740 --> 00:08:34,760
幸运的是，这一个成功了。

124
00:08:34,760 --> 00:08:40,460
让我用gdb调试它，在sprintf之后，在检查堆栈之前设置一个断点。

125
00:08:40,460 --> 00:08:41,460
饼干。

126
00:08:41,460 --> 00:08:43,530
让我们看看这个堆栈。

127
00:08:43,530 --> 00:08:49,210
这是用空格填充的%d个字符，用来打印我们想要的字符数。

128
00:08:49,210 --> 00:08:50,660
写信给某人。

129
00:08:50,660 --> 00:08:54,480
最后是我们要写入的目标地址。

130
00:08:54,480 --> 00:08:56,250
得到的地址。

131
00:08:56,250 --> 00:09:00,170
我们现在也可以看看这里写了什么值。

132
00:09:00,170 --> 00:09:03,550
所以我们将跳转到0x40066B。

133
00:09:03,550 --> 00:09:08,450
让我们看看分解图，看看它在哪里。

134
00:09:08,450 --> 00:09:09,450
66 B。

135
00:09:09,450 --> 00:09:11,280
嗯…等等！

136
00:09:11,280 --> 00:09:14,620
地址无效，对吗？

137
00:09:14,620 --> 00:09:17,760
它在比较和跳跃之间不相等。

138
00:09:17,760 --> 00:09:25,180
让我们用x来打印3条指令，而不是反汇编命令。

139
00:09:25,180 --> 00:09:26,240
你看到了吗？

140
00:09:26,240 --> 00:09:29,650
WTF现在有移动，而不是CMP？

141
00:09:29,650 --> 00:09:31,440
搞什么鬼？

142
00:09:31,440 --> 00:09:34,850
欢迎使用Intel汇编程序和更高级的ROP。

143
00:09:34,850 --> 00:09:39,980
这种性质被称为英特尔汇编程序的几何，在著名的ROP论文中，

144
00:09:39,980 --> 00:09:42,280
但从未听人用过这个词。

145
00:09:42,280 --> 00:09:48,770
总之，我们在预期指令的字节之间跳转，CPU是哑的，

146
00:09:48,770 --> 00:09:52,090
它只读取这些字节并将其解释为汇编程序。

147
00:09:52,090 --> 00:09:59,900
在这种情况下，cmp和jne变成了两个简单的移动。

148
00:09:59,900 --> 00:10:06,010
这就是说，现在没有空头支票了，我们就跑到印刷品上印上了胜利的字样。

149
00:10:06,010 --> 00:10:07,850
消息。

150
00:10:07,850 --> 00:10:13,250
当我们现在单步前进时，我们进入程序链接表进行堆栈检查失败，

151
00:10:13,250 --> 00:10:19,390
我们跳到got条目，这是我们在vuln中的奇怪地址，我们执行mov，并且

152
00:10:19,390 --> 00:10:22,440
然后我们调用Puts来打印消息。

