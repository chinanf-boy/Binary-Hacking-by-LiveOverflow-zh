1
00:00:00,560 --> 00:00:06,800
来吧，脏牛 或CVE-2016-5195 的公开教学，正式开始。

2
00:00:06,800 --> 00:00:11,700
此漏洞很古老，允许系统上的普通用户，

3
00:00:11,700 --> 00:00:13,940
执行本地特权升级，并成为根。

4
00:00:13,940 --> 00:00:21,670
我想向你们展示它，并探索它是如何工作的，谈论它的一般性。

5
00:00:21,669 --> 00:00:29,539
让我们直接切入主题，从提供的概念验证入手。

6
00:00:29,539 --> 00:00:34,859
这里有一个易受攻击的Ubuntu系统，我可以下载并编译该漏洞。

7
00:00:34,860 --> 00:00:40,360
然后我创建了一个根权限，拥有的文件，作为普通用户我不能写入。

8
00:00:40,360 --> 00:00:42,800
我可以读，但不能写。

9
00:00:42,800 --> 00:00:47,390
对于文件系统上的许多文件，例如：ping二进制文件来说，权限都是差不多的。

10
00:00:47,390 --> 00:00:50,570
Ping属于根权限，并且设置了setuid位。

11
00:00:50,570 --> 00:00:56,080
这意味着，任何人都可以执行它，它将作为根权限运行，

12
00:00:56,080 --> 00:00:57,760
但是，ping除了发送一些网络流量，不能做更多了。

13
00:00:57,760 --> 00:01:02,350
所以，我们刚刚创建的根文件，类似于 ping。

14
00:01:02,350 --> 00:01:04,770
属于根权限，我们(普通用户)是无法写入。

15
00:01:04,769 --> 00:01:09,839
现在，当我们执行 dirtyc0w，并将根文件传递给它，并指定一个我们想要写入的字符串时，

16
00:01:09,840 --> 00:01:14,120
我们可以观察到，字符串是被写入了文件。

17
00:01:14,119 --> 00:01:19,739
作为系统的普通用户，我们确实对一个根文件写入了，

18
00:01:19,740 --> 00:01:20,860
但是我们却没有写入访问权限。

19
00:01:20,859 --> 00:01:22,199
这太疯狂了。

20
00:01:22,200 --> 00:01:26,700
现在，假设我们已经在ping二进制文件中，编写了一个后门的话，

21
00:01:26,700 --> 00:01:27,700
我们随时都能成为根用户。

22
00:01:27,700 --> 00:01:29,250
不需要知道根的密码。

23
00:01:29,250 --> 00:01:32,360
现在，让我们试着理解漏洞代码。

24
00:01:32,360 --> 00:01:35,930
让我们先检查一下 main() 代码的起始位置。

25
00:01:35,929 --> 00:01:40,079
因此，首先它将以只读(READ_ONLY)方式，打开要写入的文件。

26
00:01:40,079 --> 00:01:42,049
接下来调用 mmap() 。

27
00:01:42,049 --> 00:01:47,369
mmap 用于在当前进程中，创建新的映射内存段。

28
00:01:47,369 --> 00:01:51,769
其中一个参数可以是文件描述符，在本例中，

29
00:01:51,770 --> 00:01:53,150
就是根用户拥有的那个只读文件。

30
00:01:53,149 --> 00:01:57,169
这意味着，它将文件映射到一个新的内存区域。

31
00:01:57,170 --> 00:02:01,570
权限标志也显示，这个新的内存区域是只读的。

32
00:02:01,569 --> 00:02:02,979
到现在为止，都还行。

33
00:02:02,979 --> 00:02:06,899
另一个重要标志，是 MAP_PRIVATE 标志。

34
00:02:06,899 --> 00:02:11,259
这里的注释，是从mmap的手册页复制的，它指出，

35
00:02:11,260 --> 00:02:13,390
这将创建一个，copy-on-wirte(复制) 映射。

36
00:02:13,390 --> 00:02:15,980
或者，简写 C.O.W，牛。

37
00:02:15,980 --> 00:02:18,830
这是此漏洞名称，的一部分来源。

38
00:02:18,830 --> 00:02:24,240
使用此标志，mmap不会将文件的全部内容，复制到内存中，

39
00:02:24,239 --> 00:02:25,919
mmap 是将文件映射到您的内存。

40
00:02:25,920 --> 00:02:29,850
这太棒了，因为您不需要大量的RAM，来加载文件副本，

41
00:02:29,850 --> 00:02:33,340
您可以直接从磁盘上的文件中读取。

42
00:02:33,340 --> 00:02:37,350
或者相对直接地，我们将在一秒钟内，了解更多关于内存的信息。

43
00:02:37,349 --> 00:02:41,899
而 copy-on-write 意味着，如果你要写入这个内存段，

44
00:02:41,900 --> 00:02:43,500
你要创建一个副本。

45
00:02:43,500 --> 00:02:48,380
因此，尽管文件被映射为只读，但由于我们有私有映射，

46
00:02:48,380 --> 00:02:50,340
因此，我们可以对它的副本写入。

47
00:02:50,340 --> 00:02:55,100
而重要的是，mmap将根文件直接映射到内存，

48
00:02:55,100 --> 00:03:00,330
您可以读取文件的内容，也可以写入到，文件的副本。

49
00:03:00,330 --> 00:03:04,520
本来嘛，对副本的更改，是不应该传播到真正的源文件的。

50
00:03:04,520 --> 00:03:07,010
只能自娱自乐一下。

51
00:03:07,010 --> 00:03:09,830
但是转机来了，接下来，我们启动两个并行运行的线程。

52
00:03:09,830 --> 00:03:15,300
脏牛，是一个竞态条件漏洞，这意味着，一些事件，

53
00:03:15,300 --> 00:03:19,890
必须以顺序发生，所以在正常情况下，该漏洞不太可能发生。

54
00:03:19,890 --> 00:03:23,490
所以你试着，与不可能发生的概率赛跑。

55
00:03:23,489 --> 00:03:25,379
你只是一次又一次的尝试。

56
00:03:25,379 --> 00:03:27,579
也许你会走运。

57
00:03:27,579 --> 00:03:30,379
让我们看看这两个线程，在做什么。

58
00:03:30,379 --> 00:03:33,179
第一条线索是 madviseThread。

59
00:03:33,180 --> 00:03:38,520
这个线程使用 syscall madvise，它的名字可不代表什么(memory advise)内存建议，

60
00:03:38,520 --> 00:03:43,460
应该是，疯了(mad)的建议，我认为市场部在这里失败了，

61
00:03:43,459 --> 00:03:45,159
‘疯牛(mad COW)’这一漏洞名称也挺好的，是吧？

62
00:03:45,159 --> 00:03:46,529
好啊。开够了父亲玩笑了。

63
00:03:46,530 --> 00:03:50,030
所以，这个 syscall 是用于优化的。

64
00:03:50,030 --> 00:03:56,240
您可以向内核提供一些，关于如何使用内存映射区域的信息，

65
00:03:56,240 --> 00:04:01,110
因为，在处理缓存时，有不同的技术，所以要向前看。

66
00:04:01,109 --> 00:04:07,059
我们给内核的一个建议是，我们文件映射到的内存区域

67
00:04:07,060 --> 00:04:11,930
或者至少是前100字节，可能不需要用在任何时间。

68
00:04:11,930 --> 00:04:16,740
我们带上，MADV_DONTNEED 标志，它代表：

69
00:04:16,739 --> 00:04:19,839
不希望在不久的将来，访问。

70
00:04:19,840 --> 00:04:24,190
（目前，应用程序在给定范围内，完成，因此内核可以释放

71
00:04:24,190 --> 00:04:26,550
与之相关的资源。）

72
00:04:26,550 --> 00:04:31,970
此范围内的页面 Subsequent 访问将成功，但将导致重新加载

73
00:04:31,970 --> 00:04:34,760
来自底层映射文件的内存内容。

74
00:04:34,759 --> 00:04:37,549
最后一句是漏洞的关键。

75
00:04:37,550 --> 00:04:39,450
不然，这里就不会发生什么了。

76
00:04:39,449 --> 00:04:43,659
另一个线程 procselfmemThread，打开了文件 /proc/self/mem。

77
00:04:43,660 --> 00:04:47,980
这是一个特殊的文件，我试着快速解释下。

78
00:04:47,979 --> 00:04:51,259
/proc 是一个所谓的伪文件系统。

79
00:04:51,259 --> 00:04:55,969
实际上，Linux上的大多数资源，都是作为“文件”管理的。

80
00:04:55,970 --> 00:05:00,530
所以在谈论“文件”时，你应该总是看到引号中的“files”。

81
00:05:00,530 --> 00:05:03,970
想象一个文件，只是某种东西，你可以读，也可以写。

82
00:05:03,970 --> 00:05:08,430
所以，这可能是打印机，当写入“文件”这个打印机时，

83
00:05:08,430 --> 00:05:12,420
结果会是，一台物理打印机，在一张纸上打印字符串。

84
00:05:12,420 --> 00:05:15,930
所以，/proc在常理上，并不真正包含“files”。

85
00:05:15,930 --> 00:05:19,870
它们指的是更一般的东西，对于我们的情况而言最为重要，

86
00:05:19,870 --> 00:05:21,360
是一些你可以读写的东西。

87
00:05:21,360 --> 00:05:27,670
因此，在本例中/proc/self指的是，为当前进程提供的特殊“文件”。

88
00:05:27,670 --> 00:05:29,820
所以，每个进程都有自己的/proc/self。

89
00:05:29,819 --> 00:05:35,609
其中有一个名为 mem 的“文件”，它表示当前进程的

90
00:05:35,610 --> 00:05:36,610
内存。

91
00:05:36,610 --> 00:05:42,050
所以，理论上你可以通过读取这个文件，来读取你自己进程的内存。

92
00:05:42,050 --> 00:05:46,830
在这种情况下，漏洞会在一个循环中，写入该文件。

93
00:05:46,830 --> 00:05:51,350
因此，首先它执行一个查找，将当前光标，移动到文件的开头，

94
00:05:51,349 --> 00:05:53,059
所谓的开头，还是在映射内存中的。

95
00:05:53,060 --> 00:05:57,790
然后，它会写入我们传递的程序字符串参数。

96
00:05:57,790 --> 00:06:03,340
所以，这将触发内存的一个副本，这样我们就可以写入它，并看到这些更改。

97
00:06:03,340 --> 00:06:07,690
但请记住，我们不会写入真正的底层文件。

98
00:06:07,690 --> 00:06:12,600
所以，如果你只做一次这些事情，或者把操作分割开来，

99
00:06:12,599 --> 00:06:13,629
可能什么都不会发生。

100
00:06:13,629 --> 00:06:16,909
因为，要的就是预期结果。

101
00:06:16,910 --> 00:06:21,550
但是，因为在某个地方有一个竞态条件的问题，反复尝试这个后，

102
00:06:21,550 --> 00:06:27,250
将创建一个奇怪的边缘，通常不会发生，

103
00:06:27,250 --> 00:06:30,970
但在这种情况下，会欺骗内核，确实地写入底层文件。

104
00:06:30,970 --> 00:06:34,070
现在，让我们来看看这个补丁，因为我觉得这很有趣，也不是

105
00:06:34,070 --> 00:06:35,070
很大。

106
00:06:35,070 --> 00:06:37,660
所以在提交消息中，作者声明

107
00:06:37,660 --> 00:06:42,370
这是一种古老的 bug ，我确实试图一次修复(不好啊)，在11年前的

108
00:06:42,370 --> 00:06:44,140
提交 4ceb5db9757a（“修复 get_user_pages() 在 write 访问的竞态”）中，但那时

109
00:06:44,139 --> 00:06:46,999
通过提交 f33ea7f4004e5（“修复 get_user_pages bug”），撤消S390上的问题。

110
00:06:47,000 --> 00:06:51,410
所以，我对我的IBM朋友也有点失望，因为他们几乎都有

111
00:06:51,410 --> 00:06:52,640
部分责任。

112
00:06:52,639 --> 00:06:56,329
S390是 IBM Mainframes，System Z 使用的体系结构。

113
00:06:56,330 --> 00:06:58,700
不管怎样，让我们快点看看。

114
00:06:58,699 --> 00:07:04,439
修补的文件属于 Linux内存管理器，因此，是 mm 目录。

115
00:07:04,439 --> 00:07:08,249
文件本身被称为 gup，它代表 get_user_pages (获取用户页面)）。

116
00:07:08,250 --> 00:07:13,110
vm 代表虚拟内存，pte 代表页面表格条目。

117
00:07:13,110 --> 00:07:15,880
我认为这有助于理解代码。

118
00:07:15,880 --> 00:07:20,950
So，当您想要写入这个映射内存时，内核必须复制它，

119
00:07:20,950 --> 00:07:23,440
因为你不允许写入底层文件。

120
00:07:23,440 --> 00:07:26,030
但复制需要时间。

121
00:07:26,030 --> 00:07:30,930
现在通常你复印一次就可以了，但在这种情况下，我们调用 madvise 带上 DONTNEED 标志，

122
00:07:30,930 --> 00:07:33,710
一遍又一遍地运行。

123
00:07:33,710 --> 00:07:35,850
让我们在代码中，查找这个。

124
00:07:35,849 --> 00:07:39,279
因此，如果使用此标志，就执行此函数。

125
00:07:39,280 --> 00:07:42,340
内核源代码解释了：

126
00:07:42,340 --> 00:07:44,610
应用程序不再需要这些页面。

127
00:07:44,610 --> 00:07:48,010
如果页面脏了，把它们扔掉就可以了。

128
00:07:48,010 --> 00:07:50,610
这个应用程序会对它想要保存的数据，更加小心。

129
00:07:50,610 --> 00:07:51,610
还一定要释放交换资源。

130
00:07:51,610 --> 00:07:52,720
我想我快速解释 脏 (dirty)了。

131
00:07:52,720 --> 00:07:53,720
漏洞名称的另一部分来源。

132
00:07:53,720 --> 00:07:57,610
当您读写磁盘时，您永远不能直接这样做，速度会以某种方式，放慢。

133
00:07:57,610 --> 00:07:59,410
所以，你会缓存，或缓冲它们。

134
00:07:59,409 --> 00:08:03,409
这意味着，您将此数据保存在某个位置，并在某个时间点，按时

135
00:08:03,410 --> 00:08:04,410
写入磁盘。

136
00:08:04,410 --> 00:08:05,410
好啊。

137
00:08:05,410 --> 00:08:08,760
因此，如果您将数据从磁盘，读取到内存中，

138
00:08:08,760 --> 00:08:09,760
你可以为近一步读取，把它们留在缓存。

139
00:08:09,760 --> 00:08:14,710
但是，如果您想写入磁盘，您把(数据)写入，这个缓存/缓冲区，

140
00:08:14,710 --> 00:08:18,850
不过，现在您必须告诉系统，这个缓冲区被碰了，变脏了。

141
00:08:18,849 --> 00:08:20,969
告诉系统，它不再是干净的新鲜内存了。

142
00:08:20,970 --> 00:08:26,200
在这种情况下，系统必须确保更改，

143
00:08:26,200 --> 00:08:27,200
正确传播到底层物理内存。

144
00:08:27,200 --> 00:08:30,920
让它成为，磁盘或闪存上的文件。

145
00:08:30,919 --> 00:08:36,409
因此，在本例中，如果您要写入复制的映射内存，

146
00:08:36,409 --> 00:08:37,409
则会把这个内存页标记上，dirty。

147
00:08:37,409 --> 00:08:41,259
因为你现在告诉内核，页面不再需要了，

148
00:08:41,260 --> 00:08:43,690
这意味着，你不在乎脏页是否，写出来。

149
00:08:43,690 --> 00:08:44,910
你只是扔了它。

150
00:08:44,910 --> 00:08:50,010
所以，这个 madvise 调用会让这些内存消失。

151
00:08:50,010 --> 00:08:54,180
这意味着，它不再存在于任何内存缓存中。

152
00:08:54,180 --> 00:08:57,960
而这对该漏洞很重要，因为这意味着，

153
00:08:57,959 --> 00:09:01,859
每当我们试图写它，内存的副本可能已经被丢弃了。

154
00:09:01,860 --> 00:09:06,250
所以我，们必须从内存中，重新加载一个新的副本，这样我们才能写入它。

155
00:09:06,250 --> 00:09:08,340
而创建这个副本需要时间。

156
00:09:08,340 --> 00:09:12,620
正是这时，竞争条件发生了，如果 copy-on-write 周期还没有完成。

157
00:09:12,620 --> 00:09:16,310
补丁程序，添加了这个函数，来检查 copy-on-write 是否完成，

158
00:09:16,310 --> 00:09:18,670
只有这样才允许写入。

159
00:09:18,670 --> 00:09:23,370
老实说，我真的不理解这段代码，

160
00:09:23,370 --> 00:09:25,600
无法告诉你，为什么这段代码就能确保“copy-on-write”已完成。

161
00:09:25,600 --> 00:09:30,390
但它增加了一些额外的检查，所以我想现在可以了。

162
00:09:30,390 --> 00:09:32,910
这是我们竞态状况的思维图。

163
00:09:32,910 --> 00:09:37,730
我们经常使用 madvise，删除映射文件的任何缓存副本。

164
00:09:37,730 --> 00:09:42,420
同时，我们试图写入，而这导致了内存的复制。

165
00:09:42,420 --> 00:09:47,290
此时，在一些竞态条件的作用下，只要反复尝试，就可以非常可靠地击中它，漏洞产生。

166
00:09:47,290 --> 00:09:52,510
也就是，在页面表格更新，让我们指向新副本之前，

167
00:09:52,510 --> 00:09:54,340
执行了对内存的写操作。

168
00:09:54,339 --> 00:09:58,169
我们就会对真实文件写入，而不是复制的版本(因为已经消失了，被 madvise)。

169
00:09:58,170 --> 00:10:03,050
关于这个漏洞的疯狂之处在于，它已经在内核中，存在了很长一段时间了。

170
00:10:03,050 --> 00:10:05,240
长时间。

171
00:10:05,240 --> 00:10:09,950
根据补丁作者的说法，在尝试修补之前，

172
00:10:09,950 --> 00:10:11,880
这甚至是一个已知的问题。

173
00:10:11,880 --> 00:10:17,810
随着时间的推移，这个具有明确理论的竞态条件的实现变得很可行，

174
00:10:17,810 --> 00:10:19,240
因为我们的系统越来越快。

175
00:10:19,240 --> 00:10:23,360
Petr Matousek也指出，这是一个在法外，使用的零日漏洞。

176
00:10:23,360 --> 00:10:25,680
所以有一个真正的威胁。

177
00:10:25,680 --> 00:10:27,190
现在，带有争议。

178
00:10:27,190 --> 00:10:32,910
进入了几十年来未解决的争论，就是如何进行漏洞披露

179
00:10:32,910 --> 00:10:33,910
披露。

180
00:10:33,910 --> 00:10:38,840
如果你是在法外，发现这一漏洞的人，你会怎么做？

181
00:10:38,839 --> 00:10:41,539
一个有力观点是：

182
00:10:41,540 --> 00:10:46,230
完全披露，因为这样它可以被积极响应，

183
00:10:46,230 --> 00:10:49,170
完全披露，让大家处于同一认知水平线，就不会给高级攻击者任何的新信息。

184
00:10:49,170 --> 00:10:53,040
但是，这些知识，是否能够让系统管理员

185
00:10:53,040 --> 00:10:54,040
立即修复系统。

186
00:10:54,040 --> 00:10:57,390
也就有了一个薄弱且普遍的弱点，

187
00:10:57,389 --> 00:11:01,729
一个完全披露的漏洞，会让技术较差的黑客军队利用它，

188
00:11:01,730 --> 00:11:04,710
直到专业的系统管理员或私人，去修补它。

189
00:11:04,710 --> 00:11:10,130
完全的另一方面，就是责任披露，这里的第一步，要联系开发人员，

190
00:11:10,131 --> 00:11:13,571
给出一个解决办法，实际测试，然后再告诉人们。

191
00:11:13,570 --> 00:11:19,420
这里的有力论点是，您让专业系统管理员不能，

192
00:11:19,420 --> 00:11:23,300
迅速对系统进行热修补，让其暴露在持续的攻击中。

193
00:11:23,300 --> 00:11:26,500
对于我而言，我并不知道最好的方法是什么。

194
00:11:26,500 --> 00:11:28,740
两种方法都有优缺点。

195
00:11:28,740 --> 00:11:31,590
这完全取决于你的危险模型。

196
00:11:31,589 --> 00:11:35,919
一般来说，我更倾向于完全披露，

197
00:11:35,920 --> 00:11:41,260
可能是因为我喜欢信息的自由吧，尽管，我自己实际做的是负责披露，因为我是个 hypocrite。

198
00:11:41,260 --> 00:11:45,080
我希望，你喜欢这种漏洞演练的视频，

199
00:11:45,079 --> 00:11:46,639
可以给你看一些新颖有趣的东西。

200
00:11:46,639 --> 00:11:51,409
如果我说了错误的话，或者你有关于为什么必须通过写入/proc/mem，

201
00:11:51,410 --> 00:11:56,920
而不是直接写入地址，才能触发此漏洞的其他补充信息，请更正我的错误。

202
00:11:56,920 --> 00:12:02,130
或者在下面的评论中，发布补充信息，以便其他关注的观众，

203
00:12:02,130 --> 00:12:03,130
可以受益。

204
00:12:03,130 --> 00:12:03,260
谢谢。

