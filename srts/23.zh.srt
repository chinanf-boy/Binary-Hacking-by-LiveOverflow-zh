1
00:00:00,560 --> 00:00:06,800
因此，DirtyC0W或CVE-2016-5195的公开披露才刚刚发生。

2
00:00:06,800 --> 00:00:11,700
此漏洞很古老，允许系统上的常规用户执行本地

3
00:00:11,700 --> 00:00:13,940
特权升级并成为根。

4
00:00:13,940 --> 00:00:21,670
我想向你们展示它，探索它是如何工作的，并且通常会谈论它。

5
00:00:21,669 --> 00:00:29,539
让我们直接切入主题，从提供的概念验证入手。

6
00:00:29,539 --> 00:00:34,859
这里有一个易受攻击的Ubuntu系统，我可以下载并编译该漏洞。

7
00:00:34,860 --> 00:00:40,360
然后我创建了一个根目录拥有的文件，作为普通用户我不能写入。

8
00:00:40,360 --> 00:00:42,800
我可以读，但不能写。

9
00:00:42,800 --> 00:00:47,390
对于文件系统上的许多文件，例如ping二进制文件，这是正确的。

10
00:00:47,390 --> 00:00:50,570
Ping属于根目录，并且设置了setuid位。

11
00:00:50,570 --> 00:00:56,080
这意味着任何人都可以执行它，它将作为根目录运行，但是ping除了

12
00:00:56,080 --> 00:00:57,760
发送一些网络流量。

13
00:00:57,760 --> 00:01:02,350
所以我们刚刚创建的根文件类似于一个文件或者类似于ping的二进制文件。

14
00:01:02,350 --> 00:01:04,770
它属于根目录，我们无法写入。

15
00:01:04,769 --> 00:01:09,839
现在，当我们执行dirtyc0w并将根文件传递给它并指定一个我们想要的字符串时

16
00:01:09,840 --> 00:01:14,120
为了写入，我们可以观察到，字符串被写入了文件。

17
00:01:14,119 --> 00:01:19,739
作为系统的常规用户，我们已经写入了一个根文件，但是我们没有

18
00:01:19,740 --> 00:01:20,860
写入访问权限。

19
00:01:20,859 --> 00:01:22,199
这太疯狂了。

20
00:01:22,200 --> 00:01:26,700
现在假设我们已经在ping二进制文件中编写了一个后门，我们可以成为根

21
00:01:26,700 --> 00:01:27,700
任何时候。

22
00:01:27,700 --> 00:01:29,250
不知道根的密码。

23
00:01:29,250 --> 00:01:32,360
现在让我们试着理解漏洞代码。

24
00:01:32,360 --> 00:01:35,930
让我们先检查一下main() 代码的起始位置。

25
00:01:35,929 --> 00:01:40,079
因此，首先它将以只读方式打开要写入的文件。

26
00:01:40,079 --> 00:01:42,049
接下来调用mmap() 。

27
00:01:42,049 --> 00:01:47,369
mmap用于在当前进程中创建新的映射内存段。

28
00:01:47,369 --> 00:01:51,769
其中一个参数可以是文件描述符，在本例中是只读文件

29
00:01:51,770 --> 00:01:53,150
由根所有。

30
00:01:53,149 --> 00:01:57,169
这意味着它将文件映射到一个新的内存区域。

31
00:01:57,170 --> 00:02:01,570
权限标志也显示，这个新的内存区域是只读的。

32
00:02:01,569 --> 00:02:02,979
到现在为止，一直都还不错。

33
00:02:02,979 --> 00:02:06,899
另一个重要标志是地图私有标志。

34
00:02:06,899 --> 00:02:11,259
这里的注释是从mmap的手册页复制的，它指出，这将创建一个

35
00:02:11,260 --> 00:02:13,390
写映射上的私有副本。

36
00:02:13,390 --> 00:02:15,980
或者短的C.O.W，牛。

37
00:02:15,980 --> 00:02:18,830
这是此漏洞名称的一部分来源。

38
00:02:18,830 --> 00:02:24,240
使用此标志，mmap不会将文件的全部内容复制到内存中，mmap映射

39
00:02:24,239 --> 00:02:25,919
将文件存入您的内存。

40
00:02:25,920 --> 00:02:29,850
这太棒了，因为您不需要大量的RAM来加载文件副本，

41
00:02:29,850 --> 00:02:33,340
您只是直接从磁盘上的文件中读取。

42
00:02:33,340 --> 00:02:37,350
或者相对直接地，我们将在一秒钟内了解更多关于记忆的信息。

43
00:02:37,349 --> 00:02:41,899
而copy-on-write意味着，如果你要写这个内存段，你会

44
00:02:41,900 --> 00:02:43,500
然后创建一个副本。

45
00:02:43,500 --> 00:02:48,380
因此，尽管文件被映射为只读，但由于我们可以写入私有映射，因此

46
00:02:48,380 --> 00:02:50,340
一份副本。

47
00:02:50,340 --> 00:02:55,100
所以这里重要的是，mmap将根文件直接映射到

48
00:02:55,100 --> 00:03:00,330
内存，您可以读取文件的内容，也可以写入文件的副本。

49
00:03:00,330 --> 00:03:04,520
对副本的更改不应传播到真正的参考底图文件。

50
00:03:04,520 --> 00:03:07,010
这是给你的

51
00:03:07,010 --> 00:03:09,830
接下来，我们启动两个将并行运行的线程。

52
00:03:09,830 --> 00:03:15,300
dirtyc0w是一个种族条件漏洞，这意味着某些事件必须发生在

53
00:03:15,300 --> 00:03:19,890
在正常情况下不太可能发生的特定命令。

54
00:03:19,890 --> 00:03:23,490
所以你试着和它不可能发生的概率赛跑。

55
00:03:23,489 --> 00:03:25,379
你只是一次又一次的尝试。

56
00:03:25,379 --> 00:03:27,579
也许你会走运。

57
00:03:27,579 --> 00:03:30,379
让我们看看这两个线程在做什么。

58
00:03:30,379 --> 00:03:33,179
第一条线索是宗教信仰。

59
00:03:33,180 --> 00:03:38,520
这个线程使用系统调用madvise，它可能不代表内存建议，

60
00:03:38,520 --> 00:03:43,460
但是，疯狂的建议，我认为市场部在这里失败了，没有说出这种可能性。

61
00:03:43,459 --> 00:03:45,159
疯牛，我说得对吗？

62
00:03:45,159 --> 00:03:46,529
好啊。别跟爸爸开玩笑了。

63
00:03:46,530 --> 00:03:50,030
所以这个系统调用可以用于优化。

64
00:03:50,030 --> 00:03:56,240
您可以向内核提供一些关于如何使用内存映射区域的信息，

65
00:03:56,240 --> 00:04:01,110
因为在处理缓存时有不同的技术，所以要向前看等等。

66
00:04:01,109 --> 00:04:07,059
我们给内核的建议是，我们映射文件的内存区域

67
00:04:07,060 --> 00:04:11,930
到，或者至少是前100字节，可能不需要很快。

68
00:04:11,930 --> 00:04:16,740
我们说，用马德夫·唐特纳的旗帜，它代表：

69
00:04:16,739 --> 00:04:19,839
不希望在不久的将来访问。

70
00:04:19,840 --> 00:04:24,190
（目前，应用程序在给定范围内完成，因此内核可以释放

71
00:04:24,190 --> 00:04:26,550
与之相关的资源。）

72
00:04:26,550 --> 00:04:31,970
此范围内的后续页面访问将成功，但将导致重新加载

73
00:04:31,970 --> 00:04:34,760
来自基础映射文件的内存内容。

74
00:04:34,759 --> 00:04:37,549
最后一句话是利用漏洞的关键。

75
00:04:37,550 --> 00:04:39,450
否则这里就不会发生什么了。

76
00:04:39,449 --> 00:04:43,659
另一个线程proc self mem thread打开文件/proc/self/mem。

77
00:04:43,660 --> 00:04:47,980
这是一个特殊的文件，我试着快速解释。

78
00:04:47,979 --> 00:04:51,259
so/proc是一个所谓的伪文件系统。

79
00:04:51,259 --> 00:04:55,969
实际上，Linux上的大多数资源都是作为“文件”管理的。

80
00:04:55,970 --> 00:05:00,530
所以在谈论“文件”时，你应该总是看到引号中的“文件”。

81
00:05:00,530 --> 00:05:03,970
想象一个文件只是为了某种东西，你可以读，也可以写。

82
00:05:03,970 --> 00:05:08,430
所以这可能是打印机，写入打印机“文件”可能会导致

83
00:05:08,430 --> 00:05:12,420
在一张纸上打印字符串的物理打印机。

84
00:05:12,420 --> 00:05:15,930
所以/proc在常识上并不真正包含“files”。

85
00:05:15,930 --> 00:05:19,870
它们指的是更一般的东西，最重要的是对于我们的情况，你可以

86
00:05:19,870 --> 00:05:21,360
读写。

87
00:05:21,360 --> 00:05:27,670
因此，在本例中/proc/self指的是为当前进程提供的特殊“文件”。

88
00:05:27,670 --> 00:05:29,820
所以每个进程都有自己的/proc/self。

89
00:05:29,819 --> 00:05:35,609
其中有一个名为mem的“文件”，它表示当前进程的

90
00:05:35,610 --> 00:05:36,610
记忆。

91
00:05:36,610 --> 00:05:42,050
所以理论上你可以通过读取这个文件来读取你自己进程的内存。

92
00:05:42,050 --> 00:05:46,830
在这种情况下，漏洞会在循环中写入该文件。

93
00:05:46,830 --> 00:05:51,350
因此，首先它执行一个查找，将当前光标移动到文件的开头，

94
00:05:51,349 --> 00:05:53,059
我们映射到内存中。

95
00:05:53,060 --> 00:05:57,790
然后它写入我们通过程序参数传递给它的字符串。

96
00:05:57,790 --> 00:06:03,340
所以这将触发内存的一个副本，这样我们就可以写入它并看到这些更改。

97
00:06:03,340 --> 00:06:07,690
但请记住，我们不会写入真正的参考文件。

98
00:06:07,690 --> 00:06:12,600
所以，如果你只做一次这些事情，或者只是孤立在一起，可能什么都没有。

99
00:06:12,599 --> 00:06:13,629
将会发生。

100
00:06:13,629 --> 00:06:16,909
因为这是预期的结果。

101
00:06:16,910 --> 00:06:21,550
但是因为在某个地方有一个种族条件的问题，反复尝试这个问题

102
00:06:21,550 --> 00:06:27,250
将创建一个奇怪的边缘，通常不会发生，但在这种情况下，会欺骗

103
00:06:27,250 --> 00:06:30,970
内核写入底层文件。

104
00:06:30,970 --> 00:06:34,070
现在让我们来看看这个补丁，因为我觉得这很有趣，而且不是很有趣

105
00:06:34,070 --> 00:06:35,070
大的。

106
00:06:35,070 --> 00:06:37,660
所以在提交消息中，作者声明

107
00:06:37,660 --> 00:06:42,370
这是一种古老的虫子，我十一年来一直试图修复一次。

108
00:06:42,370 --> 00:06:44,140
在commit 4ceb5db9757a（“fix get_user_pages() race for write access”）中，但那时

109
00:06:44,139 --> 00:06:46,999
通过提交f33ea7f4004e5（“修复get_user_pages bug”）撤消S390上的问题。

110
00:06:47,000 --> 00:06:51,410
所以我对我的IBM朋友有点失望，因为他们几乎有

111
00:06:51,410 --> 00:06:52,640
部分有罪。

112
00:06:52,639 --> 00:06:56,329
S390是IBM Mainframes，System Z使用的体系结构。

113
00:06:56,330 --> 00:06:58,700
不管怎样，让我们快点看看。

114
00:06:58,699 --> 00:07:04,439
修补的文件属于Linux内存管理器，因此是mm目录。

115
00:07:04,439 --> 00:07:08,249
文件本身被称为gup，它代表get-user-pages。

116
00:07:08,250 --> 00:07:13,110
vm代表虚拟内存，pte代表页表条目。

117
00:07:13,110 --> 00:07:15,880
我认为这应该有助于理解代码。

118
00:07:15,880 --> 00:07:20,950
因此，当您想要写入这个映射内存时，内核必须复制它，因为

119
00:07:20,950 --> 00:07:23,440
不允许写入基础文件。

120
00:07:23,440 --> 00:07:26,030
但复制需要时间。

121
00:07:26,030 --> 00:07:30,930
现在通常你复印一次就可以了，但在这种情况下我们称之为疯子

122
00:07:30,930 --> 00:07:33,710
一遍又一遍。

123
00:07:33,710 --> 00:07:35,850
让我们在代码中查找这个。

124
00:07:35,849 --> 00:07:39,279
因此，如果使用此标志，则执行此函数。

125
00:07:39,280 --> 00:07:42,340
内核源代码解释了：

126
00:07:42,340 --> 00:07:44,610
应用程序不再需要这些页面。

127
00:07:44,610 --> 00:07:48,010
如果书页脏了，把它们扔掉就可以了。

128
00:07:48,010 --> 00:07:50,610
这个应用程序会对它想要保存的数据更加小心。

129
00:07:50,610 --> 00:07:51,610
一定要释放交换资源。

130
00:07:51,610 --> 00:07:52,720
我想我很快就解释了。

131
00:07:52,720 --> 00:07:53,720
这也是名称的另一部分的来源。

132
00:07:53,720 --> 00:07:57,610
当您读写磁盘时，您永远不会直接这样做，这将是您放慢速度的方法。

133
00:07:57,610 --> 00:07:59,410
所以可以缓存或缓冲它们。

134
00:07:59,409 --> 00:08:03,409
这意味着您将此数据保存在某个位置，并在某个时间点将其写入

135
00:08:03,410 --> 00:08:04,410
磁盘。

136
00:08:04,410 --> 00:08:05,410
好啊。

137
00:08:05,410 --> 00:08:08,760
因此，如果您将数据从磁盘读取到内存中，您可以将其留在缓存中，

138
00:08:08,760 --> 00:08:09,760
进一步阅读。

139
00:08:09,760 --> 00:08:14,710
但是，如果您想写入磁盘，您可以将它写入这个缓存/缓冲区，但是现在您可以

140
00:08:14,710 --> 00:08:18,850
必须告诉系统，这个缓冲区被碰了，现在变脏了。

141
00:08:18,849 --> 00:08:20,969
它不再是干净的新鲜记忆了。

142
00:08:20,970 --> 00:08:26,200
在这种情况下，系统必须确保更改正确传播到底层。

143
00:08:26,200 --> 00:08:27,200
物理内存。

144
00:08:27,200 --> 00:08:30,920
让它成为磁盘或闪存上的文件。

145
00:08:30,919 --> 00:08:36,409
因此，在本例中，如果您写入复制的mmaped内存，则会标记内存页。

146
00:08:36,409 --> 00:08:37,409
脏了。

147
00:08:37,409 --> 00:08:41,259
因为你现在告诉内核，页面不再需要了，这意味着

148
00:08:41,260 --> 00:08:43,690
你不在乎脏页还没有写出来。

149
00:08:43,690 --> 00:08:44,910
你就扔了。

150
00:08:44,910 --> 00:08:50,010
所以这个疯狂的呼唤会让记忆消失。

151
00:08:50,010 --> 00:08:54,180
这意味着它不再存在于任何内存缓存中。

152
00:08:54,180 --> 00:08:57,960
这对这种利用很重要，因为这意味着，每当我们试图写

153
00:08:57,959 --> 00:09:01,859
对它来说，记忆的副本可能已经被丢弃了。

154
00:09:01,860 --> 00:09:06,250
所以我们必须从内存中重新加载一个新的副本，这样我们才能写入它。

155
00:09:06,250 --> 00:09:08,340
创建这个拷贝需要时间。

156
00:09:08,340 --> 00:09:12,620
这就是竞争条件，如果写时复制周期还没有完成。

157
00:09:12,620 --> 00:09:16,310
补丁程序添加了这个函数来检查写入时的拷贝是否完成，以及

158
00:09:16,310 --> 00:09:18,670
只有这样才允许写入。

159
00:09:18,670 --> 00:09:23,370
老实说，我真的不理解这段代码来告诉你为什么这段代码

160
00:09:23,370 --> 00:09:25,600
请确保“写时复制”已完成。

161
00:09:25,600 --> 00:09:30,390
但它增加了一些额外的检查，所以我想现在可以了。

162
00:09:30,390 --> 00:09:32,910
这是我们种族状况的心理图。

163
00:09:32,910 --> 00:09:37,730
我们经常使用madvise删除映射文件的任何缓存副本。

164
00:09:37,730 --> 00:09:42,420
同时，我们试图给它写信，这导致了记忆的复制。

165
00:09:42,420 --> 00:09:47,290
现在在一些罕见的情况下，只要反复尝试就可以非常可靠地击中它。

166
00:09:47,290 --> 00:09:52,510
同样，我们在页表更新到点之前执行对内存的写操作。

167
00:09:52,510 --> 00:09:54,340
我们把我们复制的版本。

168
00:09:54,339 --> 00:09:58,169
我们写的是真正的文件而不是复制的内存。

169
00:09:58,170 --> 00:10:03,050
关于这个漏洞的疯狂之处在于，它已经在内核中存在了很长一段时间了。

170
00:10:03,050 --> 00:10:05,240
长时间。

171
00:10:05,240 --> 00:10:09,950
根据补丁作者的说法，这甚至是一个已知的问题

172
00:10:09,950 --> 00:10:11,880
之前要修补。

173
00:10:11,880 --> 00:10:17,810
随着时间的推移，这个明显的理论竞赛条件变得可行，因为我们的系统

174
00:10:17,810 --> 00:10:19,240
越来越快。

175
00:10:19,240 --> 00:10:23,360
Petr Matousek也指出，这是一个在野外使用的第0天的开发。

176
00:10:23,360 --> 00:10:25,680
所以有一个真正的威胁。

177
00:10:25,680 --> 00:10:27,190
现在有点争议。

178
00:10:27,190 --> 00:10:32,910
这进入了腐朽者如何应对脆弱性的未解决的争论。

179
00:10:32,910 --> 00:10:33,910
披露。

180
00:10:33,910 --> 00:10:38,840
如果你是在野外发现这一漏洞的人，你会怎么做？

181
00:10:38,839 --> 00:10:41,539
显而易见的论点是：

182
00:10:41,540 --> 00:10:46,230
完全披露，因为它被积极利用，完全披露它马上就会

183
00:10:46,230 --> 00:10:49,170
没有给高级攻击者任何新信息。

184
00:10:49,170 --> 00:10:53,040
但是这些知识将使系统管理员能够立即对

185
00:10:53,040 --> 00:10:54,040
系统。

186
00:10:54,040 --> 00:10:57,390
但另一方面，这是一个如此容易和普遍的弱点，一个充分披露

187
00:10:57,389 --> 00:11:01,729
会让技术较差的黑客军队利用它，直到

188
00:11:01,730 --> 00:11:04,710
专业的系统管理员或私人人员可以修补它。

189
00:11:04,710 --> 00:11:10,130
另一方面，我们有一个负责任的披露，在这里您首先联系开发人员，创建

190
00:11:10,131 --> 00:11:13,571
一个解决办法，试着推出，然后告诉人们。

191
00:11:13,570 --> 00:11:19,420
这里的明显论点是，您停止了专业系统管理员对其进行热修补

192
00:11:19,420 --> 00:11:23,300
系统迅速，让他们暴露在持续的攻击中。

193
00:11:23,300 --> 00:11:26,500
现在我不知道最好的方法是什么。

194
00:11:26,500 --> 00:11:28,740
两种方法都有优缺点。

195
00:11:28,740 --> 00:11:31,590
这完全取决于你的威胁模型。

196
00:11:31,589 --> 00:11:35,919
一般来说，我更倾向于全面披露，因为我喜欢

197
00:11:35,920 --> 00:11:41,260
自由吧，尽管我自己做了负责任的披露，因为我是个伪君子。

198
00:11:41,260 --> 00:11:45,080
我希望你喜欢这种利用演练的视频，我可以给你看一些东西

199
00:11:45,079 --> 00:11:46,639
新颖有趣。

200
00:11:46,639 --> 00:11:51,409
如果我说了错误的话，或者你有关于为什么必须触发此漏洞的其他信息

201
00:11:51,410 --> 00:11:56,920
通过写入/proc/mem而不是直接写入地址，请更正我的错误。

202
00:11:56,920 --> 00:12:02,130
或者在下面的评论中发布其他信息，以便其他关注的观众可以受益。

203
00:12:02,130 --> 00:12:03,130
从它。

204
00:12:03,130 --> 00:12:03,260
谢谢。

