1
00:00:00,560 --> 00:00:06,800
所以公开披露dirtyc0w或cve-2016-5195刚刚发生了。

2
00:00:06,800 --> 00:00:11,700
这个弱点是古老的，并且允许系统上执行本地操作的常规用户

3
00:00:11,700 --> 00:00:13,940
特权升级并成为根。

4
00:00:13,940 --> 00:00:21,670
我想向你展示它，探索它的工作原理一般说来。

5
00:00:21,669 --> 00:00:29,539
我们直奔追逐的方向，从前面开始吧查看提供的概念验证利用。

6
00:00:29,539 --> 00:00:34,859
我这里有一个易受攻击的Ubuntu系统我可以下载并编译该漏洞。

7
00:00:34,860 --> 00:00:40,360
然后我创建一个根目录拥有的文件我作为一个普通用户不能写信给。

8
00:00:40,360 --> 00:00:42,800
我可以读，但不能写。

9
00:00:42,800 --> 00:00:47,390
对于文件系统中的许多文件都是如此例如ping二进制文件。

10
00:00:47,390 --> 00:00:50,570
Ping属于根目录，具有setuid位集合。

11
00:00:50,570 --> 00:00:56,080
这意味着任何人都可以执行它以根目录运行，但是ping除了

12
00:00:56,080 --> 00:00:57,760
发送一些网络流量。

13
00:00:57,760 --> 00:01:02,350
所以我们刚刚创建的根文件类似于像ping这样的文件或二进制文件。

14
00:01:02,350 --> 00:01:04,770
它归根所有，我们不能写对它。

15
00:01:04,769 --> 00:01:09,839
现在，当我们执行dirtyc0w并传递它时根文件并指定所需的字符串

16
00:01:09,840 --> 00:01:14,120
我们可以观察到，写入文件。

17
00:01:14,119 --> 00:01:19,739
作为系统的常规用户，我们写入根文件，但我们没有

18
00:01:19,740 --> 00:01:20,860
写入访问权限。

19
00:01:20,859 --> 00:01:22,199
这太疯狂了。

20
00:01:22,200 --> 00:01:26,700
想象一下我们会写一个后门在ping二进制文件中，我们可以成为根

21
00:01:26,700 --> 00:01:27,700
任何时候。

22
00:01:27,700 --> 00:01:29,250
不知道根的密码。

23
00:01:29,250 --> 00:01:32,360
现在，让我们试着了解利用代码。

24
00:01:32,360 --> 00:01:35,930
让我们先看看main（）中的代码开始。

25
00:01:35,929 --> 00:01:40,079
所以首先它打开我们要写的文件以只读方式。

26
00:01:40,079 --> 00:01:42,049
接下来调用mmap（）。

27
00:01:42,049 --> 00:01:47,369
mmap用于创建新的映射内存当前进程中的段。

28
00:01:47,369 --> 00:01:51,769
其中一个参数可以是文件描述符在这种情况下，它是只读文件

29
00:01:51,770 --> 00:01:53,150
由根所有。

30
00:01:53,149 --> 00:01:57,169
这意味着它将文件映射到新内存中面积。

31
00:01:57,170 --> 00:02:01,570
权限标志还显示新的内存区是只读的。

32
00:02:01,569 --> 00:02:02,979
到现在为止，一直都还不错。

33
00:02:02,979 --> 00:02:06,899
另一个重要标志是地图私有旗帜。

34
00:02:06,899 --> 00:02:11,259
这里的评论是从手册页复制的在mmap和它的声明中，这会创建一个

35
00:02:11,260 --> 00:02:13,390
写映射上的私有副本。

36
00:02:13,390 --> 00:02:15,980
或者短的C.O.W，牛。

37
00:02:15,980 --> 00:02:18,830
这就是这个名字的一部分漏洞来自。

38
00:02:18,830 --> 00:02:24,240
使用此标志，mmap不会复制整个将文件内容存入内存，mmap映射

39
00:02:24,239 --> 00:02:25,919
将文件存入您的内存。

40
00:02:25,920 --> 00:02:29,850
这太棒了，因为你不需要巨大的加载文件副本所需的RAM数量，

41
00:02:29,850 --> 00:02:33,340
您只是直接从磁盘上的文件中读取。

42
00:02:33,340 --> 00:02:37,350
或者相对直接地，我们会学到更多关于记忆在一秒钟内

43
00:02:37,349 --> 00:02:41,899
写上副本意味着，如果你是要写入这个内存段，您需要

44
00:02:41,900 --> 00:02:43,500
然后创建一个副本。

45
00:02:43,500 --> 00:02:48,380
所以尽管文件被映射为只读，因为我们可以写私有映射

46
00:02:48,380 --> 00:02:50,340
一份副本。

47
00:02:50,340 --> 00:02:55,100
所以这里的重要收获是，MMAP将根文件直接映射到

48
00:02:55,100 --> 00:03:00,330
内存，您可以读取文件，或写入副本。

49
00:03:00,330 --> 00:03:04,520
不应传播对副本的更改到真正的参考文件。

50
00:03:04,520 --> 00:03:07,010
这是给你的

51
00:03:07,010 --> 00:03:09,830
接下来，我们启动两个将在其中运行的线程平行的。

52
00:03:09,830 --> 00:03:15,300
dirtyc0w是一个种族条件漏洞，这意味着某些事件必须发生在

53
00:03:15,300 --> 00:03:19,890
不太可能的特定订单在正常情况下发生。

54
00:03:19,890 --> 00:03:23,490
所以你试着和概率赛跑这是不可能的。

55
00:03:23,489 --> 00:03:25,379
你只是一次又一次的尝试。

56
00:03:25,379 --> 00:03:27,579
也许你会走运。

57
00:03:27,579 --> 00:03:30,379
让我们看看这两个线程在做什么。

58
00:03:30,379 --> 00:03:33,179
第一条线索是宗教信仰。

59
00:03:33,180 --> 00:03:38,520
此线程使用syscall madvise，其中可能不代表记忆建议，

60
00:03:38,520 --> 00:03:43,460
但我认为营销部此处失败，将此易损性命名为

61
00:03:43,459 --> 00:03:45,159
疯牛，我说得对吗？

62
00:03:45,159 --> 00:03:46,529
好啊。别跟爸爸开玩笑了。

63
00:03:46,530 --> 00:03:50,030
所以这个系统调用可以用于优化原因。

64
00:03:50,030 --> 00:03:56,240
您可以向内核提供一些信息关于如何使用内存映射区域，

65
00:03:56,240 --> 00:04:01,110
因为有不同的技术如何您处理缓存，向前看等等。

66
00:04:01,109 --> 00:04:07,059
我们给内核的建议是，我们映射文件的内存区域

67
00:04:07,060 --> 00:04:11,930
到，或至少前100个字节，可能是很快就不需要了。

68
00:04:11,930 --> 00:04:16,740
我们用马德夫·唐特纳的旗帜说，那是代表：

69
00:04:16,739 --> 00:04:19,839
不希望在不久的将来访问。

70
00:04:19,840 --> 00:04:24,190
（目前，申请已经完成在给定的范围内，内核可以释放

71
00:04:24,190 --> 00:04:26,550
与之相关的资源。）

72
00:04:26,550 --> 00:04:31,970
此范围内页面的后续访问会成功，但会导致重新加载

73
00:04:31,970 --> 00:04:34,760
来自底层的内存内容映射文件。

74
00:04:34,759 --> 00:04:37,549
最后一句话是利用漏洞的关键。

75
00:04:37,550 --> 00:04:39,450
否则这里就不会发生什么了。

76
00:04:39,449 --> 00:04:43,659
另一个线程procselfmemthread打开文件/proc/self/mem。

77
00:04:43,660 --> 00:04:47,980
这是一个特殊的文件，我想解释一下真的很快。

78
00:04:47,979 --> 00:04:51,259
so/proc是一个所谓的伪文件系统。

79
00:04:51,259 --> 00:04:55,969
实际上，Linux上的大多数资源都是管理的作为"文件"。

80
00:04:55,970 --> 00:05:00,530
所以你应该总是看到报价中的"文件"谈论它们时会留下痕迹。

81
00:05:00,530 --> 00:05:03,970
想象一下一个文件只是为了某种东西，你可以读或写。

82
00:05:03,970 --> 00:05:08,430
所以这可能是打印机，写给打印机"文件"可能导致

83
00:05:08,430 --> 00:05:12,420
打印字符串的物理打印机一张纸

84
00:05:12,420 --> 00:05:15,930
所以/proc并不真正包含"files"在常识上。

85
00:05:15,930 --> 00:05:19,870
它们指的是更一般的东西，大多数对我们来说很重要，你可以

86
00:05:19,870 --> 00:05:21,360
读写。

87
00:05:21,360 --> 00:05:27,670
所以在本例中/proc/self指的是特殊的为当前进程提供的"文件"。

88
00:05:27,670 --> 00:05:29,820
所以每个进程都有自己的/proc/self。

89
00:05:29,819 --> 00:05:35,609
里面有一个叫做mem的"文件"表示当前进程的

90
00:05:35,610 --> 00:05:36,610
记忆。

91
00:05:36,610 --> 00:05:42,050
所以理论上你可以阅读你自己的过程从这个文件读取内存。

92
00:05:42,050 --> 00:05:46,830
在这种情况下，漏洞会写入循环中的文件。

93
00:05:46,830 --> 00:05:51,350
所以首先它执行一个查找，它移动当前光标指向文件开头

94
00:05:51,349 --> 00:05:53,059
我们映射到内存中。

95
00:05:53,060 --> 00:05:57,790
然后它写下我们通过的字符串程序参数。

96
00:05:57,790 --> 00:06:03,340
所以这将触发内存的副本，这样我们就可以写信给它并看到这些变化。

97
00:06:03,340 --> 00:06:07,690
但是记住，我们不会写信给真实的参考文件。

98
00:06:07,690 --> 00:06:12,600
所以如果你想做这些事情一次，或者只是相互孤立，可能什么都没有

99
00:06:12,599 --> 00:06:13,629
将会发生。

100
00:06:13,629 --> 00:06:16,909
因为这是预期的结果。

101
00:06:16,910 --> 00:06:21,550
但是因为有一个种族条件的问题在某个地方，反复尝试

102
00:06:21,550 --> 00:06:27,250
会造成一个奇怪的边缘，通常不会发生，但在这种情况下

103
00:06:27,250 --> 00:06:30,970
内核实际写入底层文件。

104
00:06:30,970 --> 00:06:34,070
现在让我们看看补丁，因为我觉得这很有趣，不是很有趣

105
00:06:34,070 --> 00:06:35,070
大的。

106
00:06:35,070 --> 00:06:37,660
所以在提交消息中，作者声明那个

107
00:06:37,660 --> 00:06:42,370
这是一只古代的虫子十一年后由我修一次（严重）

108
00:06:42,370 --> 00:06:44,140
在commit 4ceb5db9757a中的ago（"fix get_user_pages（））争取写访问），但那时

109
00:06:44,139 --> 00:06:46,999
提交f33ea7f4004e5，由于s390上的问题而撤消（"修复获取用户页面错误"）。

110
00:06:47,000 --> 00:06:51,410
所以我有点失望我的IBM朋友，因为他们几乎有

111
00:06:51,410 --> 00:06:52,640
部分有罪。

112
00:06:52,639 --> 00:06:56,329
S390是IBM Mainframes使用的体系结构，系统Z

113
00:06:56,330 --> 00:06:58,700
不管怎样，让我们快点看看。

114
00:06:58,699 --> 00:07:04,439
修补的文件属于Linux内存管理器，因此是mm目录。

115
00:07:04,439 --> 00:07:08,249
文件本身叫做gup获取用户页面。

116
00:07:08,250 --> 00:07:13,110
vm代表虚拟内存，pte代表页面表条目。

117
00:07:13,110 --> 00:07:15,880
我认为这应该有助于理解代码。

118
00:07:15,880 --> 00:07:20,950
所以当你想写这个映射内存时，内核必须复制它，因为

119
00:07:20,950 --> 00:07:23,440
不允许写入基础文件。

120
00:07:23,440 --> 00:07:26,030
但复制需要时间。

121
00:07:26,030 --> 00:07:30,930
现在通常你复印一次就可以了好吧，但在这种情况下我们称之为疯子

122
00:07:30,930 --> 00:07:33,710
一遍又一遍。

123
00:07:33,710 --> 00:07:35,850
让我们在代码中查找这个。

124
00:07:35,849 --> 00:07:39,279
因此，如果使用此标志，则此函数是执行。

125
00:07:39,280 --> 00:07:42,340
内核源代码解释了：

126
00:07:42,340 --> 00:07:44,610
应用程序不再需要这些页面。

127
00:07:44,610 --> 00:07:48,010
如果书页脏了，可以直接扔他们离开了。

128
00:07:48,010 --> 00:07:50,610
应用程序会更加小心数据想要保持。

129
00:07:50,610 --> 00:07:51,610
一定要释放交换资源。

130
00:07:51,610 --> 00:07:52,720
我想我很快就解释了。

131
00:07:52,720 --> 00:07:53,720
这也是名字的另一部分是来自。

132
00:07:53,720 --> 00:07:57,610
当你读写磁盘时，你永远不会直接这样做，会让你慢下来。

133
00:07:57,610 --> 00:07:59,410
所以可以缓存或缓冲它们。

134
00:07:59,409 --> 00:08:03,409
这意味着你将这些数据保存在某个地方，在某个时间点，你把它写给

135
00:08:03,410 --> 00:08:04,410
磁盘。

136
00:08:04,410 --> 00:08:05,410
好啊。

137
00:08:05,410 --> 00:08:08,760
所以，如果您将数据从磁盘读取到内存中你可以把它放在缓存里

138
00:08:08,760 --> 00:08:09,760
进一步阅读。

139
00:08:09,760 --> 00:08:14,710
但是，如果你想写到磁盘上，把它写进这个缓存/缓冲区，但是现在你

140
00:08:14,710 --> 00:08:18,850
必须告诉系统，这个缓冲区被碰了，现在脏了。

141
00:08:18,849 --> 00:08:20,969
它不再是干净的新鲜记忆了。

142
00:08:20,970 --> 00:08:26,200
在这种情况下，系统必须确保更改已正确传播到参考线

143
00:08:26,200 --> 00:08:27,200
物理内存。

144
00:08:27,200 --> 00:08:30,920
让它成为磁盘或闪存上的文件。

145
00:08:30,919 --> 00:08:36,409
所以在这种情况下，如果你写信给mmaped内存，内存页被标记

146
00:08:36,409 --> 00:08:37,409
脏了。

147
00:08:37,409 --> 00:08:41,259
因为你现在告诉内核页面不再需要了，这意味着

148
00:08:41,260 --> 00:08:43,690
你不在乎脏页没有已经写好了。

149
00:08:43,690 --> 00:08:44,910
你就扔了。

150
00:08:44,910 --> 00:08:50,010
所以这个疯狂的呼吁导致了关于这个记忆。

151
00:08:50,010 --> 00:08:54,180
这意味着它不在任何记忆中不再是高速缓存了。

152
00:08:54,180 --> 00:08:57,960
这对这种利用很重要，因为这意味着，每当我们试图写作时

153
00:08:57,959 --> 00:09:01,859
对它来说，记忆的拷贝可能被扔了。

154
00:09:01,860 --> 00:09:06,250
所以我们必须从内存中重新加载一个新的拷贝所以我们可以写信给它。

155
00:09:06,250 --> 00:09:08,340
创建这个拷贝需要时间。

156
00:09:08,340 --> 00:09:12,620
这就是比赛条件，如果复印件写在纸上循环尚未完成。

157
00:09:12,620 --> 00:09:16,310
补丁添加了检查如果书面副本已完成，以及

158
00:09:16,310 --> 00:09:18,670
只有这样才允许写入。

159
00:09:18,670 --> 00:09:23,370
说实话，我不懂这个准则真的告诉你为什么这个片段

160
00:09:23,370 --> 00:09:25,600
请确保"写时复制"已完成。

161
00:09:25,600 --> 00:09:30,390
但它增加了一些额外的支票，所以我假设现在没事。

162
00:09:30,390 --> 00:09:32,910
这是我们种族的心理图景条件。

163
00:09:32,910 --> 00:09:37,730
我们经常使用Madvise删除任何缓存映射文件的副本。

164
00:09:37,730 --> 00:09:42,420
同时，我们也尝试着给它写信，这会导致记忆的复制。

165
00:09:42,420 --> 00:09:47,290
现在在一些罕见的情况下，可能会被击中通过反复尝试非常可靠

166
00:09:47,290 --> 00:09:52,510
同样，我们对内存执行写操作，在页表更新到点之前

167
00:09:52,510 --> 00:09:54,340
我们把我们复制的版本。

168
00:09:54,339 --> 00:09:58,169
我们写的是真正的文件而不是复制内存。

169
00:09:58,170 --> 00:10:03,050
所以这个弱点的疯狂之处也就是说，它已经在内核中很长时间了

170
00:10:03,050 --> 00:10:05,240
长时间。

171
00:10:05,240 --> 00:10:09,950
据报道，这甚至是一个众所周知的问题已经尝试过的补丁作者

172
00:10:09,950 --> 00:10:11,880
之前要修补。

173
00:10:11,880 --> 00:10:17,810
所以随着时间的推移，这显然是理论上的种族因为我们的系统

174
00:10:17,810 --> 00:10:19,240
越来越快。

175
00:10:19,240 --> 00:10:23,360
Petr Matousek也指出在野外使用的0天漏洞。

176
00:10:23,360 --> 00:10:25,680
所以有一个真正的威胁。

177
00:10:25,680 --> 00:10:27,190
现在有点争议。

178
00:10:27,190 --> 00:10:32,910
这进入了悬而未决的辩论一直在为腐朽的人做脆弱的事

179
00:10:32,910 --> 00:10:33,910
披露。

180
00:10:33,910 --> 00:10:38,840
如果你是发现这种剥削的人在野外，你会怎么做？

181
00:10:38,839 --> 00:10:41,539
显而易见的参数是：

182
00:10:41,540 --> 00:10:46,230
充分披露，因为它被积极利用，立即全面披露

183
00:10:46,230 --> 00:10:49,170
没有给高级攻击者任何新信息。

184
00:10:49,170 --> 00:10:53,040
但是知识会允许系统管理员立即修补

185
00:10:53,040 --> 00:10:54,040
系统。

186
00:10:54,040 --> 00:10:57,390
但另一方面，这是如此简单和普遍存在的脆弱性，即充分披露

187
00:10:57,389 --> 00:11:01,729
会让技能较差的军队黑客利用它，直到

188
00:11:01,730 --> 00:11:04,710
专业的系统管理员或私人人员可以修补它。

189
00:11:04,710 --> 00:11:10,130
另一方面，我们有责任披露在第一次联系开发人员的地方，创建

190
00:11:10,131 --> 00:11:13,571
一个解决方案，试着推出，然后告诉人们之后。

191
00:11:13,570 --> 00:11:19,420
显而易见的参数是，你停止了专业的系统管理员进行热修补

192
00:11:19,420 --> 00:11:23,300
快速系统，并将其暴露于持续的攻击。

193
00:11:23,300 --> 00:11:26,500
现在我不知道最好的方法是什么。

194
00:11:26,500 --> 00:11:28,740
两种方法都有优缺点。

195
00:11:28,740 --> 00:11:31,590
这完全取决于你的威胁模型。

196
00:11:31,589 --> 00:11:35,919
一般来说，我会稍微向全身倾斜一点。披露，因为我喜欢信息

197
00:11:35,920 --> 00:11:41,260
尽管我自己也要负责任地公开因为我是个伪君子。

198
00:11:41,260 --> 00:11:45,080
我希望你喜欢这种利用演练视频，我可以给你看一些东西

199
00:11:45,079 --> 00:11:46,639
新颖有趣。

200
00:11:46,639 --> 00:11:51,409
如果我说错了或者你有其他的有关必须触发此漏洞的原因的信息

201
00:11:51,410 --> 00:11:56,920
通过写入/proc/mem而不是直接写入写信到地址，请纠正我

202
00:11:56,920 --> 00:12:02,130
或者在下面的评论中发布附加信息，以便其他细心的观众能受益

203
00:12:02,130 --> 00:12:03,130
从它。

204
00:12:03,130 --> 00:12:03,260
谢谢。

