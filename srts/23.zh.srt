1
00:00:00,560 --> 00:00:06,800
So the public disclosure of dirtyc0w or CVE-2016-5195 just happened.

2
00:00:06,800 --> 00:00:11,700
此漏洞由来已久，允许系统上的常规用户执行本地

3
00:00:11,700 --> 00:00:13,940
privilege escalation and become root.

4
00:00:13,940 --> 00:00:21,670
I want to show it to you, explore how it works and generally talk about it.

5
00:00:21,669 --> 00:00:29,539
Let’s cut right to the chase and start by looking at the provided proof-of-concept exploit.

6
00:00:29,539 --> 00:00:34,859
I have here a vulnerable Ubuntu system where I can downloa and compile the exploit.

7
00:00:34,860 --> 00:00:40,360
Then I create a file owned by root to that I as a normal user can’t write to.

8
00:00:40,360 --> 00:00:42,800
I can read it, but not write.

9
00:00:42,800 --> 00:00:47,390
This is true for many files on the file system like for example the ping binary.

10
00:00:47,390 --> 00:00:50,570
ping belongs to root and has the setuid bit set.

11
00:00:50,570 --> 00:00:56,080
这意味着任何人都可以执行它，它将作为根目录运行，但是ping除了

12
00:00:56,080 --> 00:00:57,760
sending out some networking traffic.

13
00:00:57,760 --> 00:01:02,350
So our root file we just created resembles a file or binary like ping.

14
00:01:02,350 --> 00:01:04,770
It’s owned by root and we can’t write to it.

15
00:01:04,769 --> 00:01:09,839
现在，当我们执行dirtyc0w并将根文件传递给它并指定一个我们想要的字符串时

16
00:01:09,840 --> 00:01:14,120
to write, we can observe, that the string got written to the file.

17
00:01:14,119 --> 00:01:19,739
作为系统的常规用户，我们已经写入了一个根文件，但是我们没有

18
00:01:19,740 --> 00:01:20,860
write access to.

19
00:01:20,859 --> 00:01:22,199
This is insane.

20
00:01:22,200 --> 00:01:26,700
现在假设我们已经在ping二进制文件中编写了一个后门，我们可以成为根

21
00:01:26,700 --> 00:01:27,700
anytime.

22
00:01:27,700 --> 00:01:29,250
Without knowing the password of root.

23
00:01:29,250 --> 00:01:32,360
Now let’s try to understand the exploit code.

24
00:01:32,360 --> 00:01:35,930
Let’s check out main() first where the code starts.

25
00:01:35,929 --> 00:01:40,079
So first it opens the file we want to write to as READ_ONLY.

26
00:01:40,079 --> 00:01:42,049
Next comes a call to mmap().

27
00:01:42,049 --> 00:01:47,369
Mmap is used to create a new mapped memory segment in the current process.

28
00:01:47,369 --> 00:01:51,769
其中一个参数可以是文件描述符，在本例中是只读文件

29
00:01:51,770 --> 00:01:53,150
owned by root.

30
00:01:53,149 --> 00:01:57,169
This means it maps the file into a new memory area.

31
00:01:57,170 --> 00:02:01,570
Also the permission flags show, that this new memory area is READ_ONLY.

32
00:02:01,569 --> 00:02:02,979
So far so good.

33
00:02:02,979 --> 00:02:06,899
The other important flag is the MAP_PRIVATE flag.

34
00:02:06,899 --> 00:02:11,259
这里的注释是从mmap的手册页复制的，它指出，这将创建一个

35
00:02:11,260 --> 00:02:13,390
private copy-on-write mapping.

36
00:02:13,390 --> 00:02:15,980
Or short C.O.W, cow.

37
00:02:15,980 --> 00:02:18,830
This is where one part of the name for this vulnerability is from.

38
00:02:18,830 --> 00:02:24,240
使用此标志，mmap不会将文件的全部内容复制到内存中，mmap映射

39
00:02:24,239 --> 00:02:25,919
the file into your memory.

40
00:02:25,920 --> 00:02:29,850
这太棒了，因为您不需要大量的RAM来加载文件副本，

41
00:02:29,850 --> 00:02:33,340
you just directly read from the file on disk.

42
00:02:33,340 --> 00:02:37,350
或者相对直接地，我们将在一秒钟内了解更多关于记忆的信息。

43
00:02:37,349 --> 00:02:41,899
而copy-on-write意味着，如果你要写这个内存段，你会

44
00:02:41,900 --> 00:02:43,500
then create a copy of it.

45
00:02:43,500 --> 00:02:48,380
因此，尽管文件被映射为只读，但由于我们可以写入私有映射，因此

46
00:02:48,380 --> 00:02:50,340
to a copy of it.

47
00:02:50,340 --> 00:02:55,100
所以这里重要的是，mmap将根文件直接映射到

48
00:02:55,100 --> 00:03:00,330
memory, and you can read the content of the file, or write to a COPY of it.

49
00:03:00,330 --> 00:03:04,520
The changes to your copy should not be propagated to the real underlaying file.

50
00:03:04,520 --> 00:03:07,010
这是给你的

51
00:03:07,010 --> 00:03:09,830
Next we start two threads that will run in parallel.

52
00:03:09,830 --> 00:03:15,300
dirtyc0w是一个种族条件漏洞，这意味着某些事件必须发生在

53
00:03:15,300 --> 00:03:19,890
a specific order, that are fairly unlikely to happen under normal circumstances.

54
00:03:19,890 --> 00:03:23,490
So you try to race against the probability of it not happenign.

55
00:03:23,489 --> 00:03:25,379
And you simply try it over and over again.

56
00:03:25,379 --> 00:03:27,579
And maybe you get lucky.

57
00:03:27,579 --> 00:03:30,379
So let’s see what the two threads are doing.

58
00:03:30,379 --> 00:03:33,179
The first thread is the madviseThread.

59
00:03:33,180 --> 00:03:38,520
这个线程使用系统调用madvise，它可能不代表内存建议，

60
00:03:38,520 --> 00:03:43,460
但是，疯狂的建议，我认为市场部在这里失败了，没有说出这种可能性。

61
00:03:43,459 --> 00:03:45,159
疯牛，我说得对吗？

62
00:03:45,159 --> 00:03:46,529
Ok. done with the dad jokes.

63
00:03:46,530 --> 00:03:50,030
So this syscall can be used for optimization reasons.

64
00:03:50,030 --> 00:03:56,240
您可以向内核提供一些关于如何使用内存映射区域的信息，

65
00:03:56,240 --> 00:04:01,110
because there are different techniques how you handle caching, look ahead and so forth.

66
00:04:01,109 --> 00:04:07,059
我们给内核的建议是，我们映射文件的内存区域

67
00:04:07,060 --> 00:04:11,930
to, or at least the first 100 byte, is probably not needed anytime soon.

68
00:04:11,930 --> 00:04:16,740
我们说，用马德夫·唐特纳的旗帜，它代表：

69
00:04:16,739 --> 00:04:19,839
Do not expect access in the near future.

70
00:04:19,840 --> 00:04:24,190
（目前，应用程序在给定范围内完成，因此内核可以释放

71
00:04:24,190 --> 00:04:26,550
与之相关的资源。）

72
00:04:26,550 --> 00:04:31,970
此范围内的后续页面访问将成功，但将导致重新加载

73
00:04:31,970 --> 00:04:34,760
of the memory contents from the underlying mapped file.

74
00:04:34,759 --> 00:04:37,549
The last sentence is key to the exploit.

75
00:04:37,550 --> 00:04:39,450
Otherwise not much else happening here.

76
00:04:39,449 --> 00:04:43,659
The other thread, procselfmemThread, opens the file /proc/self/mem.

77
00:04:43,660 --> 00:04:47,980
This is a special file and I try to explain really quick.

78
00:04:47,979 --> 00:04:51,259
So /proc is a so called pseudo filesystem.

79
00:04:51,259 --> 00:04:55,969
In fact most resources on linux are managed as “files”.

80
00:04:55,970 --> 00:05:00,530
So you should always see “files” in quotation marks when talking about them.

81
00:05:00,530 --> 00:05:03,970
Imagine a file just to be something, you can read from, or write to.

82
00:05:03,970 --> 00:05:08,430
所以这可能是打印机，写入打印机“文件”可能会导致

83
00:05:08,430 --> 00:05:12,420
physical printer printing the string on a piece of paper.

84
00:05:12,420 --> 00:05:15,930
So /proc does not really contain “files” in the common sense.

85
00:05:15,930 --> 00:05:19,870
它们指的是更一般的东西，最重要的是对于我们的情况，你可以

86
00:05:19,870 --> 00:05:21,360
read and write to.

87
00:05:21,360 --> 00:05:27,670
So in this case /proc/self refers to special “files” provided for the current process.

88
00:05:27,670 --> 00:05:29,820
So every process will have it’s own /proc/self.

89
00:05:29,819 --> 00:05:35,609
其中有一个名为mem的“文件”，它表示当前进程的

90
00:05:35,610 --> 00:05:36,610
memory.

91
00:05:36,610 --> 00:05:42,050
So you could theoretically read your own process’s memory by reading from this file.

92
00:05:42,050 --> 00:05:46,830
Now in this case, the exploit WRITES to this file in a loop.

93
00:05:46,830 --> 00:05:51,350
因此，首先它执行一个查找，将当前光标移动到文件的开头，

94
00:05:51,349 --> 00:05:53,059
we mapped into memory.

95
00:05:53,060 --> 00:05:57,790
And then it writes the string we pass via the program arguments to it.

96
00:05:57,790 --> 00:06:03,340
So this will trigger a copy of the memory, so that we can write to it and see these changes.

97
00:06:03,340 --> 00:06:07,690
But remember, we will not write to the real underlaying file.

98
00:06:07,690 --> 00:06:12,600
所以，如果你只做一次这些事情，或者只是孤立在一起，可能什么都没有。

99
00:06:12,599 --> 00:06:13,629
would happen.

100
00:06:13,629 --> 00:06:16,909
Because that would be the expected result.

101
00:06:16,910 --> 00:06:21,550
但是因为在某个地方有一个种族条件的问题，反复尝试这个问题

102
00:06:21,550 --> 00:06:27,250
将创建一个奇怪的边缘，通常不会发生，但在这种情况下，会欺骗

103
00:06:27,250 --> 00:06:30,970
kernel into actually writing to the underlaying file.

104
00:06:30,970 --> 00:06:34,070
现在让我们来看看这个补丁，因为我觉得这很有趣，而且不是很有趣

105
00:06:34,070 --> 00:06:35,070
big.

106
00:06:35,070 --> 00:06:37,660
所以在提交消息中，作者声明

107
00:06:37,660 --> 00:06:42,370
这是一种古老的虫子，我十一年来一直试图修复一次。

108
00:06:42,370 --> 00:06:44,140
在commit 4ceb5db9757a（“fix get_user_pages（）race for write access”）中，但那时

109
00:06:44,139 --> 00:06:46,999
undone due to problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").

110
00:06:47,000 --> 00:06:51,410
所以我对我的IBM朋友有点失望，因为他们几乎有

111
00:06:51,410 --> 00:06:52,640
partial guilt here.

112
00:06:52,639 --> 00:06:56,329
S390 is the architecture used by IBM mainfraimes, system z.

113
00:06:56,330 --> 00:06:58,700
Anyhow, let’s have a quick look.

114
00:06:58,699 --> 00:07:04,439
The file that is patched belongs to the linux memory manager, hence the mm directory.

115
00:07:04,439 --> 00:07:08,249
And the file itself is called GUP, which stands for get_user_pages.

116
00:07:08,250 --> 00:07:13,110
Vm stands for virtual memory and pte for page table entry.

117
00:07:13,110 --> 00:07:15,880
I think that should help a little bit to understand the code.

118
00:07:15,880 --> 00:07:20,950
因此，当您想要写入这个映射内存时，内核必须复制它，因为

119
00:07:20,950 --> 00:07:23,440
not allowed to write to the underlying file.

120
00:07:23,440 --> 00:07:26,030
But a copy takes time.

121
00:07:26,030 --> 00:07:30,930
现在通常你复印一次就可以了，但在这种情况下我们称之为疯子

122
00:07:30,930 --> 00:07:33,710
DONTNEED over and over again.

123
00:07:33,710 --> 00:07:35,850
Let’s look this up in the code.

124
00:07:35,849 --> 00:07:39,279
So if this flag is used, this function is executed.

125
00:07:39,280 --> 00:07:42,340
内核源代码解释了：

126
00:07:42,340 --> 00:07:44,610
Application no longer needs these pages.

127
00:07:44,610 --> 00:07:48,010
If the pages are dirty, it's OK to just throw them away.

128
00:07:48,010 --> 00:07:50,610
The app will be more careful about data it wants to keep.

129
00:07:50,610 --> 00:07:51,610
Be sure to free swap resources too.

130
00:07:51,610 --> 00:07:52,720
I guess I quickly explain dirty.

131
00:07:52,720 --> 00:07:53,720
This is also where the other part of the name is from.

132
00:07:53,720 --> 00:07:57,610
When you read and write to disk you never do this directly, that would be wayyy to slow.

133
00:07:57,610 --> 00:07:59,410
So you cache, or buffer them.

134
00:07:59,409 --> 00:08:03,409
这意味着您将此数据保存在某个位置，并在某个时间点将其写入

135
00:08:03,410 --> 00:08:04,410
disk.

136
00:08:04,410 --> 00:08:05,410
Ok.

137
00:08:05,410 --> 00:08:08,760
因此，如果您将数据从磁盘读取到内存中，您可以将其留在缓存中，

138
00:08:08,760 --> 00:08:09,760
further reads.

139
00:08:09,760 --> 00:08:14,710
但是，如果您想写入磁盘，您可以将它写入这个缓存/缓冲区，但是现在您可以

140
00:08:14,710 --> 00:08:18,850
have to tell the system, that this buffer got touched and is dirty now.

141
00:08:18,849 --> 00:08:20,969
It’s not clean fresh memory anymore.

142
00:08:20,970 --> 00:08:26,200
在这种情况下，系统必须确保更改正确传播到底层。

143
00:08:26,200 --> 00:08:27,200
physical memory.

144
00:08:27,200 --> 00:08:30,920
Let it be a file on disk or flash memory.

145
00:08:30,919 --> 00:08:36,409
因此，在本例中，如果您写入复制的mmaped内存，则会标记内存页。

146
00:08:36,409 --> 00:08:37,409
dirty.

147
00:08:37,409 --> 00:08:41,259
因为你现在告诉内核，页面不再需要了，这意味着

148
00:08:41,260 --> 00:08:43,690
you don’t care that the dirty page has not been written yet.

149
00:08:43,690 --> 00:08:44,910
You just toss it.

150
00:08:44,910 --> 00:08:50,010
So this madvise call causes the throwing away of this memory.

151
00:08:50,010 --> 00:08:54,180
This means it’s not in any of the memory caches anymore.

152
00:08:54,180 --> 00:08:57,960
这对这种利用很重要，因为这意味着，每当我们试图写

153
00:08:57,959 --> 00:09:01,859
to it again, the copy of the memory might have been tossed.

154
00:09:01,860 --> 00:09:06,250
So we have to re load a new copy from memory so we can write to it.

155
00:09:06,250 --> 00:09:08,340
And creating this copy takes time.

156
00:09:08,340 --> 00:09:12,620
And this is the race condition, if the copy-on-write cycle is not complete yet.

157
00:09:12,620 --> 00:09:16,310
补丁程序添加了这个函数来检查写入时的拷贝是否完成，以及

158
00:09:16,310 --> 00:09:18,670
only then allows writing to it.

159
00:09:18,670 --> 00:09:23,370
老实说，我真的不理解这段代码来告诉你为什么这段代码

160
00:09:23,370 --> 00:09:25,600
sure that the copy on write is complete.

161
00:09:25,600 --> 00:09:30,390
But it added some additional checks, so I assume now it’s fine.

162
00:09:30,390 --> 00:09:32,910
So here is the mental picture of our race condition.

163
00:09:32,910 --> 00:09:37,730
We constantly use madvise to drop any cached copy of the mapped file.

164
00:09:37,730 --> 00:09:42,420
And at the same time we try to write to it, which causes a copy of that memory.

165
00:09:42,420 --> 00:09:47,290
现在在一些罕见的情况下，只要反复尝试就可以非常可靠地击中它。

166
00:09:47,290 --> 00:09:52,510
同样，我们在页表更新到点之前执行对内存的写操作。

167
00:09:52,510 --> 00:09:54,340
us to our copied version.

168
00:09:54,339 --> 00:09:58,169
And we write to the real file instead of the copied memory.

169
00:09:58,170 --> 00:10:03,050
关于这个漏洞的疯狂之处在于，它已经在内核中存在了很长一段时间了。

170
00:10:03,050 --> 00:10:05,240
long time.

171
00:10:05,240 --> 00:10:09,950
根据补丁作者的说法，这甚至是一个已知的问题

172
00:10:09,950 --> 00:10:11,880
to be patched before.

173
00:10:11,880 --> 00:10:17,810
随着时间的推移，这个明显的理论竞赛条件变得可行，因为我们的系统

174
00:10:17,810 --> 00:10:19,240
faster and faster.

175
00:10:19,240 --> 00:10:23,360
And Petr Matousek also states, that this was an 0day exploit used in the wild.

176
00:10:23,360 --> 00:10:25,680
So there was a real threat.

177
00:10:25,680 --> 00:10:27,190
Now a bit of controversy.

178
00:10:27,190 --> 00:10:32,910
这进入了腐朽者如何应对脆弱性的未解决的争论。

179
00:10:32,910 --> 00:10:33,910
disclosure.

180
00:10:33,910 --> 00:10:38,840
如果你是在野外发现这一漏洞的人，你会怎么做？

181
00:10:38,839 --> 00:10:41,539
显而易见的论点是：

182
00:10:41,540 --> 00:10:46,230
完全披露，因为它被积极利用，完全披露它马上就会

183
00:10:46,230 --> 00:10:49,170
not given advanced attackers anything new.

184
00:10:49,170 --> 00:10:53,040
但是这些知识将使系统管理员能够立即对

185
00:10:53,040 --> 00:10:54,040
systems.

186
00:10:54,040 --> 00:10:57,390
但另一方面，这是一个如此容易和普遍的弱点，一个充分披露

187
00:10:57,389 --> 00:11:01,729
会让技术较差的黑客军队利用它，直到

188
00:11:01,730 --> 00:11:04,710
professional sysadmins or private people could patch it.

189
00:11:04,710 --> 00:11:10,130
另一方面，我们有一个负责任的披露，在这里您首先联系开发人员，创建

190
00:11:10,131 --> 00:11:13,571
a fix, try to roll it out and then tell people afterwards.

191
00:11:13,570 --> 00:11:19,420
这里的明显论点是，您停止了专业系统管理员对其进行热修补

192
00:11:19,420 --> 00:11:23,300
system quickly and leave them exposed for the ongoing attacks.

193
00:11:23,300 --> 00:11:26,500
Now I don’t know what is the best way.

194
00:11:26,500 --> 00:11:28,740
Both ways have advantages and disadvantages.

195
00:11:28,740 --> 00:11:31,590
And it entirely depends on your threat model.

196
00:11:31,589 --> 00:11:35,919
一般来说，我更倾向于全面披露，因为我喜欢

197
00:11:35,920 --> 00:11:41,260
be free, though I myself do responsible disclosure because I’m a hypocrite.

198
00:11:41,260 --> 00:11:45,080
我希望你喜欢这种利用演练的视频，我可以给你看一些东西

199
00:11:45,079 --> 00:11:46,639
new and interesting.

200
00:11:46,639 --> 00:11:51,409
如果我说了错误的话，或者你有关于为什么必须触发此漏洞的其他信息

201
00:11:51,410 --> 00:11:56,920
通过写入/proc/mem而不是直接写入地址，请更正我的错误。

202
00:11:56,920 --> 00:12:02,130
或者在下面的评论中发布其他信息，以便其他关注的观众可以受益。

203
00:12:02,130 --> 00:12:03,130
from it.

204
00:12:03,130 --> 00:12:03,260
Thanks.

